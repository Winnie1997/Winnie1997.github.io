<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hi, Dai</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://daisine.github.io/"/>
  <updated>2020-01-02T11:40:18.995Z</updated>
  <id>https://daisine.github.io/</id>
  
  <author>
    <name>Dai Sine</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020重庆大学软件工程考研小记</title>
    <link href="https://daisine.github.io/2020ky/"/>
    <id>https://daisine.github.io/2020ky/</id>
    <published>2020-01-02T11:31:01.000Z</published>
    <updated>2020-01-02T11:40:18.995Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>作为一只<del>没有梦想</del>的咸鱼，其实从大一开始就一直在不读研和读研之间反复横跳…后来终于决定不读研了，结果大三末又被父母劝说着去考研 Orz 虽然现在考完了，但我仍旧处在一种纠结的状态。</p> <a id="more"></a>  <p>从9.13号开始准备考研初试的复习，共约三个月时间。<strong>科目为：政治，英二，数二，(CQU)877</strong>。个人<strong>个人情况</strong>：数学一直都不太好，高中成绩全靠语文英语拉分<del>所以我为什么要选理科</del>，大一高数低分飘过；英语<del>心安理得</del>吃着高中的老本过了英语四六级；政治就是理科生的那种政治基础，初高中大学考试都是开卷；专业课考的是C语言和数据库，从目前的真题包括今年来看考得比较基础。</p><h3 id="资料及利用情况"><a href="#资料及利用情况" class="headerlink" title="资料及利用情况"></a>资料及利用情况</h3><p>用的复习资料不多，具体如下:</p><ul><li>李王考研数学复习全书+数学历年真题全精解析+李永乐线代辅导讲义：三本书完整做了一遍，并整理了一些具体的知识点，其中倍速听了汤高数基础班+<strong>李永乐线代强化班</strong>，因为个人高数不太好，如果高数基础好的话可以不用听汤的基础班，因为真的讲的挺基础的。<strong>李永乐线代强化班配合讲义听一听对线代的理解会很有帮助。</strong></li><li>考研数学李林6+4套卷：题出得不错，考察的点、方式也和历年真题相似，只是今年的题个人觉得问法比较奇怪，后期用来保持数学做题的手感可以，但不要对押中题抱太大希望。</li><li>考研英语二张剑黄皮书：因为数学不太好的原因所以…其实题阅读题做得蛮少的，最重要的是从自己错题的类型总结出题的思路。翻译没练习，考前就看了两眼近两年的真题，比较简单，最后考得也比较基础。考研作文的模板是从这个黄皮书的优秀范文中自己编了一个，考试的时候还挺好用。2020考研英语真题的<strong>完形填空没有以前出得那么难，完全可以做。</strong></li><li>肖秀荣精讲精练+肖1000+肖八肖四：精讲精练十月份的时候看不下去，所以看的是微博上一个研友总结的徐涛政治的听课笔记。十二月做肖八肖四的时候发现小部分知识点听课笔记上没有，翻了一下精讲精练，发现精讲精练这本书还是不错的，缺点是太细、重要考点不够突出。肖1000做了马原部分，其他Part没碰。大题背的肖四，考试够用。<strong>多选的错误选项有一定技巧</strong>，因为我政治选择复习得比较水，个人感觉单选比多选做得差…各种帽子题太为难我这记忆力了。</li><li>专业课：先是没复习把12-19年的真题做了一遍，其中早年真题考的科目不太一样，因此只挑了C语言+数据库原理Part写。总的来说考得比较基础，翻书复习并总结了一下真题的知识点，<a href="https://daisine.github.io/cky/">C语言</a>   <a href="https://daisine.github.io/sqlky/">数据库</a>。除此之外，我去打印店买了隔壁某学院C语言的期末考试试卷(<del>因为买不到软件学院的</del>)，和真题的题型考察的点几乎差不多，共约4、5套，刷完了总结一些易错点和坑。数据库原理考得比本科的期末考试简单，因此我稍微看了一下大二准备的<a href="https://daisine.github.io/sql01/">数据库原理期末考试的复习笔记</a> + 数据仓库/数据挖掘的概念和简单应用，写了一些<a href="https://www.nowcoder.com/ta/sql" target="_blank" rel="noopener">牛客网SQL语句的题目</a>(考得比这上面的题简单)。</li><li>网上研友总结的资料：包括但不限于政治知识点笔记，政治各模拟题知识点提炼，英语完形+阅读+作文技巧，数学公式/某些高频考点题型的解题思路。来源：微信公众号，微博，B站。<strong>PS: 网上各式各样的资源很多很杂，找自己真正需要的看，而不是随波逐流。</strong></li></ul><h3 id="APP-PC端工具"><a href="#APP-PC端工具" class="headerlink" title="APP/ PC端工具"></a>APP/ PC端工具</h3><p>APP/PC端软件如下：</p><ul><li><strong>Notability</strong> ：记听课笔记+刷题，开始写着不习惯，笔略重。写久了觉得还挺顺手的。</li><li>知米背单词：背了3000个考研高频词汇(但感觉用处不大，考英语的时候该不认识的还是不认识QAQ，唯一的区别就是：这单词我好像见过唉！)</li><li><strong>WolframAlpha</strong>：<strong>高数求积分/求极限/解各种方程/看复杂函数图像</strong>的利器，做题看不懂解析省略的步骤的时候会用这个。</li><li>nPlayer：看课程视频，可1.0-4.0选择倍速播放。</li><li>Baiduyun：各种模拟试卷/研友总结知识点/微博微信的资源链接一般都是百度云，但是由于baiduyun各种限制，我还开了三个月的baidunyu会员，省点心。</li><li>欧陆词典：习惯用这个词典查词</li><li>Scanner Pro：扫描手写笔记，公式等</li><li>蜜题考研政治：11月末发现的。花了1块钱，可以刷政治真题、模拟题的选择题，有解析、可收藏题目和回顾错题。个人感觉挺好用。</li><li>(PC端) <strong>Adobe Acrobat + Pitstop插件</strong>：去水印，编辑合并PDF文件必备。…网上考研资料的水印真是一重又一重，作为一个强迫症不去水印极度不适。</li><li><a href="https://www.ilovepdf.com/zh-cn" target="_blank" rel="noopener">I love PDF</a> 简易的pdf在线编辑page，最重要的一点是可以将限制编辑的pdf解密，不然无法去水印。</li></ul><h3 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h3><ul><li><p><strong>具体情况具体分析，所有人的经验贴都不能照搬。</strong></p></li><li><p>效率比时长重要：一天专注学习8个小时个人觉得足够了。前期：上午+下午做题/复习新的点，晚上总结。也不一定非要是晚上总结，把总结放到你一天之中觉得效率最低、脑子最转不过来的时间即可。<strong>总结完后期复习要看，不看不如别浪费时间。</strong></p></li><li>给自己定近期的具体的DDL：众所周知，<del>DDL是第一生产力</del>。例如，两天写+总结完一套真题，到哪天之前刷完；2天看完线代某章题目，哪天之前看完所有线代。</li><li>不要过长时间久坐，不时站起来走走，考研是一件耗费体力和脑力的事情，身体的疲惫感也需要重视。</li></ul><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>写这篇文的时候，离考完研两周不到。成绩未出，也不打算对答案。甚至想国家线公布以后再查成绩。目前准备复习专业课，准备复试是一方面，更重要的是准备20年的春招。人的一生真正能自己选择的路很少，我想给自己多几个选项。</p><p>以及，</p><p>新年快乐呀！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;作为一只&lt;del&gt;没有梦想&lt;/del&gt;的咸鱼，其实从大一开始就一直在不读研和读研之间反复横跳…后来终于决定不读研了，结果大三末又被父母劝说着去考研 Orz 虽然现在考完了，但我仍旧处在一种纠结的状态。&lt;/p&gt;
    
    </summary>
    
      <category term="DAIの日常" scheme="https://daisine.github.io/categories/DAI%E3%81%AE%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="杂念" scheme="https://daisine.github.io/tags/%E6%9D%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>C语言试卷笔记</title>
    <link href="https://daisine.github.io/cxky/"/>
    <id>https://daisine.github.io/cxky/</id>
    <published>2020-01-02T11:18:28.000Z</published>
    <updated>2020-01-02T11:45:35.938Z</updated>
    
    <content type="html"><![CDATA[<h4 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h4><ul><li>程序填空题：已知程序的功能也要将整个程序的每一个语句看完 (通常有坑)</li><li>求平均值，近似值(小数点)的题目，<strong>注意int类型相除赋值给float型的错误</strong>。</li><li><p>填条件时</p><ul><li>i 的值是为1还是为0，i 是小于还是小于等于</li><li>i++ 还是 i– ，<strong>i- -通常是逆序操作</strong></li></ul><a id="more"></a><ul><li>循环次数是几次？</li><li>== 还是 != ？</li></ul></li><li>%f输出时，小数不足6位添0 → 89.500000</li><li>问输出结果的时候，注意有没有换行符，制表符等。</li><li>调用两个参数的函数时，注意写入实参的顺序有没有坑。fun(&amp;y, &amp;x)</li><li>for循环，j=0，1，2，3 里面条件为if(j%2) 满足真的j值有0和2.(不要忽略了0)</li><li>特别注意问输出结果：printf的变量是int还是double型的。<br>double w = int(a+b) 那么w仍然是作为double型输出的。</li><li>int t[ 3 ] [2] 则&amp;t[ 3 ] [ 2 ]不能表达其数组元素的地址，因为越界了！</li><li>C语言中的按位运算：<ul><li>&amp; 相同为1不同为0</li><li>|  全为0才为0</li><li>^ 相同为0不同为1</li><li>~ 取反 与!功能类似<br>关于负数的补码：eg.-2 → 2为0010，从右到左遇到第一个1的后面取反：1110</li></ul></li><li>递归函数中的printf，注意按值传递的递归函数返回上一层原变量的值依旧。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stido.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fun(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a=a+<span class="number">2</span>;</span><br><span class="line">b=a+b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>,a,b);</span><br><span class="line"><span class="keyword">if</span>(a&lt;<span class="number">4</span>)</span><br><span class="line">fun(a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>,a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> </span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="comment">//返回上层递归函数 a的值并不会传回来，依旧是2！</span></span><br></pre></td></tr></table></figure><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ul><li>continue不能用于switch语句，因为switch语句不是循环语句，是分支选择结构，break可以用于循环语句和switch语句。</li><li>switch后面的“表达式”，可以是int、char和枚举型中的一种，<strong>不能是float型变量</strong>；case后面必须是“常量表达式”，表达式中不能包含变量</li><li>enum在c语言中是关键字 ，c语言对大小写比较敏感，所以ENUM是一个标识符，但不是关键字。</li><li>有如下说明int a［10］={1,2,3,4,5,6,7,8,9,10}, * p=a;<ul><li>本题主要考查指针变量对数组元素的引用。在本题中，首先一个一维数组a，并对其进行初始化操作，然后定义了一个同类型的指针变量p，使其指向数组a的首地址。</li><li>通过指针引用数组元素主要分如下两种情况。<br>引用<strong>数组a首元素</strong>的常用等价方式有：<br>① 获取首元素地址：a，p；<br>② 访问首地址的值：a[0]，<strong>p[0]</strong>， <em> a， </em>  p。<br>引用<strong>数组第i个元素</strong>（从0开始计数）的常用等价方式有：<br>① 获取i元素地址：a+i，&amp;a[i]，p+i，&amp;p[i]；<br>② 访问i运算的值：<em> (a+i)，a[i]，</em> (p+i)，p[i]。</li></ul></li><li>初始化整型数组时，未赋值元素自动初始化为0。定义数组时，仅指定了数组长度而未初始化，整型自动复制为0，<strong>字符型’\0’，指针型NULL</strong>。</li><li>char单个字符和char数组(即字符串)类型的指针赋值输出的区别：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p=<span class="string">"hello"</span>; p指向了静态字符串常量的地址</span><br><span class="line"><span class="keyword">char</span> p[]=<span class="string">"hello"</span>;  -&gt; <span class="keyword">char</span> p[<span class="number">5</span>];</span><br><span class="line">   <span class="built_in">strcpy</span>(p, <span class="string">"Hello world"</span>);</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line">p=<span class="string">"hello"</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">char</span> a[<span class="number">5</span>]=<span class="string">"hello"</span>;<span class="keyword">char</span> a=<span class="string">'c'</span>;</span><br><span class="line"><span class="keyword">char</span> *p;<span class="keyword">char</span> *p;</span><br><span class="line">p=a;p=&amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,p);<span class="built_in">printf</span>(<span class="string">"%c"</span>,*p);    <span class="comment">//printf("%s",p);单个字符两者都可注意区别</span></span><br></pre></td></tr></table></figure><ul><li>数组名是指向首元素地址，仅仅是代表一个地址而不是指针。不能与指针等价，不能进行自加预算或是当成指针赋值。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">s=<span class="string">"right"</span>;× 数组名不能这样直接赋值。</span><br><span class="line">s[<span class="number">10</span>]=<span class="string">"right"</span>;×</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>]=<span class="string">"hello"</span>; √会自动在末尾添<span class="string">'\0'</span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>]=&#123;<span class="string">"hello"</span>&#125;; √ </span><br><span class="line"></span><br><span class="line">等价于   <span class="keyword">char</span> s[<span class="number">10</span>]=&#123;<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line">不等价于 <span class="keyword">char</span> s[<span class="number">10</span>]=&#123;<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>EOF 为一个宏名，不能作为用户标识符。EOF宏的值为 -1，EOF 宏表示读文件到了结尾这一状态，返回值为-1。这种状态可以用 feof(fp) 来检测，如果遇到文件结束，函数feof（fp）的值为非零值，否则为0。</li><li>数组指针可以用p[ i ]来表示数组元素。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p=a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,p[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,*(p+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,a[<span class="number">1</span>]);<span class="built_in">printf</span>(<span class="string">"%d"</span>,*(a+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">p++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,*p);√</span><br><span class="line">a++; × 数组名不能自加，仅仅是能看a[<span class="number">0</span>]的指针。</span><br></pre></td></tr></table></figure><ul><li>printf(strlen(“1234567\0\0”)) 输出为7，因为strlen()函数不会计算空字符’\0’。</li><li>printf(“%d”,(int)strlen(“a\n\”\x4e”));输出为4。<strong>\x4e是16进制ASCII码，表示一个字符N，类似还有\x41是16进制ASCII码，表示一个字符A。</strong></li><li>已有定义”char ch=6; int i=6,j;”  执行”j=ch | | i++”以后，i的值为6。<strong>&amp; &amp; 和| | 从左向右判断到能出结果的时候就不再继续往下判断了。</strong></li><li>函数insertsubstr的功能是：将字符串s2插入到字符串s1中指定位置c字符前。如果字符串s1中没有c字符，插入失败，函数返回0，如果有c字符，插入成功，返回1。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertsubstr</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">char</span> *s2, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *p1;</span><br><span class="line">p1=<span class="built_in">strchr</span>【(s1, c)】;</span><br><span class="line"><span class="keyword">if</span>(p1==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">   【<span class="built_in">strcat</span>(s2, p1)】;</span><br><span class="line"><span class="built_in">strcpy</span>(p1, s2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行语句：for(i=1; i++&lt;10)后，循环控制变量 i 的值是11。先比较，再自加。</li><li>关于返回指针值的函数<ul><li>函数可以返回自动变量、静态局部变量的值，但是<strong>不能返回自动变量的地址。可以返回静态局部变量的地址。</strong></li></ul></li><li>设有C语句序列：struct T{ int num,  int age} t, * p;  p=&amp; t ;则对结构体变量 t 的成员age引用<ul><li>正确表达： t.age    p -&gt; age     ( * p).age   </li><li>错误表达： * p.age</li></ul></li><li>结构体变量的存储空间是连续的，但其中可能会因<strong>对齐方式</strong>而导致实际结构体所占空间大于结构体变量所有成员所占空间之和。联合体的存储空间是占用最大存储空间成员所需的存储空间。</li><li>32/64位系统，int类型变量都是占4个字节。书上：Turbo2.0为int分配2个字节，Visual C++为int分配4字节。</li><li>在C语言中，进行关系运算时，<strong>逻辑值“真”用数字1表示</strong>，逻辑值“假”是用数字0表示。判别时，<strong>任何非0数字都能够被系统解释为“逻辑真”</strong>。</li><li>已知定义 int (* p)(  ); <strong>p可以指向函数的入口地址。</strong></li><li>写出下面程序执行后的结果</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="number">10</span>;j++)</span><br><span class="line"><span class="keyword">if</span>(j=<span class="number">5</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">2</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">2</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"j=%d,"</span>,j);</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">"i=%d\n"</span>,i);</span><br><span class="line">&#125;</span><br><span class="line">内层<span class="keyword">for</span>循环和<span class="keyword">if</span>语句没有用括号，要注意<span class="keyword">break</span>和<span class="keyword">continue</span>到底是作用的哪个<span class="keyword">for</span></span><br><span class="line">输出结果为：j=<span class="number">5</span>,i=<span class="number">3</span></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;<span class="built_in">string</span>.h&gt;</span><br><span class="line"><span class="keyword">void</span> fun(<span class="keyword">char</span> *s, <span class="keyword">int</span> n);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"ABCDEFG"</span>;</span><br><span class="line">fun(str,<span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="built_in">puts</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> fun(<span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> t, *s1, *s2;</span><br><span class="line">s1=s;  s2=s+n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(s1&lt;s2)</span><br><span class="line">&#123;</span><br><span class="line">t=*s1++;</span><br><span class="line">*s1=*s2;</span><br><span class="line">*s2--=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">注意s1，s2是指向的同一个数组的指针。和指向两个相同数组的指针区别。</span><br><span class="line">输出为：AGFEFGA</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">struct A&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> *y;</span><br><span class="line">&#125;a[<span class="number">4</span>],*p;</span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">10</span>,i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i].x=n;</span><br><span class="line">        a[i].y=&amp;a[i].x;</span><br><span class="line">        n+=<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p=a;</span><br><span class="line">    p++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>,*(p++)-&gt;y,*(++p)-&gt;y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">注意指针的自加结合解引用。*p++ 等同于*(p++)，自增p但返回p自增之前的值。</span><br><span class="line">输出为<span class="number">15</span>，<span class="number">25.</span></span><br></pre></td></tr></table></figure><ul><li>char ch=’a’;   //97<br>int k=12;<br>printf(“%x,%o,”,ch,ch,k);<br>printf(“k=%%d\n”,k);<br><strong>输出为：61，141，k = % d</strong><ul><li>printf函数按照后面的参数对应的顺序逐个输出，而<strong>不理会参数的个数</strong>，如果前面的输出多，如printf(“%x,%o,%d，%d，%d”,ch,ch,k);则<strong>多出的部分输出随机数</strong>；如果后面的多，如printf(“%x,%o,”,ch,ch,k);则，按顺序输出，<strong>多余的被忽略</strong>。</li><li>printf中的%表示格式化输出，即按照<strong>%后面设定的格式输出</strong>，所以，<strong>每两个%就会忽略前面的那个，而取后面的部分，因此 % % d将会输出%d</strong>，而%d不是一个格式，不会输出十进制数字，而是在忽略前一个%后，原样输出，即输出k = % d。</li></ul></li><li>设A为存放短整型的一维数组，如果A的<strong>首地址</strong>为P，那么A中的第i个元素的地址为P+(i-1) * 2。 (地址而不是指针，需要乘以short int的字节数2</li><li>设有说明double( <em> p1)[N], </em> p2[N];<ul><li>标识符p1是<strong>一个</strong>指向由N个double型元素组成的一维<strong>数组</strong>。</li><li>标识符p2是具有N个指针的一维指针数组，每个元素都只能指向double型量</li></ul></li><li>char * func(int x, int y);它是对函数func的<strong>原型声明</strong>。</li><li>对二维数组a进行正确初始化：<ul><li>全部赋初值时，可以不指定第一维，但<strong>必须指定第二维</strong>。</li><li>赋初值可以全部写在一个花括号里，也可以按行赋值(每一行写在一个花括号里)。<strong>按行赋值时</strong>没赋值的元素默认为0(int型)。</li></ul></li><li>设有如下定义：char * a[2]={“abcd, “ABCD”};<ul><li>a数组的两个元素中各自存放了字符’a’和’A’的地址。√</li><li>a数组的两个元素分别存放的是含有4个字符的一维字符数组的首地址。×<br>因为a数组是<strong>指向字符型</strong>的指针数组，而<strong>不是指向一维字符数组</strong>的。</li></ul></li><li>float f=3.14159727;<br>printf(“%f,%5.4f,%3.3f”, f, f, f);<br>则程序输出结果为：3.141593, 3,1416, 3.142 <strong>会四舍五入！</strong>区别于整型相除</li><li>建立一个名为myflie的文件并输入….   fp=fopen(“myfile”, “w”)新建myfile文件并赋予写入相应内容的权限</li><li>浮点数不精确，在作为判断条件时候不能用==，其他的可以，包括&gt;=等。</li><li>x和y为double型，则表达式x=2, y=x+3/2的值是3.000000。</li><li>int i=1, j=2, k=3;<br>if(i++==1&amp;&amp;++j==3 || k++==3)  <strong>\k++==3不会被执行，上一步已经判断完值</strong><br>printf(“%d %d %d\n”,i, j, k);  输出为2 3 3 </li><li>能正确进行字符串赋值的是：<ul><li>char s[5]={‘A’, ‘B’, ‘C’, ‘D’,’E’}; × <strong>没有终止符</strong>‘\0’只是字符数组<strong>不是字符串</strong></li><li>char * S; S=”ABCDE”; √</li></ul></li><li>在文件包含预处理语句的使用形式中，当#include后面的文件名用(双引号)括时，寻找被包含文件的方式是先在源程序所在的目录搜索，如没找到，再按系统设定的标准方式搜索。</li></ul><h4 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h4><ul><li>a.txt b.txt 相同字符作为新的字符串存入c.txt</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[<span class="number">256</span>]=&#123;<span class="string">'\0'</span>&#125;, a[<span class="number">256</span>], b[<span class="number">256</span>]; </span><br><span class="line"><span class="comment">//*arr *a *b不可以 只是指针 不能代表字符串数组的  注意区别</span></span><br><span class="line"><span class="comment">//arrc初始化'\0' 是因为可能一个相同的也没有</span></span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    FILE *fpa, *fpb, *fpc;</span><br><span class="line">    <span class="keyword">if</span>((fpa=fopen(<span class="string">"a.txt"</span>,<span class="string">"r"</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cannt \n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((fpb=fopen(<span class="string">"b.txt"</span>,<span class="string">"r"</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cannt \n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((fpc=fopen(<span class="string">"c.txt"</span>,<span class="string">"w"</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cannt \n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fgets(a,<span class="number">256</span>,fpa);</span><br><span class="line">    fgets(b,<span class="number">256</span>,fpb);</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;*(a+i)!=<span class="string">'\0'</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;*(b+j)!=<span class="string">'\0'</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*(a+i)==*(b+j))</span><br><span class="line">            &#123;</span><br><span class="line">                p=<span class="built_in">strchr</span>(arr,*(a+i));</span><br><span class="line">                <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                     arr[n]=*(a+i);</span><br><span class="line">                     n++;</span><br><span class="line">                     arr[n]=<span class="string">'\0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fputs</span>(arr,fpc);</span><br><span class="line">    fclose(fpa);</span><br><span class="line">    fclose(fpb);</span><br><span class="line">    fclose(fpc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>读取a.txt中的文本行为字符串，并将每一行的数字字符转换成一个实数，将每一行的这些实数的和写入a.txt的尾部。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">extraNumber</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">255</span>];</span><br><span class="line">    <span class="keyword">double</span> sum,num;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">"a.txt"</span>,<span class="string">"r+"</span>))==<span class="literal">NULL</span>) <span class="comment">//不知道为什么vscode运行 a+ 不行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cannot open the file"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fgets(s,<span class="number">255</span>,fp)!=<span class="literal">NULL</span>)   <span class="comment">// while(!feof(fp))&#123;</span></span><br><span class="line">    &#123;                              <span class="comment">//     fgets(s,255,fp);</span></span><br><span class="line">        num = extraNumber(s);</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">"%f"</span>,sum);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">extraNumber</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;*(s+i)!=<span class="string">'\0'</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((*(s+i)&gt;=<span class="string">'0'</span>) &amp;&amp; (*(s+i)&lt;=<span class="string">'9'</span>))</span><br><span class="line">            num = num*<span class="number">10</span> + (<span class="keyword">double</span>)(*(s+i)-<span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.txt beforeafter</span><br><span class="line">abc1c23deabc1c23de</span><br><span class="line">sa1da2sd3asa1da2sd3a246<span class="number">.000000</span></span><br></pre></td></tr></table></figure><ul><li>从键盘上反复输入字符串(直到输入空字符串为止)，将字符串中的所有小写字母转换成对应大写字母，其他字符保持不变，然后后写入文本文件a.txt中。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *p;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">255</span>];</span><br><span class="line">    <span class="keyword">if</span>((p=fopen(<span class="string">"a.txt"</span>,<span class="string">"w"</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cannot open the file\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">strlen</span>(gets(s)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;s[i];i++)</span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;=<span class="string">'a'</span> &amp;&amp; s[i] &lt;= <span class="string">'z'</span>)</span><br><span class="line">                s[i] -=<span class="number">32</span>;</span><br><span class="line">        <span class="built_in">fprintf</span>(p,<span class="string">"%s\n"</span>,s);    <span class="comment">//fputs(s,p); fputc('\n',f);</span></span><br><span class="line">    &#125;</span><br><span class="line">    fclose(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;易错点&quot;&gt;&lt;a href=&quot;#易错点&quot; class=&quot;headerlink&quot; title=&quot;易错点&quot;&gt;&lt;/a&gt;易错点&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;程序填空题：已知程序的功能也要将整个程序的每一个语句看完 (通常有坑)&lt;/li&gt;
&lt;li&gt;求平均值，近似值(小数点)的题目，&lt;strong&gt;注意int类型相除赋值给float型的错误&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;填条件时&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;i 的值是为1还是为0，i 是小于还是小于等于&lt;/li&gt;
&lt;li&gt;i++ 还是 i– ，&lt;strong&gt;i- -通常是逆序操作&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C语言-考研专业课笔记</title>
    <link href="https://daisine.github.io/cky/"/>
    <id>https://daisine.github.io/cky/</id>
    <published>2020-01-02T10:06:47.000Z</published>
    <updated>2020-01-02T12:01:36.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-选填"><a href="#1-选填" class="headerlink" title="1. 选填"></a>1. 选填</h3><h4 id="19年"><a href="#19年" class="headerlink" title="19年"></a>19年</h4><p><strong>选择</strong></p><ol><li>已知float a; int b=1; 执行语句”a=b++/3”后，变量a的值是 _D_<br>A) 2/3        B) 1            C) 1/3            D) 0</li></ol><ul><li><p>考点：不同数据类型间的混合运算[<strong>自动转换</strong>/强制转换]</p><ul><li>两个int型相除，不管是否有余数，结果都为整型。</li><li>+. -. * . /运算的两个数中有一个数为float或double型，结果是double型，因为系统将所有float型数据都先转换为double型，然后进行运算。</li><li>char型与int型数据进行运算，是把字符的ASCII码与整型数据进行运算。</li></ul><a id="more"></a></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> a; <span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line"> a=b++/<span class="number">3</span>;        输出为<span class="number">0.000000</span> -&gt; 等价于a=(<span class="keyword">float</span>)(b++/<span class="number">3</span>);</span><br><span class="line"> a=b++/<span class="number">3.0</span>;      输出为<span class="number">0.333333</span></span><br><span class="line"> a=(<span class="keyword">float</span>)b++/<span class="number">3</span>; 输出为<span class="number">0.333333</span></span><br></pre></td></tr></table></figure><ol start="2"><li>表达式8 / 4 <em> (int)2.5 / (int)(1.25 </em> (3.7+2.3)) 值的数据类型为 _A_<br>A) int        B) float        C) double        D) 不确定</li></ol><ul><li>考点：不同数据类型间的混合运算[自动转换/<strong>强制转换</strong>]<ul><li>(int)(表达式) 表示将括号内的表达式的数据类型<strong>强制转换</strong>为int型。</li><li>两个int型相除，不管是否有余数，结果都为整型。</li></ul></li></ul><ol start="3"><li>以下描述中正确的是 _C_  (但其实4个选项都不对系列)<br>A) 由于do-while循环中循环语句只能是一条可执行语句，所以循环体内不能使用复合语句。<br>B) do-while循环由do开始，用while结束，在while(表达式)后面不能写分号<br>C) 在do-while循环体中，一定要有能使while后面表达式的值变为零(“假”)的操作<br>D) do-while循环中，根据情况可以省略while</li></ol><ul><li>考点：do-while循环的使用<ul><li>A 循环体内可以使用复合语句</li><li>B do-while在while(表达式)后面必须写分号</li><li>C 只要循环体内有break即可，不在乎表达式的内容。[只能勉强选了]</li><li>D do-while循环是一个整体，不能省略while</li></ul></li></ul><ol start="4"><li>为了判断两个字符串s1和s2是否相等，应当使用 _D_<br>A) if(s1==s2)                B) if(s1=s2)<br>C) if(strcpy(s1, s2))        D) if(strcmp(s1, s2)==0)</li></ol><ul><li>考点：字符串处理函数</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>(str);输出字符串</span><br><span class="line">gets(str);输入字符串</span><br><span class="line"><span class="built_in">strcat</span>(str1, str2);将str2放到str1后面，str1的<span class="string">'\0'</span>取消[str1足够大]</span><br><span class="line"><span class="built_in">strcpy</span>(str1, str2);字符数组无赋值语句，用字符串复制函数</span><br><span class="line"><span class="built_in">strncpy</span>(str1, str2, n);将str2的前n个字符复制到str1中去</span><br><span class="line"><span class="built_in">strcmp</span>(str1,str2);自左向右比较两字符串直到出现不同或遇到<span class="string">'\0'</span></span><br><span class="line">        比较的是同位置的字符ascii值大小，返回正，<span class="number">0</span>，负。</span><br><span class="line"><span class="built_in">strlen</span>(str);返回str数组长度(不包括<span class="string">'\0'</span>在内)</span><br><span class="line">strlwr(str);将str中大写字母换成小写字母</span><br><span class="line">strupr(str);将str中小写字母换成大写字母</span><br></pre></td></tr></table></figure><ol start="5"><li>下面程序片段（字符串内没有空格字符）的输出结果是 _C_<br>printf(“%d\n”, strlen(“ATS\n012\’\“));<br>A) 11        B) 10        C) 9            D) 8</li></ol><ul><li>转义字符：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">'\0'</span>表示空字符<span class="string">'\\'</span>表示字符 \</span><br><span class="line"><span class="string">'\a'</span>警告<span class="string">'\''</span>表示字符 '</span><br><span class="line"><span class="string">'\r'</span>回车<span class="string">'\n'</span>换行</span><br></pre></td></tr></table></figure><ol start="6"><li>下列程序是求1到100的累加和，其中有1个不能够完成规定的功能，是 _B_</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A) <span class="keyword">int</span> s=<span class="number">0</span>,i=<span class="number">1</span>;B) <span class="keyword">int</span> s=<span class="number">0</span>,i=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span>(i&lt;=<span class="number">100</span>)s+=i++;   <span class="keyword">while</span>(i++&lt;<span class="number">100</span>)s+=i;</span><br><span class="line">C) <span class="keyword">int</span> s=<span class="number">0</span>,i=<span class="number">0</span>;D) <span class="keyword">int</span> s=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>(i&lt;<span class="number">100</span>) s+=++i;   <span class="keyword">while</span>(++i&lt;=<span class="number">100</span>)s+=i;</span><br></pre></td></tr></table></figure><ul><li>考点：while循环的流程+前缀/后缀自加<br>判断第一次循环s累加的值是否为1以及最后一次循环s累加的值是否为100即可。<br>对选项B：第一次循环 s累加为2 错误</li></ul><ol start="7"><li>根据C语言规定，可知以下不正确的说法是 _B_<br>A) 实参可以是常量、变量或表达式         B) 形参可以是常量、变量或表达式<br>C) 实参可以为任意类型                D) 形参应与其对应的实参类型一致</li></ol><ul><li>考点：实参与形参的区别与联系<br>实参可以是常量、变量、表达式或函数等，但是形参只能是变量。</li></ul><ol start="8"><li>若有以下说明语句，其中只有(    )能获取到c数组的元素的值<br>int c[ 4 ] [ 5 ], (<em> p)[5];<br>p=c;<br>A) p+1        B) </em> (p+3)     C) <em> (p+1)+3        D) </em> ( * p+2) </li></ol><ul><li>考点：数组指针(行指针)与二维数组<ul><li>p是一个指针，指向一个整型的一维数组，这个一维数组的长度是5，也可以说是p的步长。也就是说执行p+1时，p要跨过5个整型数据的长度。</li><li>间接访问：指针变量存放变量i的地址，通过指针找到变量i的地址从而访问变量i。</li><li><strong>指针不等于指针变量。</strong>一个变量的地址称为该变量的指针，指针变量是存放地址的<strong>变量</strong>。</li><li>在二维数组c[ 4 ] [ 5 ]中，<strong>c[0]，c[1]，c[2]，c[3]被看作一维数组名</strong>，即指向对应行首元素的指针。</li><li>‘ &amp; ‘是取地址符号，取得某一个变量的地址；如：&amp;a</li><li>‘ * ‘ 是指针运算符，可以表示一个变量是指针类型；也可以表示一个指针变量的所指向的存储单元，获取某个地址存储的值。<br><img src="/cky/0.png" width="10%" height="80%"></li></ul></li></ul><p>A：p+1是指向c[1]的指针。c[1]本身又是指向c[ 1 ] [ 0 ]的指针，存放的是c[ 1 ] [ 0 ]的地址。<em> (p+1)可以获得c[1]的值即&amp;c[ 1 ] [ 0 ]，</em> (  <em> (p+1))即为c[ 1 ] [ 0 ]的值。<br>B：</em> (p+3) 是指向c[3]指针，c[1]本身又是指向c[ 1 ] [ 0 ]的指针，等价于&amp;c[ 3 ] [ 0 ]。<br>C：<em> (p+1) + 3是指向第二行的第4个元素的指针，值为c[ 1 ] [ 3 ] 的地址，等价于&amp;c [ 1 ] [ 3 ]。<br>D：</em> ( * p+2)是对c[ 0 ] [ 2]的引用，等价于c[ 0 ] [ 2 ]。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c[<span class="number">4</span>][<span class="number">5</span>]=&#123;&#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;,&#123;<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>&#125;,  &#123;<span class="number">31</span>,<span class="number">32</span>,<span class="number">33</span>,<span class="number">34</span>,<span class="number">35</span>&#125;,&#123;<span class="number">41</span>,<span class="number">42</span>,<span class="number">43</span>,<span class="number">44</span>,<span class="number">45</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">5</span>];</span><br><span class="line">p=c;    将c的首元素地址c[<span class="number">0</span>][<span class="number">0</span>]赋值给p</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *(*(p+<span class="number">1</span>)));  输出<span class="number">21</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *(*(p+<span class="number">3</span>)));输出<span class="number">41</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *(*(p+<span class="number">1</span>)+<span class="number">3</span>)); 输出<span class="number">24</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *(*p+<span class="number">2</span>));输出<span class="number">13</span></span><br></pre></td></tr></table></figure><ol start="9"><li>下列程序的输出结果是 _A_</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *s1=<span class="string">"ABCdEf"</span>, *s2=<span class="string">"aB"</span>;</span><br><span class="line">s1++;s2++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">strcmp</span>(s1,s2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A) 正数        B) 负数         C) 零        D) 不确定的值 </p><ul><li>考点：字符串处理函数与大小写字母Ascii值关系<br>strcmp(s1,s2)，由于s1++;s2++，从s1和s2的第二个字符开始:<br>‘B’ - ‘B’=0 -&gt; ‘C’-‘\0’ = 67 - 0 = 67<br>输出结果为67</li></ul><ol start="10"><li>以下scanf函数调用语句中对结构体变量成员的不正确引用是 _D_ </li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pupll</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];<span class="keyword">int</span> age; <span class="keyword">int</span> sex;</span><br><span class="line">&#125;pup[<span class="number">5</span>],*p;</span><br><span class="line">p=pup;</span><br></pre></td></tr></table></figure><p>A) sancf(“%s”, pup[0].name)     B) scanf(“%d”, &amp;pup[0].age)<br>C)scanf(“%d”, &amp;(p-&gt;sex));        D)scanf(“%d”, p-&gt;age) </p><ul><li>考点：结构体变量 / 结构体数组 的初始化与引用 P297， 指向结构体的指针 P303<ul><li>“ . “运算符是成员运算符，它在所有运算符中优先级最高。<br>A. pup[0].name表示：结构体数组pup的第一个元素的name成员。name为表示姓名的一维字符数组名，也就是指向该数组的首元素的指针，所以不用+’&amp;’ √<br>B. pup[0].age，由于age是整数型，因此使用scanf输入需要在前面+’&amp;’ √<br>C. p为指向pup[0]的结构体指针，即p等于&amp;pup[0]等于pup，p-&gt;sex表示结构体数组pup中第一个元素sex成员，pup[0].sex的地址需要在前面+’&amp;’ √<br>D. 与C选项类似，需要在p-&gt;age的前面+’&amp;’ ，本身就是pup[0].age。 ×</li></ul></li></ul><p><strong>填空/程序阅读题</strong></p><ol><li>下列程序的输出结果是 <em>yes</em></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">'0'</span> &lt;= c || c &lt;= <span class="string">'9'</span>) <span class="built_in">printf</span>(<span class="string">"yes"</span>);注意这里是 <span class="string">"||"</span> 不是 <span class="string">"&amp;&amp;"</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"no"</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>若运行时输入：-2&lt;回车&gt;，则以下程序的输出结果为 _2_</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">b = (a&gt;=<span class="number">0</span>)? a:-a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"b=%d"</span>,b);</span><br></pre></td></tr></table></figure><ol start="3"><li>程序读入20个整数，统计非负数个数，并计算负数之和，请在【   】处填入适当内容。</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i, a[<span class="number">20</span>], sum, count;</span><br><span class="line">sum = count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(【 a[i]&gt;=<span class="number">0</span> 】)&#123;</span><br><span class="line">   【 sum += a[i] 】;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>gets()函用来从标准输入设备读入一个字符串， <em>puts()</em> 函数用来从标准输入设备输出一个字符串。putchar()函数是用来向输出设备输出一个字符，而 <em>getchar()</em> 函数用来从输入设备读取一个字符。</li><li>下面程序的功能：输出100以内能被3整除且个位数为6的所有整数。请在【   】处填入适当内容。</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;【i&lt;<span class="number">10</span>】; i++)&#123;</span><br><span class="line">j = i*<span class="number">10</span>+<span class="number">6</span>;</span><br><span class="line"><span class="keyword">if</span>(【 j%<span class="number">3</span> != <span class="number">0</span> 】)<span class="keyword">continue</span>; 提前结束本次循环，进入下一次循环</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>若一个外部变量的定义形式为static int x; 那么，其中static的作用应该是 <em>使x只能在本文件内引用</em></li><li>下面程序的输出结果是：1,2,3,</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">x++;<span class="built_in">printf</span>(<span class="string">"%d,"</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)add();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>P206 x 是静态局部变量，<strong>在add()调用结束后，它并不释放，保留其当前值。</strong><br>静态局部变量：<strong>在编译时赋初值，且只赋初值一次</strong>。</li></ul><p>自动变量：在函数调用时赋初值。</p><ol start="8"><li>当从键盘输入18时，程序运行后变量i的最终值为 _5_ ，程序的运行结果是 <em>10010</em> 。</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x,y,i = <span class="number">0</span>,j,u,v,a[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">y = x;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">u = y/<span class="number">2</span>; a[i] = y%<span class="number">2</span>; i++; y = u;</span><br><span class="line">&#125;<span class="keyword">while</span>(y&gt;=<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(j=i<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)<span class="built_in">printf</span>(<span class="string">"%d"</span>, a[j]);  a[<span class="number">5</span>]-&gt;a[<span class="number">0</span>]输出</span><br></pre></td></tr></table></figure><ol start="9"><li>下面程序的输出结果是： _5_</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">b--; p = &amp;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="comment">//竟然不是int main()？</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, *p = &amp;a;</span><br><span class="line">fun(p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>考点：按值传递和按指针传递 + 指针变量作为函数参数 P229</li><li>实参和形参之间数据传的是单向的。用指针变量作函数参数同样遵循这一规则。<strong>不可能通过调用函数来改变实参指针变量的值，但可以改变实参指针变量所指向变量的值</strong>。</li><li><ul><li>(&amp;a)等于a，而不是等于p，</li></ul></li><li>int <em> p = &amp;a只有在定义的时候初始化是这样写，否则写成int </em> p, p = &amp;a<br>示例如下：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_fail</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = p1; p1 = p2; p2 = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_success</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">*p = *p1; *p1 = *p2; *p2 = *p; </span><br><span class="line">p1 p2所指向的地址没变。但对应地址所存放的值交换了。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="10"><li>下面程序用变量count统计文件中字符的个数。请在【   】处填入适当内容。</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stido.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">FILE *fp; <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>((fp=fopen(<span class="string">"letter.dat"</span>,<span class="string">"r"</span>)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"cannot open file\n"</span>);<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!feof(fp))&#123;  </span><br><span class="line">【 fgetc(fp) 】;【 count++ 】;&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"count=%ld\n"</span>,count);</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>feof()函数用来检测当前文件流上的文件结束标识，判断是否读到了文件结尾：<br>int feof(FILE * stream);<br>【参数】stream为文件流指针。<br>【返回值】检测到文件结束标识返回1，否则返回0。</li><li>int <strong>fgetc</strong>(FILE * stream) 从指定的流 stream 获取下一个字符（一个无符号字符），并把<strong>位置标识符往前移动</strong>。</li></ul><h4 id="18年"><a href="#18年" class="headerlink" title="18年"></a>18年</h4><ul><li><strong>宏替换</strong>不占用运行时间，只占用编译时间 √(区别：宏定义&amp;宏替换)<br>在程序的一行上只允许一个宏定义(因为宏定义不是语句，没有用逗号隔开)</li><li><strong>逗号表达式</strong>：从左往右执行，但最后只输出最右部分的内容<br>eg.表达式a=1, a+1, a++的值是____<br>从左往右顺序执行，将1赋值给a，a+1没有改变a的值，<em> </em> a++是先返回a的值1，再使a的值加1。<em> </em> 因此最后的答案为1。</li><li><strong>指针的自增运算</strong><br>eg. int x[ ] = {1, 2, 3, 4, 5} , <em> p =x，值为3的表达式：____<br>A.p+=2, </em> ++p        B. p+=2, <em> p++        C. p+=2, </em> p        D.p+=2,  ++ * p<ol><li>选项ABCD都是逗号表达式，选项内不是并列的关系。</li><li>++a，在使用a之前，先使a的值加1，再使用a。<br>a++，在使用a之后，再使a的值加1。</li><li>解引用的优先级低于后缀 + + 操作符， <em> p+ + 等同于 </em> (p++)，它自增p并返回p 自增之前所指向的值。要自增 p 指向的值, 使用 ( <em> p)+ + , 如果副作用的顺序无关紧要也可以使用 ++ </em> p。</li></ol></li><li>自动型(auto)变量存储在动态存储区，分配在内存的堆栈区；静态局部变量存储在静态存储区；寄存器存储在CPU的寄存器中。（P204)<ul><li>程序代码区：存放函数体的二进制代码。</li><li>静态数据区：也称全局数据区，包含的数据类型比较多，如全局变量、静态变量、一般常量、字符串常量</li></ul></li></ul><h4 id="17年"><a href="#17年" class="headerlink" title="17年"></a>17年</h4><ul><li>关键字：while, case, char, if(不等于IF C语言严格区分大小写)<br><a href="http://c.biancheng.net/cpp/html/797.html" target="_blank" rel="noopener">C语言32个关键字</a></li><li>C语言标准库函数：getc, printf, sancf, pow</li><li>宏包含预处理指令：include</li><li>宏定义预处理指令：define</li><li>scanf中“%3d”代表：输入的数据的域宽为3列区域(靠右)，域宽应为正整数。<br>scanf的输入格式与scanf函数中的格式字符形式<strong>严格对应</strong>。 -P77-</li><li>指定数据宽度和小数位数，用%m.nf<ul><li>f 格式符：以小数形式输出实数，不指定输出数据的长度，由系统处理。</li><li>系统一般是输出实数中的全部整数部分+6位小数部分。<br>eg.printf(“%20.15f\n”, a/3) 指定输出的数据占20列，其中包括15位小数。</li></ul></li><li>若int型数据在内存中占2个字节，则unsigned int型数据的取值范围0-65535<br><strong>2^16 - 1 = 65535    2^8-1=32767</strong></li><li>计算a、b中最小值的条件表达式为a=(a&gt;b?) b:a</li></ul><h3 id="2-编程题-手写代码"><a href="#2-编程题-手写代码" class="headerlink" title="2. 编程题(手写代码)"></a>2. 编程题(手写代码)</h3><h4 id="19年-1"><a href="#19年-1" class="headerlink" title="19年"></a>19年</h4><ol><li>编程将1、2、3、4四个数字所组成的互不相同且无重复数字的三位数全部找出来。</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[N];</span><br><span class="line">    <span class="keyword">int</span> i,j,k, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)</span><br><span class="line">            <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=<span class="number">4</span>;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=j &amp;&amp; j!=k &amp;&amp; k!=i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%5d"</span>,<span class="number">100</span>*i+<span class="number">10</span>*j+k);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The total number is: %d "</span>, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line">输出为:</span><br><span class="line">  <span class="number">123</span>  <span class="number">124</span>  <span class="number">132</span>  <span class="number">134</span>  <span class="number">142</span>  <span class="number">143</span></span><br><span class="line">  <span class="number">213</span>  <span class="number">214</span>  <span class="number">231</span>  <span class="number">234</span>  <span class="number">241</span>  <span class="number">243</span></span><br><span class="line">  <span class="number">312</span>  <span class="number">314</span>  <span class="number">321</span>  <span class="number">324</span>  <span class="number">341</span>  <span class="number">342</span></span><br><span class="line">  <span class="number">412</span>  <span class="number">413</span>  <span class="number">421</span>  <span class="number">423</span>  <span class="number">431</span>  <span class="number">432</span></span><br><span class="line">&gt; The total numbers: <span class="number">24</span></span><br></pre></td></tr></table></figure><ol start="2"><li>设计程序将二维数组a中的n个整数按相反顺序存放，即定义一个数组a并附初值a[ 4 ] [ 3 ]  =<img src="/cky/3.jpg" width="10%" height="80%"><br>，首先按照3x4格式输出该数组，然后通过设计排序函数sort来对a数组元素重新排序，使其元素值排列为a[ 4 ] [ 3 ] =<img src="/cky/4.jpg" width="10%" height="80%">，随后按3x4格式输出数组。</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putarray</span><span class="params">( <span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%5d"</span>,*(p+<span class="number">3</span>*i+j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">11</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">11</span>-i;j++)</span><br><span class="line">        &#123;           </span><br><span class="line">            <span class="keyword">if</span>(*(p+j)&lt; *(p+j+<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                temp = *(p+j);</span><br><span class="line">                *(p+j) = *(p+j+<span class="number">1</span>);</span><br><span class="line">                *(p+j+<span class="number">1</span>) = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;, &#123;<span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>&#125;, &#123;<span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>&#125;, </span><br><span class="line">  &#123;<span class="number">19</span>, <span class="number">21</span>, <span class="number">23</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p =a[<span class="number">0</span>];</span><br><span class="line">    putarray(p);</span><br><span class="line">    sort(p);</span><br><span class="line">    putarray(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出为：</span><br><span class="line">    <span class="number">1</span>    <span class="number">3</span>    <span class="number">5</span></span><br><span class="line">    <span class="number">7</span>    <span class="number">9</span>   <span class="number">11</span></span><br><span class="line">   <span class="number">13</span>   <span class="number">15</span>   <span class="number">17</span></span><br><span class="line">   <span class="number">19</span>   <span class="number">21</span>   <span class="number">23</span></span><br><span class="line"></span><br><span class="line">   <span class="number">23</span>   <span class="number">21</span>   <span class="number">19</span></span><br><span class="line">   <span class="number">17</span>   <span class="number">15</span>   <span class="number">13</span></span><br><span class="line">   <span class="number">11</span>    <span class="number">9</span>    <span class="number">7</span></span><br><span class="line">    <span class="number">5</span>    <span class="number">3</span>    <span class="number">1</span></span><br></pre></td></tr></table></figure><ol start="3"><li>请编写一个函数fun()，它的功能是：比较两个字符串的长度，(不得调用C语言提供的求字符串长度函数)，函数返回较长的字符串。若两个字符串长度相等，则返回第1个字符串。例如，输入beijing&lt;回车&gt;shanghai&lt;回车&gt;，函数将返回shanghai</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *p, <span class="keyword">char</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="number">0</span>, len2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *str1=p, *str2=q;</span><br><span class="line">    <span class="keyword">while</span>(*str1 != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len1++;</span><br><span class="line">        str1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*str2 !=<span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len2++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;;    </span><br><span class="line">    <span class="keyword">if</span>(len1 &gt;= len2)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> q;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">20</span>], b[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Input 1st string:"</span>);</span><br><span class="line">gets(a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Input 2ed string:"</span>);</span><br><span class="line">gets(b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, fun(a,b));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出为：</span><br><span class="line">Input <span class="number">1</span>st <span class="built_in">string</span>:beijing</span><br><span class="line">Input <span class="number">2</span>ed <span class="built_in">string</span>:shanghai</span><br><span class="line">shanghai</span><br><span class="line"></span><br><span class="line">Input <span class="number">1</span>st <span class="built_in">string</span>:<span class="number">123</span></span><br><span class="line">Input <span class="number">2</span>ed <span class="built_in">string</span>:abc</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><h4 id="18年-1"><a href="#18年-1" class="headerlink" title="18年"></a>18年</h4><ul><li>请编写函数void fun(char* s) ，函数的功能是：在字符串中所有数字字符前加一个\$字符。例如，输入：A1B23CD45，则输出为：A1B\$2$3CD\$4\$5。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">2</span>*<span class="built_in">strlen</span>(s));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s);i++,j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">p[j] = <span class="string">'$'</span>;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">p[j] = s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s \n"</span>,p);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">20</span>] = &#123;<span class="string">"ada12j213"</span>&#125;;</span><br><span class="line">    fun(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>请编写一个函数double fun(double h)，函数的功能是对变量h中的值保留2位小数，并对第三位进行四舍五入。例如：h值位8.32433，则函数返回8.32；h的值为8.32533，则函数返回8.33。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fun</span><span class="params">(<span class="keyword">double</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> b = (<span class="keyword">int</span>)(h*<span class="number">100</span>)/<span class="number">100.0</span>;</span><br><span class="line"><span class="keyword">if</span>((<span class="keyword">int</span>)(h*<span class="number">1000</span>)%<span class="number">10</span> &gt;= <span class="number">5</span>)</span><br><span class="line">    b = (<span class="keyword">int</span>)(h*<span class="number">100</span>+<span class="number">1</span>)/<span class="number">100.0</span>;</span><br><span class="line"><span class="keyword">return</span> b; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lf"</span>,fun(a));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="17年-1"><a href="#17年-1" class="headerlink" title="17年"></a>17年</h4><ul><li>什么是全局变量和局部变量？局部变量有哪几种存储类型？<br>全局变量：所有函数外部定义的变量，作用域为整个程序(即所有源文件，包括.c和.h文件)。<br>局部变量：定义在函数体内部的变量，作用域仅限于函数体内部。<ul><li>局部变量的存储类型：auto，static，register</li></ul></li><li>C语言中，函数参数的传递有哪几种方式，各自的特点是什么？<ol><li>值传递：函数调用中发生的<strong>数据传递</strong>是<strong>单向</strong>的，只能把实参的值传递给形参，而不能把形参的值反向地传递给实参。形参的值发生<strong>改变</strong>并<strong>不会影响实参</strong>。</li><li>地址(指针)传递：将<strong>函数外部的地址</strong>传递到函数内部，使得在函数内部可以操作函数外部的数据，并且这些数据<strong>不会随着函数的结束</strong>而被<strong>销毁</strong>。</li><li>引用传递：调用函数时，将<strong>实参的地址</strong>传递到函数中，在函数中对参数所进行的修改<strong>将影响到实参</strong>。</li></ol></li><li><p>简要说明关键字static的作用。</p><ol><li><strong>修饰变量。</strong>变量又分为局部和全局变量。<br><strong>静态全局变量</strong>：在函数体之外定义，作用域仅限于变量被定义的文件。<br><strong>静态局部变量</strong>：在函数体里定义，只能在这个函数里使用。在静态存储区内分配存储单元，所以函数调用结束后值不会被销毁。</li><li><strong>修饰函数。</strong>函数前加static 使得函数成为静态函数。<br>但此处“static”的含义不是指存储方式，而是指对函数的作用域仅局限于本文件(所以又称内部函数)。</li></ol></li><li><p>用C语言编写一个程序，从data.txt读入整数n后，从内存中分配存储n个双精度实数的存储空间(动态数组)，再从文件 data.txt中读入n个实数存放到这个动态数组中，然后求该数组的平均值。最后，释放动态数组、关闭文件和打印平均值。</p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line">    <span class="keyword">float</span> sum, avg, *arr;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">"data.txt"</span>,<span class="string">"r"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"can't open the file"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fputs("3 1 2 3", fp); 同时要修改fopen的权限</span></span><br><span class="line">    <span class="comment">// rewind(fp);</span></span><br><span class="line">    <span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    arr = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fscanf</span>(fp,<span class="string">"%f"</span>, &amp;arr[i]);</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    avg = sum / n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"avg is %f"</span>,avg);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用C语言编写函数int fun(char s[], char c)，函数的功能是从字符串s中删除指定的字符。同一字母的大、小写按不同字符处理。例如，当程序执行时，输入字符串为”turbo C and borland  c++”，从键盘输入字符’n’，则输出后变为“turbo C ad borlad c++”。要求写出调用该函数的主函数。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> s[], <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line">p = s;</span><br><span class="line"><span class="keyword">while</span>(*p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(*p != c)</span><br><span class="line">&#123;</span><br><span class="line">s[i] = *p;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line">s[i] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">20</span>], c;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"please enter the string\n"</span>);</span><br><span class="line">gets(s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"please enter the char that will be deleted.\n"</span>);</span><br><span class="line">c = getchar();</span><br><span class="line">fun(s, c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-选填&quot;&gt;&lt;a href=&quot;#1-选填&quot; class=&quot;headerlink&quot; title=&quot;1. 选填&quot;&gt;&lt;/a&gt;1. 选填&lt;/h3&gt;&lt;h4 id=&quot;19年&quot;&gt;&lt;a href=&quot;#19年&quot; class=&quot;headerlink&quot; title=&quot;19年&quot;&gt;&lt;/a&gt;19年&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;选择&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;已知float a; int b=1; 执行语句”a=b++/3”后，变量a的值是 _D_&lt;br&gt;A) 2/3        B) 1            C) 1/3            D) 0&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;考点：不同数据类型间的混合运算[&lt;strong&gt;自动转换&lt;/strong&gt;/强制转换]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个int型相除，不管是否有余数，结果都为整型。&lt;/li&gt;
&lt;li&gt;+. -. * . /运算的两个数中有一个数为float或double型，结果是double型，因为系统将所有float型数据都先转换为double型，然后进行运算。&lt;/li&gt;
&lt;li&gt;char型与int型数据进行运算，是把字符的ASCII码与整型数据进行运算。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="软件工程" scheme="https://daisine.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="note" scheme="https://daisine.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>SQL-考研专业课笔记</title>
    <link href="https://daisine.github.io/sqlky/"/>
    <id>https://daisine.github.io/sqlky/</id>
    <published>2020-01-02T10:06:47.000Z</published>
    <updated>2020-01-02T11:58:58.004Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-选填"><a href="#1-选填" class="headerlink" title="1. 选填"></a>1. 选填</h3><h4 id="12年"><a href="#12年" class="headerlink" title="12年"></a>12年</h4><ul><li>数据完整性约束的建立需要通过数据库管理系统提供的 <em>数据定义语言</em> 来实现。</li><li>某高校五个学院的学生信息存放在同一个基本表中，采取建立各学院的行级视图，并将对该视图的读权限赋予该学院的管理员。</li><li>设关系R与S的<strong>属性个数</strong>分别为 r 和 s，则(R X S)操作结果的b为 <em>r+s</em> 。</li><li>学生关系R(sno, sname, dno, mag)，其中sno为学生号，sname为学生姓名，dno为学院号，mag为院长，主键诶sno，则关系R属于 <em>2NF</em> 。<br>sno → (sname, dno, mag) 完全依赖<br>dno → mag   传递函数依赖而非直接函数依赖，故不是3NF</li></ul><a id="more"></a><ul><li>索引提高了查询的速度，但一般会降低更新的速度。<br>不应该创建索引的情况： <em>修改性能远远大于检索性能</em></li><li>规范化理论是关系数据库进行逻辑设计的理论依据，根据这个理论，关系数据库中的关系必须满足：每一个属性都是 <em>不可分解的</em> 。</li><li><em>DBA - 数据库管理员</em> 是指负责数据库的建立、使用和维护的专门人员。</li><li>在关系代数运算中，从关系中取出满足条件的元组的运算称为 _选择_ 。</li><li><em>存储过程</em> 是一组为了完成特定功能的SQL语句集，经<strong>编译后</strong>存储在数据库中。用户通过指定其名字并给出参数来执行它，一般是作为独立的部分来执行。</li><li>在传统关系系统中，关系是笛卡尔积的子集/关系是一张二维表，其中的元组次序可以交换， <em>关系不可以嵌套定义</em> 。(1NF)</li><li>数据的<strong>物理独立性</strong>是指用户和用户程序不依赖于数据库的物理结构。<br>数据的<strong>逻辑独立性</strong>是指当数据库重构造时，用户和用户程序不受影响。</li></ul><h4 id="13年"><a href="#13年" class="headerlink" title="13年"></a>13年</h4><ul><li><strong>嵌入式SQL</strong>中负责向主语言传递SQL语句执行状态的是 <em>SQLCA</em> 。<ol><li><strong>主变量</strong>实现主语言与SQL语句交换数据。</li><li><strong>游标</strong>用于将SQL查询结果集带回给主语言进行逐行处理。</li><li><strong>SQLCA</strong>用于传递SQL语句的执行状态给主语言，再由主语言据此决定程序执行流程。</li><li><strong>SQL语句</strong>只能对数据库对象进行操作。</li></ol></li><li>存储过程和函数的区别：<ol><li>存储过程可以返回参数，而函数只能返回值或者表对象。</li><li>存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用。</li><li>存储过程在调用时才加载，函数在系统启动时就进行编译并加载。</li><li>一般来说，存储过程实现的功能要复杂一些，函数实现的功能针对性更强    </li></ol></li><li>数据库系统中完整性约束的句子主要有三种： <em>主键(primary key)</em>、检查子句(check)和外键子句 (foreign key)。</li><li>数据库系统的体系结构分为单用户结构、主从式结构、分布式结构、 <em>客户机</em>服务器结构_ 和 <em>浏览器</em>服务器结构_ 。</li></ul><h4 id="14年"><a href="#14年" class="headerlink" title="14年"></a>14年</h4><ul><li>在<strong>SQL Server2008</strong>中，<strong>Master数据库</strong>记录SQL Server系统的所有系统级信息，包括实例范围内的元数据、端点、链接服务器和系统配置设置。<ol><li><strong>Model数据库</strong>用作SQL Server实例上创建的所有数据库的模板。</li><li><strong>Resource数据库</strong>是一个只读数据库，包含SQL Server包括的系统对象。</li><li><strong>tempdb数据库</strong>是一个工作空间，用于保存临时对象或中间结果集。P69</li></ol></li><li>数据库的三级模式结构是指数据库系统由外模式、模式、内模式三级构成，数据库的三级模式结构保证了 <em>数据库的独立性</em> 。</li></ul><h4 id="15年"><a href="#15年" class="headerlink" title="15年"></a>15年</h4><ul><li>在select语句中使用sum(列名)时，列名要求 <em>不限制数据类型</em> 。</li><li><p>数据库安全性控制措施：审计，视图，加密</p></li><li><p>SQL语言中 commit 语句的主要作用是 <em>提交事务</em> 。</p></li><li>在视图上<strong>不能</strong>完成的操作是 <em>在视图上定义新的基本表</em> 。</li><li>DMBS总是基于某种数据模型，可以分为层次型、网状型、关系型和面向对象型DBMS。</li><li>并发控制是以 _事务_ 为单位进行的。</li><li>在数据库系统中，游标是系统为用户开设的一个 <em>数据缓冲区</em> ，存放SQL语句的执行结果。</li><li>SQL语句通过 <em>revoke语句</em> 实现收回所授权限的操作。<br>revoke &lt;权限&gt; [on &lt;对象类型&gt; &lt;对象名&gt;]  from &lt;用户&gt;</li><li>结构化查询语言SQL是一种关系数据库语言，其主要功能有数据定义、数据查询、 <em>数据操纵</em>、数据控制等。</li></ul><h4 id="16年"><a href="#16年" class="headerlink" title="16年"></a>16年</h4><ul><li>“age between 18 and 40”短语的正确含义是： <em>age&lt;=40 and age&gt;=18</em></li><li>存储过程是一组预先 _定义_ 并 _编译_ 的T-SQL语句。</li><li>数据库的完整性是指保护数据库中数据的正确性、 <em>有效性</em> 和相容性，防止不合语义的数据进入数据库。</li><li>通过加锁可以保证处理程序开发时的数据 <em>一致性</em> 。</li><li>视图是关系数据库系统提供给用户以多角度观察数据库数据的重要机制。视图是从一个或几个基本表(或视图)导出的 <em>虚拟表</em> ，通过视图可以看到数据库中相应的数据及其变化。</li></ul><h4 id="17年"><a href="#17年" class="headerlink" title="17年"></a>17年</h4><ul><li>数据库类型是按照 <em>数据模型</em> 来划分的。</li><li><em>数据无冗余</em> 不属于<strong>数据库的特点</strong>。一般我们说<strong>数据冗余度低</strong>。<br>特点：数据结构化，数据共享，数据独立性高，数据的完整性、灵活性、安全性 </li><li>在关系代数中，从一个关系中选取若干属性列组成新的关系，称为<strong>投影</strong>。P42</li><li>属性A是关系R的主属性，则属性A不能取空值，这是 <em>实体完整性规则</em> 。P37</li><li>在SQL语言中，删除基本表的命令是 <em>drop table</em> 。</li><li>存储过程 <em>不是客户端的程序</em> 。<br>存储过程是数据库服务器端的一段程序。<pre><code>* Type1:(select)检索数据，检索到的数据以数据集的形式返回给客户端。* Type2:(insert, delete)不返回数据，只执行一个动作</code></pre>存储过程的作用：<pre><code>* 屏蔽表的细节，起到安全作用。* 简化用户的操作。* 提高系统的执行效率。</code></pre></li><li><em>触发器</em> 是一种特殊的存储过程，它可以在对一个表进行insert、update和delete操作中任一种或几种操作时被自动调用。</li><li><em>封锁(技术)</em> 是目前DBMS普遍采用的并发控制的方法，可以有效地控制并发事务之间的相互作用，保证数据的一致性。</li><li>如果一个属性或属性集合的值能唯一标识一个关系的元组而又不含有多余的属性，则称该属性或属性集合为该关系的 <em>候选键</em> 。</li></ul><h4 id="18年"><a href="#18年" class="headerlink" title="18年"></a>18年</h4><p>用关系型数据库系统来管理数据，数据由 <em>DBMS</em> 统一管理和控制，数据的独立性高，共享性好，冗余度低。</p><ul><li>基本的SQL语言不可以实现 <em>并发控制</em>。</li><li>数据库管理机制要解决丢失更新、不一致以及 <em>“脏资料”</em> 等问题，可以通过枷锁技术解决。</li><li>数据库系统中，<strong>游标</strong>是系统为用户开设的一个数据缓冲区，存放SQL语句的 <em>结果数据集</em> 。</li><li>数据库设计的一般步骤包括需求分析、概念结构设计、逻辑结构设计、 <em>数据库物理设计</em>、数据库实施、数据库运行维护等。</li><li>关系模式SCS(Sno, Cno, Score)中，Sno是学生的学号，Cno是课程号，Score为成绩。需查询出每门课的平均成绩，且要求查询结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列，其SQL语言可写为：<br>select Cno, avg(Score) from SCS group by Cno order by Cno/2 desc<pre><code>* order by 2 = order by Cno 表示按照第二列。* 默认升序，即asc，可以省略不写。</code></pre></li><li>SQL语句select语句中，“having条件表达式”用来筛选满足条件的 <em>组(group)</em> 。</li><li>数据库的并发操作可能带来的问题包括 <em>丢失更新</em> 、 <em>不可重复读</em> 和 <em>读“脏“数据。</em></li><li>E-R图某实体具有一个多值属性，在转化为关系模式时，应 <em>将实体的键与多值属性单独构成关系模式</em> 。 -课本P250-<br>Way1:将联系转换成一个独立的关系，其关系的属性由与该联系相连的各实体键以及联系本身的属性组成，而该联系的键为n端实体集的键。<br>Way2:在n端实体集增加新属性，新属性由联系对应1端实体集的键和联系自身的属性构成， <em><strong>新增属性后原关系的键不变。</strong></em></li><li>数据库三级模式体系结构的划分，有利于保持数据库的 <em>数据独立性</em> ；外模式<em>模式的映像保证逻辑独立；模式</em>内模式则保证 <em>物理独立性</em> 。</li><li>主键的<strong>列</strong>一定是not null，在行记录不可重复，可以将若干非null列合并起来作为主键。主键的列数据类型不受约束。</li><li><em><strong>完整性约束</strong></em> ：主键约束(实体完整性)、外键约束(参照完整性)、属性约束(用户定义的完整性)、域约束、断言约束。 -课本P156 对应笔记-</li><li>为数据表创建索引的目的是 <em>提高查询的检索性能</em> 。</li><li>关系数据库用 <em>表格数据</em> 来表示实体之间的联系，其任何检索操作的实现都是由 <em><strong>选择、投影和连接</strong></em> 三种基本操作组合而成。</li><li>结构化查询语言SQL是一种关系型数据库语言。其主要功能有数据定义、数据操作和 <em>数据查询和数据控制</em> 。</li><li>数据字典包括：1.数据项、2.数据结构、3.数据存储、4.数据流和5.处理过程。</li><li>员工工资总额在800元至30000元之间”的约束属于DBMS的 <em>完整性控制</em><br>A．封锁控制<br>B．并发控制<br>C．完整性控制<br>D．安全性控制</li></ul><h4 id="19年"><a href="#19年" class="headerlink" title="19年"></a>19年</h4><ol start="11"><li>下列四项中，不属于数据库系统的主要特点的是 _B_<br>A) 数据结构化                 B) 程序的标准化<br>C) 较高的数据独立性            D) 数据的冗余度小</li></ol><ul><li>考点：数据库的特点<br>数据库具有较<strong>小</strong>冗余度、较高的程序与数据独立性、易于扩充和数据结构化的特点。</li></ul><ol start="12"><li>保护数据以防止未经授权或不合法的使用造成的数据泄露、更改或破坏是指数据库的 _A_<br>A) 安全性控制     B) 完整性控制     C) 并发控制        D)故障恢复</li><li>视图是一个“虚表”，视图的构造基于 _C_<br>A) 基本表         B) 视图            C)基本表或视图    D)数据字典 </li><li>关系数据模型的三个组成部分中，不包括 _C_<br>A) 完整性约束     B) 数据结构         C) 恢复            D)数据操作</li></ol><ul><li>考点：关系数据模型的三个组成部分：1.数据结构、2.数据操作 3.完整性约束。</li></ul><ol start="15"><li>设属性A是关系R的主属性，则属性A不能取空值(NULL)，这是 _A_<br>A) 实体完整性规则             B) 参照完整性规则<br>C)用户定义完整性规则        D) 域完整性规则</li></ol><ul><li>考点：<ul><li>实体完整性：规定表的每一行在表中是惟一的实体。</li><li>域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。</li><li>参照完整性：是指两个表的主键和外键的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。</li><li>用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。</li></ul></li></ul><ol start="16"><li>现有关系表：学生（宿舍编号，宿舍地址，学号，姓名，性别，专业，出生日期）的主键是 _B_<br>A) 宿舍编号                    B) 学号<br>C) 宿舍地址、姓名            D) 宿舍编号、学号</li></ol><ul><li>主键：学号可以唯一标识一条记录。<br>学号→(宿舍编号, 宿舍地址, 学号, 姓名, 性别, 专业, 出生日期) 完全依赖√<br>宿舍编号→宿舍地址   传递函数依赖√ 而非直接函数依赖，故不是3NF</li></ul><ol start="17"><li>如果事务T已在数据R上加了X锁，则其他事务在数据R上 _D_<br>A) 只可加X锁                     B) 只可加S锁<br>C) 可加S锁或X锁                D) 不能加任何锁</li></ol><ul><li>封锁类型：<ul><li>排它锁(写锁/独占锁)：若事务T对数据对象A加上X锁 / 排他锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。</li><li>共享锁(读锁)：若事务T对数据对象A加上S锁 / 共享锁，则事务T可以读A但不能修改A，其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。</li></ul></li></ul><ol start="18"><li>如果一个班只能有一个班长，而且一个班长不能同时担任其他班的班长，班级和班长两个实体之间的关系属于 _D_<br>A) m:n        B) 1:m         C) m:1        D) 1:1</li><li><p>从数据库管理系统的角度看，数据库系统一般采用三级模式结构，如下图所示，图中1 2 处应填写(   _C_   )，3 处应填写(   _D_   )。<br>1 2   A) 外模式 / 概念模式             B) 概念模式 / 内模式     </p><pre><code>     C) 外模式 / 概念模式映像         D) 概念模式 / 内模式映像3   A) 外模式 / 概念模式             B) 概念模式 / 内模式          C) 外模式 / 概念模式映像         D) 概念模式 / 内模式映像        &lt;img src=&quot;1.png&quot; width=&quot;30%&quot; height=&quot;80%&quot; /&gt;</code></pre></li><li><p>结构化查询语言SQL是一种关系数据库语言，其主要功能有数据定义、数据查询、数据操纵以及 <em>数据控制</em> 。</p></li><li><em>DBMS</em> 是位于用户与操作系统之间的一层数据管理软件，为用户或应用程序提供访问DB的方法。</li><li>“向emp表增加一个telephone列，其数据类型为11个字符型”的SQL语句是：ALTER TABLE emp <em>add telephone char(11)</em></li></ol><ul><li>修改已有表：向已有表中新增一列</li></ul><ol start="14"><li>一个SQL语句原则上可产生或处理一组记录，而程序语言一次只能处理一个记录，为此必须协调两种处理方式，这是通过使用 _游标_ 机制来解决的。</li><li>并发控制的主要方法是采用封锁机制，其锁的类型有 <em>排他锁</em> (写锁/独占锁)和 <em>共享锁</em> (读锁)两种。</li></ol><h3 id="2-大题"><a href="#2-大题" class="headerlink" title="2. 大题"></a>2. 大题</h3><h4 id="19年-1"><a href="#19年-1" class="headerlink" title="19年"></a>19年</h4><ol><li>设有一个关系数据库，有三个基本表，表结构如下：<br>STUDENT(学号，姓名，年龄，性别，系号)<br>SC(学号，课程号，成绩)<br>COURSE(课程号，课程名，学时数，课程类型)<br>1) 请写出创建COURSE表的SQL语句，可合理取定相关数据类型。</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course&#123;</span><br><span class="line">课程号 <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">课程名 <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">学时数 <span class="built_in">int</span>,</span><br><span class="line">课程类型 <span class="built_in">varchar</span>(<span class="number">255</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2) 请写出SQL语句，要求将COURSE表中课程号为’100010’的学时数从32改为48。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> course</span><br><span class="line"><span class="keyword">set</span> 学时数 = <span class="number">32</span></span><br><span class="line"><span class="keyword">where</span> 课程号 = <span class="string">'100010'</span></span><br></pre></td></tr></table></figure><p>3) 由于学生“张华”退学，需要从数据库中删除该学生的所有相关信息，请写出相应的SQL语句。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> 学号 = (<span class="keyword">select</span> 学号 <span class="keyword">from</span> student <span class="keyword">where</span> 姓名 = <span class="string">'张华'</span>)</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> 姓名 = <span class="string">'张华'</span></span><br></pre></td></tr></table></figure><ol start="2"><li>绘制E-R图，要求在图中表示联系的类型，最后转换成关系表，并指明主键。<br>设某商业集团数据库有三个实体集：<br>“商店”实体集，属性有商店编号、商店名、地址等；<br>“商品”实体集，属性有商品号、商品名、规格、单价等；<br>“职工”实体集，属性有职工编号、姓名、性别、业绩等。<br>商品与商品间存在“销售”联系，每个商店可销售多种商品，每种商品也可放在多个商店销售，有一个销售量属性；商品与职工间存在“聘用”联系，每个商店有许多职工，每个职工只能在一个商店工作，商店聘用职工有聘期和月薪两个属性。<br><img src="/sqlky/2.png" width="80%" height="80%"></li></ol><h4 id="18年-1"><a href="#18年-1" class="headerlink" title="18年"></a>18年</h4><ul><li><p><strong>数据库日志</strong>：是用来记录事务对数据库的更新操作的文件。<br>作用：1.进行事务故障恢复和系统故障恢复。</p><pre><code>2.协助后备副本进行介质恢复。</code></pre></li><li><p><strong>数据仓库</strong>：是一个面向主题的、集成的、不可更新的、随时间不断变化的数据集合，用以支持企业或组织的决策分析处理。</p></li><li><p><strong>数据库完整性约束</strong>：指的是<strong>为了</strong>防止不符合规范的数据进入数据库，<strong>在</strong>用户对数据进行插入、修改、删除等<strong>操作时</strong>，<strong>DBMS</strong>自动按照一定的约束条件对数据进行监测，使不符合规范的数据不能进入数据库，<strong>以确保</strong>数据库中存储的数据<strong>正确、有效、相容</strong>。</p></li><li><p>SQL中的完整性约束机制主要有：主键约束、外键约束、属性约束、 -域约束、断言约束和触发器约束。-</p></li><li><p><strong>事务</strong>：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。具有原子性、一致性、隔离性和持续性。</p></li><li><p><strong>并发控制</strong>：是指为了确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性，对并发操作进行控制。</p></li><li><p>什么是视图？使用视图有什么优点？<br><strong>视图</strong>：是从一个或几个基本表(或视图)导出的一个虚拟表，数据库中只存放视图的定义，而不存放视图对应的数据， -这些数据仍然存储在原来的基本表中，基本表中的数据发生了改变，视图中查询出的数据也会发生改变。-<br><strong>使用视图的优点:</strong> </p><ol><li>提高安全性</li><li>简化操作</li><li>增强数据逻辑独立性</li></ol></li><li><p><strong>存储过程</strong>：是一组完成特定功能的SQL语句集，经编译后存储在数据库中。用户通过指定存储过程的名字并给出参数来 -(如果有)- 执行它。<br><strong>存储过程的作用</strong>：</p><ol><li>重复使用</li><li>提高性能</li><li>减少网络流量</li><li>安全性</li></ol></li><li><p>什么是数据挖掘？它和数据仓库有什么关系？<br><strong>数据挖掘</strong>是指从大量的、不完全的、有噪声的、模糊的数据中提取出人们视线不知道，但对人们有潜在价值的信息和知识的过程。<br><strong>数据仓库</strong>是一个面向主题的、集成的、不可更新的、随时间不断变化的数据集合，用以支持企业或组织的决策分析处理。</p><ul><li>区别：数据仓库是为了支持复杂的分析和决策，数据挖掘是为了在海量的数据里面发掘出预测性的、分析性的信息。</li><li>联系：数据仓库可以作为数据挖掘的数据源。</li></ul></li><li><p>数据库运行中可能产生的故障有哪几类？哪些故障影响事务的正常执行？哪些故障破坏数据库数据？ -P199-</p><ol><li><strong>事务故障</strong><ul><li>(1)逻辑错误。事务由于某些内部条件而无法继续正常执行，如非法输入、找不到数据、运算溢出或超出资源限制。 </li><li>(2)系统错误。系统进入一种不良状态(如死锁)，结果事务无法继续正常执行。</li></ul></li><li><strong>系统故障</strong>/软故障：引起系统停止运转随之要求重新启动的事件称为”系统故障“。</li><li><strong>介质故障</strong>/硬故障：指外存故障，系统在运行过程中，由于某种硬件故障，使存储在外存上的数据部分损失或全部损失，并影响正在存取这部分数据的所有事务。</li><li><strong>计算机病毒</strong><br>影响事务的正常执行：1，2，<strong>3</strong><br>破坏数据库数据：<strong>3</strong>，4</li></ol></li><li><p>什么是索引？索引有何优点和缺点？<br><strong>索引</strong>：是对数据库表中一列或多列的值进行排序的一种结构。<br><strong>优点</strong>：</p><pre><code>1. **加快**数据的**检索**速度2. 创建**唯一性索引**，**保证**数据库表中每一行**数据的唯一性**3. 加速**表和表**之间的**连接**4. 使用**分组**和**排序子句**进行数据**检索**时，可以显著**减少**查询中分组和排序的**时间**</code></pre><p> <strong>缺点</strong>：</p><pre><code>1. 占据物理空间。除了数据表占数据空间之外，每一个**索引**还要**占一定的物理空间**2. **创建**索引和**维护**索引要耗**费时**间3. 当对表中的数据进行**增**加、**删**除和修**改**的时候，**索引**也要**动态的维护**，**降低**了**数据**的**维护速度**</code></pre></li><li><p>设有一个数据库Library，包括Book，Borrow，Reader三个关系模式：<br>Book(Bno, Btitile, Bauthor, Bprice);<br>Borrow(Rno, Bno, BorrowDate, Returndate);<br>Reader(Rno, Rname, Rsex, Rage, Reducation);<br>图书表Book由图书编号(Bno)、图书名称 (Btitle)、图书作者 (Bauthor)、图书价格 (Bprice)组成；<br>借阅表Borrow由读者编号(Rno)、图书编号 (Bno)、借阅时间 (BorrowDate)、归还时间 (Returndate)组成；<br>读者表Reader由读者编号(Rno)、读者姓名 (Rname)、读者性别 (Rex)、读者年纪 (Rage)、读者学历 (Reducation)组成。<br>针对数据库Library，写出实现下列操作的SQL语句。</p><p>1) 修改读者表Reader中的Rename列；把Rename列修改成下列定义：<br>列名：Rename；数据类型：Char；长度：20；<strong>允许空否：NULL；</strong></p></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Reader</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">column</span> <span class="keyword">Rename</span> <span class="built_in">Char</span>(<span class="number">20</span>) <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>2)查询所有年龄在17～22岁(包括17岁到22岁)之间的读者姓名及年龄。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Rname, Rage </span><br><span class="line"><span class="keyword">from</span> Reader</span><br><span class="line"><span class="keyword">where</span> Rage <span class="keyword">between</span> <span class="number">17</span> <span class="keyword">and</span> <span class="number">22</span></span><br></pre></td></tr></table></figure><p>3)查询所有姓林的读者的姓名(Rname)、性别(Rsex)和年龄(Rage)。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Rname, Rsex, Rage</span><br><span class="line"><span class="keyword">from</span> Reader</span><br><span class="line"><span class="keyword">Where</span> Rname <span class="keyword">like</span> <span class="string">'林%'</span></span><br></pre></td></tr></table></figure><p>4)查阅所有的借阅记录，按读者编号(Rno)升序排列，读者编号相同的，按照借阅时间(BorrowDate)降序排列。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> Borrow</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Rno <span class="keyword">asc</span>, BorroDate <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>5)查阅比编号为B01的图书的价格低的图书的编号(Bno)，书名(Btitle)和价格(Bprice)。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Rno, Btitle, Bprice</span><br><span class="line"><span class="keyword">from</span> Book</span><br><span class="line"><span class="keyword">Where</span> Bprice &lt;</span><br><span class="line">(<span class="keyword">select</span> Bprice <span class="keyword">from</span> Book <span class="keyword">where</span> Bno = <span class="string">'B01'</span>)</span><br></pre></td></tr></table></figure><h4 id="17年-1"><a href="#17年-1" class="headerlink" title="17年"></a>17年</h4><ul><li>常用的<strong>控制数据库安全性的方法</strong>有哪些？<ol><li>用户标识和身份鉴定</li><li>存取控制</li><li>定义视图</li><li>审计</li><li>数据加密</li></ol></li><li>什么是视图？使用视图的主要优点是什么？<br><strong>视图</strong>：从一个或者几个基本基本表(或视图)导出的表，它是一个虚表，只存放视图的定义，而不存放视图定义的数据。<br><strong>优点</strong>：<ol><li>简化用户操作</li><li>增强数据逻辑独立性</li><li>能够对机密数据提供安全保护(提高安全性)</li></ol></li><li>在数据库中<strong>为什么要并发控制</strong>？<br>多个用户并行地存取数据库系统，就会发生多个用户并发地存取同一数据的情况。如果对这些并发奥做不加控制，数据库就可能存取和存储不正确的数据，破坏数据库的一致性，所以DBMS必须对并发执行的事务之间进行并发控制。</li><li><strong>数据库设计</strong>的一般<strong>步骤</strong>是什么？<ol><li>需求分析：需求文档，数据字典，数据流图</li><li>概念设计：E-R图</li><li>逻辑结构设计：某种数据模型</li><li>物理结构设计：存储安排，方法选择，存储路径建立</li><li>系统实施：编写模式，数据装入，数据库试运行</li><li>系统维护：性能测试，转储/恢复，数据库的重组和重构</li></ol></li><li><em>什么是索引？索引有何优点和缺点？<strong>18年</strong></em></li><li>根据下面要求绘制E-R图<br>实体类型“商店”的属性有：商店编号，店名，店址，店经理；<br>实体类型“会员”的属性有：会员编号，会员名，地址；<br>实体类型“职工”的属性有：职工编号，职工名，性别，工资；<br>每家商店有若干职工，但每个职工只能服务于一家商店。每家商店有若干会员，每个会员可以属于多家商店。在联系中应反映出职工参加某商店工作的开始时间，会员的加入时间。</li></ul><ul><li>按题目要求写出SQL语句。<br>设有一个关系数据库，有三个基本表，表结构如下：<br>STUDENT(学号，姓名，年龄，性别，学院号)<br>SC(学号，课程号，成绩)<br>COURSE(课程号，课程名，学时数，课程类型)<br>1)创建STUDENT表，SQL语句中属性用汉字表示，指定学号为主键。可合理取定相关数据类型。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> STUDENT(</span><br><span class="line">学号 <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>, <span class="comment">-- 学号 int not null primary key,</span></span><br><span class="line">姓名 <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">年龄 <span class="built_in">int</span>,</span><br><span class="line">性别 <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">学院号 <span class="built_in">int</span>,</span><br><span class="line">primary <span class="keyword">key</span>(学号),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>2) 将SC表中学号为“20090105”的成绩从62改为82。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> SC </span><br><span class="line"><span class="keyword">set</span> 成绩 = <span class="number">82</span></span><br><span class="line"><span class="keyword">where</span> 学号 = <span class="string">'20090105'</span></span><br></pre></td></tr></table></figure><p>3) 创建一个视图Myview，查询课程类型为“选修课程”的学生的学院号，学号，姓名。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> Myview </span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> a.学院号, 学号, 姓名 <span class="keyword">from</span> STUDENT a, SC b, COURSE c</span><br><span class="line"><span class="keyword">where</span> a.学号 = b.学号 <span class="keyword">and</span> b.课程号 = c.课程号 <span class="keyword">and</span> c.课程类型 = <span class="string">'选修类型'</span></span><br></pre></td></tr></table></figure><p>4) 删除上述表中与课程名“数据库原理”有关的所有记录。<strong>2句不能合在一起写</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> 课程号 = (<span class="keyword">select</span> 课程号 <span class="keyword">from</span> COURSE <span class="keyword">where</span> 课程名= <span class="string">'数据库原理'</span>)</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> COURSE</span><br><span class="line"><span class="keyword">where</span> 课程名= <span class="string">'数据库原理'</span> <span class="comment">--注意两个delete语句的先后顺序</span></span><br></pre></td></tr></table></figure><h4 id="16年-1"><a href="#16年-1" class="headerlink" title="16年"></a>16年</h4><ul><li><strong>数据字典</strong>：是结构化设计的一个工具，它用于对系统中各类数据进行详尽的描述，是对各类数据描述的集合， -它通常包括数据项、数据结构、数据流、数据存储和处理过程5个部分。-</li><li><strong>事务</strong> <em>(18’)</em> ：是数据库的逻辑工作单元，是用户定义的一组操作序列。</li><li><strong>并发控制</strong> <em>(18’)</em> ：是指为了确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性，对并发操作进行控制。</li><li><strong>数据表索引</strong>：索引是对数据库表中一列或者多列的值进行排序的一种结构。建立索引是加快查询的有效手段，用户可以滚举应用环境的需要，在基本表上建立一个或多个索引，以提供多种存取路径，加快查询速度。</li><li><strong>触发器</strong>：是数据库服务器中发生事件时自动执行的特殊的存储过程，它不需要由用户调用执行，而是当用户对表进行update、insert、delete操作时，会自动执行触发器所定义的SQL语句。</li><li>采用数据库三层模式结构的优点有哪些？<ol><li>保证数据的独立性</li><li>简化用户接口</li><li>有利于数据共享</li><li>有利于数据的安全和保密</li></ol></li><li>为什么要使用NoSQL数据库？<ol><li>NoSQL数据库易扩展</li><li>数据量大，高性能</li><li>灵活的数据模型</li><li>可用性高</li></ol></li><li>采用数据库日志的目的是什么？ (<em>*2 18,16</em>)<br>数据库日志时用来记录事务对数据库的更新操作的文件<ol><li>进行事务故障恢复和系统故障恢复</li><li>协助后备副本进行介质恢复</li></ol></li><li>相对于数据库技术，XML技术在数据应用方面具有哪些优缺点？<br>优点：<ol><li>跨平台：XML是纯文本文件，不受操作系统、软件平台的限制。</li><li>易表义：XML 具有基于Schema 自描述语义的功能，容易描述数据的语义</li><li>XML 可以描述结构化、半结构化，甚至非结构化数据。<br>缺点：</li><li>XML 技术采用的是基于文件的管理机制，容量大、管理困难</li><li>XML 的检索基于节点，大量的XML 文件检索速度低</li><li>解析机制存在缺陷</li><li>XML 的安全性及并发操作机制问题</li></ol></li><li>数据库SALES包含四个关系：<br>CUSTOMERS(cid, cname, city, discnt)，CUSTOMERS存储顾客信息，包括顾客编号、姓名、所在城市和获得的折扣率。<br>PRODUCTS(pid, pname, city, quantity, price)，PRODUCTS存储商品的信息，包括商品编号、名称、商品库存所在城市、库存量和单价。<br>AGENTS(aid,  aname, city, percent)，AGENTS存储代理商的信息，包括代理商编号、名称、城市和代理佣金。<br>ORDERS(ordno, month, cid, aid, pid, qty, dollars)，ORDERS存储订购信息，包括订购编号、当年订购月份、顾客编号、代理商编号、商品编号、订购数量和总价。<br>针对数据库SALES，写出实现下列操作的SQL语句。<br>1) 查询姓名以字母“w”开始的顾客在上半年的所有订购信息。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> CUSTOMERS c, ORDERS o <span class="comment">--o.month between 1 and 6</span></span><br><span class="line"><span class="keyword">where</span> c.cname <span class="keyword">like</span> <span class="string">'w%'</span> <span class="keyword">and</span> c.cid = o.cid <span class="keyword">and</span> o.month &lt;= <span class="number">6</span></span><br></pre></td></tr></table></figure><p>2) 查询顾客的cid值，这些顾客购买的产品是由代理商a03订购的。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> y.cid <span class="keyword">from</span> ORDERS x, ORDERS y</span><br><span class="line"><span class="keyword">where</span> x.pid = y.pid <span class="keyword">and</span> x.aid = <span class="string">'a03'</span></span><br></pre></td></tr></table></figure><p>3) 产品名为“充电娃娃”的产品被购买，数据已入库，但由于产品质量问题全部退货，现要求删除所有涉及到“充电娃娃”的数据。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> ORDERS</span><br><span class="line"><span class="keyword">where</span> pid = (<span class="keyword">select</span> pid <span class="keyword">from</span> PRODUCTS <span class="keyword">where</span> pname = <span class="string">'充气娃娃'</span>)</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> PRODUCTS </span><br><span class="line"><span class="keyword">where</span> pname = <span class="string">'充气娃娃'</span></span><br></pre></td></tr></table></figure><p>4) 将所有订货总金额超过12000的顾客的折扣率增加8%。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> CUSTOMERS</span><br><span class="line"><span class="keyword">set</span> discnt = discnt*<span class="number">1.08</span></span><br><span class="line"><span class="keyword">where</span> cid <span class="keyword">in</span> (<span class="keyword">select</span> cid <span class="keyword">from</span> ORDERS <span class="keyword">group</span> <span class="keyword">by</span> cid <span class="keyword">having</span> <span class="keyword">sum</span>(dollars) &gt;<span class="number">12000</span> )</span><br></pre></td></tr></table></figure><p>5) 查询获得最大折扣值的所有顾客的姓名。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> cname <span class="keyword">from</span> CUSTOMERS</span><br><span class="line"><span class="keyword">where</span> disct = (<span class="keyword">select</span> <span class="keyword">max</span>(disct) <span class="keyword">from</span> CUSTOMERS) </span><br><span class="line"><span class="comment">--'in' replace '=' ?</span></span><br></pre></td></tr></table></figure><h4 id="15年-1"><a href="#15年-1" class="headerlink" title="15年"></a>15年</h4><ul><li><strong>数据库日志</strong> </li><li><strong>数据仓库</strong> </li><li><strong>数据库完整性</strong> </li><li><strong>事务</strong> </li><li><strong>并发控制</strong> </li><li>什么是视图？有什么作用？ </li><li>什么是数据挖掘？它和数据仓库间有什么关系？</li><li>数据库设计的一般步骤是什么？</li><li>什么是索引？索引有何优点和缺点？</li><li><strong>设计一个完整的数据库应用系统应注意哪些问题？</strong><ol><li>要满足用户的需求</li><li>要便于维护和扩产</li><li>要具有“可读性”</li><li>能够满足空间和效率的要求</li><li>好的数据库设计可以简化业务逻辑的设计</li></ol></li><li>设有一个关系数据库，有三个基本表，表结构如下：<br>STUDENT(学号，姓名，年龄，性别，系号)<br>SC(学号，课程号，成绩)<br>COURSE(课程号，课程名，学时数，课程类型)<br>1) 写出创建STUDENT表的SQL语句，指定学号为主键。可合理取定相关数据类型。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> STUDENT(</span><br><span class="line">学号 <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,<span class="comment">--sno </span></span><br><span class="line">姓名 <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,<span class="comment">--sname</span></span><br><span class="line">年龄 <span class="built_in">int</span>,<span class="comment">--sage</span></span><br><span class="line">性别 <span class="built_in">varchar</span>(<span class="number">255</span>),<span class="comment">--ssex</span></span><br><span class="line">系号 <span class="built_in">varchar</span>(<span class="number">255</span>)<span class="comment">--adept</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>2) 将COURSE表中课程号为“100020”的学时数从24改为32。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> COURSE</span><br><span class="line"><span class="keyword">set</span> 学时数 = <span class="number">32</span> <span class="keyword">where</span> 课程号 = <span class="number">100020</span></span><br><span class="line"><span class="comment">-- set ctime = '32' where cno = '100020'</span></span><br></pre></td></tr></table></figure><p>3) 在STUDENT表中插入一条记录，其中学号=’20130101’，姓名=’王芳’，年龄=20，性别=’女’，系号=’rj’</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> STUDENT <span class="keyword">values</span>(<span class="string">'20130101'</span>, <span class="string">'王芳'</span>, <span class="number">20</span>, <span class="string">'女'</span>, <span class="string">'rj'</span>)</span><br></pre></td></tr></table></figure><p>4) 创建一个视图TView，查询课程类型为选修课程的学生的系号、学号、姓名。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> TView</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">select</span> a.系号, 学号, 姓名 <span class="keyword">from</span> STUDENT a, SC b, COURSE c <span class="keyword">where</span> a.学号 = b.学号 <span class="keyword">and</span> b.课程号 = c.课程号 <span class="keyword">and</span> c.课程类型 = <span class="string">'选修课程'</span></span><br></pre></td></tr></table></figure><p>5) 由于某个系号=’rj’的学生退学，从数据库删除该学生的所有相关信息。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> STUDENT <span class="keyword">where</span> 系号 = <span class="string">'rj'</span></span><br></pre></td></tr></table></figure><h4 id="14年-1"><a href="#14年-1" class="headerlink" title="14年"></a>14年</h4><ul><li><strong>视图</strong> </li><li><strong>事务</strong> </li><li><strong>索引</strong> </li><li><strong>存储过程</strong> </li><li><strong>数据库完整性</strong> </li><li>简述数据库设计的基本步骤。</li><li>数据库的安全性保护的常用措施有哪些？</li><li><strong>简述E-R概念模型转换为关系模型的转换规则。</strong><ol><li>实体集的转换规则：将一个实体集转化为一个关系，实体的属性就是关系的属性，实体的标识符就是关系的键，关系的结构就是关系模式。</li><li>实体集间联系的转换规则：实体集间的联系可以按照1:1, 1:n, m:n来转化。<ul><li>1:1 联系可转换为一个独立的关系，也可与任一端实体集对应关系合并</li><li>1:n  联系转换一个独立关系(两端实体的键+联系本身的属性)，或在n端实体集增加新属性(联系对应于1端实体集的键+联系本身的属性)</li><li>m:n 联系转换为关系(两端实体的键+联系本身属性)，新关系的键为<strong>两端实体键的组合</strong>。</li></ul></li><li>关系合并规则：具有相同键的关系，可根据情况合并为一个关系。</li></ol></li><li>数据库运行过程中可能产生的故障有哪几类？<strong>具体内容是什么？</strong> </li><li>什么是<strong>日志文件</strong>？为什么要在系统中建立日志文件？</li><li>数据库SALES包含四个关系：<br>CUSTOMERS(cid, cname, city, discnt)，CUSTOMERS存储顾客信息，包括顾客编号、姓名、所在城市和获得的折扣率。<br>PRODUCTS(pid, pname, city, quantity, price)，PRODUCTS存储商品的信息，包括商品编号、名称、商品库存所在城市、库存量和单价。<br>AGENTS(aid,  aname, city, percent)，AGENTS存储代理商的信息，包括代理商编号、名称、城市和代理佣金。<br>ORDERS(ordno, month, cid, aid, pid, qty, dollars)，ORDERS存储订购信息，包括订购编号、当年订购月份、顾客编号、代理商编号、商品编号、订购数量和总价。<br>针对数据库SALES，写出实现下列操作的SQL语句。<br>1) 查询姓名以字母“A”开头的顾客的所有信息。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> CUSTOMERS <span class="keyword">where</span> cname <span class="keyword">like</span> <span class="string">'A%'</span></span><br></pre></td></tr></table></figure><p>2) 查询订购了被代理商a06订购过的产品的所有顾客的cid。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> cid <span class="keyword">from</span> ORDERS <span class="keyword">where</span> pid <span class="keyword">in</span>(<span class="keyword">select</span> pid <span class="keyword">from</span> ORDERS <span class="keyword">where</span> aid = <span class="string">'a06'</span>)</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> x.cid <span class="keyword">from</span> ORDERS x, ORDERS y</span><br><span class="line"><span class="keyword">where</span> x.pid = y.pid <span class="keyword">and</span> y.aid = <span class="string">'a06'</span></span><br></pre></td></tr></table></figure><p>3) 删除数据表AGENTS中的居住在“New York”的所有代理商的记录。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> AGENTS</span><br><span class="line"><span class="keyword">where</span> city = <span class="string">'New York'</span></span><br></pre></td></tr></table></figure><p>4) 查询折扣值小于最大折扣值的所有顾客的cid。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> cid <span class="keyword">from</span> CUSTOMERS <span class="keyword">where</span> discnt &lt; </span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">max</span>(discnt) <span class="keyword">from</span> CUSTOMERS)</span><br></pre></td></tr></table></figure><p>5) 将所有订货总金额超过2000的顾客的折扣率增加10%。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">from</span> CUSTOMERS </span><br><span class="line"><span class="keyword">set</span> discnt = discnt * <span class="number">1.1</span></span><br><span class="line"><span class="keyword">where</span> cid <span class="keyword">in</span> (<span class="keyword">select</span> cid <span class="keyword">from</span> ORDERS <span class="keyword">group</span> <span class="keyword">by</span> cid <span class="keyword">having</span> <span class="keyword">sum</span>(dollars) &gt; <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><h4 id="13年-1"><a href="#13年-1" class="headerlink" title="13年"></a>13年</h4><ul><li>什么是<strong>数据库日志</strong>？有什么作用？</li><li>简述数据库设计的基本步骤。</li><li>数据库安全性保护的常用措施有哪些？</li><li>什么是视图？使用视图的主要优点是什么？</li><li>什么是事务？<strong>简述事务ACID特性。</strong><br><strong>A - 原子性</strong>：事务时数据库的逻辑工作单位，事务的所有操作要么都做，要么都不做。<br><strong>C - 一致性</strong>：事务单独执行时，保持数据库的一致性。执行的结果是数据库从一个一致性的状态变为另一个一致性的状态。<br><strong>I - 隔离性</strong>：一个事务的执行不能被其他事务干扰。(并发的事务间不能相互干扰)<br><strong>D - 持续性</strong>：一旦事务提交成功，它对数据库中数据的改变是永久的，即使数据库发生故障也是如此。</li><li>数据库SALES包含四个关系：<br>CUSTOMERS(cid, cname, city, disct)，CUSTOMERS存储顾客信息，包括顾客编号、姓名、所在城市和获得的折扣率。<br>PRODUCTS(pid, pname, city, quantity, price)，PRODUCTS存储商品的信息，包括商品编号、名称、商品库存所在城市、库存量和单价。<br>AGENTS(aid,  aname, city, percent)，AGENTS存储代理商的信息，包括代理商编号、名称、城市和代理佣金。<br>ORDERS(ordno, month, cid, aid, pid, qty, dollars)，ORDERS存储订购信息，包括订购编号、当年订购月份、顾客编号、代理商编号、商品编号、订购数量和总价。<br>针对数据库SALES，写出实现下列操作的SQL语句。<br>1) 查询既订购了商品编号为P03，又订购了商品编号为P05的商品的顾客的cid。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> cid <span class="keyword">from</span> ORDERS</span><br><span class="line"><span class="keyword">where</span> pid = <span class="string">'P03'</span> <span class="keyword">and</span> cid <span class="keyword">in</span> </span><br><span class="line">(<span class="keyword">select</span> cid <span class="keyword">from</span> ORDERS <span class="keyword">where</span> pid = <span class="string">'P05'</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> cid <span class="keyword">from</span> ORDERS x, ORDERS y</span><br><span class="line"><span class="keyword">where</span> x.pid = <span class="string">'P03'</span> <span class="keyword">and</span> y.pid = <span class="string">'P05'</span> <span class="keyword">and</span> x.cid = y.cid</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> cid <span class="keyword">from</span> ORDERS <span class="keyword">where</span> pid = <span class="string">'P03'</span></span><br><span class="line"><span class="keyword">intersect</span></span><br><span class="line"><span class="keyword">select</span> cid <span class="keyword">from</span> ORDERS <span class="keyword">where</span> pid = <span class="string">'P05'</span></span><br></pre></td></tr></table></figure><p>2) 查询满足条件为某个代理商所订购的某种产品的总数量超过1000的商品编号、代理商编号和总数量。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> pid, aid, <span class="keyword">sum</span>(qty) <span class="keyword">as</span> total<span class="comment">--as别名</span></span><br><span class="line"><span class="keyword">from</span> ORDERS <span class="keyword">group</span> <span class="keyword">by</span> pid, aid <span class="keyword">having</span> <span class="keyword">sum</span>(qty)&gt;<span class="number">1000</span></span><br></pre></td></tr></table></figure><p>3) 修改表PRODUCTS的数据，把存放在城市Duluth或Dallas的所有产品的价格提高10%。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> PRODUCTS</span><br><span class="line"><span class="keyword">set</span> price = price * <span class="number">1.1</span></span><br><span class="line"><span class="keyword">where</span> city = <span class="string">'Duluth'</span> <span class="keyword">or</span> city = <span class="string">'Dallas'</span></span><br><span class="line"><span class="comment">--where city in('Duluth', 'Dallas')</span></span><br></pre></td></tr></table></figure><p>4) 授予用户SQLTest对数据库Sales的CUSTOMERS表的列cid、cname的查询权限。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> CUSTOMERS(cid, cname) <span class="keyword">to</span> SQLTest</span><br></pre></td></tr></table></figure><p>5) 删除数据表AGENTS中的居住在“New York”的所有代理商的记录。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> AGENTS <span class="keyword">where</span> city = <span class="string">'New York'</span></span><br></pre></td></tr></table></figure><h4 id="12年-1"><a href="#12年-1" class="headerlink" title="12年"></a>12年</h4><ul><li>什么是<strong>数据库日志</strong>？有什么作用？  </li><li>简述数据库设计的基本步骤。 </li><li>数据库安全性保护的常用措施有哪些？ </li><li>什么是视图？使用视图的主要优点是什么？ </li><li>什么是事务？简述事务ACID特性。 </li><li>设有一个数据库Library，包括Book，Borrow，Reader三个关系模式：<br>Book(Bno, Btitile, Bauthor, Bprice);<br>Borrow(Rno, Bno, BorrowDate, Returndate);<br>Reader(Rno, Rname, Rsex, Rage, Reducation);<br>图书表Book由图书编号(Bno)、图书名称 (Btitle)、图书作者 (Bauthor)、图书价格 (Bprice)组成；<br>借阅表Borrow由读者编号(Rno)、图书编号 (Bno)、借阅时间 (BorrowDate)、归还时间 (Returndate)组成；<br>读者表Reader由读者编号(Rno)、读者姓名 (Rname)、读者性别 (Rex)、读者年纪 (Rage)、读者学历 (Reducation)组成。<br>针对数据库Library，写出实现下列操作的SQL语句。<br>1)  请写出创建Reader表的SQL语句，以读者编号为主键，且姓名不能为空值。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Reader(</span><br><span class="line">Rno <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">Rname <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">Rsex <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">Rage <span class="built_in">int</span>,</span><br><span class="line">Reducation <span class="built_in">varchar</span>(<span class="number">255</span>)</span><br><span class="line">foreign <span class="keyword">key</span>(Rno) <span class="keyword">references</span> Borrow(Rno)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>2)  查询比编号为B01的图书价格低的图书的编号、书名和价格。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Bno, Btitle, Bprice <span class="keyword">from</span> Book <span class="keyword">where</span> Bprice &lt; </span><br><span class="line">(<span class="keyword">select</span> Bprice <span class="keyword">from</span> Book <span class="keyword">where</span> Bno = <span class="string">'B01'</span>)</span><br></pre></td></tr></table></figure><p>3)  删除所有没有人借的书。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Book</span><br><span class="line"><span class="keyword">where</span> Bno <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> Bno <span class="keyword">from</span> Borrow)</span><br></pre></td></tr></table></figure><p>4)  将编号为“R03”的读者年龄改为22岁。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> Reader</span><br><span class="line"><span class="keyword">set</span> Rage = <span class="number">22</span> <span class="keyword">where</span> Rno = <span class="string">'R03'</span></span><br></pre></td></tr></table></figure><p>5)  建立一个视图，显示读者的借书记录，包括读者姓名、书名、借书日期。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> MyView(Rname, Btitle, Borrowdate)</span><br><span class="line"><span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> a.Rname, b.Btitle, c.Borrowdate </span><br><span class="line"><span class="keyword">from</span> Reader a, Book b, Borrow c </span><br><span class="line"><span class="keyword">where</span> a.Rno = c.Rno <span class="keyword">and</span> c.Bno = b.Bno.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-选填&quot;&gt;&lt;a href=&quot;#1-选填&quot; class=&quot;headerlink&quot; title=&quot;1. 选填&quot;&gt;&lt;/a&gt;1. 选填&lt;/h3&gt;&lt;h4 id=&quot;12年&quot;&gt;&lt;a href=&quot;#12年&quot; class=&quot;headerlink&quot; title=&quot;12年&quot;&gt;&lt;/a&gt;12年&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;数据完整性约束的建立需要通过数据库管理系统提供的 &lt;em&gt;数据定义语言&lt;/em&gt; 来实现。&lt;/li&gt;
&lt;li&gt;某高校五个学院的学生信息存放在同一个基本表中，采取建立各学院的行级视图，并将对该视图的读权限赋予该学院的管理员。&lt;/li&gt;
&lt;li&gt;设关系R与S的&lt;strong&gt;属性个数&lt;/strong&gt;分别为 r 和 s，则(R X S)操作结果的b为 &lt;em&gt;r+s&lt;/em&gt; 。&lt;/li&gt;
&lt;li&gt;学生关系R(sno, sname, dno, mag)，其中sno为学生号，sname为学生姓名，dno为学院号，mag为院长，主键诶sno，则关系R属于 &lt;em&gt;2NF&lt;/em&gt; 。&lt;br&gt;sno → (sname, dno, mag) 完全依赖&lt;br&gt;dno → mag   传递函数依赖而非直接函数依赖，故不是3NF&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="软件工程" scheme="https://daisine.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="note" scheme="https://daisine.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop安装hive&amp;配置mysql元数据库</title>
    <link href="https://daisine.github.io/hive/"/>
    <id>https://daisine.github.io/hive/</id>
    <published>2019-07-02T06:56:22.000Z</published>
    <updated>2019-07-02T07:00:56.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装Hive"><a href="#1-安装Hive" class="headerlink" title="1. 安装Hive"></a>1. 安装Hive</h2><ul><li>环境：<strong>Dokcer</strong>搭建的Hadoop完全分布式集群 - namenode节点</li><li>安装包：<a href="https://archive.apache.org/dist/hive/hive-1.2.1/" target="_blank" rel="noopener">apache-hive1.2.1-bin.tar.gz</a></li></ul><a id="more"></a><ul><li><p>从本地上传安装包到namenode主机并解压</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp /home/daisine/software/apache-hive-1.2.1-bin.tar.gz root@172.18.0.2:/usr/local/</span><br><span class="line"><span class="meta">#</span> 解压到/usr/local中</span><br><span class="line">sudo tar -zxvf ./apache-hive-1.2.1-bin.tar.gz -C /usr/local   </span><br><span class="line">cd /usr/local/</span><br><span class="line"><span class="meta">#</span> 将文件夹名改为hive</span><br><span class="line">sudo mv apache-hive-1.2.1-bin hive</span><br></pre></td></tr></table></figure></li><li><p>配置hive-env.sh文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HADOOP_HOME=/usr/local/hadoop</span><br><span class="line">export HIVE_CONF_DIR=/usr/local/hive/conf</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-安装MySQL"><a href="#2-安装MySQL" class="headerlink" title="2. 安装MySQL"></a>2. 安装MySQL</h2><ul><li><p>MySQL安装过程</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>添加mysql yum源</span><br><span class="line">rpm -Uvh http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm</span><br><span class="line"><span class="meta">#</span>查看当前可用的MySQL安装资源</span><br><span class="line">yum repolist enabled | grep "mysql.*-community.*"</span><br><span class="line"><span class="meta">#</span>使用yum的方式安装MySQL</span><br><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></table></figure></li><li><p>安装MySQL5.6.44：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>查看mysql安装结果</span><br><span class="line">rpm -qa|grep mysql</span><br><span class="line">mysql-community-release-el7-5.noarch</span><br><span class="line">mysql-community-client-5.6.44-2.el7.x86_64</span><br><span class="line">mysql-community-common-5.6.44-2.el7.x86_64</span><br><span class="line">mysql-community-libs-5.6.44-2.el7.x86_64</span><br><span class="line">mysql-community-server-5.6.44-2.el7.x86_64</span><br></pre></td></tr></table></figure></li><li><p>配置MySQL</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>开机启动</span><br><span class="line">systemctl enable mysqld</span><br><span class="line"><span class="meta">#</span>启动mysql</span><br><span class="line">systemctl start mysqld</span><br><span class="line"><span class="meta">#</span>查看mysql当前状态</span><br><span class="line">systemctl status mysqld</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>重置密码</span><br><span class="line">mysql_secure_installation</span><br><span class="line">Set root password? [Y/n] y        [设置root用户密码]</span><br><span class="line">Remove anonymous users? [Y/n] y            [删除匿名用户]</span><br><span class="line">Disallow root login remotely? [Y/n] n            [禁止root远程登录]</span><br><span class="line">Remove test database and access to it? [Y/n] y       [删除test数据库]</span><br><span class="line">Reload privilege tables now? [Y/n] y        [刷新权限]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>修改访问权限 让其他计算机也能访问</span><br><span class="line">mysql -u root -p</span><br><span class="line">mysql &gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'yourpassword' WITH GRANT OPTION;</span><br><span class="line">mysql &gt; flush privileges;</span><br><span class="line"></span><br><span class="line">mysql &gt; show databases;</span><br><span class="line">mysql &gt; use mysql;</span><br><span class="line">mysql &gt; show tables;</span><br><span class="line">mysql &gt; desc user;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>停止mysql</span><br><span class="line">systemctl stop mysqld</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：不建议安装<code>MySQL 5.7版本</code>或更高，后期配置需要解决很多新问题。</p></li><li><p>使用yum安装的MySQL 5.7版本完全卸载方式方案  <code>不卸载干净再安装MySQL5.6 启动会出问题</code> </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>停止mysql</span><br><span class="line">systemctl stop mysqld</span><br><span class="line"><span class="meta">#</span>卸载MySQL5.7</span><br><span class="line">yum remove  mysql mysql-server mysql-libs mysql-server</span><br><span class="line">cd /var/lib/</span><br><span class="line">rm -rf mysql </span><br><span class="line"></span><br><span class="line">cd /usr/share/</span><br><span class="line">rm -rf mysql/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查询MySQL安装包</span><br><span class="line">rpm -qa |grep mysql</span><br><span class="line"><span class="meta">#</span>将查询到的结果删去</span><br><span class="line">yum remove $(查询到的结果)</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-Hive配置MySQL为元数据库"><a href="#3-Hive配置MySQL为元数据库" class="headerlink" title="3. Hive配置MySQL为元数据库"></a>3. Hive配置MySQL为元数据库</h2><ul><li><p>mysql jdbc 包：<a href="https://dev.mysql.com/downloads/connector/j/" target="_blank" rel="noopener">mysql-connector-java-5.1.47.tar.gz</a>(进入网页后选择<code>Platform Independent</code>)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp /home/daisine/software/mysql-connector-java-5.1.47.tar.gz root@172.18.0.2:/usr/local/</span><br><span class="line">tar -zxvf mysql-connector-java-5.1.47.tar.gz</span><br><span class="line">cd mysql-connector-java-5.1.47</span><br><span class="line">cp mysql-connector-java-5.1.47-bin.jar /usr/local/hive/lib/</span><br></pre></td></tr></table></figure></li><li><p>配置Metastore到MySQL</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/hive/conf</span><br><span class="line">touch hive-site.xml</span><br><span class="line">vi hive-site.xml</span><br></pre></td></tr></table></figure></li><li><p>hive-site.xml 需要根据自己的情况<strong>修改</strong>两处</p><ul><li><strong>ConnectionURL</strong>：<code>jdbc:mysql://$(hostname):3306/metastore</code> </li><li><strong>ConnectionPassword</strong>：<code>&lt;value&gt;$(password)&lt;/value&gt;</code> </li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://hadoop1:3306/metastore?createDatabaseIfNotExist=true&amp;amp;useSSL=false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>JDBC connect string for a JDBC metastore<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Driver class name for a JDBC metastore<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>username to use against metastore database<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>111111<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>password to use against metastore database<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-启动hive"><a href="#4-启动hive" class="headerlink" title="4. 启动hive"></a>4. 启动hive</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 启动hdfs yarn</span><br><span class="line"><span class="meta">#</span> namenode</span><br><span class="line">sbin/start-dfs.sh</span><br><span class="line"><span class="meta">#</span> resourcemanager</span><br><span class="line">sbin/start-yarn.sh</span><br><span class="line"><span class="meta">#</span> 启动hive</span><br><span class="line">cd /usr/local/hive</span><br><span class="line">bin/hive</span><br><span class="line">Logging initialized using configuration in jar:file:/usr/local/hive/lib/hive-common-1.2.1.jar!/hive-log4j.properties</span><br><span class="line">hive &gt;</span><br></pre></td></tr></table></figure><h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h2><p><a href="https://www.jianshu.com/p/481763139ef2" target="_blank" rel="noopener">Centos7使用yum安装MySQL5.6</a></p><p><a href="https://blog.csdn.net/weixin_42280360/article/details/80599326" target="_blank" rel="noopener">在centos7.4彻底删除mysql5.7</a></p><p><a href="http://dblab.xmu.edu.cn/blog/install-hive/" target="_blank" rel="noopener">Ubuntu安装hive，并配置mysql作为元数据库</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-安装Hive&quot;&gt;&lt;a href=&quot;#1-安装Hive&quot; class=&quot;headerlink&quot; title=&quot;1. 安装Hive&quot;&gt;&lt;/a&gt;1. 安装Hive&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;环境：&lt;strong&gt;Dokcer&lt;/strong&gt;搭建的Hadoop完全分布式集群 - namenode节点&lt;/li&gt;
&lt;li&gt;安装包：&lt;a href=&quot;https://archive.apache.org/dist/hive/hive-1.2.1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;apache-hive1.2.1-bin.tar.gz&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="大数据分析" scheme="https://daisine.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="hadoop" scheme="https://daisine.github.io/tags/hadoop/"/>
    
      <category term="Docker" scheme="https://daisine.github.io/tags/Docker/"/>
    
      <category term="hive" scheme="https://daisine.github.io/tags/hive/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下Docker搭建Hadoop完全分布式集群</title>
    <link href="https://daisine.github.io/dockerhadoop/"/>
    <id>https://daisine.github.io/dockerhadoop/</id>
    <published>2019-07-02T02:15:11.000Z</published>
    <updated>2019-07-02T05:40:01.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-系统环境"><a href="#1-系统环境" class="headerlink" title="1. 系统环境"></a>1. 系统环境</h2><ul><li><p>Mac OS X 10.13</p></li><li><p>Parallels Desktop 虚拟机软件</p></li><li><p>Ubuntu 14.04 虚拟机</p><blockquote><p>Ubuntu 14.04 与Mac OS X共享网络，文件夹。</p></blockquote></li></ul><a id="more"></a><h2 id="2-安装Docker"><a href="#2-安装Docker" class="headerlink" title="2.  安装Docker"></a>2.  安装Docker</h2><ul><li>参考<a href="http://dblab.xmu.edu.cn/blog/1233/" target="_blank" rel="noopener">安装Docker-厦大数据库实验室</a></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -r</span><br><span class="line"><span class="meta">#</span>安装Dokcer: 64位Linux系统，其次内核版本必须大于3.10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>更新apt，安装CA证书，因为访问Docker用的是https协议</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install apt-transport-https ca-certificates</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>添加新的GPG key；</span><br><span class="line">sudo apt-key adv \</span><br><span class="line">               --keyserver hkp://ha.pool.sks-keyservers.net:80 \</span><br><span class="line">               --recv-keys 58118E89F3A912897C070ADBF76221572C52609D</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>Ubuntu系统添加Docker源</span><br><span class="line">echo deb https://apt.dockerproject.org/repo ubuntu-xenial main | sudo tee /etc/apt/sources.list.d/docker.list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>更新apt包索引</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>验证下是否从正确的仓库拉取安装包</span><br><span class="line">apt-cache policy docker-engine</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>安装Docker[出现问题]</span><br><span class="line">sudo apt-get install docker-engine</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>启动Docker</span><br><span class="line">sudo service docker start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>docker默认是只有root才能执行Docker命令，因此需要添加用户权限</span><br><span class="line"><span class="meta">#</span>创建docker用户组</span><br><span class="line">sudo groupadd docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>添加当前用户到Docker用户组 $USER用当前用户名替换</span><br><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><ul><li><p>在最后一步安装Docker指令遇到问题：</p><blockquote><p>Some packages could not be installed. This may mean that you have requested an impossible situation or if you are using the unstable distribution that some required packages have not yet been created or been moved out of Incoming.<br>The following information may help to resolve the situation:<br>The following packages have unmet dependencies:<br>docker-engine : Depends: init-system-helpers (&gt;= 1.18~) but 1.14 is to be installed<br>Depends: lsb-base (&gt;= 4.1+Debian11ubuntu7) but 4.1+Debian11ubuntu6 is to be installed<br>Depends: libdevmapper1.02.1 (&gt;= 2:1.02.99) but 2:1.02.77-6ubuntu2 is to be installed<br>Recommends: aufs-tools but it is not going to be installed<br>Recommends: cgroupfs-mount but it is not installable or cgroup-lite but it is not going to be installed<br>Recommends: git<br>E: Unable to correct problems, you have held broken packages.</p></blockquote></li><li><p>意思是安装Docker对系统有些软件包的版本有要求，而现在系统已有的软件包版本过低不符合Docker安装的依赖关系。</p></li><li><p>解决方法：使用如下指令安装Dokcer  参考<a href="https://github.com/moby/moby/issues/15692" target="_blank" rel="noopener">Github issues Docker安装问题</a></p></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo wget -qO- https://get.docker.com/ | SH</span><br></pre></td></tr></table></figure><h2 id="3-Docker构建Hadoop镜像"><a href="#3-Docker构建Hadoop镜像" class="headerlink" title="3. Docker构建Hadoop镜像"></a>3. Docker构建Hadoop镜像</h2><h3 id="获取CentOS7镜像"><a href="#获取CentOS7镜像" class="headerlink" title="获取CentOS7镜像"></a>获取CentOS7镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>大约70+ MB 速度较慢</span><br><span class="line">docker pull centos</span><br></pre></td></tr></table></figure><blockquote><p>建议使用阿里云Docker镜像加速器，参考<a href="https://blog.csdn.net/weixin_36794678/article/details/81434487" target="_blank" rel="noopener">使用阿里云Docker镜像加速器</a></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>查看镜像列表 可以看到刚才pull的centos的镜像</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><h3 id="在CentOS7的基础上构建CentOS-SSH镜像"><a href="#在CentOS7的基础上构建CentOS-SSH镜像" class="headerlink" title="在CentOS7的基础上构建CentOS-SSH镜像"></a>在CentOS7的基础上构建CentOS-SSH镜像</h3><ul><li><p>使用Dockerfile安装CentOS-SSH镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>最好在一个空文件夹中创建 不要在系统根目录创建</span><br><span class="line">mkdir ~/centos-ssh</span><br><span class="line">cd centos-ssh</span><br><span class="line">vi Dockerfile</span><br></pre></td></tr></table></figure></li><li><p>Dockerfile内容为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">RUN yum install -y openssh-server sudo</span><br><span class="line">RUN sed -i 's/UsePAM yes/UsePAM no/g' /etc/ssh/sshd_config</span><br><span class="line">RUN yum  install -y openssh-clients</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 用户root，密码111111，将此用户添加到sudoers里  </span><br><span class="line">RUN echo "root:111111" | chpasswd</span><br><span class="line">RUN echo "root   ALL=(ALL)       ALL" &gt;&gt; /etc/sudoers</span><br><span class="line">RUN ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key</span><br><span class="line">RUN ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key</span><br><span class="line"></span><br><span class="line">RUN mkdir /var/run/sshd</span><br><span class="line">EXPOSE 22</span><br><span class="line">CMD ["/usr/sbin/sshd", "-D"]</span><br></pre></td></tr></table></figure><blockquote><p>关于Dockerfile更多指令来构建镜像，参考<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile官方文档</a></p></blockquote></li><li><p>构建CentOS-SSH镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t="centos7-ssh" .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查看镜像列表 可以看到刚才build的centos7-ssh的镜像</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure></li></ul><h3 id="在CentOS-SSH的基础上构建Hadoop-JDK镜像"><a href="#在CentOS-SSH的基础上构建Hadoop-JDK镜像" class="headerlink" title="在CentOS-SSH的基础上构建Hadoop+JDK镜像"></a>在CentOS-SSH的基础上构建Hadoop+JDK镜像</h3><ul><li><p>使用Dockerfile安装CentOS-SSH镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>最好在一个空文件夹中创建 不要在系统根目录创建</span><br><span class="line">mkdir ~/hadoop</span><br><span class="line">cd hadoop</span><br><span class="line">vi Dockerfile</span><br></pre></td></tr></table></figure></li><li><p>在~/hadoop文件夹中放入JDK安装包和Hadoop安装包</p><blockquote><p>我使用的是jdk-8u131-linux-x64.tar.gz与hadoop-2.7.2.tar.gz</p><p>不同版本JDK或Hadoop需在Dockerfile中修改</p></blockquote></li><li><p>Dockerfile内容为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos7-ssh</span><br><span class="line">ADD jdk-8u131-linux-x64.tar.gz /usr/local/</span><br><span class="line">RUN mv /usr/local/jdk1.8.0_131 /usr/local/jdk1.8</span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8</span><br><span class="line">ENV PATH $JAVA_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">ADD hadoop-2.7.2.tar.gz /usr/local</span><br><span class="line">RUN mv /usr/local/hadoop-2.7.2 /usr/local/hadoop</span><br><span class="line">ENV HADOOP_HOME /usr/local/hadoop</span><br><span class="line">ENV PATH $HADOOP_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">RUN yum install -y which sudo</span><br></pre></td></tr></table></figure><blockquote><p>关于Dockerfile更多指令来定制镜像，参考<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile官方文档</a></p></blockquote></li><li><p>构建CentOS-SSH镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t="hadoop" .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查看镜像列表 可以看到刚才build的hadoop的镜像</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-Dokcer搭建Hadoop完全分布式集群"><a href="#4-Dokcer搭建Hadoop完全分布式集群" class="headerlink" title="4. Dokcer搭建Hadoop完全分布式集群"></a>4. Dokcer搭建Hadoop完全分布式集群</h2><ul><li><p>两个概念的区别：参考<a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank" rel="noopener">Docker-从入门到实践</a></p><ul><li>Docker镜像(类)</li><li>Docker容器(对象)</li></ul></li><li><p>基本规划：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">172.18.0.2 hadoop1 namenode datanode</span><br><span class="line">172.18.0.3 hadoop2 datanode</span><br><span class="line">172.18.0.4 hadoop3 secondarynamenode datanode</span><br></pre></td></tr></table></figure></li><li><p>由于docker容器重新启动之后ip会发生变化，所以需要设置固定ip</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>创建自定义网络 并且指定网段172.18.0.0/16</span><br><span class="line">docker network create --subnet=172.18.0.0/16 mynetwork</span><br><span class="line"><span class="meta">#</span>查看创建的mynetwork</span><br><span class="line">docker network ls</span><br><span class="line"><span class="meta">#</span>启动三个容器，分别作为hadoop1 hadoop2 hadoop3</span><br><span class="line">docker run --privileged --name hadoop1 --hostname hadoop1 --net mynetwork --ip 172.18.0.2 -d -P -p 50070:50070 -p 8088:8088 -p 9000:9000 -p 50020:50020 hadoop /usr/sbin/init</span><br><span class="line">docker run --name hadoop2 --hostname hadoop2 --net mynetwork --ip 172.18.0.3 -d -P hadoop</span><br><span class="line">docker run --name hadoop3 --hostname hadoop3 --net mynetwork --ip 172.18.0.4 -d -P hadoop</span><br></pre></td></tr></table></figure></li><li><p>关于hadoop1容器的启动方式说明</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 由于CentOS7镜像本身存在的缺陷 无法使用systemctl命令</span><br><span class="line"><span class="meta">#</span> 可以通过启动容器时加参数--privileged和最末加上/usr/sbin/init 使用systemctl命令</span><br><span class="line">docker run --privileged .... /usr/sbin/init</span><br></pre></td></tr></table></figure><ul><li>具体报错：在安装好mysql启动时：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld</span><br><span class="line">Failed to get D-Bus connection: Operation not permitted</span><br></pre></td></tr></table></figure></li></ul><h3 id="SSH免密码登录设置"><a href="#SSH免密码登录设置" class="headerlink" title="SSH免密码登录设置"></a>SSH免密码登录设置</h3><ul><li><p>打开3个容器的终端</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>打开三个终端分别为hadoop1，hadoop2与hadoop3</span><br><span class="line">docker exec -it hadoop1 /bin/bash</span><br><span class="line">docker exec -it hadoop2 /bin/bash</span><br><span class="line">docker exec -it hadoop3 /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>配置主机映射</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>在该文件内加入新的主机映射 内网ip 主机名</span><br><span class="line">vi /etc/hosts</span><br><span class="line">172.18.0.2 hadoop1</span><br><span class="line">172.18.0.3 hadoop2</span><br><span class="line">172.18.0.4 hadoop3</span><br></pre></td></tr></table></figure></li><li><p>SSH免密码登录设置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen  </span><br><span class="line"><span class="meta">#</span>拷贝公钥到需要免密码登录的目标服务器上</span><br><span class="line">ssh-copy-id hadoop01 </span><br><span class="line">ssh-copy-id hadoop02</span><br><span class="line">ssh-copy-id hadoop03</span><br><span class="line"><span class="meta">#</span>使用`ssh 主机名`免密码登录目标服务器</span><br><span class="line">ssh hadoop0x</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-配置Hadoop与JDK的环境变量"><a href="#5-配置Hadoop与JDK的环境变量" class="headerlink" title="5. 配置Hadoop与JDK的环境变量"></a>5. 配置Hadoop与JDK的环境变量</h2><ul><li><p>profile文件中加入环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>#JAVA_HOME</span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_131</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line"><span class="meta">#</span>#HADOOP_HOME</span><br><span class="line">export HADOOP_HOME=/opt/module/hadoop-2.7.2</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>让修改后的profile生效</span><br><span class="line">source  /etc/profile </span><br><span class="line">java -version</span><br><span class="line">hadoop</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-修改Hadoop配置文件"><a href="#6-修改Hadoop配置文件" class="headerlink" title="6. 修改Hadoop配置文件"></a>6. 修改Hadoop配置文件</h2><ul><li><p>相关文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/hadoop/etc/hadoop</span><br><span class="line">vi core-site.xml</span><br><span class="line">vi hdfs-site.xml</span><br><span class="line">vi yarn-site.xml</span><br><span class="line">vi slaves</span><br><span class="line">vi yarn-env.sh</span><br><span class="line">vi mapred-env.sh</span><br></pre></td></tr></table></figure></li><li><p>core-site.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop1:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/hadoop/data/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>hdfs-site.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop3:50090<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.permissions<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>slaves</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop1</span><br><span class="line">hadoop2</span><br><span class="line">hadoop3</span><br></pre></td></tr></table></figure></li><li><p>yarn-env.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/hadoop1.8</span><br></pre></td></tr></table></figure></li><li><p>mapred-env.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/hadoop1.8</span><br></pre></td></tr></table></figure></li><li><p>hadoop-env.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> Hadoop启动报Error: JAVA_HOME is not set and could not be found</span><br><span class="line">export JAVA_HOME=$JAVA_HOME  </span><br><span class="line"><span class="meta">#</span> 修改为绝对路径</span><br><span class="line">export JAVA_HOME=/usr/local/hadoop1.8</span><br></pre></td></tr></table></figure></li><li><p>分发文件到hadoop2与hadoop3</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r /usr/local/hadoop/etc/hadoop hadoop2:/usr/local/hadoop/etc/</span><br><span class="line">scp -r /usr/local/hadoop/etc/hadoop hadoop3:/usr/local/hadoop/etc/</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-Hadoop集群启动"><a href="#7-Hadoop集群启动" class="headerlink" title="7. Hadoop集群启动"></a>7. Hadoop集群启动</h2><ul><li><p>首次启动集群，需要格式化namenode</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/hdfs namenode -format</span><br></pre></td></tr></table></figure></li><li><p>在Hadoop01中启动HDFS</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbin/start-dfs.sh</span><br></pre></td></tr></table></figure></li><li><p>此时可以打开本地ubuntu浏览器输入:localhost:50070看到web管理界面</p></li><li><p>关闭HDFS</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbin/stop-dfs.sh</span><br></pre></td></tr></table></figure></li><li><p>启动与关闭yarn</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbin/start-yarn.sh</span><br><span class="line">sbin/stop-yarn.sh</span><br></pre></td></tr></table></figure></li><li><p>全部启动与关闭</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-all.sh</span><br><span class="line">stop-all.sh</span><br></pre></td></tr></table></figure></li><li><p>备注：由于本地ubuntu使用docker启动容器时，指定的为主机网络。Docker 容器的网络会附属在主机上，两者是互通的。所以使用ssh可以直接连接到三个容器。</p><blockquote><p>如，在容器中运行一个Web服务，监听8080端口，则主机的8080端口就会自动映射到容器中。</p></blockquote></li></ul><h2 id="8-参考资料"><a href="#8-参考资料" class="headerlink" title="8. 参考资料"></a>8. 参考资料</h2><p><a href="https://www.cnblogs.com/liujinhong/p/8795387.html" target="_blank" rel="noopener">使用Docker部署Hadoop环境和Presto</a></p><p><a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank" rel="noopener">Docker — 从入门到实践</a></p><p><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile官方文档</a></p><p><a href="https://www.jianshu.com/p/a6bfe81247b6" target="_blank" rel="noopener">Hadoop启动报Error: JAVA_HOME is not set and could not be found解决办法</a></p><p><a href="http://dblab.xmu.edu.cn/blog/1233/" target="_blank" rel="noopener">安装Docker-厦大数据库实验室</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-系统环境&quot;&gt;&lt;a href=&quot;#1-系统环境&quot; class=&quot;headerlink&quot; title=&quot;1. 系统环境&quot;&gt;&lt;/a&gt;1. 系统环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Mac OS X 10.13&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Parallels Desktop 虚拟机软件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ubuntu 14.04 虚拟机&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ubuntu 14.04 与Mac OS X共享网络，文件夹。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="大数据分析" scheme="https://daisine.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="hadoop" scheme="https://daisine.github.io/tags/hadoop/"/>
    
      <category term="大数据" scheme="https://daisine.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Docker" scheme="https://daisine.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>3个阿里云ECS搭建Hadoop完全分布式集群</title>
    <link href="https://daisine.github.io/hadoops/"/>
    <id>https://daisine.github.io/hadoops/</id>
    <published>2019-06-26T01:47:56.000Z</published>
    <updated>2019-07-04T07:15:30.941Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-准备阿里云ECS"><a href="#1-准备阿里云ECS" class="headerlink" title="1. 准备阿里云ECS"></a>1. 准备阿里云ECS</h2><ul><li>我使用的是Mac OS X 10.13，在终端中可以进行：<ul><li><code>ssh</code>连接远程服务器，</li><li><code>scp</code>上传/下载远程服务器文件</li></ul></li><li>云服务器ECS * 3  <code>共享基本型</code>  - <code>1vCPU</code>  - <code>1Gib</code></li><li>PS：3个ECS需要在同一个地域，如<code>华东1</code>。因为<strong>不同地域</strong>的实例之间<strong>内网互不相通</strong>。</li></ul><a id="more"></a><ul><li><p>操作系统：CentOS 7.3 <code>64位</code></p></li><li><p>分配公网IPv4地址：理论上只需要1个ECS分配公网IP即可，3个ECS使用内网互通。<code>之后需要进行设置内网互通，免费</code></p><blockquote><p>如果是3个不同账号/跨地域的ECS，也可以搭建</p></blockquote></li><li><p>ESC设置内网互通，参考：<a href="https://help.aliyun.com/document_detail/65861.html?spm=a2c4g.11186623.6.558.491f303e3Lb1M5" target="_blank" rel="noopener">阿里云帮助-同账号同地域VPC和VBR互通</a></p></li></ul><p><img src="/hadoops/ecs.png" width="80%"></p><h2 id="2-SSH免密码登录"><a href="#2-SSH免密码登录" class="headerlink" title="2. SSH免密码登录"></a>2. SSH免密码登录</h2><ul><li><p>关闭防火墙        <code>3个ECS</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>关闭防火墙</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"><span class="meta">#</span>开机禁止启动</span><br><span class="line">systemctl disable firewalld.service</span><br><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure></li><li><p>修改主机名称：此处我将3个ECS的主机名分别修改为<code>hadoop01</code>，<code>hadoop02</code>，<code>hadoop03</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>将该文件中的内容修改为新的主机名</span><br><span class="line">sudo vim /etc/hostname</span><br><span class="line"><span class="meta">#</span>重启服务器生效</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure></li><li><p>配置主机映射：由于内网互通，所以均填写的为ecs的内网IP。</p><blockquote><p>如果内网不互通，则自己主机的IP填写为内网IP，其他主机的IP填写为公网IP。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>在该文件内加入新的主机映射 内网ip 主机名</span><br><span class="line">vi /etc/hosts </span><br><span class="line">172.16.119.x hadoop01</span><br><span class="line">172.16.119.y hadoop02</span><br><span class="line">172.16.238.z hadoop03</span><br></pre></td></tr></table></figure></li><li><p>此时，<code>ECS</code> 之间ping对方的内网IP可以ping通。</p><blockquote><p>事实上我设置了阿里云的ECS内网互通之后就可以ping通内网IP了。</p></blockquote></li><li><p>SSH免密码登录设置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen  #回车完成操作</span><br><span class="line">ssh-copy-id hadoop01 #拷贝公钥到需要免密码登录的目标服务器上</span><br><span class="line">ssh-copy-id hadoop02</span><br><span class="line">ssh-copy-id hadoop03</span><br><span class="line">ssh hadoop0x #使用`ssh 主机名`免密码登录目标服务器</span><br></pre></td></tr></table></figure></li><li><p>~/.ssh/下的文件功能</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ls</span><br><span class="line">authorized_keys  id_rsa  id_rsa.pub  known_hosts</span><br><span class="line"><span class="meta">#</span>~/.ssh的4个文件</span><br><span class="line"><span class="meta">#</span> known_hosts：记录ssh访问过计算机的公钥(public key)</span><br><span class="line"><span class="meta">#</span> id_rsa：生成的私钥</span><br><span class="line"><span class="meta">#</span> id_rsa.pub：生成的公钥</span><br><span class="line"><span class="meta">#</span> authorized_keys：存放授权过得无秘登录服务器公钥</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-安装JDK与Hadoop"><a href="#3-安装JDK与Hadoop" class="headerlink" title="3. 安装JDK与Hadoop"></a>3. 安装JDK与Hadoop</h2><ul><li><p>在root用户下的<code>opt</code>文件夹中创建<code>module</code>、<code>software</code>文件夹</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">mkdir module #安装的JDK与Hadoop的位置</span><br><span class="line">mkdir software #安装包的存储位置</span><br></pre></td></tr></table></figure></li><li><p><strong>way1</strong>：将本地的JDK和Hadoop安装包上传到服务器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>在mac os的本地用户的终端下使用scp上传安装包</span><br><span class="line"><span class="meta">#</span>scp 本地安装包路径 root@公网ip:存放文件夹路径</span><br><span class="line">scp /users/yi/Downloads/jdk-8u131-linux-x64.tar.gz root@123.56.135.146:/opt/software</span><br><span class="line">scp /users/yi/Downloads/hadoop-2.7.2.tar.gz root@123.56.135.146:/opt/software</span><br></pre></td></tr></table></figure></li><li><p><strong>way2</strong>:在ECS用户下使用wget下载安装包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>wget 下载链接</span><br><span class="line"><span class="meta">#</span>我使用的是Hadoop2.7.2 与 Java 1.8.0_131</span><br><span class="line"><span class="meta">#</span>Hadoop2.x 与 Hadoop3.x 有区别</span><br><span class="line">cd /opt/software #下载的安装包的存放位置</span><br><span class="line">wget JDK‘s URL</span><br><span class="line">wget Hadoop‘s URL</span><br></pre></td></tr></table></figure></li><li><p>在<code>/opt/module</code>安装Hadoop与JDK</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/software #安装包的位置</span><br><span class="line"><span class="meta">#</span> tar -zxvf 压缩包名称 -C 解压文件存放位置</span><br><span class="line">tar -zxvf jdk-8u131-linux-x64.tar.gz -C /opt/module/</span><br><span class="line">tar -zxvf hadoop-2.7.2.tar.gz -C /opt/module/</span><br></pre></td></tr></table></figure></li><li><p>配置hadoop中的hadoop-env.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/module/hadoop-2.7.2/etc/hadoop</span><br><span class="line">vi hadoop-env.sh</span><br><span class="line"><span class="meta">#</span>修改JAVA_HOME的值为/opt/module/jdk1.8.0_131</span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_131</span><br></pre></td></tr></table></figure></li><li><p>配置Hadoop与JDK的环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/profile #在profile中加入以下环境变量</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>#JAVA_HOME</span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_131</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line"><span class="meta">#</span>#HADOOP_HOME</span><br><span class="line">export HADOOP_HOME=/opt/module/hadoop-2.7.2</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin</span><br><span class="line"></span><br><span class="line">source  /etc/profile #让修改后的profile生效</span><br><span class="line">java -version#查询Java版本可以正确显示结果</span><br><span class="line">hadoop #显示Hadoop的使用方式</span><br></pre></td></tr></table></figure><blockquote><p>如果不能查询Java版本和Hadoop指令，可以使用<code>reboot</code>重启服务器再进行尝试。</p></blockquote></li></ul><h2 id="4-Hadoop完全分布式集群搭建"><a href="#4-Hadoop完全分布式集群搭建" class="headerlink" title="4. Hadoop完全分布式集群搭建"></a>4. Hadoop完全分布式集群搭建</h2><ul><li><p>修改<code>/opt/module/hadoop-2.7.2/etc/hadoop</code>文件夹中的配置文件</p></li><li><p>core-site.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop01:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定hadoop运行时产生文件的存储目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/module/hadoop-2.7.2/data/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>hdfs-site.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop03:50090<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>slaves</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>删掉了localhost，加入以下内容</span><br><span class="line">hadoop01</span><br><span class="line">hadoop02</span><br><span class="line">hadoop03</span><br></pre></td></tr></table></figure></li><li><p>yarn-env.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 修改JAVA_HOME的值并取消注释#</span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_131</span><br></pre></td></tr></table></figure></li><li><p>yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- reducer获取数据的方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定YARN的ResourceManager的地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop02<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>mapred-env.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 修改JAVA_HOME的值并取消注释#</span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_131</span><br></pre></td></tr></table></figure></li><li><p>mapred-site.xml(原本不存在这个文件)</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定mr运行在yarn上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>分发以上修改的文件到另外2个ECS</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r /opt/module/hadoop-2.7.2/etc/hadoop hadoop02:/opt/module/hadoop-2.7.2/etc/</span><br><span class="line">scp -r /opt/module/hadoop-2.7.2/etc/hadoop hadoop03:/opt/module/hadoop-2.7.2/etc/</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-Hadoop集群启动"><a href="#5-Hadoop集群启动" class="headerlink" title="5. Hadoop集群启动"></a>5. Hadoop集群启动</h2><ul><li><p>首次启动集群，需要格式化namenode</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/hdfs namenode -format</span><br></pre></td></tr></table></figure></li><li><p>在Hadoop01中启动HDFS</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbin/start-dfs.sh</span><br></pre></td></tr></table></figure></li><li><p>使用<code>jps</code>查看Hadoop进程</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 hadoop-2.7.2]# jps</span><br><span class="line">6649 Jps</span><br><span class="line">6316 NameNode</span><br><span class="line">6446 DataNode</span><br><span class="line">[root@hadoop01 hadoop-2.7.2]# ssh hadoop02</span><br><span class="line">[root@hadoop02 ~]# jps</span><br><span class="line">14206 Jps</span><br><span class="line">14111 DataNode</span><br><span class="line">[root@hadoop02 ~]# ssh hadoop 03</span><br><span class="line">[root@hadoop03 ~]# jps</span><br><span class="line">5091 DataNode</span><br><span class="line">5192 SecondaryNameNode</span><br><span class="line">5260 Jps</span><br></pre></td></tr></table></figure></li><li><p>在阿里云ECS控制台中将Hadoop01服务器的<code>安全组规则</code>中开放50070端口</p><blockquote><p>50070为hadoop2.x中namenode的默认web访问端口</p></blockquote></li><li><p>在HDFS启动的时候，访问<code>http://hadoop01&#39;s公网IP:50070</code></p></li></ul><p><img src="/hadoops/h1.png" width="100%"></p><p><img src="/hadoops/h2.png" width="100%"></p><ul><li><p>启动与关闭HDFS</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbin/start-dfs.sh</span><br><span class="line">sbin/stop-dfs.sh</span><br></pre></td></tr></table></figure></li><li><p>启动与关闭yarn</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbin/start-yarn.sh</span><br><span class="line">sbin/stop-yarn.sh</span><br></pre></td></tr></table></figure></li><li><p>全部启动与关闭</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-all.sh</span><br><span class="line">stop-all.sh</span><br></pre></td></tr></table></figure></li><li><p>上传文件到集群</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>创建上传的文件所在目录</span><br><span class="line">bin/hdfs dfs -mkdir -p /user/root/tmp/conf</span><br><span class="line"><span class="meta">#</span>上传文件到HDFS</span><br><span class="line">bin/hdfs dfs -put etc/hadoop/*-site.xml /user/root/tmp/conf</span><br><span class="line"><span class="meta">#</span>下载HDFS中的文件</span><br><span class="line">bin/hadoop fs -get /user/root/input/workcount.txt</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-使用eclipse远程连接hadoop集群"><a href="#6-使用eclipse远程连接hadoop集群" class="headerlink" title="6. 使用eclipse远程连接hadoop集群"></a>6. 使用eclipse远程连接hadoop集群</h2><ul><li><p>本地安装eclipse与Java环境(JDK版本不需要与服务器一致)</p></li><li><p>下载<code>hadoop-eclipse-plugin-2.7.3.jar</code>(没找到2.7.2版本的，2.7.3能用)</p></li><li>将<code>hadoop-eclipse-plugin-2.7.3.jar</code>放在eclipse - contents - eclipse - plugins文件夹中</li><li>打开<code>eclipse</code> 添加插件 - Map</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-准备阿里云ECS&quot;&gt;&lt;a href=&quot;#1-准备阿里云ECS&quot; class=&quot;headerlink&quot; title=&quot;1. 准备阿里云ECS&quot;&gt;&lt;/a&gt;1. 准备阿里云ECS&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我使用的是Mac OS X 10.13，在终端中可以进行：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ssh&lt;/code&gt;连接远程服务器，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scp&lt;/code&gt;上传/下载远程服务器文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;云服务器ECS * 3  &lt;code&gt;共享基本型&lt;/code&gt;  - &lt;code&gt;1vCPU&lt;/code&gt;  - &lt;code&gt;1Gib&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;PS：3个ECS需要在同一个地域，如&lt;code&gt;华东1&lt;/code&gt;。因为&lt;strong&gt;不同地域&lt;/strong&gt;的实例之间&lt;strong&gt;内网互不相通&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="大数据分析" scheme="https://daisine.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="hadoop" scheme="https://daisine.github.io/tags/hadoop/"/>
    
      <category term="大数据" scheme="https://daisine.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>数字图像处理习题</title>
    <link href="https://daisine.github.io/diptimu/"/>
    <id>https://daisine.github.io/diptimu/</id>
    <published>2019-06-11T08:00:53.000Z</published>
    <updated>2019-06-11T08:17:45.512Z</updated>
    
    <content type="html"><![CDATA[<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ul><li>数字图像处理  - 冈萨雷斯 - 第三版中文版</li><li><p>习题答案为英文版翻译删减版 + 小部分个人理解</p><a id="more"></a></li></ul><h4 id="C2-6-22"><a href="#C2-6-22" class="headerlink" title="C2[6, 22]"></a>C2[6, 22]</h4><ul><li>2.6 某汽车制造商想在一条限量版跑车生产线上将一些零件自动安放在跑车保险杠上，这一部件就是彩色坐标，为选择合适的保险杠零件，机器人需要知道每辆车的颜色。模型有4种颜色：蓝色、绿色、红色、白色。请提出一种基于成像的解决方案。你怎样解决自动确定每辆跑车颜色的问题？记住，在选择零件时价格是最主要的考虑因素。<ul><li>一种可能的解决方案是为单色相机配备机械装置，该装置在镜头前依次放置红色，绿色和蓝色通过滤光器。相机最强的响应决定了颜色。 如果所有三个响应大致相等，则为白色。</li><li>更快的系统将使用三个不同的相机，每个相机配备一个单独的滤光器。 然后，轮询每个摄像机的响应进行分析。 这个系统会贵一点，但会更快，更可靠。 </li><li>请注意，两种解决方案都<strong>假设摄像机的视野是完全由均匀的颜色填充</strong>[即，摄像机聚焦在车辆的一部分上 它的颜色可见。 否则，需要进一步分析以隔离均匀颜色的区域，这是解决该问题所关注的所有问题。</li></ul></li><li>2.22 图像相减通常用于在生产线上检测缺失的元件。方法是存储一幅对应于正确组装的“金”图像；然后，从相同产品的传入图像中减去该图像。理想情况下，如果新产品组装正确，则差值为零。对于缺失元件的产品，在不同于金图像的位置，差值图像将不为零。在实际中，你认为在什么条件下使用这种方式工作才是合适的？<ul><li>有三个基本因素需要严格控制基于差异的检查才能发挥作用：</li><li>（1）<strong>正确组装：</strong>产品会打上特殊标记，用于图像的对齐。如果它相对于金图像移位，则比较它们之间的差值是没有意义的。</li><li>（2）<strong>照明控制：</strong>照明的变化会显着影响差值图像中的值。所以必须保证照明控制，才不会对差值图像的结果产生影响。</li><li>（3）<strong>足够低的噪声水平：</strong>这样才不会对黄金和输入图像之间的比较产生实质性影响。良好的信号强度对降低噪声影响有很大帮助。</li><li>（4）<strong>设定阈值</strong>，使传入的图像与金图像的差值对比足够接近也能接受。</li></ul></li><li>灰度分辨率，结合课后习题。</li></ul><h4 id="C3-5-6-7-14"><a href="#C3-5-6-7-14" class="headerlink" title="C3[5, 6, 7, 14]"></a>C3[5, 6, 7, 14]</h4><ul><li><p>3.5 (a) 通常，如果将低阶比特平面的一半设为零值，对一幅图像的直方图有何影响？</p><ul><li>具有不同灰度值的像素的数量将减少，从而导致直方图中的分量的数量减少。由于像素的数量不会改变，所以这将导致剩下的直方图分量的(幅值)高度增加。通常，灰度值的丰富性降低会导致<strong>对比度下降</strong>。</li></ul></li><li><p>3.5 (b) 如果将高阶比特平面的一半设为零值，对一幅图像的直方图有何影响？</p><ul><li>最明显的效果是<strong>图像显著变暗</strong>。例如，丢弃最高位将会使8位图像中最亮的亮度限制在127.由于像素数保持不变，直方图的某些峰值的高度会增加，总体呈现出更高更窄的直方图。</li></ul></li><li><p>3.6 试解释为什么离散直方图均衡技术一般不能得到平坦的直方图？</p><ul><li>直方图均衡所做的事是在亮度范围上<strong>重新映射</strong>直方图的分量。为了获得平坦的直方图，需要<strong>重新分配像素灰度值</strong>，直方图均衡没有灰度值重新分配的过程。</li></ul></li><li><p>3.7 假设对一幅数字图像进行直方图均衡处理。试证明(对直方图均衡化的图像)进行第二次直方图均衡处理的结果，与第一次直方图均衡处理的结果相同。</p><ul><li><p>令n = MN，像素的总数，n<sub>r<sub>j</sub></sub>是具有灰度值r<sub>j</sub>的输入图像的像素个数。那么直方图均衡处理为：</p><p><img src="/diptimu/371.png" width="35%"></p></li><li><p>因为每个具有灰度值 r<sub>k</sub> 的像素被映射到灰度值 s<sub>k</sub> ，所以n<sub>s<sub>k</sub></sub> = n<sub>r<sub>k </sub></sub> 。第二次直方图均衡处理将产生值v<sub>k</sub></p></li></ul><p><img src="/diptimu/372.png" width="30%"></p><ul><li>由于n<sub>s<sub>k</sub></sub> = n<sub>r<sub>k </sub></sub>  ：</li></ul><p><img src="/diptimu/373.png" width="30%"></p><ul><li>这表明直方图均衡的第二次处理结果与第一次处理相同。(舍入误差忽略不计)</li></ul></li><li><p>3.14 如图所示图像很不相同，但它们的直方图却相同，假设每幅图像都用一个3x3的均值模版来进行模糊处理。</p><p><img src="/diptimu/314.png" width="20%"></p><ul><li><p>模糊后图像的直方图还相同吗？试解释原因。</p><p>右侧图像中<strong>黑色和白色区域之间的边界点数量要多得多</strong>。当进行模糊处理时，边界点将在右侧产生更多数量的不同值，因此模糊处理后的直方图不同。</p></li><li><p>如果你的答案是不相同，画出两个直方图。</p><p>3x3的均值模版，其系数为1/9。假设图片的大小为NxN，用0的边框环绕图像。模糊处理后两张图像的值如下表所示：</p><p><img src="/diptimu/3142.png" width="50%"></p></li></ul></li></ul><ul><li><p>第三章的概念，需要掌握：平滑滤波，中值滤波，直方图等。公式不会考，需要掌握定性的内容如：高频，低频，滤波器，etc</p><h4 id="C11-1-2-8"><a href="#C11-1-2-8" class="headerlink" title="C11[1, 2, 8]"></a>C11[1, 2, 8]</h4></li><li><p>11.1(a) 重新定义链码的一个起始点，以便所得的数字序列形成一个最小整数。请证明该编码与边界的初始起点无关。</p><ul><li>链码中每个元素的值都与其前元素的值相关。 以一致方式（例如，顺时针方向）跟踪的边界的代码是唯一的圆形数字集。 <strong>从该集合中的不同位置开始不会改变循环序列的结构</strong>。 </li><li>选择最小整数作为起始点只是标识序列中的相同点。 即使起点不是唯一的，这种方法仍然会给出一个独特的序列。 例如，序列101010具有三个可能的起始点，但它们都产生相同的最小整数010101。</li></ul></li><li><p>11.1(b) 求编码10176722335422的归一化起始点。</p><ul><li>代码：11076765543322.起点为0，产生序列07676554332211。</li></ul></li><li><p>11.2(a) 证明链码的一次差分会将该链码关于旋转归一化</p><ul><li>一次差分仅计算分隔代码的相邻元素的<strong>方向数</strong>。 因为计数过程与方向无关，所以第一个差异与边界旋转无关。 （这里的假设是旋转不会改变代码本身）。</li></ul></li><li><p>11.2(b)计算编码0110233210332322111的一次差分</p><ul><li>编码：0101030303323232212111</li><li>差分：3131331313031313031300。</li><li>编码被视为循环序列，因此差分的第一个元素是代码的最后一个元素和第一个元素之间的方向变化数，如文中所述。</li></ul></li><li><p>11.8 画出下列图形的中轴：一个圆，一个等边五角形，一个矩形，一个等边三角形</p><p><img src="/diptimu/118.png" width="50%"></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;备注&quot;&gt;&lt;a href=&quot;#备注&quot; class=&quot;headerlink&quot; title=&quot;备注&quot;&gt;&lt;/a&gt;备注&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;数字图像处理  - 冈萨雷斯 - 第三版中文版&lt;/li&gt;
&lt;li&gt;&lt;p&gt;习题答案为英文版翻译删减版 + 小部分个人理解&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="软件工程" scheme="https://daisine.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="note" scheme="https://daisine.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>数字图像处理笔记</title>
    <link href="https://daisine.github.io/dip/"/>
    <id>https://daisine.github.io/dip/</id>
    <published>2019-06-11T08:00:44.000Z</published>
    <updated>2019-06-11T08:06:00.454Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-数字图像处理概述"><a href="#1-数字图像处理概述" class="headerlink" title="1. 数字图像处理概述"></a>1. 数字图像处理概述</h3><ul><li><p>图像处理的应用</p><ul><li>货车安全状态自动识别系统</li></ul></li><li><p>DIP阶段划分：</p><a id="more"></a></li></ul><p><img src="/dip/dip.png" width="65%"></p><ul><li><p>数字图像处理在各个领域的应用</p><ul><li>伽马射线成像：核医学，天文观测…</li><li>X射线成像：医学诊断，工业成像…</li><li>紫外波段成像：平板印刷术，显微方法，工业检测…</li><li>可见光及红外波段成像：遥感，天气观测与预报，生产产品的自动视觉检测</li><li>微波波段成像(雷达)，无线电波段成像(医学，天文学)</li></ul></li><li><p>数字图像处理关键步骤：</p><p><img src="/dip/keys.png" width="50%"></p><ul><li>图像获取：通常包括图像预处理，如图像缩放。</li><li>图像增强：对一幅图像进行某种操作，使其结果在特定应用中比原始图像更适合进行处理。(主观的)</li><li>图像复原：复原技术倾向于以图像退化的图数学或概率模型为基础。(客观的)</li><li>形态学处理：涉及提取图像成分的工具，这些成分在表示和描述形状方面很有用。(输出图像属性处理)</li><li>分割：将一幅图片划分为其组成部分或目标。分割越准确，识别越成功。</li><li>表示与描述：选择一种合适的表示，如关注外部形状特征&amp;一条边界，内部特效&amp;整个区域。描述又称为特征选择，涉及特征提取。</li><li>目标识别：基于目标的描述给该目标赋予标志的过程。</li></ul></li></ul><h3 id="2-数字图像基础"><a href="#2-数字图像基础" class="headerlink" title="2. 数字图像基础"></a>2. 数字图像基础</h3><h5 id="2-1-采样和量化"><a href="#2-1-采样和量化" class="headerlink" title="2.1 采样和量化"></a>2.1 采样和量化</h5><ul><li><p>为了产生一幅数字图像，我们需要将连续的感知数据转换为数字形式。采集到的图像都需要经过离散化变成数字图像后才能被计算机识别和处理。</p></li><li><p>数字图像始终只是现实世界场景的近似值。</p><p><img src="/dip/采样量化.png" width="30%"></p></li><li><p>采样：对坐标值进行数字化。</p></li><li><p>量化：对幅值数字化。(把采样点上对应的灰度连续变化区间转换为单个特定数码的过程)</p></li></ul><p><img src="/dip/采样.png" width="45%"><img src="/dip/量化.png" width="45%"></p><h5 id="2-2-空间分辨率和灰度分辨率"><a href="#2-2-空间分辨率和灰度分辨率" class="headerlink" title="2.2 空间分辨率和灰度分辨率"></a>2.2 空间分辨率和灰度分辨率</h5><ul><li>空间分辨率是图像中可辨识的最小细节的度量。(像素大小，每英寸点数DPI)</li><li>灰度分辨率是指在灰度级中可分辨的最小变化。<ul><li>灰度分辨率指的是用于量化灰度的比特数。</li><li>灰度分辨率越高，图中可辨识的细节程度越精细。(低细节，中细节，高细节)</li></ul></li></ul><p><img src="/dip/灰度等级.png" width="50%"></p><h3 id="3-灰度变化与空间滤波"><a href="#3-灰度变化与空间滤波" class="headerlink" title="3. 灰度变化与空间滤波"></a>3. 灰度变化与空间滤波</h3><h5 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h5><ul><li>图像增强：对一幅图像进行某种操作，使其结果在特定应用中比原始图像更适合进行处理。</li><li>图像增强的原因：<ul><li>突出显示图像中的有趣细节</li><li>消除图像中的噪点</li><li>使图像更具视觉吸引力</li></ul></li><li><p>图像增强的方法：</p><ul><li>点处理</li><li>直方图处理</li><li>算数/逻辑运算</li><li>邻域操作</li></ul></li><li><p>到目前为止，当我们谈到图像灰度值时，说它们在[0, 255]范围内。其中0为黑色，255为白色，这个范围源于显示技术。而对于本章的许多图像处理操作，假设<strong>灰度级在[0.0, 1.0]</strong>范围。</p></li><li><p>空间域和频率域</p><ul><li><strong>空间域</strong>指图像平面本身，这类图像处理方法直接操作图像中的元素，主要分为灰度变换和空间滤波两类。<strong>灰度变换</strong>对图片的单个像素进行操作，主要以对比度和阈值处理为目的。<strong>空间滤波</strong>设计改善性能的操作，如通过图片中每个像素的邻域处理来锐化图像。</li><li><strong>频率域</strong>的图像处理，如傅立叶变换、小波变换的操作</li></ul></li></ul><h5 id="3-2-点处理"><a href="#3-2-点处理" class="headerlink" title="3.2 点处理"></a>3.2 点处理</h5><ul><li><p>灰度变换是所有图像处理技术中最简单的技术。r和s分别代表处理前后的像素值</p></li><li><p>s = T( r ) T是把像素值r映射到像素值s的一种变换。</p></li><li><p>负像操作/图像反转</p><ul><li>适用于增强嵌入图像暗色区域中的白色或灰色细节，特别是当黑色面积占主导地位时。</li><li>s = L - 1 - r，灰度级范围[0, L-1]</li></ul></li><li><p>阈值处理(二值化) P64图3.2</p><ul><li>阈值转换：将感兴趣的对象与背景隔离的分割。</li></ul></li><li><p>对数变换</p><ul><li>s = c log ( 1 + r )，c为常数，r ≥ 0</li><li>使用对数变换来<strong>扩展</strong>图像中的<strong>暗像素值</strong>，同时<strong>压缩更高灰度级</strong>的值。该变换将输入中范围较窄的低灰度值映射为输出中范围较宽的灰度值，或将输入中范围较宽的高灰度值映射为输出中范围较窄的灰度值。</li><li>应用：傅立叶频谱 P66</li></ul></li><li><p>幂律(伽马)变换</p><ul><li>s = r <sup><em>γ</em></sup>，c和<em>γ</em>为正常数</li><li>与对数变换情况类似，部分<em>γ</em>值的幂律曲线将较窄范围的暗色输入映射为较宽范围的输出值，或将较宽范围的高灰度级输入映射为较窄范围的输出值。<strong>不同的是</strong>，<em>γ</em>&gt;1的值所生成的曲线(<strong>图像变暗</strong>)和 <em>γ</em>&lt;1的值所生成的曲线(<strong>图像变亮</strong>)效果完全相反，当c = <em>γ</em> = 1，为恒等变换。</li><li><strong>伽马校正</strong>：显示设备不能线性响应不同的亮度，所以需要将图像输入到显示设备前进行预处理，使得经过伽马校正过的输入产生外观上接近原图像的输出。</li></ul></li><li><p><strong>分段</strong>线性变换<strong>函数</strong></p><ul><li><p>灰度级分层：突出显示图像中特定灰度范围的亮度。一种方法是将感兴趣范围内所有灰度值显示为一个值(eg白)，其他灰度值显示为另一个值(eg黑)；另一种方法是将感兴趣范围的灰度变亮(/暗)，保持图像中其他灰度级不变。</p><p><img src="/dip/gl.png" width="50%"></p></li><li><p>比特平面分层：像素是由比特组成的数字。如在256级灰度图像中，每个像素的灰度由8比特组成。替代突出灰度级范围，我们可用突出比特来突出整个图像的外观。</p><blockquote><p>比如一幅8比特图像由8个1比特平面组成，其中平面1包含图像中所有像素的低阶比特，而8包含图像中所有像素的最高阶比特。P71</p></blockquote></li></ul></li></ul><h5 id="3-3-直方图处理"><a href="#3-3-直方图处理" class="headerlink" title="3.3 直方图处理"></a>3.3 直方图处理</h5><ul><li><p>灰度范围为[0, L-1]的数字图像的直方图是离散函数 h ( r <sub>k</sub> ) = n <sub>k</sub>，其中 r <sub>k</sub>是第k级灰度值， n <sub>k</sub>是图像中灰度为 r <sub>k</sub>的像素个数。</p><ul><li>归一化：p ( r <sub>k</sub> ) = n <sub>k</sub> / MN， M和N为图像的行数和列数，p ( r <sub>k</sub> )为r <sub>k</sub>在图像中出现的概率估计。</li></ul></li><li><p>直方图的主要性质：</p><ul><li>直方图只能反应图像的灰度分布情况，不能表示灰度所在位置。</li><li>一幅图像对应唯一的灰度直方图，不同图像可对应相同的直方图。</li></ul></li><li><p>图像与其直方图之间的关系 P73：<strong>高对比度图像</strong>具有最均匀间隔的直方图。若一幅图像的像素占有全部可能灰度级范围并且分布均匀，则这幅图像对比度高，灰度色调多变。</p></li><li><p>直方图均衡化 P76</p><ol><li>统计图象中各灰度级像素个数n <sub>k</sub></li><li>计算直方图中应变量的值: p <sub>k</sub> = n <sub>k</sub>/(M×N)</li><li>计算累计直方图中应变量的值: s <sub>k</sub> = Σ p <sub>k</sub></li><li>取整S <sub>k</sub>=int{(L-1)s <sub>k</sub>};</li><li>确定映射对应关系: k → S <sub>k</sub>;</li><li>对图象进行增强变换( k → S <sub>k</sub>).</li></ol><p><img src="/dip/gs.png" width="55%"></p></li></ul><h5 id="3-4-算数-逻辑运算"><a href="#3-4-算数-逻辑运算" class="headerlink" title="3.4 算数/逻辑运算"></a>3.4 算数/逻辑运算</h5><ul><li><p>算术运算：加法，减法，乘法</p></li><li><p>逻辑运算：NOT，AND，OR，XOR</p><p><img src="/dip/logic.png" width="75%"></p></li></ul><h5 id="3-5-空间滤波"><a href="#3-5-空间滤波" class="headerlink" title="3.5 空间滤波"></a>3.5 空间滤波</h5><ul><li><p>空间滤波器由(1)邻域(通常是一个较小的矩形)，(2)对该邻域所包围的图像像素执行的预定义操作组成。</p><ul><li>线性操作 - 线性空间滤波器  eg.平滑空间滤波器<ul><li>非线性操作 - 非线性空间滤波器 eg.中值滤波器</li></ul></li></ul></li><li><p>简单的邻域操作：</p><ul><li>Min：将像素值设置为最小值</li><li>Max：将像素值设置为最大值</li><li>Median：将像素值设置为中值(中位数)。有时候中值比平均值效果更好。</li></ul><p><img src="/dip/滤波.png" width="60%"></p></li><li><p>对原始图像中的每个像素重复上述操作以生成滤波图像。</p></li></ul><h5 id="3-6-平滑空间滤波器"><a href="#3-6-平滑空间滤波器" class="headerlink" title="3.6  平滑空间滤波器"></a>3.6  平滑空间滤波器</h5><ul><li><p>用于模糊处理和降低噪声。模糊处理经常用于预处理任务中，例如在目标提取之前去除图像中一些琐碎细节。</p></li><li><p>平滑线性空间滤波器/均值滤波器：使用滤波器模版确定的邻域内像素的平均灰度值来代替图像中的每个像素的值。</p><p><img src="/dip/均值滤波.png" width="60%"><img src="/dip/加权平滑.png" width="15%"></p></li></ul><ul><li>加权平滑滤波器：通过允许平均函数中邻域中的不同像素具有不同的权重，可以生成更有效的平滑滤波器。更接近中心像素的像素更重要，通常称为加权平均。</li></ul><h5 id="3-7-中值滤波器-统计排序-非线性-滤波器"><a href="#3-7-中值滤波器-统计排序-非线性-滤波器" class="headerlink" title="3.7  中值滤波器 - 统计排序(非线性)滤波器"></a>3.7  中值滤波器 - 统计排序(非线性)滤波器</h5><ul><li>统计排序(非线性)滤波器以滤波器包围的图像区域中所包含的像素排序为基础，使用统计排序结果决定的值代替中心像素的值。</li><li>中值滤波器：对处理脉冲噪声非常有效，这种噪声也称为<strong>椒盐噪声</strong>，因为这种噪声以黑白点的形式叠加在图像上。</li></ul><h5 id="3-8-邻域的边界问题"><a href="#3-8-邻域的边界问题" class="headerlink" title="3.8 邻域的边界问题"></a>3.8 邻域的边界问题</h5><ul><li><p>在图像的边缘，我们缺少像素以形成邻域</p><p><img src="/dip/边界.png" width="25%"></p></li><li><p>处理方法：</p><ul><li>忽略丢失的像素：仅适用于某些滤波器，可以添加额外代码并减缓处理速度</li><li>填充图像：通常使用全白或者全黑像素</li><li>复制边框像素</li><li>允许像素环绕图像</li></ul></li></ul><h5 id="3-9-锐化空间滤波器-拉普拉斯算子"><a href="#3-9-锐化空间滤波器-拉普拉斯算子" class="headerlink" title="3.9 锐化空间滤波器 - 拉普拉斯算子"></a>3.9 锐化空间滤波器 - 拉普拉斯算子</h5><ul><li><p>锐化处理的主要目的是突出<strong>灰度的过渡部分</strong>。锐化处理可由<strong>空间</strong>微分来实现。</p><ul><li>从图像中消除模糊</li><li>高亮显示边缘</li></ul></li><li><p>基于<strong>一阶微分</strong>和<strong>二阶微分</strong>的锐化滤波器</p></li><li><p>使用二阶微分锐化图像 - <strong>拉普拉斯算子 P100</strong></p><ul><li>各向同性滤波器：这种滤波器的响应与滤波器作用的图像的突变方向无关。</li></ul></li></ul><blockquote><p>通常，为了达到令人满意的结果，对给定的任务需要应用多种互补的图像增强技术。 例子P104 增强骨骼扫描</p></blockquote><h3 id="4-频率域滤波"><a href="#4-频率域滤波" class="headerlink" title="4. 频率域滤波"></a>4. 频率域滤波</h3><h5 id="4-1-傅里叶级数和傅里叶变换"><a href="#4-1-傅里叶级数和傅里叶变换" class="headerlink" title="4.1 傅里叶级数和傅里叶变换"></a>4.1 傅里叶级数和傅里叶变换</h5><ul><li><p>傅里叶级数：任何周期函数都可以表示为不同频率的正弦和或余弦之和的形式，每个正弦项和/或余弦项都乘以不同的<strong>系数</strong> - 傅立叶级数</p></li><li><p>逆DFT：值得注意的是傅立叶变换是完全可逆的。</p></li><li><p>二维图像的DFT可以通过显示图像分量频率的频谱来可视化。 P155</p><ul><li>谱对图像平移不敏感，它随着旋转图像以相同的角度旋转</li></ul><p><img src="/dip/dft.png" width="40%"></p></li></ul><h5 id="4-2-频域中的图像处理"><a href="#4-2-频域中的图像处理" class="headerlink" title="4.2 频域中的图像处理"></a>4.2 频域中的图像处理</h5><ul><li><p>频率域滤波是指先修改一幅图像的傅里叶变换，然后计算其反变换，得到处理后的结果。</p><ol><li>计算 F(u, v)，即图像的DFT</li><li>用滤波函数H(u, v) 乘以F(u, v)</li><li>计算结果的<strong>逆DFT</strong></li></ol><p><img src="/dip/dft2.png" width="70%"></p></li></ul><h5 id="4-3-图像平滑"><a href="#4-3-图像平滑" class="headerlink" title="4.3 图像平滑"></a>4.3 图像平滑</h5><ul><li>平滑频域滤波器：通过丢弃高频分量在频域中实现平滑。</li><li><p>过滤的基本模型是：</p><ul><li>G(u, v) = H(u, v) F(u, v)</li><li>其中F(u, v)是被滤波图像的傅里叶变换，H(u, v)是滤波器变换函数</li></ul></li><li><p>低通滤波器：仅通过低频，衰减高频滤波。</p><ul><li>理想低通滤波器(ILPF)：非常急剧</li><li>布特沃斯低通滤波器(BLPF)：阶数值较高，接近于ILPF；阶数值较低，接近于GLPF。可以视为两种”极端”滤波器的过渡。</li><li>高斯低通滤波器(GLPF)：非常平滑</li></ul></li><li><p>理想低通滤波器(ILPF) P169  <strong>[存在振铃现象]</strong></p><ul><li>在以原点为中心，以D<sub>0</sub>为半径的圆内，无衰减地通过所有频率，而在该圆外”阻断”所有频率的二位低通滤波器。 </li><li>对于一个理想低通滤波器横截面，在H(u, v) = 1 和 H(u,v) = 0 之间的过渡点称为<strong>截止频率</strong>。</li><li>D<sub>0</sub>越小，处理后的结果越模糊。D(u, v)是距频率矩形中心的距离。</li></ul><p><img src="/dip/ilpf.png" width="65%"></p></li><li><p>布特沃斯低通滤波器(BLPF)<strong>[振铃现象与阶数有关]</strong></p><ul><li>与ILPGF不同，BLPF函数并没有在通过频率和滤除频率之间给出明显截止的急剧不连续性。对于具有平滑传递函数的滤波器，可在这样一点上定义截止频率：即使得H(u, v) 下降为其最大值的某个百分比的点。</li><li>空间域的<strong>一阶</strong>布特沃斯低通滤波器<strong>没有振铃现象</strong>，<strong>二阶</strong>中振铃现象<strong>很难被察觉</strong>，但更高阶数的滤波器中的振铃现象会很明显。</li></ul><p><img src="/dip/blpf.png" width="65%"></p></li><li><p>高斯低通滤波器(GLPF)<strong>[无振铃现象]</strong></p><p><img src="/dip/glpf.png" width="65%"></p></li><li><p>应用：</p><ul><li>低分辨率文本：使用GLPF对图像滤波后的结果，断开的字符段已被连接到一起。</li><li>用不同D<sub>0</sub>的高斯滤波器处理照片。</li></ul></li></ul><h5 id="4-4-图像锐化"><a href="#4-4-图像锐化" class="headerlink" title="4.4 图像锐化"></a>4.4 图像锐化</h5><ul><li><p>图像中的边缘和精细细节与高频分量相关联</p></li><li><p>高通滤波器：仅通过高频，降低低频滤波。高通滤波器是从给定低通滤波器得到：H<sub>hp</sub>(u, v) = 1 - H<sub>lp</sub>(u ,v)</p><ul><li>理想高通滤波器(IHPF)：非常急剧</li><li>布特沃斯高通滤波器(BHPF)：表现为理想滤波器的锐利性和高斯滤波器的宽阔平滑性间的一种过渡。</li><li>高斯高通滤波器(GHPF)：非常平滑</li></ul><p><img src="/dip/hp.png" width="65%"></p></li><li><p>应用：使用高通滤波法和阈值法增强图像 - 指纹图像P179</p></li><li><p>频率域的拉普拉斯算子</p><ul><li>使用拉普拉斯算子在频率域锐化图像 P180</li></ul></li></ul><h5 id="4-5-快速傅里叶变换"><a href="#4-5-快速傅里叶变换" class="headerlink" title="4.5 快速傅里叶变换"></a>4.5 快速傅里叶变换</h5><ul><li>允许傅里叶变换在合理时间内执行</li><li>将执行傅里叶变换所需的时间缩短100到600倍</li><li>可以在空间域和频率域中完成类似的工作</li><li>可以更容易理解空间域中的过滤</li><li>在频率域中过滤可以更快——特别是对于大图像</li></ul><h3 id="5-图像复原"><a href="#5-图像复原" class="headerlink" title="5. 图像复原"></a>5. 图像复原</h3><h5 id="5-1-图像复原定义"><a href="#5-1-图像复原定义" class="headerlink" title="5.1 图像复原定义"></a>5.1 图像复原定义</h5><ul><li><p>定义</p><ul><li>图像复原技术的主要目的是以预先确定的目标来改善图像。</li><li>类似于图像增强，但更客观。</li><li>图像复原是图利用退化现象的某种先验知识(或后验的)来复原被退化的图像。</li><li>面向退化模型，采用相反的过程进行处理。</li></ul></li><li><p>图像退化：图像在形成、记录、处理和传输过程中，由于成像系统、记录设备、传输介质和处理方法的不完善，导致图像质量的下降的现象。</p><p><img src="/dip/th.png" width="65%"></p></li></ul><h5 id="5-2-噪声与噪声模型"><a href="#5-2-噪声与噪声模型" class="headerlink" title="5.2 噪声与噪声模型"></a>5.2 噪声与噪声模型</h5><ul><li>数字图像中，<strong>噪声</strong>主要来源于图像的获取和/或传输过程。<ul><li>成像传感器的性能受各种因素的影响，如图像获取过程中环境条件和传感元件自身的重量。</li><li>图像在传输中被污染主要是由于传输信道的干扰。</li></ul></li><li><p>将噪声模型建模为：g(x, y) = f(x, y) + η(x, y)</p></li><li><p>其中 f(x, y)是原始图像像素，η(x, y)是噪声项，g(x, y)是得到的噪声像素。</p></li><li><p>图像噪声项η(x, y)有许多不同的模型： <strong>P201 噪声效果</strong></p><ul><li>高斯噪声：最常见的模型</li><li>瑞利噪声</li><li>爱尔兰(伽马)噪声</li><li>指数噪声</li><li>均匀噪声</li><li>脉冲(椒盐)噪音</li></ul><p><img src="/dip/zs.png" width="60%"></p></li></ul><h5 id="5-3-只存在噪声的复原-——-空间滤波"><a href="#5-3-只存在噪声的复原-——-空间滤波" class="headerlink" title="5.3 只存在噪声的复原 —— 空间滤波"></a>5.3 只存在噪声的复原 —— 空间滤波</h5><ul><li>在仅存在加性噪声的情况下，可以选择空间滤波方法。</li><li><p>均值滤波器：</p><ul><li><strong>算数均值</strong>滤波器：作为简单的平滑滤波器实现的，<strong>模糊图像</strong>以消除噪音。</li><li><strong>几何均值</strong>滤波器：实现与算术平均值类似的平滑，但这种处理丢失的图像细节更少。</li><li><strong>谐波均值</strong>滤波器：对于盐粒噪声效果较好，但不适用于胡椒噪声。善于处理像高斯噪声那样的其他噪声。</li><li><strong>逆谐波均值</strong>滤波器P204：Q为滤波器的阶数。这种滤波器适合减少或在实际中消除椒盐噪声的影响。当Q为正，消除胡椒噪声；Q为负，消除盐粒噪声；Q=0，为算数均值滤波器；Q=-1，为谐波均值滤波器。</li></ul></li><li><p>统计排序滤波器：</p><ul><li><strong>中值</strong>滤波器：引起的模糊更小。在存在椒盐噪声的情况下，中值滤波器尤其有效。</li><li><strong>最大值和最小值</strong>滤波器：最大值滤波器发现最亮点，有利于降低胡椒噪音(值低)；最小值滤波器发现最暗点，有利于降低胡椒噪音(值高)。</li><li><strong>中点</strong>滤波器：最大值和最小值中间的点。适用于处理随机分布的噪声，如高斯噪声或均匀噪声。</li><li><strong>修正的阿尔法均值</strong>滤波器P206：d=0，退化为算数均值滤波器；d=mn-1，退化为中值滤波器；d为其他值，在包括多种噪声的情况下很有用，如混合有高斯噪声和椒盐噪声的情况。</li></ul></li></ul><h5 id="自适应中值滤波器"><a href="#自适应中值滤波器" class="headerlink" title="自适应中值滤波器"></a>自适应中值滤波器</h5><ul><li><strong>自适应滤波器</strong>：到目前为止讨论的用于图像处理的滤波器，并未考虑图像中的一点对其他点的特征变化。<ul><li>自适应滤波器的行为根据滤波器区域内的图像的特性而改变。</li></ul></li><li><strong>自适应中值滤波器</strong><ul><li>可以处理具有更大概率的脉冲噪声，传统中值滤波器只要脉冲噪声的空间密度不大，性能就会很好。</li><li>平滑非脉冲噪声时会试图保留细节，这是传统中值滤波器做不到的。</li><li>在进行滤波处理时，会根据图像的特征而改变。</li></ul></li><li>考虑如下符号：自适应滤波器也工作在矩形窗口区域 S <sub>xy</sub>内。<ul><li>Z <sub>min</sub> = S <sub>xy</sub> 中的最小灰度值</li><li>Z <sub>max</sub> =  S <sub>xy</sub>中的最大灰度值</li><li>Z <sub>med</sub> =  S <sub>xy</sub>中灰度值的中值</li><li>Z <sub>xy</sub> = 坐标(x, y)处的灰度值</li><li>S <sub>max</sub> =   S <sub>xy</sub>允许的最大尺寸</li></ul></li><li>自适应中值滤波器算法以两个进程工作，分别表示为进场A和进程B</li><li>进程A：<ul><li>A <sub>1</sub> = Z <sub>med</sub> - Z <sub>min</sub> </li><li>A <sub>2</sub> = Z <sub>med</sub> - Z <sub>max</sub> </li><li>如果 A <sub>1</sub> &gt; 0 且 A <sub>2</sub> &lt; 0，则转到进程B</li><li>否则增大窗口尺寸</li><li>如果窗口尺寸≤ S <sub>max</sub>，则重复进程A</li><li>否则输出Z <sub>med</sub></li></ul></li><li><p>进程B </p><ul><li>B <sub>1</sub> = Z <sub>xy</sub> - Z <sub>min</sub> </li><li>B <sub>2</sub> = Z <sub>xy</sub> - Z <sub>max</sub> </li><li>如过 B <sub>1</sub> &gt; 0 且 B <sub>2</sub> &lt; 0  ，则输出Z <sub>xy</sub></li><li>否则输出Z <sub>med</sub> </li></ul></li><li><p>该算法的三个主要目的：</p><ol><li>去除椒盐噪声</li><li>平滑其他非脉冲噪声</li><li>减少诸如物体边界细化或粗化等失真</li></ol></li></ul><h5 id="5-4-用频率域滤波消除周期噪声"><a href="#5-4-用频率域滤波消除周期噪声" class="headerlink" title="5.4 用频率域滤波消除周期噪声"></a>5.4 用频率域滤波消除周期噪声</h5><ul><li><p><strong>周期噪声</strong>[空间相关噪声]：在图像获取期间由于电力或者机电干扰产生的。周期噪声可以通过频率域滤波中来显著地减少(傅里叶变换)。</p></li><li><p>带阻滤波器：从图像中去除周期性噪声涉及从该图像中去除特定范围的频率</p></li></ul><blockquote><p>图像恢复比增强更客观<br>空间域技术对于消除随机噪声特别有用<br>频域技术对于消除周期性噪声特别有用</p></blockquote><h3 id="6-形态学图像处理"><a href="#6-形态学图像处理" class="headerlink" title="6. 形态学图像处理"></a>6. 形态学图像处理</h3><ul><li>形态学图像处理描述了一系列处理图像中特征形状(或形态)的图像处理技术。</li><li>形态学，是图像处理中应用最为广泛的技术之一，主要用于从图像中提取对表达和描绘区域形状有意义的图像分量，<strong>使后续的识别工作</strong>能够抓住目标对象最为本质〈最具区分能力）的形状特征，如边界和连通区域等。同时像细化、像素化和修剪毛刺等技术也常应用于图像的预处理和后处理中，成为图像增强技术的有力补充。</li></ul><h5 id="6-1-基础知识"><a href="#6-1-基础知识" class="headerlink" title="6.1 基础知识"></a>6.1 基础知识</h5><ul><li><strong>结构元</strong>：设有两幅图像A，S。若A是被处理的对象， 而S是用来处理A的， 则称S为结构元。结构元通常都是一些比较小的图像， A与S的关系类似于滤波中图像和模板的关系。<ul><li>结构元可以是任何尺寸， 形状。</li><li>为简单起见，我们使用矩形构造结构元，其原点位于中间像素。</li></ul></li><li>适合：结构元的所有像素都覆盖图像中的像素。</li><li>击中：结构元的任意一个像素域与图像中的像素重叠。</li></ul><h5 id="6-2-基本形态学操作"><a href="#6-2-基本形态学操作" class="headerlink" title="6.2 基本形态学操作"></a>6.2 基本形态学操作</h5><ul><li><p>腐蚀</p><ul><li><p>结构元 s 对图像 f 的腐蚀定义为： f ㊀ s  。结构元的原点位于(x, y)，新的像素值由以下规则确定：</p><p><img src="/dip/er.png" width="25%"></p></li><li><p>缩小或者细化了二值图像中的物体。</p></li><li>可以分裂连接的物体</li></ul></li><li><p>膨胀</p><ul><li>结构元 s 对图像 f 的膨胀定义为： f ⊕ s  。结构元的原点位于(x, y)，新的像素值由以下规则确定：</li></ul><p><img src="/dip/di.png" width="25%"></p><ul><li>会增长或粗化二值图像中的物体</li><li>可以连接裂缝</li></ul></li></ul><h5 id="6-3-复合操作"><a href="#6-3-复合操作" class="headerlink" title="6.3 复合操作"></a>6.3 复合操作</h5><ul><li><p>开：先腐蚀后膨胀 f 〇 s =  (f ㊀ s)  ⊕ s</p><ul><li>平滑物体的轮廓</li><li>断开较窄的连接，消除较细的突出物</li></ul><p><img src="/dip/2.png" width="45%"></p></li><li><p>闭：先膨胀后腐蚀  f • s = ( f ⊕ s) ㊀ s</p><ul><li>使轮廓变得光滑</li><li>弥合较窄的间断和细长的沟壑</li><li>消除(填充)较小的孔洞，填补轮廓线中的断裂</li></ul><p><img src="/dip/1.png" width="45%"></p></li></ul><h5 id="6-4-形态学算法-P412"><a href="#6-4-形态学算法-P412" class="headerlink" title="6.4 形态学算法 P412"></a>6.4 形态学算法 P412</h5><ul><li><p>边界提取：提取对象的边界(或轮廓)非常有用。</p><ul><li>β(A) = A – (A㊀B)</li></ul><p><img src="/dip/b.png" width="25%"></p></li><li><p>孔洞填充</p><ul><li>X<sub>k</sub> =( X<sub>k-1</sub>⊕ B ) ∩A<sup>c</sup></li></ul><p><img src="/dip/fill.png" width="35%"></p></li><li><p>连通分量的提取</p></li><li><p>凸壳，细化，粗化，骨架，剪裁</p></li></ul><h3 id="7-图像分割"><a href="#7-图像分割" class="headerlink" title="7. 图像分割"></a>7. 图像分割</h3><ul><li>本章的多数分割算法均基于灰度值的两个基本性质之一：<ul><li>不连续性</li><li>相似性</li></ul></li></ul><h5 id="7-1-点、线和边缘检测"><a href="#7-1-点、线和边缘检测" class="headerlink" title="7.1 点、线和边缘检测"></a>7.1 点、线和边缘检测</h5><ul><li><p>点检测(孤立点)</p><p><img src="/dip/point.png" width="15%"></p></li><li><p>线检测</p><p><img src="/dip/line.png" width="55%"></p></li><li><p>边缘检测</p><ul><li>通常，在边缘检测中出现问题，因为存在<strong>太多细节</strong>，这种精致的细节在边缘检测中通常是不符合需要的。克服这个问题的一种方法是在边缘检测之前进行<strong>平滑处理</strong>。</li></ul><p><img src="/dip/edge.png" width="60%"></p><ul><li>拉普拉斯边缘检测：拉普拉斯算子通常不会单独使用，因为它对噪声过于敏感。通常用于边缘检测的拉普拉斯算子与平滑高斯滤波器相结合</li><li>拉普拉斯高斯滤波器：使用高斯去除噪声，使用拉普拉斯算子进行边缘检测。</li></ul></li></ul><h5 id="7-2-阈值"><a href="#7-2-阈值" class="headerlink" title="7.2 阈值"></a>7.2 阈值</h5><ul><li><p>基本的全局阈值处理 P478</p><ul><li>基于图像的直方图。</li><li>当物体和背景的灰度分布十分明显，可以用适用于整个图像的单个阈值。</li><li>在大多数应用中，通常图像之间有较大变化，即使使用全局阈值，对每一幅图像有能力自动估计阈值的算法是必要的。</li></ul><p><img src="/dip/fuc.png" width="80%"></p></li><li><p>用Otsu方法的最佳全局阈值处理</p><ul><li>假定图像包含两类像素（前景像素和背景像素），直方图为双峰直方图，然后计算使得两类像素能分开的最佳阈值（类内方差），或<strong>等价的间类间方差最大</strong>。</li><li>按图像的灰度特性,将图像分成背景和目标两部分，或者说，是寻找一个阈值为K，将图像的颜色分为1,2…..K和K+1…..256两部分。</li><li>自适应的。</li></ul></li></ul><h3 id="8-表示-amp-描述"><a href="#8-表示-amp-描述" class="headerlink" title="8. 表示&amp; 描述"></a>8. 表示&amp; 描述</h3><ul><li><p>边界可用特征对其进行描述：</p><ul><li>长度</li><li>连接端点的直线的方向</li><li>边界上凹陷的数量</li></ul></li><li><p>形状特征 - 外部表示</p></li><li>内部属性，如颜色，纹理 - 内部表示</li></ul><h5 id="8-1-表示"><a href="#8-1-表示" class="headerlink" title="8.1 表示"></a>8.1 表示</h5><ul><li>分割技术会获得原始数据，其形式是沿着边界或包含在区域中的像素。标准做法是使用某种方案将分割后的数据精简为便于描绘子计算的表示，以减小数据的大小。</li></ul><h5 id="1-链码"><a href="#1-链码" class="headerlink" title="1. 链码"></a>1. 链码</h5><ul><li><p>链码被用来以顺次连接的具有指定长度和方向的直线段来表示边界。</p></li><li><p>这种表示基于4连接或者8连接。</p></li><li><p>原链码：沿着顺时针方向追踪一个边界，并对连接酶对像素的线段赋予一个方向的方法产生。</p><ul><li>得到的链码往往太长</li><li>噪声或不完美分割沿边界引起的任何较小干扰都会导致编码的变化</li><li><strong>解决方案</strong>：选取一个较大的网格间距来对边界重取样，编码表示的京都取决于取样网格的间距。</li></ul></li><li><p>归一化链码：原链码具有平移不变性（平移时不改变指向符），但当改变起点S时，会得到不同的链码表示，即不具备唯一性。为此可引入归一化链码，其方法是：</p><ul><li>对于闭合边界，任选一起点S得到原链码，将链码看作由各方向数构成的n位自然数，将该码按一个方向循环，使其构成的n位自然数最小，此时就形成起点唯一的链码，称为归一化链码，也称为规格化链码。</li><li>使用链码的一次差分而非链码本身，来对旋转进行归一化。这个差分时通过计算链码分隔两个相邻像素的方向变化的数得到的。</li></ul><p><img src="/dip/lm.png" width="100%"></p></li></ul><h5 id="2-多边形近似"><a href="#2-多边形近似" class="headerlink" title="2. 多边形近似"></a>2. 多边形近似</h5><ul><li><p>使用最小周长多边形的多边形近似</p><ul><li>将目标边界勘城市一个橡皮筋，将组成边界的像素序列内外边各堪称一堵墙，边界处于内外墙之间，如果将向脾经收缩，则可得到目标的最小周长多边形。</li></ul></li><li><p>聚合技术：</p><ul><li>沿一条边界来聚合一些点，直到拟合这些聚合点的直线的最小均方差超过某个预设的阈值。当这种条件出现时，存储该直线的参数，将误差设为0，并且重复该过程，沿边界聚合新的点，直到误差再次超过预设的阈值。过程结束后，相邻线段的交点就构成多边形的顶点。</li><li>难点：得到的近似顶点不总是对应于原始边界的形变。</li></ul><p><img src="/dip/聚合.png" width="30%"></p></li><li><p>分裂技术</p><ul><li>将线段不断地细分为两部分，直到满足规定的准则。</li></ul><p><img src="/dip/分裂.png" width="30%"></p></li></ul><h5 id="3-标记图"><a href="#3-标记图" class="headerlink" title="3. 标记图"></a>3. 标记图</h5><ul><li><p>将边界表示简化为描述起来可能比原始二维边界更简单的一维函数。</p><ul><li>距离为角度的函数</li></ul><p><img src="/dip/标记.png" width="50%"></p></li></ul><h5 id="4-骨架"><a href="#4-骨架" class="headerlink" title="4. 骨架"></a>4. 骨架</h5><p><img src="/dip/骨架.png" width="50%"></p><ul><li><p>迭代删除一个区域边界点的细化算法：</p><ul><li>不能删除端点</li><li>不能破坏连续性</li><li>不能导致区域的过度腐蚀</li></ul></li><li><p>细化算法步骤 P526-527 (稍微偷了个懒，然后它就考到了？？？ )</p></li></ul><h5 id="8-2-描述"><a href="#8-2-描述" class="headerlink" title="8.2 描述"></a>8.2 描述</h5>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-数字图像处理概述&quot;&gt;&lt;a href=&quot;#1-数字图像处理概述&quot; class=&quot;headerlink&quot; title=&quot;1. 数字图像处理概述&quot;&gt;&lt;/a&gt;1. 数字图像处理概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;图像处理的应用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;货车安全状态自动识别系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DIP阶段划分：&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="软件工程" scheme="https://daisine.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="note" scheme="https://daisine.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>VS Code调教笔记 on Mac OS</title>
    <link href="https://daisine.github.io/vscode-macos/"/>
    <id>https://daisine.github.io/vscode-macos/</id>
    <published>2019-05-24T02:30:20.000Z</published>
    <updated>2019-05-27T07:08:58.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python-OpenCV"><a href="#Python-OpenCV" class="headerlink" title="Python-OpenCV"></a>Python-OpenCV</h2><ol><li><p>在终端使用homebrew 安装 <code>python3</code> 和<code>opencv3</code>。</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">➜  ~ brew install python3</span><br><span class="line">➜  ~ pip3 install opencv-python</span><br></pre></td></tr></table></figure><a id="more"></a></li><li><p>查看python和opencv的版本。(由于OS X系统自带python2，所以后面会出问题)        </p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">➜  ~ python3 --version</span><br><span class="line">Python 3.6.5</span><br><span class="line">➜  ~ python3</span><br><span class="line">Python 3.6.5 (default, Jun 17 2018, 12:15:43) </span><br><span class="line">[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)] on darwin</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> or <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; import cv2</span><br><span class="line">&gt;&gt;&gt; cv2.__version__</span><br><span class="line"><span class="string">'3.4.4'</span></span><br></pre></td></tr></table></figure></li><li><p>在VS Code的扩展中安装<code>Python</code>和<code>Code Runner</code>。<code>Code Runner</code>是一个方便编译运行的一个插件。</p></li><li><p>使用<code>Code Runner</code>右键RunCode，发现输出存在问题。原因是<code>Code Runner</code>不是使用的python3，而是使用 系统自带的python2。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Running] python -u &quot;/Users/yi/Documents/Python-opencv/blur.py&quot;</span><br></pre></td></tr></table></figure><p>解决方法：VS Code  ➜ 首选项 ➜ 设置 ➜ 用户区 / 工作区(按照自己的情况选择) ➜ 扩展 ➜ Run Code configuration  ➜ 找到Executor Map ➜ 在settings.json中编辑。详见<a href="https://github.com/formulahendry/vscode-code-runner#configuration" target="_blank" rel="noopener">Code Runner的说明文档关于configuration描述</a></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"code-runner.executorMap": &#123;</span><br><span class="line">    "python": "/usr/local/bin/python3"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之后运行得到：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">[Running] /usr/<span class="built_in">local</span>/bin/python3 <span class="string">"/Users/yi/Documents/Python-opencv/blur.py"</span></span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>在.py文件中使用cv2的函数：imread, imshow等，会报错。这是由于VS Code中python的语法检查工具pylint无法识别cv2的函数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Module &apos;cv2&apos; has no &apos;imread&apos; member pylint(no-member)</span><br><span class="line">Module &apos;cv2&apos; has no &apos;imshow&apos; member pylint(no-member)</span><br></pre></td></tr></table></figure><p>解决方法：VS Code  ➜ 首选项 ➜ 设置 ➜ 用户区 / 工作区(按照自己的情况选择) ➜ 扩展 ➜ Python  ➜ Python › Linting: Pylint Args ➜ 在settings.json中加入：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"python.linting.pylintArgs": ["--generate-members"]</span><br></pre></td></tr></table></figure></li></ol><h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><ol><li><p>OS X已经安装XCode</p></li><li><p>在VS Code的扩展中安装<code>C/C++</code>和<code>C/C++ Clang Command Adapter</code>。</p></li><li><p>按F5进行调试，需要选择gcc/clang++/…，我使用的是clang++。如果调试没用问题，会在终端显示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">终端将被任务重用，按任意键关闭。</span><br></pre></td></tr></table></figure></li><li><p>使用<code>Code Runner</code>在输出窗口中可以输出C/C++的结果，但是无法进行输入。所以需要进行设置修改：VS Code  ➜ 首选项 ➜ 设置 ➜ 用户区 / 工作区(按照自己的情况选择) ➜ 扩展 ➜ Run Code configuration  ➜  找到Run In Terminal 并勾选。</p></li><li><p>再使用<code>Code Runner</code>会在终端运行，可以进行输入。</p></li><li><p>遇到的问题：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">找不到任务“clang++ build active file”</span><br><span class="line">preLaunchTask“clang++ build active file”已终止，退出代码为 1。</span><br><span class="line">运行 preLaunchTask“clang++ build active file”后存在错误。</span><br></pre></td></tr></table></figure><p>最开始以为是没有配置好环境，查了半天，后来发现是程序写的有问题，没有编译通过，只不过以前用vs没见过这种方式的错误提示。<br>程序写的没问题的话，再次调试就会显示：终端将被任务重用，按任意键关闭。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Python-OpenCV&quot;&gt;&lt;a href=&quot;#Python-OpenCV&quot; class=&quot;headerlink&quot; title=&quot;Python-OpenCV&quot;&gt;&lt;/a&gt;Python-OpenCV&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在终端使用homebrew 安装 &lt;code&gt;python3&lt;/code&gt; 和&lt;code&gt;opencv3&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight zsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;➜  ~ brew install python3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;➜  ~ pip3 install opencv-python&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Mac OS X" scheme="https://daisine.github.io/categories/Mac-OS-X/"/>
    
    
      <category term="配置环境" scheme="https://daisine.github.io/tags/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记</title>
    <link href="https://daisine.github.io/sftest/"/>
    <id>https://daisine.github.io/sftest/</id>
    <published>2019-04-30T03:57:44.000Z</published>
    <updated>2019-05-10T10:50:34.331Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-软件测试概述"><a href="#1-软件测试概述" class="headerlink" title="1 软件测试概述"></a>1 软件测试概述</h3><h4 id="故障、错误-amp-失败"><a href="#故障、错误-amp-失败" class="headerlink" title="故障、错误&amp;失败"></a>故障、错误&amp;失败</h4><ul><li>软件故障(fault)：软件中的一个静态的缺陷。</li><li>软件错误(error)：软件运行中一个不正确的内部状态，这是某个故障的表现。</li><li><p>软件失败(failure)：一个与软件需求或者是预期行为描述不相符的、外在的行为。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CSta</span> <span class="params">(<span class="keyword">int</span> [ ] numbers)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> length = numbers.length; <span class="comment">//(PIE Model - 3: int length = numbers.length-1; )</span></span><br><span class="line">   <span class="keyword">double</span> mean, sum; </span><br><span class="line">   sum = <span class="number">0.0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++)**<span class="comment">//i=0** </span></span><br><span class="line">   &#123;</span><br><span class="line">         sum += numbers [ i ]; </span><br><span class="line">   &#125;</span><br><span class="line">   mean = sum / (<span class="keyword">double</span>) length; </span><br><span class="line">   System.out.println (<span class="string">"mean: "</span> + mean); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>软件错误：Input: [3,4,5]  sum=4+5  ( × )</p></li><li>软件失败：Input: [3,4,5]  sum=4+5 mean=3  ( × )</li></ul><h4 id="PIE模型"><a href="#PIE模型" class="headerlink" title="PIE模型"></a>PIE模型</h4><ul><li>Execution/Reachability 执行/可达性：执行必须通过错误的代码。</li><li>Infection 感染：在执行错误代码的时候必须触发出一个错误的中间状态。</li><li>Propagation 传播：错误的中间状态必须传播到最后输出，使得观测到输出结果与预期结果不一致，即失效。</li></ul><blockquote><ol><li>测试可能无法执行故障的位置。</li><li>一个测试执行到包含错误的代码，不一定会产生错误的中间状态。Test Input: [0,4,5] sum=4+5  mean=3</li><li>产生了错误的中间状态，不一定会失效(failure)。Test Input: [3,5,4] sum=3+5 mean=8/2=4</li></ol></blockquote><p>Q: 是否存在一个fault，任何测试都不会将其测试出来？这样还能称之为fault吗？</p><p>A: 存在这样的fault。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>测试用例(test case)：所有测试用例的基类，它是软件测试中最基本的组成单元。<ul><li>测试输入：测试数据</li><li>测试预期输出(test oracle)：软件中给定输入的预期输出</li><li>其他：环境</li></ul></li><li>测试预言(test oracle)：软件中给定输入的预期输出，测试用例的一部分。自动测试中最难的问题：测试预言的生成。</li><li>测试夹具(test fixture)：一个固定/已知的环境状态以确保测试可重复并且按照预期方式运行</li><li>测试套件(test suite)：一组测试用例。通常这些测试用例具有相似的先决条件和配置，可以按顺序一起运行。用于不同目的的不同测试套件。</li><li>测试脚本(test script)：自动运行一系列测试用例或测试套件的脚本。</li><li>测试驱动程序(test driver)：可以加载测试用例集或测试套件的软件框架，还可以处理预期输出和实际输出之间的配置和比较。</li><li>测试充分性(test adequacy)：用以判断一个软件的一组测试数据的充分性的规则。eg. 语句/分支覆盖率</li><li>Testing vs. Debugging<ul><li>Testing 是通过执行测试和观察失败来发现一个bug。</li><li>Debugging是通过定位、理解和纠正故障( fault)来修复bug。</li></ul></li><li><strong>Verification vs. Validation</strong><ul><li>Verification：确保产品，服务或系统满足客户和其他确定的利益相关者的<strong>需求</strong>。 </li><li>Validation：评估产品，服务或系统是否符合法规、要求、规范或强制条件。 它通常是一个内部过程。</li></ul></li><li><strong>Static Testing vs. Dynamic Testing</strong><ul><li>静态测试：不运行被测程序本身。</li><li>动态测试：运行被测程序。</li></ul></li><li><strong>Black-box Testing vs. White-box Testing</strong><ul><li>黑盒测试：没有源代码。</li><li>白盒测试：有源代码。</li></ul></li><li>V模型：<br><img src="/sftest/vmodel.png" width="50%"></li></ul><h3 id="C2-单元测试"><a href="#C2-单元测试" class="headerlink" title="C2 单元测试"></a>C2 单元测试</h3><ul><li>单元测试：每个模块的测试。</li><li>集成测试：测试模块之间的交互。</li><li>系统测试：开发人员对整个系统进行测试。</li><li>验收测试：根据需求和用户需要来评估软件。没有正式测试用例的客户根据用户要求验证系统。</li></ul><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul><li>测试软件的基本模块：功能，类，组件</li><li>揭示典型问题<ul><li>本地数据结构</li><li>算法</li><li>边界条件</li><li>错误处理</li></ul></li><li>为什么单元测试？<ul><li>分而治之的方法：将系统拆分为单位，单独调试单元。</li><li>缩小可能存在错误的地方，不想追逐其他单元的错误。</li></ul></li><li>如何单元测试？<ul><li>分层构建系统：从不依赖于其他的类开始，继续测试已经测试的类</li><li>好处：避免编写模拟类。当测试一个模块时，它所依赖的模块是可靠的。</li></ul></li><li>单元测试框架<ul><li>xUnit</li><li>JUnit</li></ul></li></ul><h3 id="C3-白盒测试"><a href="#C3-白盒测试" class="headerlink" title="C3 白盒测试"></a>C3 白盒测试</h3><h4 id="1-测试中的图"><a href="#1-测试中的图" class="headerlink" title="1. 测试中的图"></a>1. 测试中的图</h4><ul><li><strong>图G</strong>定义如下：G =（V，E）<ul><li>V：有限的非空顶点集V = {v<sub>1</sub>，v<sub>2</sub>，v<sub>3</sub>，v<sub>4</sub>}</li><li>E：一组边（顶点对）E = {（v<sub>1</sub>，v<sub>2</sub>），（v<sub>1</sub>，v<sub>3</sub>），（v<sub>2</sub>，v<sub>4</sub>），（v<sub>3</sub>，v<sub>4</sub>）}</li><li>V<sub>0</sub>：一组初始节点，V<sub>0</sub> = {v<sub>1</sub>}</li><li>V<sub>f</sub>：一组最终节点，Vf = {v4}</li><li>V<sub>0</sub>和V<sub>f</sub>是V的子集</li><li>图中允许存在多个初始节点，至少要有一个终止节点(或者多个)。</li></ul></li><li>Q：一个顶点是一个图吗？(Yes) E可以是一个无限的集合吗？(No)</li><li><p><strong>路径(Path)</strong>：一个节点序列[v<sub>1</sub>，v<sub>2</sub>，… ，v<sub>n</sub>]</p><ul><li>每对邻近节点(v<sub>i</sub>, v<sub>i+1</sub>)都是一条边(属于边集合E)</li><li>路径的长度：边的数量</li><li>长度为0的路径：单个节点的路径。</li><li>子路径：路径p的子路径是p的一个子序列(也可能是p自己)</li></ul></li><li><p><strong>测试路径</strong>：从初始节点(V<sub>0</sub>中某个节点)开始到最终节点(V<sub>f</sub>中某个节点)结束的路径。</p><ul><li>每个测试用例都只游历图G中的一条测试路径。</li><li>一条测试路径可以对应多个测试用例。(多对一)</li><li>一些测试路径不会被任何测试用例执行。(不可达：图G中的节点从V<sub>0</sub>中任何节点开始都无法在语法上到达，也无法满足覆盖准则)</li></ul></li><li><p><strong>测试和测试路径</strong></p><ul><li><strong>path( t )</strong>：测试 t 执行的测试路径</li><li><strong>path( T )</strong>：由一组测试执行的<strong>测试路径集 T</strong> </li></ul></li></ul><h4 id="2-图覆盖准则"><a href="#2-图覆盖准则" class="headerlink" title="2. 图覆盖准则"></a>2. 图覆盖准则</h4><ul><li><p>可达：从一个初始节点开始所有节点和边都语法可达的图。</p><ul><li>v<sub>1</sub>可达v<sub>2</sub>：存在一条路径开始于v<sub>1</sub>，终止于v<sub>2</sub>。</li><li><p>v<sub>1</sub>可达图G’：存在一条路径开始于v<sub>1</sub>，终止于图G中的某个节点。</p></li><li><p><strong>语法可达</strong>：图G中语法上存在一条路径。</p></li><li><strong>语义可达</strong>：存在测试用例执行该路径。</li></ul></li><li><p><strong>覆盖</strong>：</p><ul><li>测试路径p<strong>覆盖节点</strong>v：v在p中</li><li>测试路径p<strong>覆盖边</strong>e：e在p中</li><li>测试路径p<strong>覆盖子路径</strong>p’：p’在p中</li></ul></li><li><p><strong>图覆盖</strong></p><ul><li>结构图覆盖</li><li>数据流覆盖</li></ul></li><li><p>测试需求集<strong>( TR )</strong>：描述测试路径的属性</p></li><li><p>图覆盖：给定一个<strong>图覆盖准则C</strong>所包含的<strong>测试需求集TR</strong>，当且仅当对于TR中的<strong>每个测试需求tr</strong>，<strong>测试路径集path( T )</strong>中都至少存在一个测试路径p满足tr的时候，测试用例集T满足图G的覆盖准则C。</p></li></ul><h4 id="3-结构化的覆盖准则"><a href="#3-结构化的覆盖准则" class="headerlink" title="3. 结构化的覆盖准则"></a>3. 结构化的覆盖准则</h4><ul><li><p><strong>节点覆盖(VC)</strong></p><ul><li>当且仅当对于 V 中每个语法可达的节点 v，测试用例集T满足path( T )存在路径p使得p覆盖v。即测试用例集T在图G上满足节点覆盖。</li><li>TR包含G中的每个可达的节点。</li></ul></li><li><p><strong>边覆盖(EC)</strong></p></li><li><p>当且仅当对于 E 中的每个语法可达边e，测试用例集T满足path( T )中存在路径p使得p覆盖e。即测试用例集T在图G上满足边覆盖。</p></li><li><p>TR包含G中的每个可达的边。<br><img src="/sftest/vcec.png" width="60%"></p></li><li><p><strong>对边覆盖(EPC)</strong>：TR包含G中每个可达的长度小于等于2的路径。</p></li><li><strong>全路径覆盖(CPC)</strong>：TR中包含G中所有的路径。</li><li><p><strong>n-Path Coverage(nPC)</strong>：TR包含每个可达长度小于等于n的路径。</p></li><li><p><strong>包含(Subsume)关系</strong>：</p><ul><li><p>C1包含C2，表示为C1 ≧  C2</p></li><li><p>对任意测试用例集T，假如T满足C1，则T一定满足C2。</p></li><li>C1≧ C2 does not imply that <em>T1</em> satisfying C1 can detect any fault detected by T2 which satisfies C2.</li><li>C1≧ C2不意味着满足C1的T1可以检测到满足C2的T2检测到的故障。<br><img src="/sftest/sce.png" width="80%"></li></ul></li></ul><h4 id="4-控制流图-CFG-及其覆盖"><a href="#4-控制流图-CFG-及其覆盖" class="headerlink" title="4. 控制流图(CFG)及其覆盖"></a>4. 控制流图(CFG)及其覆盖</h4><ul><li><p>控制流图(CFG)</p><ul><li>使用图表符号表示<strong>在执行期间可能遍历程序的所有路径</strong>的表示。</li><li>边与每条可能的分支对应，节点与一系列的语句对应。</li></ul></li><li><p>基本块</p><ul><li>一段最长的可以被同时执行的程序语句序列。如果这个基本块中的一条语句被执行，那么这个块中所有语句都要被执行。</li><li>一个基本块只有一个起始点和一个终点。<br><img src="/sftest/if.png" width="40%"><img src="/sftest/ifreturn.png" width="36%"><img src="/sftest/while.png" width="40%"><img src="/sftest/do.png" width="36%"><img src="/sftest/for.png" width="45%"><img src="/sftest/switch.png" width="45%"><img src="/sftest/bc.png" width="45%"><img src="/sftest/cfg.png" width="80%"></li></ul></li><li><p>语句覆盖率：SCov = 4 / 5 = 80%</p></li><li>分支覆盖率：BCov = 2 / 4 = 50%</li><li>路径覆盖率：PCov = 1 / 4 = 25%</li></ul><p><img src="/sftest/scov.png" width="21%"><img src="/sftest/bcov.png" width="22%"><img src="/sftest/pcov.png" width="49%"></p><ul><li>如果测试套件达到100%分支覆盖率，则一定达到100%语句覆盖率。</li><li><p>如果测试套件达到100%路径覆盖率，则一定达到100%分支覆盖率。反之未必。</p></li><li><p>路径覆盖 -&gt; 分支覆盖 -&gt; 语句覆盖  (路径覆盖严格包含分支覆盖，分支覆盖严格包含语句覆盖) </p><ul><li>路径覆盖：被测试程序中的每一个语句至少被执行一次。<strong>实际运用中语句覆盖很难发现代码中的问题。</strong></li><li>分支覆盖：被测试程序中的每一个分支都至少执行一次。</li><li>语句覆盖：覆盖程序中所有可能的执行路径。</li></ul></li><li><p>基于CFG的覆盖</p><ul><li><p><strong>有效性：</strong>大约65％的错误可以在单元测试中捕获，单元测试由控制流测试方法主导，语句和分支测试在控制流测试中占主导地位。</p></li><li><p><strong>局限性：</strong>某些方面的100％覆盖率不能保证软件没有错误。</p></li><li><p>Test: assertEquals(1, sum(1,0))</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; </span><br><span class="line"><span class="keyword">return</span> x-y; <span class="comment">//should be x+y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="5-主路径覆盖-Prime-Path-Coverage-PPC"><a href="#5-主路径覆盖-Prime-Path-Coverage-PPC" class="headerlink" title="5. 主路径覆盖(Prime Path Coverage, PPC)"></a>5. 主路径覆盖(Prime Path Coverage, PPC)</h4><ul><li>简单路径<ul><li>从n<sub>i</sub>到n<sub>j</sub>的路径，当且仅当在这条路径中没有任何节点出现超过一次(除了初始节点和终止节点相同的情况)</li><li>简单路径可以是一个自环，但它没有内在的循环。<br><img src="/sftest/简单路径.png" width="55%"><img src="/sftest/主路径.png" width="40%"></li></ul></li><li>主路径：<ul><li>一条简单路径，且它不是任何其他简单路径的子路径。</li><li>最大长度的简单路径。</li></ul></li><li>往返路径：长度非0且初始节点和终止节点相同的主路径。</li><li><strong>主路径覆盖(PPC)</strong><ul><li>TR包含G中每条主路径。</li></ul></li><li><strong>简单往返路径(SRTC)</strong><ul><li>对于G中所有可达的，且可以作为往返路径起点和终点的节点，TR包含至少一条往返路径。</li></ul></li><li><p><strong>完全往返路径(CRTC)</strong></p><ul><li>对于G中所有可达的节点，TR包含所有的往返路径。<br><img src="/sftest/PPC.png" width="54%"></li></ul></li><li><p>主路径覆盖练习：<br><img src="/sftest/主路径覆盖.png" width="54%"></p></li></ul><h4 id="6-基本路径覆盖"><a href="#6-基本路径覆盖" class="headerlink" title="6. 基本路径覆盖"></a>6. 基本路径覆盖</h4><ul><li>独立路径：一条独立路径是指和其他的独立路径相比，至少引入一个新处理语句或一个新判断的程序通路。</li><li><strong>圈复杂度(Cyclomatic Complexity, CC)</strong>：<ul><li>一种为程序逻辑复杂性提供定量测度的软件度量，将该度量用于计算程序的基本的独立路径数目，为确保所有语句至少执行一次的测试数量的上界。</li><li>独立路径必须包含一条在定义之前不曾用到的边。</li><li>计算方法：<strong>CC =  E - V + 2  =  P + 1</strong>，E是边数量，V是节点的数量；P是<strong>判定结点</strong>的数量。</li></ul></li><li><strong>基本路径测试步骤</strong>：<ul><li>生成控制流图</li><li>计算圈复杂度</li><li>选择一组基本路径</li><li>生成基本路径的测试用例</li></ul></li><li>全路径测试 ≥ 基本路径测试 ≥ 分支测试</li></ul><h4 id="7-数据流覆盖"><a href="#7-数据流覆盖" class="headerlink" title="7. 数据流覆盖"></a>7. 数据流覆盖</h4><ul><li><strong>定义(def)</strong>：当一个变量的值被存储于内存时变量所处的位置。(写)</li><li><strong>使用(use)</strong>：当获取一个变量的值时变量所处的位置。(读)</li><li><p>数据流测试准则依据：数据值由定义转向使用。这种转移成为<strong>定义使用对/定义-使用/定义使用关联</strong>。<br><img src="/sftest/defuse.png" width="54%"></p></li><li><p><strong>定义使用对(DU Pair)</strong>：(l <sub>i</sub>,  l<sub>j</sub>) ，变量v在l <sub>i</sub>处定义，并在l <sub>j</sub>处使用。</p></li><li><strong>def(n) def(e)  / use(n) use(e)</strong><ul><li>由<strong>节点n</strong>或边e<strong>定义</strong>的变量集</li><li>由<strong>节点n</strong>或边e<strong>使用</strong>的变量集</li></ul></li><li><strong>无重复定义(Def-clear)</strong><ul><li>存在一条由l <sub>i</sub>到l <sub>j</sub>的路径，对于这条路径上的每个节点n<sub>k</sub>和每条边e<sub>k</sub>，k≠i 且 k≠j，变量v不属于def(n<sub>k</sub>)和def(e<sub>k</sub>)，那么这条路径对于变量v是无重复定义的。</li><li>如果变量v存在一条由l <sub>i</sub>到l <sub>j</sub>的无重复定义的路径，我们说处于l<sub>i</sub>的定义到达处于l<sub>j</sub>的使用。</li></ul></li><li><strong>定义使用路径(du-path)</strong><ul><li>定义使用路径是一条简单路径，并且对于变量v这是一条由节点n<sub>i</sub>到另一个节点n<sub>j</sub>的无重复定义路径，v在n<sub>i</sub>中存在于def(n<sub>i</sub>)而在n<sub>j</sub>中存在于use(n<sub>j</sub>)</li><li><em>du</em> (<em>n<sub>i</sub></em>, <em>n<sub>j</sub></em>, <em>v</em>)：变量v的定义使用路径集合，起始于n<sub>i</sub>，终止于n<sub>j</sub>。</li><li><em>du</em> (<em>n<sub>i</sub></em>, <em>v</em>)：对于变量v，定义路径集合是起始于n<sub>i</sub>的定义使用路径的集合。</li></ul></li><li><p><strong>全定义覆盖(ADC)</strong></p><ul><li>对于每个<strong>定义路径</strong>集合<em>S</em> = <em>du</em> (<em>n<sub>i</sub></em>, <em>v</em>)，TR包含S中至少一条路径d。</li></ul></li><li><p><strong>全使用覆盖(AUC)</strong></p><ul><li>对于每个<strong>定义对</strong>集合<em>S</em> = <em>du</em> (<em>n<sub>i</sub></em>, <em>n<sub>j</sub></em>, <em>v</em>)，TR包含S中至少一条路径d。</li></ul></li><li><p><strong>全定义使用路径覆盖(ADUPC)</strong></p><ul><li>对于每个<strong>定义对</strong>集合<em>S</em> = <em>du</em> (<em>n<sub>i</sub></em>, <em>n<sub>j</sub></em>, <em>v</em>)，TR包含S中每一条路径d。<br><img src="/sftest/dutest.png" width="54%"></li></ul></li><li><p>图覆盖准则之间的包含关系<br><img src="/sftest/包含关系.png" width="34%"></p></li></ul><h4 id="8-事件流覆盖"><a href="#8-事件流覆盖" class="headerlink" title="8. 事件流覆盖"></a>8. 事件流覆盖</h4><ul><li><strong>事件流图(EFG)</strong>是一个三元组M = &lt;V, I, E&gt;：<ul><li>V是一组表示对象所有事件的顶点。</li><li>I ⊆ V是一组初始顶点。</li><li>E ⊆ V × V是顶点之间的一组边，当v<sub>j</sub>可以在v<sub>i</sub>之后立即执行，(v<sub>i</sub>, v<sub>j</sub>) ∈ E。</li></ul></li></ul><p><img src="/sftest/event1.png" width="40%"><img src="/sftest/event2.png" width="40%"></p><p>#####9. 变异测试</p><ul><li>变异测试<ul><li>将错误插入程序以测试测试用例是否接收它们的方法。</li><li>是一种对测试集的充分性进行评估的技术。</li></ul></li><li>操作数变异操作符：将单个操作数替换为另一个操作数或常量。</li><li>表达变异操作符：更换一个操作符或者插入一个新的操作符。</li><li><strong>等价变异体</strong><ul><li>存在没有被杀死的变异体，被称为等价变异体</li><li>虽然变异体语法不同，但通过测试难以发现，需要手动检查。</li></ul></li><li><strong><em>Mutation Score = 100 \</em> K / (T - E)*</strong><ul><li>K：被杀死的变异体数</li><li>T：变异体总数</li><li>E：等价的变异体数</li></ul></li><li><p>主管程序员假设</p><ul><li>被测模块由合格的程序员或设计师编写。 因此，如果模块不正确，则它与正确的模块不同，最多只有几个小故障。</li></ul></li><li><p>耦合效应</p><ul><li>由于仅通过简单故障将所有模块与正确模块区分开来的测试套件非常敏感，它还可以隐式区分更复杂的故障。</li></ul></li></ul><p>#####10. 逻辑覆盖</p><ul><li><strong>语句覆盖(SC)</strong></li><li><strong>判定覆盖(DC)</strong><ul><li>判定的true和false至少各执行一次。</li><li>((x&gt;5) &amp;&amp; (y&gt;0)): <em>true</em> and <em>false</em></li></ul></li><li><strong>条件覆盖(CC)</strong><ul><li>每个条件的true和false至少各被执行一次。</li><li>(x&gt;5) 􏰄 <em>true</em> and <em>false</em></li><li>(y&gt;0) 􏰄<em>true</em> and <em>false</em></li></ul></li><li><strong>条件判定覆盖(C/DC)</strong><ul><li>同时满足DC和CC.</li><li>使得判定中的每个条件取到各种可能的值，并使每个判定取到各种可能的结果。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;(6, 1), (1,1)&#125;--DC</span></span><br><span class="line"><span class="comment">// &#123;(6, 0), (0,1)&#125;--CC </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> z = y;</span><br><span class="line"><span class="keyword">if</span> ((x&gt;<span class="number">5</span>) &amp;&amp; (y&gt;<span class="number">0</span>)) &#123;</span><br><span class="line">z = x; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> x*z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SC&amp;DC&amp;CC的包含关系<ul><li>DC ≥ SC</li><li>CC not ≥ SC</li><li>DC not ≥ CC􏰂 CC not ≥ DC</li><li>C/DC ≥ CC </li><li>C/DC ≥ DC</li></ul></li><li><p>MC/DC ≥ C/DC</p></li><li><p><strong>多条件覆盖(MCC)</strong></p><ul><li>使得每个判定中条件的各种可能组合都至少出现一次。<br><img src="/sftest/MCC.png" width="30%"></li></ul></li><li><p><strong>修正条件判定覆盖(MCDC)</strong></p><ul><li>每个条件都要独立影响判定结果(true和false各一次)<br><img src="/sftest/MCDC.png" width="30%"></li></ul></li><li><p>计数</p><ul><li>DC——2</li><li>CC——2*n</li><li>MC/DC——2*n+1</li><li>MCC——2<sup>n</sup></li></ul></li></ul><h3 id="C4-自动化软件测试"><a href="#C4-自动化软件测试" class="headerlink" title="C4 自动化软件测试"></a>C4 自动化软件测试</h3><ul><li>自动化测试<strong>生成</strong><ul><li>测试用例生成</li><li>测试数据生成</li></ul></li><li>自动化测试<strong>执行</strong></li><li>自动化测试<strong>选择</strong><ul><li>针对修改部分的测试</li><li>针对测试需求的用例集约简</li><li>针对测试需求的用例排序</li></ul></li><li>自动化测试修复<ul><li>测试用例修复</li><li>测试用例演化</li></ul></li><li>自动化测试<strong>扩增</strong></li></ul><h3 id="C5-黑盒测试"><a href="#C5-黑盒测试" class="headerlink" title="C5 黑盒测试"></a>C5 黑盒测试</h3><h4 id="5-1-随机测试"><a href="#5-1-随机测试" class="headerlink" title="5.1 随机测试"></a>5.1 随机测试</h4><ul><li>随机测试<ul><li>测试用例完全随机生成</li><li>必须知道输入域</li><li>在输入域中选择随机点</li><li>自动化</li></ul></li><li>ART算法</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* T = &#123;&#125;  是以前执行的一组测试用例*/</span></span><br><span class="line">随机生成输入t </span><br><span class="line">用t作为测试用例测试程序          </span><br><span class="line">将t添加到T     </span><br><span class="line"><span class="keyword">while</span>（未达到停止条件）           </span><br><span class="line">   随机生成下一个k候选c1，c2，…，ck    </span><br><span class="line">   <span class="keyword">for</span> 每个候选Ci </span><br><span class="line">      计算与T的最小距离di  </span><br><span class="line">   end <span class="keyword">for</span></span><br><span class="line">  选择一个具有最小距离的候选t</span><br><span class="line">  将t添加到T           </span><br><span class="line">  用T作为测试用例测试程序    </span><br><span class="line">end <span class="keyword">while</span></span><br></pre></td></tr></table></figure><h4 id="5-2-等价划分"><a href="#5-2-等价划分" class="headerlink" title="5.2 等价划分"></a>5.2 等价划分</h4><ul><li>等价划分<ul><li>可以同等地应用于多个级别的测试(• 单元  • 整合  • 系统)</li><li>相对容易应用，无需自动化</li><li>易于调整程序以获得更多或更少的测试</li></ul></li><li>输入域<ul><li>程序的输入域包含该程序的所有可能输入</li><li>对于即使是小型程序，输入域也是如此之大，以至于它可能是无限的</li><li>测试一般是从输入域中选择有限的值集</li><li>输入参数定义输入域的范围</li><li>每个输入参数的域被划分为区域</li><li>从每个区域至少选择一个值</li></ul></li><li><p>分区域</p><ul><li>域D</li><li>D的分区方案p</li><li>分区p定义了一组块b<sub>1</sub>，b<sub>2</sub>，… b<sub>n</sub></li><li>分区必须满足两个属性：<strong>1.块必须两两之间不相交（不重叠）2.所有块共同覆盖域D（完整）</strong></li></ul></li><li><p>两种方法</p><ul><li>基于接口的方法：直接根据各个输入参数开发特性，简单应用，在某些情况下可以部分自动化。</li><li>基于功能的方法：从被测程序的行为角度发展特征，更难开发，需要更多的设计工作，可以带来更好的测试，或者更少的测试。</li></ul></li><li><p>基于接口的方法：</p><ul><li>三角形有三个输入：q1=第一个边的输入与0的关系：大于，等于，小于</li></ul></li><li>基于功能的方法：<ul><li>三角形的类型：q1 =“几何分类”  b1=不等边  b2=等腰<strong>但不等边</strong>三角形  b3=正三角形  b4=无效</li><li>几何分区q1的可能值：b1= (4, 5, 6)，b2 = (3, 3, 4) ， b3 = (3, 3, 3)， b4 = (3, 4, 8)</li></ul></li></ul><h4 id="5-3-边界值分析"><a href="#5-3-边界值分析" class="headerlink" title="5.3 边界值分析"></a>5.3 边界值分析</h4><ul><li>示例：<ul><li>两个输入变量x1（a≤x1≤b）和x2（c≤x2≤d）。 测试用例包括：</li><li>&lt;x1nom，x2min&gt;，&lt;x1nom，x2min +&gt;，&lt;x1nom，x2nom&gt;，&lt;x1nom，x2max&gt;，&lt;x1nom，x2max-&gt;，&lt;x1min，x2nom&gt;，<x1min +，x2nom="">，&lt;x1max，x2nom&gt;，&lt;x1max-，x2nom&gt;</x1min></li><li>nomal，min，max</li></ul></li><li>弱边界值分析<ul><li>Min-  Min  Min+</li><li>Nom </li><li>Max-  Max  Max+ </li></ul></li></ul><p><img src="/sftest/弱边界1.png" width="40%"><img src="/sftest/弱边界2.png" width="30%"><img src="/sftest/边界.png" width="30%"></p><ul><li><p>强边界分析</p><p><img src="/sftest/强边界1.png" width="30%"><img src="/sftest/强边界2.png" width="35%"></p></li></ul><p><img src="/sftest/强边界3.png" width="35%"><img src="/sftest/强边界4.png" width="35%"></p><h4 id="5-4-组合测试"><a href="#5-4-组合测试" class="headerlink" title="5.4 组合测试"></a>5.4 组合测试</h4><ul><li>弱等价类测试</li><li>强等价类测试</li></ul><h4 id="5-5-测试中的约束"><a href="#5-5-测试中的约束" class="headerlink" title="5.5 测试中的约束"></a>5.5 测试中的约束</h4><ul><li>合并输入变量</li><li>优化输入域</li><li>修改测试用例</li></ul><h4 id="5-6-决策表"><a href="#5-6-决策表" class="headerlink" title="5.6 决策表"></a>5.6 决策表</h4><ul><li>决策表的优点<ul><li>能够将复杂的问题按照各种可能的情况全部列举出来，简明并避免遗漏。</li><li>利用决策表能够设计出完整的测试用例集合。 </li></ul></li><li>决策表通常由以下4部分组成:<ul><li>条件桩：列出问题的所有条件</li><li>条件项：针对条件桩中条件列出所有可能的取值</li><li>动作桩：列出问题规定的可能采取的操作</li><li>动作项：指出条件项各取值情况下应采取的动作</li></ul></li><li>构造决策表的5个步骤: <ol><li>确定规则的个数 ：有n个条件的决策表有2n个规则(每个条件取真、假值) </li><li>列出所有的条件桩和动作桩 </li><li>填入条件项 </li><li>填入动作项，得到初始决策表 </li><li>简化决策表，合并相似规则 </li></ol></li><li>练习：<ul><li>前一日函数DPreate是NextDate的逆函数，即给定一个月份、日期、年，会返回前一天的日期。</li><li>年的取值在1812年到2017年</li><li>日的取值在1日到31日之间</li><li>月的取值在1到12月之间</li><li>条件项(等价类划分)：<br><img src="/sftest/条件项.png" width="40%"></li></ul></li></ul><h3 id="C7-功能、性能、移动应用测试"><a href="#C7-功能、性能、移动应用测试" class="headerlink" title="C7 功能、性能、移动应用测试"></a>C7 功能、性能、移动应用测试</h3><ul><li>功能测试<ul><li>根据产品特性和设计需求，验证一个产品的特性和行为是否满足设计需求。</li><li>正确性、可靠性、易用性。</li></ul></li><li>性能测试<ul><li>验证产品的性能在特定负载和环境条件下使用是否满足性能指标。</li><li>度量方法：响应时间、并发用户数、吞吐量、性能计数器、负载测试、压力测试</li></ul></li><li><p>移动应用测试</p><ul><li>手机系统、型号</li><li>传感器与屏幕(尺寸？)碎片化</li></ul></li><li><p>软件缺陷的􏰀描述</p><ul><li>软件缺陷的生命周期</li><li>严重性和优先级</li><li>缺陷的其它属性</li><li>完整的缺陷信息</li><li>缺陷描述的基本要求</li><li>缺陷报告的示例</li></ul></li><li><p>软件缺陷的生命周期</p><ul><li>一个软件缺陷被发现、报告到 这个缺陷被修复、验证直至最后关闭的完整过程。</li></ul></li><li><p>基本的缺陷生命周期</p><ul><li>发现-打开:测试人员找到软件缺陷并将软件缺陷􏰁交给开发人员。 </li><li>打开-修复:开发人员再现、修复缺陷，然后提交给测试人员去验证。 </li><li>修复-关闭:测试人员验证修复过的软件，关闭已不存在的缺陷。 </li></ul></li><li><p>严重性(severity)：衡量缺陷对客户满意度的影响程度</p><ul><li>致命的(fatal)、严重的(critical)、一般的(major)、微小的(minor)</li></ul></li><li><p>优先级(Priority)：指缺陷被修复的紧急程度。</p></li><li><p><strong>缺陷􏰀述的基本要求</strong></p><ul><li>单一准确</li><li>可以再现</li><li>完整统一</li><li>短小简练</li><li>特定条件</li><li>补充完善</li><li>不做评价 </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-软件测试概述&quot;&gt;&lt;a href=&quot;#1-软件测试概述&quot; class=&quot;headerlink&quot; title=&quot;1 软件测试概述&quot;&gt;&lt;/a&gt;1 软件测试概述&lt;/h3&gt;&lt;h4 id=&quot;故障、错误-amp-失败&quot;&gt;&lt;a href=&quot;#故障、错误-amp-失败&quot; class=&quot;headerlink&quot; title=&quot;故障、错误&amp;amp;失败&quot;&gt;&lt;/a&gt;故障、错误&amp;amp;失败&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;软件故障(fault)：软件中的一个静态的缺陷。&lt;/li&gt;
&lt;li&gt;软件错误(error)：软件运行中一个不正确的内部状态，这是某个故障的表现。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;软件失败(failure)：一个与软件需求或者是预期行为描述不相符的、外在的行为。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="软件工程" scheme="https://daisine.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="note" scheme="https://daisine.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>软件项目管理</title>
    <link href="https://daisine.github.io/manage/"/>
    <id>https://daisine.github.io/manage/</id>
    <published>2019-04-21T04:50:56.000Z</published>
    <updated>2019-05-10T11:01:57.293Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C1-软件项目管理概述"><a href="#C1-软件项目管理概述" class="headerlink" title="C1 软件项目管理概述"></a>C1 软件项目管理概述</h3><ul><li><strong>项目管理</strong>是指一定的主体为了实现其目标，利用各种有效的手段，对执行中的项目周期的个阶段工作进行计划、组织、协调、指挥、控制，以取得良好经济效益的各项活动的总和。<a id="more"></a></li><li><strong>软件项目管理</strong>是为了使软件项目能够按照预定的成本，进度，质量顺利完成，而对成本，人员，进度，质量，风险等进行分析和管理的活动。</li><li>日常运作：连续不断、周而复始的活动，通过效率和有效性体现。</li><li>项目：临时性、一次性的活动，以目标为导向。<ul><li><strong>特性</strong>：目标性、相关性、临时性、独特性、资源约束性、不确定性</li></ul></li><li>项目目标实现的制约因素：项目范围、成本、进度计划和客户满意度。</li><li>项目管理包括<strong>启动</strong>过程组、<strong>计划</strong>过程组、<strong>执行</strong>过程组、<strong>控制</strong>过程组、<strong>收尾</strong>过程组等5个过程组。</li><li>项目管理知识体系(PMBOK)10个知识领域：<ul><li>项目<strong>整体</strong>管理，项目<strong>范围</strong>管理，项目<strong>时间</strong>管理，项目<strong>成本</strong>管理，项目<strong>质量</strong>管理，项目<strong>人力资源</strong>管理，项目<strong>沟通</strong>管理，项目<strong>风险</strong>管理，项目<strong>采购</strong>管理，项目<strong>干系人</strong>管理。</li></ul></li></ul><h3 id="C2-项目确立"><a href="#C2-项目确立" class="headerlink" title="C2 项目确立"></a>C2 项目确立</h3><ul><li><p>自造-购买决策</p><ul><li>在立项阶段，产品负责人进行自造-购买决策，确定待开发的产品的哪些部分应当采购、外包开发或者自主研发。除了需要考虑自造或者购买的成本，还需要考虑后续的大量费用（维护费、保险费..）。</li></ul></li><li><p>项目经理的职责：①开发计划   ②组织实施   ③项目控制</p></li><li>在招投标阶段，甲方过程包括招标书定义、供方选择、合同签署，乙方过程包括项目分析、竞标、合同签署。</li></ul><h3 id="C3-生存期模型"><a href="#C3-生存期模型" class="headerlink" title="C3 生存期模型"></a>C3 生存期模型</h3><ul><li>瀑布模型：适用于软件需求很明确的项目。要求项目所有的活动都严格按照顺序进行，一个阶段的输入是下一个阶段的输入。</li><li>V模型：瀑布模型的一个变种。</li><li><strong>快速原型模型</strong>：从核心方面开始设计和实施最初原型，根据用户反馈改进原型直到被接受。</li><li><strong>增量式模型</strong>：首先构造系统的核心功能，然后逐步增加功能和完善性能。</li><li><strong>渐进式阶段模型</strong>(<strong>迭代</strong>)：适用于中型或者大型项目，将大项目分成几个小项目来做。</li></ul><h3 id="C4软件项目范围计划-需求管理"><a href="#C4软件项目范围计划-需求管理" class="headerlink" title="C4软件项目范围计划 - 需求管理"></a>C4软件项目范围计划 - 需求管理</h3><ul><li><p>需求管理包括<strong>需求获取</strong>、<strong>需求分析/建模</strong>、<strong>需求规格编写</strong>、<strong>需求验证</strong>、<strong>需求变更</strong> 5个过程。</p><ul><li>需求获取：软件需求具有模糊性、不确定性、变化性和主观性的特点。</li><li>需求分析(/建模)：任务是借助于当前系统的逻辑模型导出目标系统的逻辑模型。</li><li>需求规格编写：完成的标志是提交一份完整的<strong>软件需求规格说明书(SRS)</strong>。</li><li>需求验证：验证需求的正确性、一致性、完整性、可行性、必要性、可验证性、可跟踪性和最后的签字。</li><li>需求变更：需求变更的主要工作如下<ul><li>建立需求基线</li><li>确定需求变更控制过程</li><li>建立<strong>变更控制委员会(SCCB)</strong></li><li>进行需求变更影响分析</li><li>跟踪所有受需求变更影响的工作产品</li><li>建立需求基准版本和需求控制版本文档</li><li>跟踪每项需求的状态</li></ul></li></ul></li><li><p>需求分析方法：<strong>①结构化分析方法  ②面向对象的用例分析方法   ③功能列表方法</strong></p><ul><li>结构化分析方法：数据流图、数据字典、实体联系图</li><li>面向对象的用例分析方法：用例视图、顺序视图、活动视图etc</li><li>功能列表方法：对项目的功能需求进行详细说明，基于功能特性及层次关系来描述需求的方法</li></ul></li></ul><h3 id="C5-软件项目范围计划-任务分解"><a href="#C5-软件项目范围计划-任务分解" class="headerlink" title="C5 软件项目范围计划 - 任务分解"></a>C5 软件项目范围计划 - 任务分解</h3><ul><li>任务分解的过程：<ul><li>将一个项目分解为更多的工作细目或者子项目， 使项目变得更小、更易管理、更易操作。 </li></ul></li><li><p>任务分解的结果：<strong>WBS(任务分解结构)</strong>。其中，工作包是WBS的最低层次的可交付成果。</p><ul><li>工作包应当由唯一主体负责，另外一位项目经理进行计划和执行，或者通过子项目的方式完成。</li><li>工作包可进一步分解为子项目的WBS或各个活动。</li></ul></li><li><p>任务分解步骤：</p><ol><li>确认并分解项目的组成要素 </li><li>确定分解标准</li><li>确定分解是否详细</li><li>确定项目交付成果 </li><li>验证分解的正确性(建立编号) </li></ol></li><li>WBS类型 <strong>分级的树形结构</strong><ul><li>清单形式</li><li>图表形式</li></ul></li><li><p>任务分解方法：</p><ul><li>模版参照方法</li><li>类比方法：许多项目有相同或者相似的周期。</li><li>自顶向下方法：从项目的大局着手，逐步分解子细目。</li><li>自底向上方法：首先定义项目的一些特定任务，然后将这些任务组织起来。</li></ul></li><li><p>检验分解结果的标准：</p><ul><li>最底层的要素是否是实现目标的充分必要条件</li><li>最底层要素是否有重复的</li><li>每个要素是否清晰完整定义</li><li>最底层要素是否有定义清晰的责任人,是否可以进行成本估算和进度安排 </li></ul></li><li><p>WBS的应用</p><ul><li>OBS(组织分解结构)</li><li>CBS(成本分解结构) </li><li>RBS(风险分解结构) </li><li>OBS(责任矩阵)</li><li>CBS(费用分解矩阵) </li><li>RBS(风险矩阵) </li></ul></li></ul><h3 id="C6-软件项目成本计划"><a href="#C6-软件项目成本计划" class="headerlink" title="C6 软件项目成本计划"></a>C6 软件项目成本计划</h3><ul><li><p>成本管理过程：</p><ul><li>资源计划编制：确定项目需要的资源种类和数量。</li><li>成本估算(中心环节)：编制一个为完成项目各活动所需要的资源成本的近似估算。</li><li>成本预算(项目进度)：将总成本估算分配到各单项工作活动上。</li><li>成本控制(项目跟踪)：控制项目预算的变更。</li></ul></li><li><p><strong>估算</strong>不是很准确的，有误差的。经验(历史)数据非常重要，不要太迷信数学模型。</p></li><li>项目规模的单位：<ul><li>􏰀LOC(Loc of Code)源代码程序长度的测量 </li><li>FP(Function Point)用系统的功能数量来测量 </li><li>人月 􏰀人天 􏰀人年</li></ul></li><li>成本的单位：<ul><li>货币单位：人命币，美元。</li></ul></li><li><strong>软件项目成本</strong>：项目规模是成本的主要因素<ul><li>完成软件规模相应付出的代价。</li><li>待开发的软件项目需要的资金。</li><li>人的劳动的消耗所需要的代价是软件产品的主要成本。</li></ul></li><li>成本估算过程：<ul><li>估算输入：<ul><li>项目需求、 WBS</li><li>历史项目度量</li><li>资源要求(资源编制计划)</li><li>资源消耗率:如人员成本: 100元/小时</li><li>进度规划:项目总进度(一般是合同要求)</li><li>学习曲线</li></ul></li><li>估算处理：<ul><li>直接成本：与具体项目相关的成本。</li><li>间接成本：不能归属于一个具体的项目，是企业的运营成本。</li></ul></li><li>估算输出<ul><li>估算文件：资源、资源的数量、质量标准、估算成本等信息，一般是货币单位。</li><li>估算说明：工作范围、估算的基础和依据、估算的假设、估算的误差变动等。</li></ul></li></ul></li></ul><h4 id="成本估算方法："><a href="#成本估算方法：" class="headerlink" title="成本估算方法："></a>成本估算方法：</h4><ul><li><p>估算的基本方法</p><ul><li>代码行、功能点、对象点、用例点估算法</li><li>类比 (自顶向下)估算法 </li><li>自下而上估算法 </li><li>参数法估算法 </li><li>专家估算法</li></ul></li><li><p><strong>代码行估算法</strong>：从软件程序量的角度定义项目规模。</p><ul><li>要求功能分解足够详细的，有一定的经验数据(类比和经验方法)，<strong>与具体的编程语言有关</strong>。</li><li>缺点：<ul><li>对代码行没有公认的可接受的标准定义，代码行数量依赖于所用的编程语言和个人的编程风格。</li><li>在项目早期,需求不稳定、设计不成熟、实现不确定的情况下很难准确地估算代码量。 </li><li>代码行强调编码的工作量，只是项目实现阶段 的一部分。</li></ul></li></ul></li><li><p><strong>功能点估算法</strong>：用系统的功能数量来测量其规模。</p><ul><li>与实现产品所使用的语言和技术没有关系。</li><li><strong>功能点计算公式</strong>：􏰀FP = UFC * TCF<ul><li>UFC: 未调整功能点计数</li><li>TCF: 技术复杂度因子(调整系数) P105</li></ul></li><li><strong>功能计数项</strong>：外部输入，外部输出，外部查询，外部文件，内部文件。</li></ul></li><li><p>类比 (自顶向下)估算法 </p><ul><li>根据以往的完成类似项目所消耗的总成本(或工作量)，来推算将要开发的软件的总成本(或工作量)，然后按比例将它分配到各个开发任务单元中。</li><li>使用情况<ul><li>有类似的历史项目数据</li><li>信息不足(要求不是非常精确)</li><li>在合同期和市场招标时</li></ul></li><li>特点：简单易行，花费少。有一定的局限性，准确性差,可能导致项目出现困难</li></ul></li><li><p>自下而上估算法：</p><ul><li>利用任务分解结构图，对各个具体工作包进行详细的成本估算，然后将结果累加起来得出项目总成本。</li><li>使用情况<ul><li>项目开始以后，WBS的开发阶段 </li><li>需要进行准确估算的时候</li></ul></li><li>特点：相对较准确，费时，可能发生虚报现象。</li></ul></li><li><p>参数法估算法：</p><ul><li>一种使用项目特性参数建立数据模型来估算成本的方法，是一种统计技术，如回归分析和学习曲线。<strong>一个模型不能适合所有情况。</strong><ul><li>静态单变量模型：面向LOC的估算模型，面向FP的估算模型</li><li>动态多变量模型：把工作量看作软件规模和开发时间这两个变量的函数。</li></ul></li><li>理论导出：不成熟阶段。 经验导出：软件估算常常采用。</li><li>使用情况<ul><li>存在成熟的项目估算模型 </li><li>应该具有良好的数据库数据为基础 </li></ul></li><li>特点：比较简单，准确。如果模型选择不当或者数据不准，也会导致偏差。</li><li>COCOMO模型：<ul><li>COCOMO 81 <strong>3个等级的模型</strong>：基本，中等，高级。</li><li>COCOMO 81模型将<strong>项目的模式</strong>分为有机型、嵌入型和半嵌入型。</li></ul></li></ul></li><li><p>专家估算法：</p><ul><li>由多位专家进行成本估算，一个专家可能会有偏见，最好由多位专家进行估算，取得多个估算值,最后得出综合的估算值。</li><li>组织者发给每位专家一份软件系统的规格说明 和一张记录估算值的表格，请他们估算 专家详细研究软件规格说明后，对该软件提出3 个规模的估算值：<ul><li>最小 ai</li><li>最可能的mi</li><li>最大bi</li></ul></li><li>计算每位专家的 E<sub>i</sub> = ( ai + 4mi + bi ) / 6</li><li>综合结果后，计算期望值: E<sub>i</sub> = E<sub>1</sub> + E<sub>2</sub> + … E<sub>n</sub> / n </li></ul></li></ul><h4 id="估算方法总结"><a href="#估算方法总结" class="headerlink" title="估算方法总结"></a>估算方法总结</h4><ul><li>􏰀初期：类比 专家估算 </li><li>计划阶段 ：自下而上 􏰀 参数模型 </li><li>实施阶段(包括变更发生)： 􏰀 自下而上 􏰀 参数模型 </li></ul><blockquote><p>主要考虑三种模型：类比法，自下而上法，参数法。自下而上法费时费力，参数法比较简单。自下向上法与参数法的估计精度相似。类比法通常用来验证参数法和自下而上法的结果。</p><p>各种方法不是孤立的，应该注意相互的结合使用</p></blockquote><h4 id="成本预算"><a href="#成本预算" class="headerlink" title="成本预算"></a>成本预算</h4><ul><li>成本预算是将项目的总成本按照项目的度分摊到各个工作单元中去。</li><li>成本预算将总的成本安排到各个任务中。</li><li>􏰁 成本预算的目的是产生成本基线 </li><li>分配项目成本预算主要包括3种情况：<ul><li>分配资源成本</li><li>分配固定资源成本</li><li>分配固定成本</li></ul></li></ul><h3 id="C7-项目进度计划"><a href="#C7-项目进度计划" class="headerlink" title="C7 项目进度计划"></a>C7 项目进度计划</h3><ul><li>任务之间的4种关系：<ul><li>结束 -&gt;  开始</li><li>结束 -&gt; 结束</li><li>开始 -&gt; 开始</li><li>开始 -&gt; 结束</li></ul></li><li><p>任务间关系的依据：</p><ul><li>强制性依赖关系：固有，不可违背的逻辑关系</li><li>软逻辑关系：人为，主观，由项目管理人员确定的项目活动之间的关系</li><li>外部依赖关系：项目活动与非项目活动之间的依赖关系。如环境测试依赖于外部提供的环境设备等。</li></ul></li><li><p>进度管理图示：</p><ul><li><strong>网络图</strong>：活动排序的一个输出，展示项目中的各个活动以及活动之间的逻辑关系，可以表达活动的历时。<ul><li>PDM：优先图法 ,节点法 (单代号)网络图。节点表示活动，箭线表示各活动之间的逻辑关系。</li><li>ADM：箭线法 (双代号)网络图。箭线表示活动，结点表示前一个任务的结束，也表示后一个任务的开始。两个代号唯一确定一个任务。 </li><li>ADM - 虚活动：不是一个实际活动，为了表达逻辑关系而引入的。</li></ul></li><li><p>甘特图</p><ul><li>显示基本的任务信息</li><li>可以查看任务的工期、开始时间和结束时间以 及资源的信息。</li><li>只有时标，没有活动的逻辑关系 </li></ul></li><li><p>里程碑图</p><ul><li>显示项目进展中的重大工作完成</li><li>里程碑不同于活动：活动是需要消耗资源的，里程碑仅仅表示事件的标记。</li></ul></li><li><p>资源图</p></li></ul></li></ul><h4 id="任务历时估计"><a href="#任务历时估计" class="headerlink" title="任务历时估计"></a>任务历时估计</h4><ul><li>定额估算法<ul><li>公式：T = Q / ( R * S )<ul><li>T: 活动持续时间。</li><li>Q: 活动的工作量。</li><li>R: 人力或设备的数量。</li><li>S: 效率，以单位时间完成的工作量表示。</li></ul></li><li>方法比较的简单，容易计算。适合对某个任务的历时估算或者规模比较小的项目。</li><li>局限性：没有考虑任务之间的关系。</li></ul></li><li>经验导出模型<ul><li>公式：D = a * E<sup>b</sup><ul><li>D: 月进度 </li><li>E: 人月工作量 </li><li>a: 2~4之间的参数</li><li>b: 1/3左右的参数，依赖于项目的自然属性。</li></ul></li></ul></li><li>工程评价技术(PERT)<ul><li>利用网络顺序图逻辑关系和加权历时估算来计算项目历时的技术。当估算项目中某项单独的活动，存在很大的不确定性时采用。</li><li>公式：期望值 E = ( O + 4m + P ) / 6<ul><li>O是最小估算值，M是最大可能估算值， P是最大估算值。</li></ul></li></ul></li><li>基于进度表的估算：①可能的最短进度表   ②有效进度表   ③普通进度表</li><li>基于承诺的进度估算：从需求出发去安排进度，不进行中间的工作量(规模)估计。</li><li>Jones的一阶估算准则：<strong>取得功能点的总和</strong>，从幂次表中选择合适的幂次将它升幂。</li><li>其他方法：专家估计方法、类推估计方法、模拟估计方法</li></ul><h4 id="进度计划编排"><a href="#进度计划编排" class="headerlink" title="进度计划编排"></a>进度计划编排</h4><h4 id="关键路径法：-正推法，逆推法-P143"><a href="#关键路径法：-正推法，逆推法-P143" class="headerlink" title="关键路径法： 正推法，逆推法 P143"></a>关键路径法： 正推法，逆推法 P143</h4><ul><li><p>步骤</p><ul><li>根据指定的网络图逻辑关系和单一的历时估算， 计算每一个活动的单一的、确定的最早和最迟 开始和完成日期。 </li><li>计算浮动时间。 </li><li>计算网络图中最长的路径。 </li><li>确定项目完成时间 </li></ul></li><li><p>概念：</p><ul><li><p>ES：最早开始时间   EF：最早完成时间  LS：最晚开始时间  LF：最晚完成时间</p></li><li><p>TF：<strong>总浮动   TF = LS - ES  = LF -EF</strong></p></li><li><p>FF：<strong>自由浮动   FF = ES(S) - EF - lag</strong>  即某任务的自由浮动等于它的<strong>(S)</strong>后置任务的ES减去它的EF，再减去它的lag。</p><blockquote><p>TF(总浮动)：在不影响项目最早完成时间，本任务可以延迟的时间</p><p>FF(自由浮动)：在不影响后置任务最早开始时间，本任务可以延迟的时间。</p></blockquote></li><li><p>lead：超前  lag：滞后   Duration：任务历时</p></li><li><p>关键任务：一个任务的最早时间和最迟时间相同。</p></li><li><p>关键路径：一系列不同任务链条上的关键任务链接成为项目的关键路径。关键路径在网络图中浮动为0，是网络图中的最长路径。</p></li></ul></li><li><p>正推法</p><ul><li>首先建立项目的开始时间 </li><li>项目的开始时间是网络图中第一个活动的最早开始时间 </li><li>从左到右，从上到下进行任务编排 </li><li>当一个任务有多个前置时，选择其中最大的EF作为其后置任务的最早开始日期 </li><li>ES + Duration = EF</li><li>EF + Lag = ES(s) 后置任务的最早开始时间</li></ul></li><li><p>逆推法</p><ul><li>首先建立项目的结束时间 </li><li>项目的结束时间是网络图中最后一个活动的最晚结束时间 </li><li>从右到左，从上到下进行计算 </li><li>当一个前置任务有多个后置任务时，选择其中最小的LF作为其前置任务的最晚完成日期 </li><li>LF - Duration = LS </li><li>LS - Lag = LF(p) </li></ul></li></ul><h4 id="时间压缩法：应急法-赶工，平行作业-快速跟进法"><a href="#时间压缩法：应急法-赶工，平行作业-快速跟进法" class="headerlink" title="时间压缩法：应急法/赶工，平行作业/快速跟进法"></a>时间压缩法：应急法/赶工，平行作业/快速跟进法</h4><ul><li><p>应急法 P146</p><ul><li>在不改变活动的前提下，通过压缩某一个或者多个活动的时间来达到缩短整个项目工期的目的。</li><li>在最小相关成本增加的条件下，压缩关键路经上的关键活动历时的方法。</li><li>进度压缩单位成本 = ( 压缩成本 - 正常成本 ) / ( 正常进度 - 压缩进度 )</li></ul></li><li><p>平行作业法</p></li></ul><h3 id="C8-软件项目质量管理计划"><a href="#C8-软件项目质量管理计划" class="headerlink" title="C8 软件项目质量管理计划"></a>C8 软件项目质量管理计划</h3><ul><li><p><strong>质量</strong>是产品或者服务满足明确和隐含需要能力的性能特性的总体。<strong>等级</strong>是对具有相同功能的实体按照不同技术特征进行分类或者分级。无论等级高低，都可以实现自己等级内的高质量。</p></li><li><p><strong>质量管理</strong>是确定质量方针、目标和职责，并在质量体系中通过诸如质量计划、质量控制、质量保障和质量改进使质量得以实现的全部管理活动。 </p></li><li><strong>质量方针</strong>是由组织的最高管理者正式发布的一个组织总的质量宗旨和质量方向，是质量管理的核心和出发点。 </li><li><strong>质量体系</strong>是为实施质量管理所需的组织结构、程序、过程和资源的总称。 </li><li><strong>质量计划</strong>是确定质量的目标和要求， 以及确定采用质量体系要素的目标和要求的活动的过程。</li><li><strong>质量控制</strong>是为达到质量要求所采取的作业技术与活动。 其内容包括 ：确定控制对象、规定控制标准、制定控制方法、 选用检验技术、 处理事故(失控)等等。</li><li><strong>质量保障</strong>是为了保障实体能够满足质量要求 , 并􏰃供足够的证明以表明实体保障能够满足质量要求，而在质量体系中实施，并根据需要进行证实的、全部有计划和有系统的活动。 </li><li><strong>质量改进</strong>是为向本组织及其顾客􏰃供更多的收益，在整个组织内所采取的旨在􏰃高活动和过程的效益和效率的各种措施。</li><li>质量模型：<ul><li>Boehm质量模型：软件产品的质量从3方面考虑— 软件的可用性、可维护性、可移植性。</li><li>McCall质量模型：通过定义的评价准则对反映质量特征的软件属性进行分级，依此来估计软件质量特征的值。</li><li>ISO/IEC 9126质量模型：”质量特征—质量子特征—度量因子”的三层结构模型</li></ul></li><li>质量控制的7种工具<ul><li>旧7种工具：统计分析法、数据分层法、散布图、 帕累托图、 􏰂 因果分析图、 􏰂 直方图、 控制图。 </li><li>新7种工具：关联图法、系统图法、 矩阵图法、 数据矩阵分析法、 网络图法、 PDPC( 过程决策程序图 ) 法、KJ(喜田二郎 ) 法。 </li></ul></li></ul><h4 id="PDCA循环"><a href="#PDCA循环" class="headerlink" title="PDCA循环"></a>PDCA循环</h4><ul><li>PDCA 循环的概念最早是由美国质量管理专家戴明􏰃出来的，所以又称 “ 戴明环 ”</li><li>P(plan)    —  计划  </li><li>D(do)       — 执行 </li><li>C(check)  — 检查 </li><li>A(action) — 处理</li></ul><h3 id="C9-软件配置管理计划"><a href="#C9-软件配置管理计划" class="headerlink" title="C9 软件配置管理计划"></a>C9 软件配置管理计划</h3><ul><li>配置管理：记录软件产品的演化过程，确保软件开发者在软件生命周期中的各个阶段都能得到精确的产品配置。最终保证软件产品的<strong>完整性、一致性、追朔性、可控性</strong>。<ul><li>主要功能：版本管理，变更管理。</li></ul></li><li><strong>软件配置项</strong>是项目需定义其受控于软件配置管理的项。每个项目的配置项也许会不同，配置项也有不同的版本。<ul><li>eg. 系统规格说明书，软件需求规格说明书，设计规格说明书，源代码，测试规格说明书</li></ul></li><li><strong>基线</strong>提供了软件生存期中各个开发阶段的一个特定点，一个(些)配置项形成并通过审核，即形成基线。<ul><li>基线标志开发过程一个阶段的结束和里程碑。</li><li>基线修改只能通过正式的变化控制过程改变。</li></ul></li><li><p><strong>配置控制委员会</strong>(SCCB)具体责任如下：</p><ul><li>评估变更</li><li>批准变更申请</li><li>在生存期内规范变更申请流程</li><li>对变更进行反馈</li><li>与项目管理层沟通</li></ul></li><li><p>配置管理的基本过程</p><ul><li>配置项标识、跟踪</li><li>配置管理环境建立</li><li>基线变更管理：变更请求，变更评估，变更批准/拒绝，变更实现</li><li>基线审核</li><li>配置状态统计</li><li>配置管理计划</li></ul></li><li>配置管理工具<ul><li>好的配置管理工具应该具备的功能：并行开发支持，履历管理，版本控制，过程控制，产品发布管理。</li><li>常见的配置管理软件<ul><li>Rational ClearCase</li><li>Hansky Firefly</li><li>CVS</li><li>SVN</li><li>Microsoft VSS</li></ul></li></ul></li></ul><h3 id="C10-软件项目人员与沟通计划"><a href="#C10-软件项目人员与沟通计划" class="headerlink" title="C10 软件项目人员与沟通计划"></a>C10 软件项目人员与沟通计划</h3><ul><li><p>项目组织结构</p><ul><li>特点：临时性，目标性</li><li>类型：职能型，项目型，矩阵型</li></ul></li><li><p><strong>职能型</strong>：项目是以部门为主体来承担项目的，一个项目由一个或者多个部门承担。</p><ul><li><p>优点：</p><p>1.可以充分发挥职能部门的资源集中优势</p><p>2.部门的专家可以同时为部门内不同项目使用</p><p>3.便于相互交流， 相互支援</p><p>4.可以随时增派人员</p><p>5.可以将项目和本部门的职能工作融为一体</p></li><li><p>缺点：</p><p>1.项目和部门利益发生冲突，职能部门更重视本部门的目标,会忽视项目目标</p><p>2.资源平衡会出现问题</p><p>3.权利分割不利于各个职能部门的交流和团结协作</p><p>4.行政隶属关系使得项目经理没有充分的权利</p></li></ul></li><li><p><strong>项目型</strong>：部门完全按照项目设置，每个项目以项目经理为首，项目工作会运用到大部分的组织资源。</p><ul><li><p>优点：</p><p>1.项目经理对项目可以负全责</p><p>2.项目目标单一，可以以项目为中心,有利于项目顺利进行</p><p>3.避免多重领导</p><p>4.组织结构简单，交流简单,快速</p></li><li><p>缺点：</p><p>1.资源不能共享</p><p>2.各个独立的项目处于相对封闭状态,不利于公司政策的贯彻</p><p>3.对项目组织的成员缺少一种事业上的连续性和安全感</p><p>4.项目组织之间处于分割状态,缺少信息交流</p></li></ul></li><li><p><strong>矩阵型</strong>：从不同的部门中选择合适的项目人员组成一个临时项目组，项目结束后买这个项目组也解体了。</p><ul><li><p>优点：</p><p>1.专职的项目经理负责整个项目 , 以项目为中心,</p><p>2.公司的多个项目可以共享各个职能部门的资源</p><p>3.即利于项目目标的实现,又利于公司目标方针的贯彻</p><p>4.项目成员的顾虑减少了</p></li><li><p>缺点：</p><p>1.容易引起职能经理和项目经理权力的冲突</p><p>2.资源共享也能引起项目之间的冲突</p><p>3.项目成员有多位领导</p></li></ul></li><li><p><strong>沟通渠道</strong>：N ( N - 1 ) / 2 ，其中N为人员总数。</p></li></ul><h3 id="C11-项目风险计划"><a href="#C11-项目风险计划" class="headerlink" title="C11 项目风险计划"></a>C11 项目风险计划</h3><ul><li><p><strong>风险的定义</strong>：损失发生的不确定性；对潜在的，未来可能发生损害的一种度量。</p></li><li><p>项目风险的三要素：一个事件，事件发生的概率，事件的影响。</p></li><li><p>风险类型：</p><ul><li>预测角度：已知风险，可预测风险，不可预测风险。</li><li>范围角度：商业风险，技术风险，管理风险，人员风险，开发环境风险，客户风险，产品风险，过程风险。</li></ul></li><li><p><strong>风险识别</strong>的方法：</p><ul><li>德尔菲方法</li><li>头脑风暴法</li><li>情景分析法</li><li>风险条目检查表</li><li>面谈法，SWOT分析</li></ul></li><li><p><strong>风险评估</strong>：确定风险发生概率的估计和评价，项目风险后果严重程度的估计和评价，项目风险影响范围的分析和评价，以及对于项目风险发生时间的估计和评价。</p><p>风险R是该风险发生的概率 P 和影响程度 I 的函数，即R = F ( P , I )。</p><ul><li>定性风险评估<ul><li>风险概率：概率值(0~1)，风险概率度量(极高、高、中、低、极低)</li><li>风险后果：风险影响项目目标的严重程度(无影响~无穷大)，风险后果度量(极高、高、中、低、极低)</li></ul></li><li>定量风险评估：在定性评估的逻辑基础上，给出各个风险源的量化指标及其发生概率<ul><li>访谈：确定概率分布模型， 领域专家访谈，信息采集。</li><li>盈亏平衡分析 </li><li>决策树分析 </li></ul></li></ul></li><li><p>风险规划的主要策略：回避风险，转移风险，损失控制，自留风险。</p></li></ul><h4 id="决策树分析"><a href="#决策树分析" class="headerlink" title="决策树分析"></a>决策树分析</h4><ul><li>决策树分析是一种图表分析方法，提供项目所有可供选择的行动方案，行动方案之间的关系，行动方案的后果以及发生的概率，提供选择一个最佳的方案的依据。</li><li><strong>损益期望值(EMV)</strong>是决策树的一种计算值，根据风险发生的概率计算出一种期望的损益<ul><li>EMV = P(概率) * outcome(收益)</li></ul></li><li>利用决策树风险分析技术来分析如下两种情况，并选择其中一种方案：<ul><li>随机投掷硬币两次，如果两次投掷的结果都是硬币正面朝上，你将获得10元；投掷的结果背面每朝上一次你需要付出1.5元。 </li><li>随机投掷硬币两次，你需要付出2元； 如果两次投掷的结果都是硬币正面朝上，你将获得10元。 </li></ul></li></ul><h3 id="C13-项目集成计划"><a href="#C13-项目集成计划" class="headerlink" title="C13 项目集成计划"></a>C13 项目集成计划</h3><ul><li>软件项目管理4要素：C = F(S , Q , T)<ul><li>范围(S)  质量(Q)  进度(T)  成本(C)</li><li>S  与 C  成一定正比关系</li><li>Q 与 C  成一定正比关系</li><li>T  与 C  成一定反比关系</li></ul></li><li>项目集成计划的内容<ul><li>确定项目概貌、团队</li><li>明确项目团队内、外的协作沟通</li><li>规划开发环境和规范，项目范围说明，编制项目进度计划，项目成本计划，项目质量计划，项目沟通计划，风险计划，项目合同计划，配置管理计划，制定其他辅助计划。</li></ul></li></ul><h3 id="C15-项目核心计划执行控制"><a href="#C15-项目核心计划执行控制" class="headerlink" title="C15 项目核心计划执行控制"></a>C15 项目核心计划执行控制</h3><ul><li><p>进度、成本、资源控制：输入计划与实际的进度成本资源，输出进度成本资源的修改决定。</p><ul><li>图解控制法</li><li>挣值分析法</li></ul></li><li><p>图解控制法：</p><ul><li><p>进度：<strong>甘特图</strong></p></li><li><p>成本：<strong>累计费用曲线图</strong></p></li><li><p>人力物力资源：<strong>资源载荷图</strong></p><ul><li><p>优点：可以一目了然地确定项目情况</p></li><li><p>缺点：只能提供视觉印象，但本身不能提供其他重要的量化信息。</p></li></ul></li></ul></li></ul><h4 id="挣值分析法-已获取价值分析"><a href="#挣值分析法-已获取价值分析" class="headerlink" title="挣值分析法 / 已获取价值分析"></a>挣值分析法 / 已获取价值分析</h4><ul><li><p>挣值分析法：对项目实施的进度、成本状态进行绩效评估的有效方法。是计算实际花在一个项目上的工作量，以及预计该项目所需成本和完成该项目的日期的一种方法。</p></li><li><p>输入：</p><ul><li>BCWS：到目前为止的总预算成本。</li><li>ACWP：到目前为止所完成工作的实际成本。</li><li>BCWP：已完成工作的预算成本。</li><li>BAC：预计总成本，项目计划中的成本估算结果。</li><li>TAC：预计总耗时，项目计划中完成时间的估算结构</li></ul></li><li>输出：<ul><li><strong>进度差异 SV = BCWP - BCWS</strong> <ul><li>=0:  按照进度进行  &lt;0:  落后于进度  &gt;0:  超前于进度</li></ul></li><li><strong>进度效能指标 SPI = BCWP / BCWS * 100%</strong><ul><li>已完成工作百分比</li><li>=1:  按照进度进行    &gt;1:  超前于进度  &lt;1:  落后于进度 </li></ul></li><li><strong>费用差异 CV = BCWP - ACWP</strong><ul><li>=0:  按照预算进行  &gt;0:  低于于预算  &lt;0:  超出于预算</li></ul></li><li><strong>成本效能指标 CPI =  BCWP / ACWP * 100%</strong><ul><li>费用的支出速度</li><li>=1:  按照预算进行   &gt;1:  低于预算     &lt;1:  超出预算</li></ul></li><li>项目完成的预测成本：EAC = BAC / CPI</li><li>项目完成的成本差异：VAC = BAC - EAC</li><li>项目完成的预测时间：SAC = TAC / SPI</li><li>未完工的成本效能指标：TCPI = ( BAC - BCWP ) / (Goal - ACWP) = 剩余工作 / 剩余成本 <ul><li>Goal是项目希望花费的数目</li></ul></li></ul></li><li>BCWP的计算<ul><li>Way1：自下而上 — 很麻烦</li><li>Way2：规则计算<ul><li><strong>50/50规则:</strong> 当一项工作开始时，假定已经获得一半的价值。 </li><li><strong>0/100规则:</strong> 当一项工作开始时，没有产生价值，直到结束获得全部的价值。 </li></ul></li><li>Way3：经验加加权法</li></ul></li></ul><h4 id="质量计划控制执行"><a href="#质量计划控制执行" class="headerlink" title="质量计划控制执行"></a>质量计划控制执行</h4><ul><li><p>质量保证的管理</p><ul><li>3个要点：在项目进展过程中，定期对项目各方面的表现进行评价，通过评价来推测项目最后是否能够达到相关的质量标准，通过质量评价来帮助项目相关的人建立对项目质量的信心。</li><li>主要活动<ul><li>产品审计：根据质量保证计划对项目过程中的工作产品进行质量审查的过程。</li><li>执行过程审计：对项目质量管理活动的结构性复查。</li></ul></li></ul></li><li><p>质量控制的管理</p><ul><li>3个要点：检查控制对象是项目工作结果，进行跟踪检查的依据是相关质量标准，对于不满意的质量问题进一步分析原因并确定采取何种措施来消除这些问题。</li><li>方法：技术评审，代码走查，测试，返工</li><li>策略手段：趋势分析，抽样统计，缺陷追踪</li></ul></li><li>质量保证与质量控制的关系：<ul><li>质量保证着重于过程和产品提交之后的质量监管。— 管理职能<ul><li>针对一般的、具有普遍性的问题</li><li>从总体上提供质量信心</li></ul></li><li>质量控制着重于产品推出前的质量把关。— 检查职能<ul><li>针对具体产品或者具体活动的质量管理</li><li>从具体环节上提高产品的质量</li></ul></li></ul></li></ul><h3 id="C16-团队人员计划的执行控制"><a href="#C16-团队人员计划的执行控制" class="headerlink" title="C16 团队人员计划的执行控制"></a>C16 团队人员计划的执行控制</h3><ul><li>项目团队建设：组建阶段、磨合阶段、规范阶段和执行阶段。</li><li>项目成员的激励：<ul><li>马斯洛的需求层次理论：生理，安全，社会归属，自尊，自我实现。</li><li>海兹伯格的激励理论<ul><li>激励因素（内在因素）：成就感，责任感，晋升，被赏识、认可</li><li>保健因素（外在因素）：工作环境，薪金，工作关系，安全等</li></ul></li><li>麦克勒格的 X理论：用马斯洛的底层需求（生理和安全）进行激励 </li><li>麦克勒格的Y 理论 ：用马斯洛的高层需求（自尊和自我实现）进行激励</li><li>期望理论：相信他们的努力很可能会产生成功的结果，他们也相信自己会因为成功得到相应的回报</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;C1-软件项目管理概述&quot;&gt;&lt;a href=&quot;#C1-软件项目管理概述&quot; class=&quot;headerlink&quot; title=&quot;C1 软件项目管理概述&quot;&gt;&lt;/a&gt;C1 软件项目管理概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;项目管理&lt;/strong&gt;是指一定的主体为了实现其目标，利用各种有效的手段，对执行中的项目周期的个阶段工作进行计划、组织、协调、指挥、控制，以取得良好经济效益的各项活动的总和。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="软件工程" scheme="https://daisine.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="note" scheme="https://daisine.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>软件需求笔记</title>
    <link href="https://daisine.github.io/require/"/>
    <id>https://daisine.github.io/require/</id>
    <published>2019-01-10T03:47:27.000Z</published>
    <updated>2019-05-10T10:53:09.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-基本的软件需求"><a href="#1-基本的软件需求" class="headerlink" title="1. 基本的软件需求"></a>1. 基本的软件需求</h2><h3 id="1-1-软件需求"><a href="#1-1-软件需求" class="headerlink" title="1.1 软件需求"></a>1.1 软件需求</h3><ul><li>要解决的问题是：<ul><li>什么是软件需求？</li><li>为什么要实现软件需求？</li><li>哪些人应参与软件需求<a id="more"></a></li></ul></li><li><strong>需求分析模型：</strong><br><img src="/require/需求分析模型.png" width="40%"><img src="/require/需求分析模型2.png" width="40%"></li><li>软件需求活动 <ul><li>需求诱导 → 需求分析 → 需求传递 → 需求确认 → 需求演化  </li></ul></li><li>IEEE软件工程标准词汇表中定义<strong>软件需求</strong>为：<br>（1）<strong>用户</strong>为解决某个问题或达到目标而需具备的条件或能力。<br>（2）<strong>系统</strong>或系统部件为满足合同、标准、规范或其它正式文档而必须满足的条件或能力。<br>（3）上述（1）或（2）中定义的条件或能力的<strong>文档表达</strong>。 </li><li>需求分析：<ul><li>分析软件用户的需求，细致的进行、调查，把用户“做什么”的要求，最终转换为一个完全的、精细的软件逻辑模型。</li><li>并写出软件的需求规格说明。</li><li>准确地表达用户的要求。</li></ul></li><li><strong>需求的层次</strong><ul><li><strong>业务需求</strong>：表示组织或客户高层次的目标。描述了组织为什么要开发一个系统，即目标。可以用前景和范围文档表述。</li><li><strong>用户需求</strong>：描述的是用户的目标，或用户要求系统必须能完成的任务，即用户能使用系统来做些什么。可以用用例、场景描述和时间-响应表表述。</li><li><strong>功能需求</strong>：规定开发人员必须在产品中实现的软件功能，用户利用这些功能来完成任务，满足业务需求，即开发人员需要实现什么。<br><img src="/require/产物.png" width="50%"></li></ul></li><li>需求不应该包括：<ul><li>设计和实现的细节</li><li>项目计划信息</li><li>测试信息</li></ul></li></ul><h3 id="1-2-需求工程"><a href="#1-2-需求工程" class="headerlink" title="1.2 需求工程"></a>1.2 需求工程</h3><h5 id="1-需求开发"><a href="#1-需求开发" class="headerlink" title="1. 需求开发"></a>1. 需求开发</h5><ul><li>需求开发的过程：<ul><li><strong>诱导 → 分析 → 规范化 → 确认</strong></li></ul></li></ul><h5 id="2-需求管理"><a href="#2-需求管理" class="headerlink" title="2. 需求管理"></a>2. 需求管理</h5><ul><li><strong>需求管理的4个主要内容</strong>：<ol><li><strong>变更控制</strong>：建议变更；分析影响；作出决策；交流；合并；测量需求的稳定性。</li><li><strong>版本控制</strong>：确定需求文档版本；确定单个需求文档版本。</li><li><strong>需求跟踪</strong>：定义对其它需求的连接链；定义对其它系统元素的连接。</li><li><strong>需求跟踪状态</strong>：定义需求状态；跟踪需求每一个状态。</li></ol></li><li>需求开发与需求管理的分界<br><img src="/require/界限.png" width="30%"></li></ul><h5 id="需求的好坏"><a href="#需求的好坏" class="headerlink" title="需求的好坏"></a>需求的好坏</h5><ul><li><strong>糟糕的需求</strong><ul><li>用户参与不足</li><li>用户需求扩展</li><li>有歧义的需求</li><li>镀金问题</li><li>过于抽象的需求</li><li>忽略了某类用户</li><li>不准确的计划</li></ul></li><li><strong>理想情况下需求的性质</strong><ul><li>完整的</li><li>正确的</li><li>可行的</li><li>必须的</li><li>优先化的 / 有优先次序的</li><li>清楚的 / 无歧义的</li><li>可检验的 / 可验证性</li></ul></li><li><strong>需求规格说明的特点</strong><ul><li>完整性</li><li>一致性</li><li>可修改性</li><li>可跟踪性</li></ul></li></ul><h2 id="2-客户眼中的需求"><a href="#2-客户眼中的需求" class="headerlink" title="2. 客户眼中的需求"></a>2. 客户眼中的需求</h2><h5 id="用户：是一种泛称"><a href="#用户：是一种泛称" class="headerlink" title="用户：是一种泛称"></a>用户：是一种泛称</h5><ul><li>掏钱买软件的用户称为<strong>客户</strong></li><li>真正操作软件的用户叫<strong>最终用户</strong></li><li><strong>间接用户</strong>既不掏钱买该软件产品，也不使用该软件，但是它可能对软件产品有很大的影响。<ul><li>eg. 财务软件 -&gt; <strong>国家财政局</strong>审核</li><li>客户与最终用户可能是同一个人也可能不是同一个人</li></ul></li></ul><h5 id="涉众"><a href="#涉众" class="headerlink" title="涉众"></a>涉众</h5><ul><li><strong>涉众</strong>：在软件开发项目中主要是<strong>指和这个项目有密切相关利益的人</strong>，他们共同感兴趣的就是需求分析阶段。</li><li>这些涉众包括客户、用户、业务或需求分析员、开发人员、测试人员、用户文档编写者、项目管理者和客户管理者。 <ul><li>需求分析员：负责收集客户需求并编写文档，以及负责客户与开发机构之间联系沟通的人</li></ul></li></ul><h5 id="软件客户的权利"><a href="#软件客户的权利" class="headerlink" title="软件客户的权利(!!!)"></a>软件客户的权利(!!!)</h5><ol><li>要求需求分析员<strong>使用客户的语言</strong></li><li>要求需求分析员<strong>熟悉客户的业务，了解客户对系统的目标</strong></li><li>要求需求分析员<strong>把需求收集过程中客户提供的信息组织成书面的<code>软件需求规格说明</code></strong></li><li>要求需求分析员<strong>解释需求过程生成的所有工作结果</strong></li><li>要求需求分析员和开发人员尊重客户，始终以合作和专业的态度与客户进行互动</li><li>要求需求分析员和开发人员为需求和产品实现提供思路和备用方案</li><li>要求开发人员实现能让产品使用起来更容易、更有趣的特性</li><li><strong>调整需求</strong>，便于重用已有的软件组件</li><li>在提<strong>出需求变更时，获得对变更的成本</strong>、影响及二者权衡关系的真实评估</li><li>获得满足功能和质量要求的系统，这些要求必须事先告知开发人员征得其同意</li></ol><h5 id="软件客户的义务"><a href="#软件客户的义务" class="headerlink" title="软件客户的义务"></a>软件客户的义务</h5><ol><li>为需求分析员和开发人员<strong>讲解业务</strong>并<strong>定义业务术语</strong></li><li>提供需求，阐明需求，通过与开发人员的交互将<strong>需求充实完善</strong></li><li>对系统需求的<strong>描述</strong>必须<strong>详细、准确</strong></li><li>需要时，及时对需求做出决断</li><li><strong>尊重</strong>开发人员对需求<strong>成本和可行性的评估</strong></li><li>与开发人员<strong>协作</strong>，为功能需求、系统特性和用例<strong>设置优先级</strong></li><li><strong>审阅</strong>需求文档，评估原型</li><li>发现需要变更需求时，<strong>及时</strong>与开发人员<strong>沟通</strong></li><li>按照开发组织的变更控制过程<strong>提出需求变更</strong></li><li>尊重需求分析员在需求工程中使用的过程</li></ol><h2 id="3-需求工程的推荐方法"><a href="#3-需求工程的推荐方法" class="headerlink" title="3. 需求工程的推荐方法"></a>3. 需求工程的推荐方法</h2><ul><li><strong>需求工程的推荐方法：</strong><ul><li>知识技能</li><li>需求管理 </li><li>项目管理 </li></ul></li><li><strong>需求开发：</strong><ul><li>获取 </li><li>分析 </li><li>编写规格说明书 </li><li>验证  </li></ul></li></ul><h2 id="4-需求分析员"><a href="#4-需求分析员" class="headerlink" title="4. 需求分析员"></a>4. 需求分析员</h2><ul><li><strong>需求分析员</strong>：<ul><li>是<strong>对软件项目设计的需求进行收集、分析、记录和验证等工作的主要承担者。</strong></li><li>是用户群体和软件开发团队之间进行需求沟通的桥梁。</li><li>是收集和传播的中心角色。</li><li>需求分析员是一种项目角色，而不是职务头衔。</li><li>需求分析员称职与否关系到项目的成败。</li></ul></li><li><strong>需求分析员的任务</strong> <strong>深刻了解</strong><ul><li>定义业务需求</li><li>确定项目涉众和用户类别</li><li>获取需求</li><li>分析需求</li><li>编写需求规格说明</li><li>为需求建模</li><li>主持对需求的验证</li><li>引导对需求的优先级划分</li><li>管理需求</li></ul></li><li><strong>需求分析员的来源</strong>：<ul><li>从<strong>用户</strong>转为分析员</li><li>从<strong>开发人员</strong>转为分析员</li><li>应用领域专家 / 主题专家</li></ul></li></ul><h2 id="5-确定产品前景与项目范围"><a href="#5-确定产品前景与项目范围" class="headerlink" title="5. 确定产品前景与项目范围"></a>5. 确定产品前景与项目范围</h2><ul><li>项目视图：描述了产品所涉及的各个方面和最终所具有的功能。 </li><li>项目范围：<ul><li>描述了产品应包括的部分和不应包括的部分。</li><li>说明了在包括的部分与不包括的部分之间的界线。</li></ul></li></ul><h5 id="前景与范围文档"><a href="#前景与范围文档" class="headerlink" title="前景与范围文档"></a>前景与范围文档</h5><ul><li><strong>业务需求</strong><ul><li>包括<strong>背景、业务机遇、业务目标与成功标准、客户与市场需求、业务风险</strong></li></ul></li><li>解决方案的前景<ul><li>包括前景声明、主要特征、假设与依赖</li></ul></li><li>范围与限制<ul><li>包括第一个版本的范围、各后续版本的范围、限制与排除</li></ul></li><li>业务背景<ul><li>包括涉及简介、项目优先级、操作环境</li></ul></li></ul><h5 id="DFD图"><a href="#DFD图" class="headerlink" title="DFD图"></a>DFD图</h5><ul><li>关联图（0层DFD） ：<ul><li>确定了通过某一接口与系统相连的<strong>外部实体</strong>。有时，称为“端点”。</li><li>以及，外部实体和系统之间的数据流和物流</li><li>我们把<strong>关联图</strong>，作为结构化分析方法，形成<strong>数据流图</strong>的<strong>最高抽象层</strong>。 </li></ul></li></ul><h2 id="6-获取客户的需求"><a href="#6-获取客户的需求" class="headerlink" title="6. 获取客户的需求"></a>6. 获取客户的需求</h2><ul><li><strong>需求的来源</strong><ol><li>与潜在的用户进行交谈和讨论</li></ol><ul><li>描述现有产品或竞争产品的文档</li><li>系统需求规格说明</li><li>现有系统的问题报告和改进要求</li><li>市场调查和用户问卷调查</li><li>观察用户如何工作</li><li>用户工作的情景分析</li><li>时间和响应</li></ul></li><li><strong>用户代言人</strong><ul><li>用户代言人本身就是实际用户</li><li><strong>外部的用户代言人</strong></li><li>对用户代言人的要求：计划、需求、确认和验证、用户辅助、变更控制</li><li>设置多位用户代言人</li><li>设置用户代言人会出现和应避免的问题 P72</li></ul></li><li><strong>步骤</strong><ul><li><strong>准备调查</strong>：首先，需求分析员应当起草需求调查问题表，将调查重点锁定在该问题表内，否则调查工作将变得漫无边际。其次，需求分析员应当确定需求调查的方式。最后需求分析员与被调查者建立联系，确定调查的时间、地点、人员等。</li><li><strong>执行调查</strong>：按照计划执行调查。在调查过程中随时记录（或存储）需求信息。需求分析员与用户面谈时应守时，先去了解用户的身份、背景。</li></ul></li><li>为了征求客户的意见，必须采取以下几步：<ul><li>明确项目用户需求的来源。</li><li>明确使用该产品的不同类型的用户。</li><li>与产品不同用户类的代表进行沟通。</li><li>遵从项目的最终决策者的意见。</li></ul></li></ul><h2 id="7-聆听客户的需求"><a href="#7-聆听客户的需求" class="headerlink" title="7. 聆听客户的需求"></a>7. 聆听客户的需求</h2><h5 id="需求获取"><a href="#需求获取" class="headerlink" title="需求获取"></a>需求获取</h5><ul><li>需求获取是最困难、最关键、最容易出错和最需要沟通的环节</li><li>需求获取的方式：面谈、小组讨论、解决冲突等</li><li>多问“为什么”</li><li>获得业务问题或总体特性</li><li>设身处地</li><li>对现有系统最感到烦恼的事情是什么？</li><li>工作流程—流程图和判定树</li><li>编写文档及评审</li></ul><h5 id="需求获取讨论会"><a href="#需求获取讨论会" class="headerlink" title="需求获取讨论会"></a>需求获取讨论会</h5><ul><li>建立基本规则</li><li>不超出范围（项目范围）</li><li>使用活动挂图来捕获以后再考虑的一些条目</li><li>时间盒讨论</li><li>保持较小的团队规模并找到合适的参与者（人多误事）</li><li>确保每个人都积极地参与讨论</li></ul><h5 id="将客户的意见归类"><a href="#将客户的意见归类" class="headerlink" title="将客户的意见归类"></a>将客户的意见归类</h5><ul><li>业务需求</li><li>用例或场景</li><li>业务规则</li><li>功能性需求</li><li>质量属性</li><li>外部接口需求</li><li>约束</li><li>数据定义</li><li>解决思路</li></ul><h2 id="8-理解用户需求"><a href="#8-理解用户需求" class="headerlink" title="8. 理解用户需求"></a>8. 理解用户需求</h2><ul><li>需要了解 使用用例获取方法  </li><li><strong>使用用例产生的成果：数据字典</strong><br><img src="/require/使用用例.png" width="50%"></li></ul><h5 id="使用用例的好处"><a href="#使用用例的好处" class="headerlink" title="使用用例的好处"></a>使用用例的好处</h5><ul><li>使用户更清楚地认识到新系统允许他们做什么</li><li>防止“孤立”的功能</li><li>揭示对象以及它们之间的责任</li></ul><h5 id="使用用例时应避免的问题"><a href="#使用用例时应避免的问题" class="headerlink" title="使用用例时应避免的问题"></a>使用用例时应避免的问题</h5><ol><li><strong>太多</strong>的使用用例 </li><li>使用用例的<strong>冗余</strong> </li><li>使用用例中的<strong>用户界面的设计</strong> </li><li>使用用例中<strong>包括数据定义</strong> </li><li>试图把每一个需求与一个使用实例相联系</li></ol><h5 id="需求整理和分析的过程"><a href="#需求整理和分析的过程" class="headerlink" title="需求整理和分析的过程"></a>需求整理和分析的过程</h5><ul><li>需求收集 -&gt; 解释原始数据 -&gt; 整理需求 -&gt; 设置权重 -&gt; 概念选择</li><li>整理单项需求：黄纸贴</li><li>头脑风暴</li></ul><h5 id="单项需求重要性定义（BSA）"><a href="#单项需求重要性定义（BSA）" class="headerlink" title="单项需求重要性定义（BSA）"></a>单项需求重要性定义（BSA）</h5><ul><li>B（Basic）：基本需求</li><li>S（Satisfied）：让客户更满意的需求 </li><li>A（Attractive）：更有吸引力的需求</li></ul><h2 id="9-遵守规则"><a href="#9-遵守规则" class="headerlink" title="9. 遵守规则"></a>9. 遵守规则</h2><ul><li>遵守业务规则（从讨论会来）</li><li>业务规则：是对业务的某个方面进行定义或约束的语句<ul><li>eg. 政策性法规</li></ul></li><li>业务规则的<strong>分类</strong>：<ul><li>事件</li><li>约束</li><li>动作触发规则</li><li>计算</li><li>推论</li></ul></li></ul><h2 id="10-编写需求文档"><a href="#10-编写需求文档" class="headerlink" title="10. 编写需求文档"></a>10. 编写需求文档</h2><ul><li><strong>软件需求规格说明</strong><ul><li>精确地阐述了一个软件系统必须提供的功能和性能，以及所要考虑的限制条件。</li><li>是一个软件系统成功的基础</li></ul></li><li>编写软件需求规格说明的<strong>三种方法</strong>：<ul><li><strong>用好的结构化和自然语言编写文本型文档</strong></li><li><strong>建立图形化模型方法：</strong>模型可以描绘转换过程、系统状态和它们之间的变化、数据关系、逻辑流或对象类和它们的关系。</li><li><strong>编写形式化规格说明：</strong>这可以通过使用数学上精确的形式化逻辑语言来定义需求。</li></ul></li><li>高质量需求文档，所具有的特征：<ul><li>完整性</li><li>一致性</li><li>必要性</li><li>明确性</li><li>可验证性</li><li>可更改性</li><li>可跟踪性</li></ul></li><li>注意事项：(最后的分析题可以用到)<ul><li>对节、小节和单个需求的号码编排，必须一致。</li><li>正确使用各种可视化强调标志 —— 例如，黑体、下划线、斜体等</li><li>创建目录表和索引表，有助于读者寻找所需的信息。</li><li>对所有图和表，指定号码和标识号，并且可按号码进行查阅。</li><li>使用字处理程序中，交叉引用的功能，来查阅文档中其它项或位置。</li></ul></li><li>优秀的需求文档应该考虑： <ul><li>保持语句和段落的简短。</li><li>采用主动语态的表达方式。</li><li>编写具有正确的语法、拼写和标点的完整句子。</li><li>使用的术语与词汇表中所定义的应该一致。</li><li>需求陈述应该具有一致的样式。</li><li>为了减少不确定性，避免模糊的、主观的术语。</li><li>避免使用比较性的词汇</li></ul></li><li>编号：<ol><li>序列号   如：UR-9、SRS-43</li><li>层次化编码 如：3.2.1</li><li>层次化文本标签  </li></ol></li><li>数据字典<ul><li>数据字典是一个共享存储库，用于定义应用程序中使用的所有数据元素或属性的含义、数据类型、长度、格式、需要的精度以及数据允许的取值范围或数据值的列表。</li><li>数据字典与数据流图配合，能清楚地表达数据处理的要求</li></ul></li></ul><h2 id="11-需求的图形化分析"><a href="#11-需求的图形化分析" class="headerlink" title="11. 需求的图形化分析"></a>11. 需求的图形化分析</h2><ul><li><strong>软件系统从三个方面来表达</strong><ul><li><strong>过程</strong>：数据流图 </li><li><strong>数据</strong>：实体-关系图 </li><li><strong>状态</strong>：状态转换图，对话图，判定表和树。</li></ul></li><li><strong>数据流图</strong>：一个数据流图可以标识系统的转换过程、系统所操纵的数据或物质集合（存储），以及过程、存储和外部世界之间的数据流或物质流。<ul><li><strong>过程</strong>：用<strong>圆圈</strong>表示</li><li><strong>端点</strong>：用<strong>矩形框</strong>表示</li><li><strong>数据流</strong>：用<strong>箭头</strong>表示</li><li><strong>数据存储区</strong>：用<strong>一对平行线</strong>表示</li></ul></li><li><strong>实体-关系图</strong>：描绘了系统的数据关系<ul><li><strong>实体</strong>用单名词来命名。用<strong>矩形</strong>框表示。</li><li>每个实体要用几个<strong>属性</strong>来描述，每个实体的单个实例具有不同的属性值。</li><li><strong>关系</strong>用能描述关系的本质来命名，它确定了一对实体之间在逻辑上和数量上的连接。用<strong>菱形框</strong>表示。</li></ul></li><li><strong>状态转换图</strong>：表示处理结果可能的状态转换。<ul><li><strong>系统状态</strong>，用<strong>矩形框</strong>表示。</li><li><strong>状态改变</strong>，用<strong>箭头连接一对矩形框</strong>表示。</li><li><strong>事件或条件</strong>，在每个迁移箭头上用<strong>文本标签</strong>来表示。</li></ul></li><li>对话图：在<strong>较高的抽象层次上</strong>表示用户界面的设计，它展示了系统的对话元素及这些元素之间的导航连接，但<strong>没有展示</strong>详细的屏幕设计。一种状态转换图<ul><li>每个<strong>对话元素</strong>表示为一个状态，用<strong>矩形框</strong>表示</li><li>将每个允许的<strong>导航选项</strong>表示为一个<strong>转换</strong>，用<strong>箭头</strong>表示。</li><li>触发用户界面导航的<strong>条件</strong>表示为<strong>转换箭头上的文本标签</strong>。</li></ul></li><li>决策表：应用表格的形式进行需求表达。<ul><li>可列出影响系统行为的所有因素的各种取值，并表明对这些因素的每一种组合所期望的系统响应动作。</li></ul></li><li>决策树：采用一种树形结构表达需求。用树形结构表示动作的各种分支。</li></ul><h2 id="12-软件质量属性"><a href="#12-软件质量属性" class="headerlink" title="12. 软件质量属性"></a>12. 软件质量属性</h2><ul><li>质量属性难以挖掘</li><li><strong>软件质量属性</strong>是系统非功能性需求的一部分。<ul><li>非功能需求：描述系统<strong>展现给用户的行为和执行的操作</strong>等。</li></ul></li><li><strong>主要对用户重要的属性</strong> <strong>一定了解</strong> <ul><li><strong>可用性</strong>：系统能够正常运行的时间比例。</li><li><strong>有效性</strong>：系统如何优化处理器、磁盘空间或通信带宽的。</li><li><strong>灵活性</strong>：在产品中，增加新功能时，所需工作量的大小。</li><li><strong>完整性</strong></li><li><strong>互操作性</strong>：表明了产品与其它系统交换数据和服务的难易程度。</li><li><strong>可靠性</strong>：软件无故障执行一段时间的概率。</li><li><strong>健壮性</strong>：是指当系统或其组成部分遇到非法输入数据、相关软件或硬件组成部分的缺陷或异常的操作情况时，能继续正确运行功能的程度。</li><li><strong>易用性</strong>：对于新用户或不常使用产品的用户在学习使用产品时的难易程度。</li></ul></li><li><strong>主要对开发人员重要的属性：</strong> <strong><code>一定了解</code></strong> <ul><li><strong>可维护性</strong>：在软件中纠正一个缺陷或做一次更改的难易程度。</li><li><strong>可移植性</strong>：把一个软件从一种运行环境转移到另一种运行环境中所花费的工作量。对于工程的成功是不重要的。</li><li><strong>可重用性</strong>：除了在最初开发的系统中使用之外，还可以在其它应用程序中使用的程度。</li><li><strong>可测试性</strong>：测试软件组件或集成产品时查找缺陷的难易程度。</li></ul></li></ul><h2 id="13-通过原型法减少项目风险"><a href="#13-通过原型法减少项目风险" class="headerlink" title="13. 通过原型法减少项目风险"></a>13. 通过原型法减少项目风险</h2><ul><li>一个软件原型：<strong>是所提出的新产品的部分实现</strong></li><li><strong>使用软件原型的3个目的：</strong><ul><li>明确并完善需求</li><li>研究设计选择方案</li><li>发展为最终产品</li></ul></li></ul><h5 id="原型的分类"><a href="#原型的分类" class="headerlink" title="原型的分类"></a>原型的分类</h5><ul><li><strong>水平原型</strong>（行为原型或演示性模型）主要描绘用户界面的一部分，<strong>不深入</strong>到体系结构的所有层次。</li><li><strong>垂直原型</strong>（结构化原型或概念模型）主要在技术服务层次上实现应用程序用户界面的一部分功能，它触及到了系统实现的<strong>所有层次。</strong></li><li><strong>进化型原型</strong>是螺旋式软件开发生命周期模型和某些面向对象软件开发过程的一个组成部分。</li><li><strong>废弃型原型</strong>是指达到预期目的后，原型本身被抛弃。<ul><li>用途：解决需求不确定性、二义性、不完整性、含糊性等。</li></ul></li><li><strong>书面原型</strong>和电子原型：用<strong>平面工具</strong>把系统是如何实现的呈现在用户面前。<ul><li>是一种廉价、快速，并且不涉及高技术的方法</li><li>它可以把一个系统某部分，是如何实现的呈现在用户面前。  </li></ul></li><li><strong>使用原型法的若干可能的方法</strong><br><img src="/require/原型.png" width="40%"></li><li><strong>原型法的好处</strong><ol><li>提供了一套强有力的技术</li></ol><ul><li>可以缩短开发进度</li><li>增加用户的满意程度</li><li>生产出高质量的产品</li><li>可以减少需求错误和用户界面的缺陷。 </li></ul></li></ul><h2 id="14-设定需求优先级"><a href="#14-设定需求优先级" class="headerlink" title="14. 设定需求优先级"></a>14. 设定需求优先级</h2><h5 id="为什么要划分优先级"><a href="#为什么要划分优先级" class="headerlink" title="为什么要划分优先级"></a>为什么要划分优先级</h5><ul><li><strong>设定优先级的好处</strong>:<ul><li>有助于项目经理解决冲突、安排阶段性交付，并且，做出必要的取舍。</li><li>尽早确定出所交付的产品应具备的最重要的功能</li><li>权衡合理的项目范围和进度安排、预算以及质量目标的约束</li></ul></li><li>设定优先级的一般方法是<ul><li>把需求分成三类：高、中、低</li></ul></li><li>每一个需求的优先级，必须写入软件需求规格说明或使用实例的说明中。</li></ul><h5 id="基于价值、费用和风险的优先级设定"><a href="#基于价值、费用和风险的优先级设定" class="headerlink" title="基于价值、费用和风险的优先级设定"></a>基于价值、费用和风险的优先级设定</h5><ol><li>列出要设定优先级的所有需求、特性或使用实例；</li></ol><ul><li>估计每一个特性提供给客户或业务的相关利益。</li><li>估计出如果没有把应该实现的特性包括到产品中，将会给客户或业务上带来的损失。</li><li>总价值栏是相对利润和相对损失的总和。<ul><li>总价值 = 相对利益 <em> 利益权值 + 相对损失 </em> 损失权值</li></ul></li><li>估计实现每个特性的相对费用。</li><li>估计出与每个特性相关的技术或风险相对程度。</li><li>一旦把所有的估算写入平面表，就可以利用如下公式计算出每一特性的优先级：<ul><li>优先级 =  价值% / (费用% <em> 费用权值+ 风险% </em> 风险权值)</li></ul></li><li>按计算出的优先级的降序排列表中的特性。   </li></ul><h2 id="15-需求确认"><a href="#15-需求确认" class="headerlink" title="15. 需求确认"></a>15. 需求确认</h2><ul><li>需求确认：是指开发方和客户方共同对《产品需求规格说明书》进行<strong>评审</strong>，双方对需求达成共识后作出<strong>承诺</strong>。</li><li>需求确认包含两个重要工作：<ol><li><strong>需求评审</strong></li><li><strong>需求承诺</strong></li></ol></li><li>评审过程要干些什么 看每一个步骤大概要点<br><img src="/require/审查.png" width="40%"></li><li>需求评审的参与者(5-9人)<ol><li>产品的开发者及其可能的同组成员</li></ol><ul><li>先前产品的开发者或正在评审的项目的SRS编写者</li><li>要根据正在审查的文档来开展工作的人</li></ul></li></ul><h2 id="18-需求管理的原则与实现"><a href="#18-需求管理的原则与实现" class="headerlink" title="18. 需求管理的原则与实现"></a>18. 需求管理的原则与实现</h2><ul><li><strong>需求管理</strong>的4个部分，每部分大概需要做什么。<br><img src="/require/管理.png" width="40%"></li><li><strong>需求基线</strong>-是团队成员已经承诺将在某一特定产品版本中实现的功能性和配功能性需求的一组集合。</li></ul><h2 id="19-变更管理"><a href="#19-变更管理" class="headerlink" title="19. 变更管理"></a>19. 变更管理</h2><ul><li>注意事项：<ol><li>应仔细评估已建议的变更</li><li>挑选合适的人选对变更做出决定</li><li>变更应及时通知所有涉及的人员</li><li>项目要按一定的程序来采纳需求变更</li></ol></li><li>变更控制策略<ol><li>所有需求变更必须遵循一个过程，按照此过程，如果一个变更需求未被采纳，则其后过程不再予以考虑。</li><li>对于未获批准的的变更，除可行性论证之外，不应再做其他设计和实现工作。</li><li>简单请求一个变更不能保证能实现变更，要由项目CCB决定实现哪些变更。</li><li>项目风险承担者应该能够了解变更数据库的内容。</li><li>绝不能从数据库中删除或修改变更请求的原始文档。</li><li>每一个集成的需求变更必须能跟踪到一个经核准的变更请求。</li></ol></li></ul><h4 id="考点：对整个需求过程比较关键的环节的概念比较重要。"><a href="#考点：对整个需求过程比较关键的环节的概念比较重要。" class="headerlink" title="考点：对整个需求过程比较关键的环节的概念比较重要。"></a>考点：对整个需求过程比较关键的环节的概念比较重要。</h4><ul><li>做需求需要哪几个典型阶段</li><li>每个阶段需要哪些参与者</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-基本的软件需求&quot;&gt;&lt;a href=&quot;#1-基本的软件需求&quot; class=&quot;headerlink&quot; title=&quot;1. 基本的软件需求&quot;&gt;&lt;/a&gt;1. 基本的软件需求&lt;/h2&gt;&lt;h3 id=&quot;1-1-软件需求&quot;&gt;&lt;a href=&quot;#1-1-软件需求&quot; class=&quot;headerlink&quot; title=&quot;1.1 软件需求&quot;&gt;&lt;/a&gt;1.1 软件需求&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;要解决的问题是：&lt;ul&gt;
&lt;li&gt;什么是软件需求？&lt;/li&gt;
&lt;li&gt;为什么要实现软件需求？&lt;/li&gt;
&lt;li&gt;哪些人应参与软件需求&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="软件工程" scheme="https://daisine.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="note" scheme="https://daisine.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>多媒体技术笔记</title>
    <link href="https://daisine.github.io/media/"/>
    <id>https://daisine.github.io/media/</id>
    <published>2019-01-07T03:45:47.000Z</published>
    <updated>2019-05-10T10:53:18.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-引论"><a href="#1-引论" class="headerlink" title="1. 引论"></a>1. 引论</h2><h4 id="媒体的分类"><a href="#媒体的分类" class="headerlink" title="媒体的分类"></a>媒体的分类</h4><ul><li><code>感觉媒体</code>: 能直接作用于人的感官，使人直接产生感觉的一类媒体<strong>（作用于人）</strong>。如人类的语言、音乐、自然界的各种声音、图形、图像。</li><li><code>表示媒体</code>: 计算机对信息的表示方法的描述。是<strong>为了加工、处理和传输感觉媒体</strong>而人为研究、构造出来的一种媒体<strong>（作用于计算机)</strong>。具体体现为：编码<a id="more"></a></li><li><code>表现媒体</code>: <strong>感觉媒体和用于通信的电信号之间转换</strong>用的一类媒体，分为输入表现媒体和输出表现媒体。如打印机、音箱、MIDI键盘，扫描仪、键盘、鼠标。除此之外，还有耳麦、轨迹球、绘图仪等<strong>（用于人与计算机交互）</strong></li><li><code>存储媒体</code>: 用于计算机存放<strong>表示媒体</strong>，以便计算机随时处理、加工和调用信息编码。常用的有光盘、硬盘、磁带、活动硬盘、优盘等</li><li><code>传输媒体</code>: 用于传输<strong>表示媒体</strong>，将表示媒体从一处传送到另一处的物理载体。如双绞线、同轴电缆、光纤等</li></ul><h4 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h4><ul><li><strong><code>多媒体</code></strong>是指信息<strong>表示媒体</strong>的多样化，包括文本、图形、图像、声音、音乐、动画、视频等，即多媒体<strong>主要研究表示媒体</strong>。</li><li>性质：<ul><li>多媒体是多种信息载体的<strong>表现</strong>形式、<strong>存储</strong>和<strong>传输</strong>方式的有机集合</li><li>多媒体系统具有<strong>多样性</strong>、<strong>集成性</strong>、<strong>实时性</strong>和<strong>交互性</strong></li></ul></li></ul><h4 id="多媒体系统的体系结构"><a href="#多媒体系统的体系结构" class="headerlink" title="多媒体系统的体系结构"></a>多媒体系统的体系结构</h4><p><img src="/media/体系结构.png" width="30%"></p><ul><li><strong>多媒体应用系统</strong> / 多媒体应用软件：利用多媒体工具软件，针对某一主题<strong>设计开发的具体多媒体应用系统</strong>。</li><li><strong>多媒体创作系统</strong> / 多媒体应用系统开发软件：集成文本、图形、声音、图像、视频和动画等多种媒体信息的编辑和著作工具，是开发多媒体应用系统的平台或环境，可以用于<strong>生成各种多媒体应用系统</strong>。</li><li><strong>媒体制作平台与工具</strong> / 多媒体素材创作软件：利用本层提供的工具及接口可以完成多媒体数据的采集、制作及编辑。</li><li><strong>多媒体核心系统</strong> / 多媒体系统软件：提供硬件层上的基础服务，拥有一系列的服务软件，包括对多种硬件设备的连接、控制，对用户使用的语言环境的支持和解释。其核心是<strong>多媒体操作系统</strong>，还包括<strong>设备驱动程序</strong></li><li><strong>多媒体计算机硬件系统</strong>：包括多媒体计算机<strong>主机系统</strong>（MPC）及各种外围设备的<strong>接口部件</strong>。</li><li><strong>多媒体外围设备</strong>：包括音频、视频等多种媒体的<strong>输入/输出设备和装置</strong>，通信（网络）<strong>传输设备及装置</strong></li></ul><h2 id="2-图形图像技术"><a href="#2-图形图像技术" class="headerlink" title="2. 图形图像技术"></a>2. 图形图像技术</h2><h4 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h4><ul><li>图形（矢量图）是用一系列计算机指令来表示一幅图，如画点、画线、画曲线、画圆、画矩形等。例如，一条直线可以用Line (1,1 5,5)表示（计算机中描述方式？）</li><li>优点<ul><li>存储和传输时数据量较小</li><li>缩放、旋转、移动图形不会失真，能保证质量（可无级缩放）</li><li>适合管理图形的每一部分</li><li>编辑方便</li><li>图块可重用</li></ul></li><li>缺点<ul><li>图形重生成花费时间较长 </li><li>不适合描述彩色图像</li></ul></li></ul><h4 id="图像-位图"><a href="#图像-位图" class="headerlink" title="图像 / 位图"></a>图像 / 位图</h4><ul><li>将一幅图像在<strong>空间</strong>上<strong>离散化</strong>为多个<strong>像素</strong>，每个像素用若干个二进制位来描述其<strong>颜色、亮度和属性</strong></li><li>位图的获取通常使用扫描仪、数码相机、数码摄像机</li><li>优点<ul><li>显示速度快</li><li>表现力强，可适于任何自然图像，细腻、层次多、细节丰富</li></ul></li><li>缺点<ul><li>存储和传输时数据量比较大</li><li>缩放、旋转时算法复杂且容易失真</li><li>矢量图和位图之间可以进行转换</li><li>由矢量图转换成位图采用光栅化技术，转换也相对容易</li><li>由位图转换成矢量图用跟踪技术</li></ul></li></ul><h4 id="采样与量化"><a href="#采样与量化" class="headerlink" title="采样与量化"></a>采样与量化</h4><ul><li>在用计算机进行处理时，需要<strong>对连续信号离散化</strong>。包括空间、时间、幅值上的离散化</li><li>其中<strong>空间/时间</strong>离散称为<strong>采样</strong>，<strong>幅值离散</strong>称为<strong>量化</strong></li><li><p>离散化后的连续信号还需要进行<strong>编码</strong>，以便计算机存储、处理和传输</p></li><li><p>对量化后的数据编码、压缩，生成不同多媒体信息的表示媒体，可以采用多种方案。思考：什么是编码？编码是否等同于压缩？</p><ul><li>对于数据编码不一定压缩数据，但压缩数据的结果一定是一种编码，即编码可以分为非压缩编码和压缩编码</li><li>压缩可以在编码前进行，也可以在编码后针对编码结果进行压缩得到另一种编码</li></ul></li><li><p>输入矢量图时是否需要采样、量化和编码？为什么？</p><ul><li>矢量图在表示方式上采用数学描述，因此在输入时不需要采样和量化，但在计算机内部有其自身的编码方式</li></ul></li></ul><h4 id="颜色模型"><a href="#颜色模型" class="headerlink" title="颜色模型"></a>颜色模型</h4><ul><li><strong><code>RGB</code></strong>：R，G，B分别代表红、绿、蓝三色，<strong>相加混色模型</strong>。用于显示设备。(从黑色开始加)</li><li><strong><code>CMYK</code></strong>：印刷四分色模式，<strong>相减混色模型</strong>。用于打印设备。（从白色开始减）</li><li><strong><code>HSL</code></strong>：H(色调)、S(饱和度)、I(光强度)这3个分量来表示一种颜色。用于人眼。</li><li><strong><code>Lab</code></strong>：颜色-对立空间，带有维度L表示亮度，a和b表示颜色对立维度，<strong>所生成的颜色与所使用的设备无关</strong>。用途：Lab模式可以用作为在不同颜色模式之间转换时使用的中间颜色模式。</li><li><strong><code>Index</code></strong>：索引色彩模式用<strong>8bit</strong>描述，最多可以使用<strong>256种颜色</strong>，采用调色板方式实现。用于减小图片文件的大小，同时基本上不影响视觉效果。(不是真的彩色)</li><li><strong><code>Grayscale</code></strong>：灰度模式用<strong>8bit</strong>描述，最多使用<strong>256级灰度</strong>来表现图像，图像中的每个像素有一个0（黑色）到255（白色）之间的亮度值。主要用于医学、图像识别领域。</li><li><strong><code>Binary</code></strong>：二值图像是每个像素只有两个可能值的数字图像(黑、白)。主要用于数字图像处理研究。</li></ul><blockquote><p>索引色彩模式和灰度模式中，每个像素值都占用一个字节，为什么一种为彩色？一种不为彩色？<br>索引彩色有调色板，灰度模式没有，且灰度模式的索引8bit就是灰度值本身灰度模式和索引色彩模式归为同一类。</p></blockquote><h4 id="位图图像基本属性"><a href="#位图图像基本属性" class="headerlink" title="位图图像基本属性"></a>位图图像基本属性</h4><ul><li><strong>分辨率</strong><ul><li>图像分辨率：构成图像的像素总数，以水平和垂直的像素表示。</li><li>显示分辨率：在某种显示方式下，在屏幕上最大的显示区域中，可显示的像素总数。</li></ul></li><li><strong>颜色深度：</strong>图像每个像素所占用的存储位数。它决定了彩色图像中最多能使用的颜色数，或者灰度图像中最多能有的灰度级数</li><li><strong>调色板：</strong><ul><li>一个彩色图像假如只包含24位真彩色空间中的16个离散的点（16色图），则可以建立一个颜色查找表，表中的每一行记录一组RGB值。</li><li>实际像素的值用来指定该点颜色在查找表中的索引值，这样就可以大大缩小存储量。这个颜色查找表就叫做调色板</li></ul></li><li><strong>真彩色、伪彩色与直接色</strong> (不考)<ul><li>真彩色：在组成一幅彩色图像的每个像素值中，有R，G，B三个基色分量，每个基色分量直接决定显示设备的基色强度。</li><li>伪彩色：把像素值当作彩色查找表(调色板)的表项入口地址，去查找一个显示图像时使用的R，G，B强度值，用查找出的R，G，B强度值产生的彩色。</li><li>直接色：每个像素值分成R，G，B分量，每个分量作为单独的索引值对它做变换。也就是通过相应的彩色变换表找出基色强度，用变换后得到的R，G，B强度值产生的彩色称为直接色</li></ul></li><li><strong>位图图像数据量</strong><ul><li>位图图像数据量计算公式B = (h <em> w </em> c ) / 8 (Byte)</li><li>其中，h:垂直分辨率，w:水平分辨率，c:颜色深度</li><li>例：一副大小为640X480，256色彩色图像，其数据量为：B =（ 640 × 480 × 8 ) / 8 = 307, 200字节</li></ul></li></ul><h4 id="BMP图像文件格式"><a href="#BMP图像文件格式" class="headerlink" title="BMP图像文件格式"></a>BMP图像文件格式</h4><ul><li>BMP图像文件格式：<ul><li>采用位映射存储格式</li><li>图像颜色深度可选lbit、4bit、8bit及24bit</li><li>不采用其他任何压缩（？）</li><li>包含的图像信息较丰富</li><li>占用磁盘空间过大，不利于网络传输</li><li>存储数据时，图像的扫描方式是按<strong>从左到右、从下到上</strong>的顺序</li></ul></li><li><p>BMP文件由4个部分组成：</p><ol><li>位图文件头</li><li>位图信息头</li><li>颜色表</li><li>图像数据阵列字节</li></ol></li><li><p>有哪些不同类型的图形/图像文件？为什么有这些不同的类型？各自有何特点？</p></li></ul><h2 id="3-音频技术"><a href="#3-音频技术" class="headerlink" title="3. 音频技术"></a>3. 音频技术</h2><ul><li>声音、语音、音乐的区别和联系？<ul><li>声音是统称，或专指除语音、音乐之外的其它声音。</li><li>语音是声音的一种特殊类型，因为人类语音的频率范围小于声音的频率范围，且具有独特的发音特点。</li><li>音乐也是声音的一种特殊类型，主要是指MIDI音乐。</li></ul></li></ul><h4 id="声音的听觉心理特性"><a href="#声音的听觉心理特性" class="headerlink" title="声音的听觉心理特性"></a>声音的听觉心理特性</h4><ul><li>音调：声音的高低。由声音的(基)频率决定</li><li>音强（响度）：表示人们所感觉到的声音能量的强弱，主要取决于声波振幅的大小。可听声音的强度范围是0-120dB</li><li>响度的特性：响度与人耳的可闻程度有关<ul><li>人耳的可听频率范围外，声音的响度再大，人耳也无法察觉</li><li>人耳的可听频域范围内，当声音弱或强到一定程度，人耳都无法听到</li></ul></li><li>等响曲线：人类感受不同频率声音时，其所感知的相同响度对应的声音能量是不同的，由此构成了等响曲线。</li><li>听阈：人能听到的最低声压级</li><li>痛阈：当声压级增大到一定强度时，人耳会感到不适或疼痛。</li></ul><h4 id="掩蔽效应："><a href="#掩蔽效应：" class="headerlink" title="掩蔽效应："></a>掩蔽效应：</h4><ul><li>一种频率的声音阻碍听觉系统感受另一种频率的声音的现象。人的耳朵只对最明显的声音反应敏感，而对于不明显的声音，反应则较不敏感</li><li>前者称为掩蔽声音，后者称为被掩蔽声音</li><li>应用此原理，人们发明了mp3等<strong>压缩的数字音乐格式</strong>，在这些格式的文件里，只突出记录了人耳朵较为敏感的中频段声音，而对于较高和较低的频率的声音则简略记录，从而大大压缩了所需的存储空间<ul><li>频域掩蔽：指一个<strong>强纯音</strong>会掩蔽在其附近同时发声的弱纯音。</li><li>时域掩蔽：指在<strong>时间上相邻的声音之间</strong>也有掩蔽现象。</li></ul></li></ul><h4 id="声音信号数字化"><a href="#声音信号数字化" class="headerlink" title="声音信号数字化"></a>声音信号数字化</h4><ul><li>声音如何数字化？  <ul><li>与模拟图像数字化相似，声音数字化包括<strong>采样、量化和编码</strong></li></ul></li><li><strong>采样</strong>：将声音信号<strong>在时间上离散化</strong>，即每隔相等的一段时间抽取一个信号样本</li><li><strong>量化</strong>：将连续的信号<strong>幅度离散化</strong>。<ul><li>如果幅度的划分是等间隔的，称为线性量化/均匀量化。</li><li>否则为非线性量化/非均匀量化。</li></ul></li><li><strong>编码</strong>：按<strong>一定的格式</strong>将离散的数字信号记录下来，并在数据的前、后加上同步、纠错等控制信号</li></ul><h4 id="影响数字音频质量的技术参数"><a href="#影响数字音频质量的技术参数" class="headerlink" title="影响数字音频质量的技术参数"></a>影响数字音频质量的技术参数</h4><ul><li>数字音频的质量取决于：<strong>采样频率、采样精度/量化位数和声道数</strong></li></ul><h4 id="采样数据量-考试不用计算，考算式"><a href="#采样数据量-考试不用计算，考算式" class="headerlink" title="采样数据量(考试不用计算，考算式)"></a>采样数据量(考试不用计算，考算式)</h4><ul><li><strong>声音采样数据量 (字节) = 采样频率 × 采样精度 / 8 × 声道数 × 采样时间</strong></li><li>为了减少数据量，采样且量化后的数据常要进行压缩编码（将在第5章介绍）</li><li>eg. <strong>1分钟</strong>的<strong>双声道声音</strong>，采用不同采样频率和精度所需的存储容量例如，采用<strong>44.1kHz采样频率</strong>和<strong>16位采样精度</strong>时，数字化后需要的存贮容量为：<strong>44.1 × 16 / 8 × 2 × 60 = 10584(字节)</strong></li></ul><h4 id="语音"><a href="#语音" class="headerlink" title="语音"></a>语音</h4><ul><li>以语音的基本特性为基础，主要针对语音的成分进行相应处理，包括语音<strong>采样、识别、模拟、合成</strong>等技术</li><li><strong>语音识别和语音合成</strong>技术是实现人机语音通信的两项关键技术</li></ul><h4 id="MIDI音乐"><a href="#MIDI音乐" class="headerlink" title="MIDI音乐"></a>MIDI音乐</h4><ul><li>数字音乐是一种音乐语言；数字音乐编码。</li><li>MIDI：电子乐器数字接口</li><li><strong>MIDI音乐是一种数字音乐</strong>，MIDI音乐通常被称为<strong>电子音乐或合成音</strong>乐，它也是声音的一种，但是这种声音与流行的乐器有关，例如，钢琴、提琴、长号、鼓等乐器。</li><li>优点：<ul><li>生成的文件比较小，一个六分多钟、有16个乐器的文件只有80多KB（为什么？）</li><li>容易编辑</li><li>可以作背景音乐</li></ul></li></ul><ul><li>缺点：<ul><li>播放效果因软、硬件而异。好的播放效果必须支持波表功能</li><li>录制较复杂，需要学习一些使用MIDI创作并改编作品的专业知识，还须有专门工具，如键盘合成器</li></ul></li></ul><h4 id="音频文件的格式"><a href="#音频文件的格式" class="headerlink" title="音频文件的格式"></a>音频文件的格式</h4><ul><li>WAV</li><li>MIDI：MIDI文件储存着MIDI资料和命令。</li><li>MP3：利用了<strong>知觉音频编码技术</strong>，削减了音乐中人耳所听不到的成分，尽可能保持原有的音质。</li><li>MP3PRO：降低压缩比</li><li>ra(RealAudio) &amp; rm(RealMedia)：网络流媒体文件格式</li><li>Windows Media</li></ul><h2 id="4-动画视频技术"><a href="#4-动画视频技术" class="headerlink" title="4. 动画视频技术"></a>4. 动画视频技术</h2><ul><li>动态图像：由多幅连续的图像构成的序列称为动态图像</li><li>原理：它利用了人眼的视觉暂留性</li></ul><h4 id="动态图像的特点"><a href="#动态图像的特点" class="headerlink" title="动态图像的特点"></a>动态图像的特点</h4><ul><li><strong>时间连续性</strong>：动态图像具有时间连续性</li><li><strong>数据量大</strong>：数据量更大</li><li><strong>相关性强</strong>：动态图像的帧与帧之间具有很强的相关性。据研究，相邻帧之间有10%以下的像素有亮度变化，1%以下的像素有色度变化(注：该性质在动态图像压缩中具有重要作用。为什么？)@<strong>“为什么”考试</strong></li><li><strong>实时性高</strong>：动态图像对实时性要求高，必须在规定的时间内完成更换画面播放的过程</li></ul><h4 id="动画文件的格式"><a href="#动画文件的格式" class="headerlink" title="动画文件的格式"></a>动画文件的格式</h4><ul><li>GIF</li><li>SWF</li><li>FLI/FLC</li></ul><h4 id="视频文件格式"><a href="#视频文件格式" class="headerlink" title="视频文件格式"></a>视频文件格式</h4><ul><li>微软的AVI </li><li>苹果公司的MOV</li><li>MPEG</li><li>RealNetwork公司的RM</li><li>ASF、 WMV</li></ul><h2 id="5-多媒体数据压缩技术"><a href="#5-多媒体数据压缩技术" class="headerlink" title="5. 多媒体数据压缩技术"></a>5. 多媒体数据压缩技术</h2><h3 id="5-1-数据压缩的基本原理和方法"><a href="#5-1-数据压缩的基本原理和方法" class="headerlink" title="5.1 数据压缩的基本原理和方法"></a>5.1 数据压缩的基本原理和方法</h3><h4 id="多媒体数据压缩的必要性和可能性"><a href="#多媒体数据压缩的必要性和可能性" class="headerlink" title="多媒体数据压缩的必要性和可能性"></a>多媒体数据压缩的必要性和可能性</h4><ul><li>必要性<ul><li>数字化后的图像、视频和音频等媒体信息的海量性</li><li>计算机存储资源和网络带宽难以满足需要</li><li>导致多媒体数据存储和传输的困难</li><li>结论：多媒体数据需要压缩</li></ul></li><li>可能性<ul><li>多媒体数据冗余：统计冗余（空间冗余、时间冗余）、结构冗余、知识冗余、感知冗余（视觉冗余、听觉冗余）</li><li>信息表达冗余：信息熵冗余</li></ul></li></ul><h4 id="数据冗余"><a href="#数据冗余" class="headerlink" title="数据冗余"></a>数据冗余</h4><ul><li><strong>统计冗余</strong> <ul><li>时间冗余: 一段视频的前后相邻的2帧中会有大量的区域有相同或相近的数据，形成帧间的数据冗余。</li><li>空间冗余: 在同一个静态图像或画面中，有部分区域数据值一样或相差不大，形成空间冗余。</li></ul></li><li>结构冗余：有些图像存在着明显的分布模式</li><li>知识冗余：许多图像的理解与某些基础知识有相当大的相关性。如人脸的图像有固定的结构。 </li><li><strong>感知冗余</strong><ul><li>视觉冗余</li><li>听觉冗余</li></ul></li><li><strong>信息熵冗余</strong>：信息的表达存在冗余。<ul><li>信息熵：一组数据所携带的<strong>平均信息量</strong>（不确定性的度量）</li><li>平均信息量乘以数据的个数，就是整个一组数据的信息量</li></ul></li></ul><blockquote><ul><li>存在数据冗余，才可能进行数据压缩</li><li>某些数据冗余是多媒体数据所特有的</li><li>针对不同数据冗余，设计不同数据压缩方法</li></ul></blockquote><h4 id="信源符号，码元，码字"><a href="#信源符号，码元，码字" class="headerlink" title="信源符号，码元，码字"></a>信源符号，码元，码字</h4><ul><li>对于<strong>消息集</strong>中的<strong>信源符号</strong>使用<strong>符号集</strong>中的<strong>码元</strong>进行编码，得到<strong>输出集（码书）</strong>中的与信源符号<strong>一一对应</strong>的<strong>码字</strong></li><li>信源符号，码元，码字（要求信源符号和码字一一对应）<ul><li>英文字母，0和1，ASCII码</li><li>数字，0和1，ASCII码</li><li>汉字，0和1，GB2312码</li></ul></li><li><strong>压缩目标：</strong>用尽量短的码字表达信源符号，且一一对应</li><li>按照单个英文字母或单个汉字，与按照单词或词组，<strong>信源符号的个数不同</strong></li><li>不同环境下的信源符号、码元、码字，<strong>同一符号可能分别为信源符号或码元</strong></li></ul><h4 id="感知冗余"><a href="#感知冗余" class="headerlink" title="感知冗余"></a>感知冗余</h4><ul><li>视觉冗余（是否知道有哪些？）<ul><li><strong>亮度和色度的差别</strong>：人眼<strong>对亮度的敏感性比色度要强</strong>，所以在色度成分上，可以不要保留太多细节，这样可以使色度成分中出现更多的冗余。</li><li><strong>高亮度区和非高亮度区差别</strong>：在高亮度区，人眼的敏感度会下降。灰度值的量化可以更粗糙些，<strong>人类视觉系统一般分辨能力约为2<sup>6</sup>灰度等级，而一般图像量化采用2<sup>8</sup>灰度等级</strong>。</li><li><strong>边缘和非边缘区别</strong>:人眼对急剧色彩和亮度变化的<strong>物体边缘</strong>的敏感度比非边缘区域强<br>听觉冗余（在“音频数据压缩技术”中介绍）</li></ul></li></ul><h4 id="数据压缩方法分类"><a href="#数据压缩方法分类" class="headerlink" title="数据压缩方法分类"></a>数据压缩方法分类</h4><ul><li>根据解码（解压缩）后数据与原始数据是否完全一致，数据压缩方法分为两类<ul><li><strong>可逆编码</strong>(无失真编码，无损编码）：解码数据与原始数据（数字而非模拟）严格相同  </li><li><strong>不可逆编码(</strong>有失真编码，有损编码）： 解码数据与原始数据存在一定的误差，但感知效果一般可以接受。常用的有<strong>变换编码和预测编码</strong>等。</li></ul></li><li>根据数据压缩的原理可以分为<ul><li><strong>统计编码</strong>（<strong>针对信息熵冗余</strong>，即信息表达冗余）</li><li><strong>预测编码</strong>（<strong>针对统计冗余</strong>，即多媒体信号的相关性）</li><li><strong>变换编码</strong>（<strong>针对感知冗余</strong>，即多媒体信号的人类感知冗余）</li><li><strong>其他编码</strong></li></ul></li><li><strong>通用无损数据压缩</strong><ul><li>研究中发现，大多数信息表达都存在着一定的冗余度，通过采用一定的模型和编码方法，可以降低这种冗余度。</li><li><strong>eg.</strong> Huffman编码，算术编码，词典式编码，LZ78，LZW，ZIP格式。</li></ul></li><li><strong>(专用)多媒体数据压缩</strong><ul><li>采用成熟的通用数据压缩技术进行压缩</li><li>根据<strong>媒体信息的特性</strong>设计新的压缩方法</li><li><strong>eg.</strong> RLE编码(游程编码，适合压缩具有面积重复的颜色块的图像)，预测编码，变换编码</li></ul></li><li>数据压缩方法评价<ul><li><strong>压缩比</strong>（压缩效果：要求压缩比高</li><li><strong>算法复杂性和运算速度</strong>（压缩效率）：要求算法简单，压缩和解压缩速度快，最好能实时解压</li><li><strong>失真度</strong>（压缩质量）：要求恢复效果好</li><li>三个指标相互制约</li></ul></li></ul><h3 id="5-2-统计编码"><a href="#5-2-统计编码" class="headerlink" title="5.2 统计编码"></a>5.2 统计编码</h3><h4 id="统计编码的基本原理"><a href="#统计编码的基本原理" class="headerlink" title="统计编码的基本原理"></a>统计编码的基本原理</h4><ul><li>数据压缩技术的理论基础是<strong>信息论</strong>，根据信息论的原理，<strong>数据压缩的理论极限是信息熵</strong></li></ul><ul><li>如果要求编码过程中不<strong>丢失信息量（无损编码）</strong>，即要求保存信息熵，这种信息保持编码叫<strong>熵编码（统计编码）</strong></li><li>信息论认为信源中存在的冗余度来自于<strong>信源本身的相关性</strong>和<strong>信源概率分布的不均匀性</strong></li><li>熵编码（统计编码）要解决的问题是，如何利用信息熵理论<strong>减少数据在存储和传输中的冗余度</strong>。也就是要找到<strong>去除信源的相关性和概率分布的不均匀性</strong>的方法</li><li>无损压缩编码</li><li>根据信源符号出现概率的分布特性进行编码<ul><li><strong>概率大</strong>的信源符号用<strong>短码字</strong>表示</li><li><strong>概率小</strong>的信源符号用<strong>长码字</strong>表示</li><li>从而去除数据之间的冗余而达到压缩的目的</li></ul></li><li>统计编码需要在信源符号和码字之间确定严格的一一对应关系，以便准确无误地再现原来信源，同时使平均码长尽量小</li><li>如果所有的信源符号出现的概率相同，则说明平均信息量最大，也就不存在信源的冗余<ul><li>游程（RLE）编码</li><li>Huffman编码</li><li>算术编码</li></ul></li></ul><h4 id="游程（RLE）编码"><a href="#游程（RLE）编码" class="headerlink" title="游程（RLE）编码"></a>游程（RLE）编码</h4><ul><li>不需要存储每一个像素的颜色值，而仅仅存储一个像素的颜色值，以及具有相同颜色的连续像素数目</li><li>即，将颜色值相同的相邻像素用一个计数值和那些像素的颜色值来代替<ul><li>例如:aaabccccccddeee，则可用3a1b6c2d3e来代替</li></ul></li></ul><ul><li><strong>游程长度</strong>：具有相同颜色并且是连续的像素数目</li><li>对于拥有大面积，相同颜色区域的图像，用RLE压缩方法非常有效</li><li>无损压缩编码</li></ul><ul><li><strong>RLE压缩编码特点</strong><ul><li>直观，经济</li><li><strong>压缩比的大小，主要取决于图像本身的特点。</strong>如果图像中具有相同颜色的图像块越大，图像块数目越少，获得的压缩比就越高。反之，压缩比就越小</li><li><strong>适用于计算机生成的图像</strong>，但对颜色丰富的自然图像不仅不能压缩图像数据，反而可能使原来的图像数据变得更大。</li></ul></li></ul><h4 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h4><ul><li>统计编码，针对信息熵冗余，无损压缩编码</li><li>1952年为文本文件建立</li><li>编码方法简单且有效，得到广泛应用，现在已经派生出很多变体。</li><li><strong>基本原理</strong>：<ul><li>使用<strong>变长编码</strong>，对出现概率大的<strong>信源符号</strong>赋于短码字，而对于出现概率小的<strong>信源符号</strong>赋于长码字</li><li>如果码字长度严格按照所对应符号出现概率大小逆序排列，则编码结果平均码字长度一定小于任何其它排列方式。</li></ul></li><li><strong>步骤</strong>：<ol><li>将信源符号按概率递减顺序排列；</li><li>把二个最小概率相加作为新符号的概率, 并按(1)重排；</li><li>重复 (1)、(2)，直到概率为1；</li><li>在每次合并信源时,将合并的信源分别赋“0”和“1”(例如概率大的赋“0”,概率小的赋“1”)；</li><li>寻找从每一信源符号到概率为1处的路径，记录下路径上的“1”和“0”；</li><li>写出每一符号的“1”、“0”序列(从树根到信源符号节点)。<br><img src="/media/huf.png" width="50%"></li></ol></li><li>特点<ul><li>Huffman编码是最佳变长码，其优点是<strong>编码效率高</strong></li><li>Huffman编码<strong>依赖于信源的统计特性</strong></li></ul></li><li>Huffman编码是否只能得到唯一编码结果？<ul><li>由于“0”和“1”的指定可以是任意的，所以Huffman编码所得到的编码不是唯一的。</li><li>各次累加时对于信源符号可以任意指定0或1，并非一定要所有大概率信源符号使用相同编码，所有小概率信源符号使用相同编码。因为最终是以查表的方式查找信源符号的码字。</li></ul></li><li>Huffman编码结果是否需要考虑如何区分不同字符的编码？<ul><li>Huffman编码不需要附加同步代码，任何一个字符的编码，都不是另一个字符编码的前缀</li></ul></li><li>Huffman编码如何解码？特别是对于自适应概率模型解码？<ul><li>查表。因此在<strong>解码时需要有编码时采用的Huffman表</strong>，才能正确解码、</li><li>如果信源符号数（例如，汉字？）很大，需要存储的码表（码书）也需很大，从而会影响存储量、编码以及解码速度等各个方面的性能。</li></ul></li><li>根据Huffman编码得到的消息编码序列，是否可以从中间开始解码？<ul><li>Huffman编码是可变长度码，很难随意查找或调用压缩文件中间的内容</li></ul></li><li>Huffman编码没有错误保护功能，会出现错误传播</li><li>总结<ul><li>信源符号的概率统计模型 → Huffman表</li><li>编码：消息（由信源符号组成） → 根据Huffman表对于消息中的信源符号逐个编码  →  消息编码</li><li>解码：消息编码 → 根据Huffman表对于消息编码逐个解码 → 信源符号 → 消息</li></ul></li></ul><h4 id="算术编码"><a href="#算术编码" class="headerlink" title="算术编码"></a>算术编码</h4><ul><li>统计编码，针对信息熵冗余，无损压缩编码。</li><li>常用于图像数据压缩标准(如JPEG，JBIG)中</li><li><strong>基本原理</strong>：将出现概率较多的<strong>“消息”</strong>(可以是字符或字符串) (Huffman编码针对信源符号) ，用尽可能少的位或字节来表示。</li><li>算术编码是一种变长码，主要针对出现概率高的消息序列标识的信息进行压缩。<ul><li>信源符号是表达消息的符号</li></ul></li><li>算术编码用到的两个基本的参数是<strong>符号的概率</strong>和它的<strong>编码间隔</strong>。<ul><li>信源符号的概率决定压缩编码的效率，也决定编码过程中信源符号的间隔。</li><li>间隔则决定了符号压缩后的输出</li></ul></li><li>算术编码区别于Huffman编码的是，它是<strong>根据信源符号估计出各个元素的概率</strong>，然后进行<strong>迭代计算</strong>。而不像Huffman编码必须预先得知信源的出现概率。</li><li>将编码的消息表示成实数0和1之间的一个间隔，<strong>消息越长，编码表示它的间隔就越小，表示这一间隔所需的二进制位就越多</strong>。</li><li><strong>步骤</strong><ul><li>两个基本的参数：符号的概率和编码间隔(在0到1之间)。令概率为p<sub>1</sub>,p<sub>2</sub>,…p<sub>n</sub>（其和为1），则编码间隔为［0,p<sub>1</sub>) 、[p<sub>1</sub>，p<sub>1</sub>+p<sub>2</sub>）…[p<sub>1</sub>+p<sub>2</sub>+…p<sub>n-1</sub>，1）</li><li>令high为间隔的高端，low为低端，range为间隔的长度，rangelow为编码字符分配的间隔低端，rangehigh为编码字符分配的间隔高端。</li><li>初始<strong>high=1，low=0，range = high-low</strong></li><li>计算一个字符编码后新的low和high：<br><strong>low = low + range×rangelow</strong><br><strong>high = low + range×rangehigh</strong><br><img src="/media/算数编码.jpg" width="100%"></li></ul></li><li><strong>特点：</strong><ul><li>算术编码的精度在64位以内，对于运算中的溢出问题，可使用比例缩放方法解决</li><li>在解码器中<strong>需要添加一个专门的终止符</strong>，当解码器看到终止符时就停止解码，否则可以无穷尽地解码。</li><li>算术编码器对整个消息只产生一个码字，这个码字是在间隔[0，1）中的<strong>一个实数</strong>，解码器在接受到表示这个实数的所有位之前不能进行解码</li><li>算术编码也是一种<strong>对错误很敏感的编码方法</strong></li><li>算术编码可以<strong>是静态的或者自适应</strong>的。在静态算术编码中，信源符号的概率是固定的。但事先很难知道精确的信源概率。最有效的方法是在编码过程中估算概率，这就是自适应算术编码，信源符号的概率根据编码时符号出现的频繁程度动态地进行修改，也就是在编码期间估算信源符号概率建模。</li><li><strong>信源符号概率接近时，建议使用算术编码</strong>，这种情况下其效率高于Huffman编码(约5%) 。</li></ul></li></ul><h3 id="5-3-词典编码"><a href="#5-3-词典编码" class="headerlink" title="5.3 词典编码"></a>5.3 词典编码</h3><ul><li>词典编码：在不知数据统计特性的前提下的通用编码算法<ol><li>用已经出现过的字符串替代重复的部分，输出仅仅是指向早期出现过的字符串的“指针”。eg. <strong>LZ77算法</strong></li><li>创建一个“短语词典”。编码中遇到已在词典中出现的“短语”时，输出词典中的短语的“索引号” 。eg. <strong>LZ78算法</strong>，改进后为LZW压缩编码。</li></ol></li></ul><h4 id="LZW压缩编码算法"><a href="#LZW压缩编码算法" class="headerlink" title="LZW压缩编码算法"></a>LZW压缩编码算法</h4><ul><li>查找冗余字符和用较短的符号标记替代冗余字符</li><li>压缩效率较高（思考：为什么？）</li><li>无损压缩编码<ul><li>LZ77  →  LZ78  →  LZW</li></ul></li><li><strong>特点：</strong><ul><li>处理过程比其他压缩过程复杂，但过程完全可逆</li><li>对于简单图像和平滑且噪音小的信号源具有较高的压缩比，并且有<strong>较高的压缩和解压缩速度</strong>。对机器硬件条件要求不高</li><li>可压缩<strong>任何类型和格式的数据</strong>。</li><li>有错误传播（虽然是定长编码，但在解码过程中需要生成词典。如果存在错误，可能导致生成词典出错，甚至无法生成词典）</li></ul></li></ul><h4 id="各种编码方式的比较"><a href="#各种编码方式的比较" class="headerlink" title="各种编码方式的比较"></a>各种编码方式的比较</h4><p><img src="/media/编码.png" width="80%"></p><h3 id="预测编码-amp-变换编码"><a href="#预测编码-amp-变换编码" class="headerlink" title="预测编码 &amp; 变换编码"></a>预测编码 &amp; 变换编码</h3><ul><li>预测编码：根据离散信号之间存在一定的<strong>相关性</strong>的特点，利用前面的一个或多个信号对下一个信号进行<strong>预测</strong>，然后对实际值和预测值的<strong>差值</strong>进行<strong>编码</strong>。<ul><li>针对<strong>统计冗余</strong></li><li>有损压缩编码</li><li>适合于声音和图像数据的压缩</li></ul></li><li>变换编码：对欲编码的原始数据所在的时间或空间域<strong>进行某种数学变</strong>换，从一种信号空间变换到另一种信号空间，产生一批<strong>变换系数</strong>，使得通过变换后<strong>能够突出原始数据中的重要部分</strong>，以便重点处理。然后再对这些系数进行编码处理。<ul><li>数据变换的方式有：傅立叶变换、沃尔什变换、正弦变换、余弦变换、斜变换、哈尔变换、K-L变换等</li><li>针对<strong>感知冗余</strong></li><li>有损压缩编码</li><li>常用于音频信号压缩编码和图像/视频信号压缩编码</li></ul></li></ul><h3 id="5-4-音频信号压缩技术"><a href="#5-4-音频信号压缩技术" class="headerlink" title="5.4 音频信号压缩技术"></a>5.4 音频信号压缩技术</h3><ul><li>音频编译码器的分类<ul><li><strong>波形编译码器</strong>：不利用生成话音的信号的任何知识，将话音视为一种普通的声音，直接对波形信号进行采样和量化。 <strong>eg.PCM、DPCM、ADPCM等</strong></li><li>音源编译码器 / 参数编译码器 / 声码器：它从话音波形信号中提取话音生成模型的参数，使用这些参数通过话音生成模型重构出话音。</li><li><strong>混合编译码器</strong>：综合使用上述两种技术。使用的激励信号波形尽可能接近于原始话音信号的波形。<strong>eg. CELP， MPEGⅠ中的音频部分是一种混合编码</strong></li></ul></li></ul><h4 id="两类压缩"><a href="#两类压缩" class="headerlink" title="两类压缩"></a>两类压缩</h4><ul><li><strong>模拟信号转换为数字信号</strong><ul><li>降低采样频率，减少量化位数</li><li>音频信号编码，PCM、DM、DPCM</li></ul></li><li><strong>针对数字信号</strong><ul><li>统计编码，词典编码。无损。通用压缩编码</li><li>预测编码，变换编码。有损。多媒体数据专用压缩编码</li></ul></li></ul><h2 id="6-多媒体数据压缩标准"><a href="#6-多媒体数据压缩标准" class="headerlink" title="6. 多媒体数据压缩标准"></a>6. 多媒体数据压缩标准</h2><h3 id="6-1-图像数据压缩标准"><a href="#6-1-图像数据压缩标准" class="headerlink" title="6.1 图像数据压缩标准"></a>6.1 图像数据压缩标准</h3><h4 id="JPEG算法特点"><a href="#JPEG算法特点" class="headerlink" title="JPEG算法特点"></a>JPEG算法特点</h4><ul><li>JPEG是一个适用范围很广的静态图像数据压缩标准，既可用于<strong>灰度图像</strong>又可用于<strong>彩色图像</strong>（为什么？） <ul><li><strong>JPEG算法与色彩空间无关</strong>，因此“RGB到YUV变换”和“YUV到RGB变换”不包含在JPEG算法中。JPEG算法处理的彩色图像是单独的彩色分量图像，因此<strong>它可以压缩来自不同彩色空间的数据</strong>，如RGB, YCbCr和CMYK</li></ul></li><li>通常使用YUV模式（为什么？）<ul><li>JPEG不仅适于<strong>静止图像</strong>的压缩，<strong>电视图像的帧内图像的压缩编码</strong>，也常采用此算法（作为动态图像压缩的一个组成部分）</li></ul></li><li>JPEG标准还可以大范围地<strong>调节</strong>图像压缩比及其保真度（如何调节？）<ul><li>JPEG中的有损压缩利用了人的视觉系统的特性，使用<strong>变换编码+量化</strong>和<strong>无损压缩编码</strong>相结合来去掉<strong>视觉的冗余信息和数据本身的冗余信息</strong></li></ul></li></ul><h4 id="JPEG压缩编码算法的主要步骤"><a href="#JPEG压缩编码算法的主要步骤" class="headerlink" title="JPEG压缩编码算法的主要步骤"></a>JPEG压缩编码算法的主要步骤</h4><ol><li>图像分块<ul><li>分为8x8图像块；相关性强，标准化，计算量的考虑。</li></ul></li><li><strong>正向离散余弦变换(FDCT)</strong><ul><li>区分重要信息和次要信息 </li></ul></li></ol><ul><li>量化<ul><li>减小非“0”系数的幅度以及<strong>增加“0”值系数的数目</strong>。</li><li>重要系数和次要系数采用不同的量化步长。分别处理，量化表可以不同，可调节压缩比和压缩质量。</li><li>不能使用一个值作为所有系数的量化系数，需要体现相对于感知冗余的不同系数的不同重要性。</li></ul></li><li>Z字形编排<ul><li>增加0值系数的长度</li></ul></li><li>使用差<strong>分脉冲编码调制(DPCM)</strong>对直流系数(DC)进行编码<ul><li>直流DC系数特点：相关性预测编码</li><li>进一步压缩：预测编码，DPCM</li></ul></li><li>使用<strong>游程长度编码(RLE)</strong>对交流系数(AC)进行编码<ul><li>交流AC系数特点：0值系数较多</li><li>进一步压缩：RLE游程编码 </li></ul></li><li><strong>熵编码</strong></li><li>组成位数据流</li><li><strong>各种压缩技术的组合</strong></li></ul><h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><ol start="2"><li>为什么不使用整个图像而使用分块图像？<ul><li>局部图像的相关性比整体图像的相关性更强</li><li>算法标准化</li><li>计算量的考虑</li></ul></li></ol><ul><li>采样精度为P位(二进制)，把[0，2<sup>P-1</sup>]范围的无符号数变换成[-2<sup>P-1</sup>，2<sup>P-1</sup>-1]范围的有符号数（为什么？），作为正向离散余弦变换的输入，通过DCT变换，把能量集中在少数几个系数上。<ul><li>使得变换后的系数分布于[-2<sup>P-1</sup>，2<sup>P-1</sup>-1]</li></ul></li><li>对经过FDCT变换后的系数进行量化（为什么？）<ul><li>目的是减小非“0”系数的幅度以及增加“0”值系数的数目</li><li>量化是图像质量下降的最主要原因 </li></ul></li><li>对经过FDCT变换后的系数进行量化（为什么？）<ul><li>目的是减小非“0”系数的幅度以及增加“0”值系数的数目</li><li>量化是图像质量下降的最主要原因 </li></ul></li><li>量化后的系数按Z字形编排（为什么？）<ul><li>目的是为了增加连续的“0”系数的个数，就是“0”的游程长度</li></ul></li><li>变换编码提到通过正交变换减少相关性，为什么这里还有相关性存在并可以加以利用？<ul><li>DCT变换减少的是8×8块内部各像素之间的相关性，但各8×8块之间的相关性依然存在</li></ul></li><li>DC、AC系数表达的特点？如何进一步压缩？<ul><li>信息表达的冗余</li><li>熵编码，先转化为中间符号</li></ul></li></ul><h4 id="JPEG图像文件格式-amp-JPEG2000"><a href="#JPEG图像文件格式-amp-JPEG2000" class="headerlink" title="JPEG图像文件格式 &amp;  JPEG2000"></a>JPEG图像文件格式 &amp;  JPEG2000</h4><ul><li>JEPG文件大体上可以分成两个部分：<strong>标记码</strong>（tag）和<strong>压缩数据</strong><ul><li><strong>标记码部分给出了JPEG图像的所有信息</strong>，如图像的宽、高、Huffman表、量化表等等</li></ul></li><li>JPEG2000主要特点<ul><li><strong>高压缩率</strong>。在具有和传统JPEG类似质量的前提下，JPEG2000的<strong>压缩率比JPEG高30%左右</strong>。</li><li><strong>同时支持有损和无损压缩</strong></li><li><strong>渐进传输。</strong>即先传输图像的轮廓，然后逐步传输数据，不断提高图像质量，让图像由朦胧到清晰显示，以满足用户的需要。从而节约、充分利用有限的带宽。</li><li><strong>感兴趣区域压缩</strong>。即可以指定感兴趣区域，在这些区域，可以在压缩时指定特定的压缩质量，或在恢复时指定特定的解压缩要求。</li></ul></li></ul><h3 id="6-2-动态图像压缩标准MPEG"><a href="#6-2-动态图像压缩标准MPEG" class="headerlink" title="6.2 动态图像压缩标准MPEG"></a>6.2 动态图像压缩标准MPEG</h3><h4 id="MPEG-Video压缩技术基本方法"><a href="#MPEG-Video压缩技术基本方法" class="headerlink" title="MPEG-Video压缩技术基本方法"></a>MPEG-Video压缩技术基本方法</h4><ul><li>如何分别实现图像空间方向压缩和运动图像时间方向压缩？<ul><li>在<strong>空间方向</strong>上，图像数据压缩采用<strong>JPEG压缩算法</strong>来去掉冗余信息</li><li>在<strong>时间方向</strong>上，图像数据压缩采用<strong>运动补偿算法</strong>来去掉冗余信息</li></ul></li></ul><h4 id="MPEG定义的三种图"><a href="#MPEG定义的三种图" class="headerlink" title="MPEG定义的三种图"></a>MPEG定义的三种图</h4><ul><li><strong>I图像（帧内图）</strong><ul><li>采用帧内编码方式，即只利用了单帧图像内的空间相关性，而没有利用时间相关性</li><li>与JPEG压缩算法大致相同</li><li>压缩后每个像素为1～2bit</li><li><strong>一个内帧是一个随机访问点</strong></li><li><strong>可作为其它图像的参考帧</strong></li></ul></li><li><strong>P图像（预测图）</strong><ul><li>用最近的前一个I图像(或P图像)预测编码得到</li><li>只采用前向时间预测</li></ul><ul><li>可以提高<strong>压缩比和图像质量</strong></li><li><strong>可作为其它图像的参考帧</strong></li></ul></li><li><strong>B图像（插补图，即双向预测图）</strong><ul><li>B图像在预测时, 既可使用前一个图像作参照, 也可使用后一个图像做参照或同时使用前后两个图像作为参照图像(双向预测)</li><li>采用双向时间预测可以大大提高压缩比</li><li><strong>不可作为其它图像的参考帧</strong></li></ul></li><li>P图像和B图像采用帧间编码方式，即同时利用了空间和时间上的相关性</li></ul><h2 id="7-多媒体应用系统创作技术"><a href="#7-多媒体应用系统创作技术" class="headerlink" title="7. 多媒体应用系统创作技术"></a>7. 多媒体应用系统创作技术</h2><h4 id="多媒体应用系统设计基本过程"><a href="#多媒体应用系统设计基本过程" class="headerlink" title="多媒体应用系统设计基本过程"></a>多媒体应用系统设计基本过程</h4><ul><li>多媒体应用系统适用于各个领域，多媒体软件融图、文、声、像于一体，它的创作是一项系统工程，涉及到多种因素。</li><li>主要涉及到制作人员、制作环境和制作步骤三个方面</li><li>包含<strong>系统目标确定、编写系统脚本、进行脚本分析、脚本制作、脚本测试、系统评价</strong>等</li></ul><h4 id="多媒体系统创作工具"><a href="#多媒体系统创作工具" class="headerlink" title="多媒体系统创作工具"></a>多媒体系统创作工具</h4><ul><li>基于<strong>多媒体著作工具的多媒体系统创作</strong></li><li>包括：<ul><li>Hypercard</li><li>ToolBook</li><li>Authorware Professional</li><li>IconAuthor</li><li>Action</li><li>Director</li><li>PowerPoint</li><li>Animation Works Interactive</li><li>Storyboard</li><li>方正奥思多媒体创作工具</li><li>洪图多媒体编著系统</li></ul></li></ul><h4 id="多媒体程序设计基础"><a href="#多媒体程序设计基础" class="headerlink" title="多媒体程序设计基础"></a>多媒体程序设计基础</h4><ul><li>在Windows系统中，对多媒体设备进行控制主要有<strong>三种方法</strong>：<ul><li><strong>使用Microsoft提供的多媒体控制接口MCI</strong>，MCI是多媒体设备和多媒体应用软件之间进行设备无关的沟通的桥梁</li><li><strong>通过调用Windows的应用程序接口API多媒体相关函数</strong>实现媒体控制</li><li><strong>使用对象链接与嵌入OLE</strong>为不同软件之间共享数据和资源提供了有效的手段</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-引论&quot;&gt;&lt;a href=&quot;#1-引论&quot; class=&quot;headerlink&quot; title=&quot;1. 引论&quot;&gt;&lt;/a&gt;1. 引论&lt;/h2&gt;&lt;h4 id=&quot;媒体的分类&quot;&gt;&lt;a href=&quot;#媒体的分类&quot; class=&quot;headerlink&quot; title=&quot;媒体的分类&quot;&gt;&lt;/a&gt;媒体的分类&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;感觉媒体&lt;/code&gt;: 能直接作用于人的感官，使人直接产生感觉的一类媒体&lt;strong&gt;（作用于人）&lt;/strong&gt;。如人类的语言、音乐、自然界的各种声音、图形、图像。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;表示媒体&lt;/code&gt;: 计算机对信息的表示方法的描述。是&lt;strong&gt;为了加工、处理和传输感觉媒体&lt;/strong&gt;而人为研究、构造出来的一种媒体&lt;strong&gt;（作用于计算机)&lt;/strong&gt;。具体体现为：编码&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="软件工程" scheme="https://daisine.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="note" scheme="https://daisine.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记</title>
    <link href="https://daisine.github.io/ml/"/>
    <id>https://daisine.github.io/ml/</id>
    <published>2019-01-03T03:41:54.000Z</published>
    <updated>2019-05-10T11:33:11.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-机器学习概述"><a href="#0-机器学习概述" class="headerlink" title="0. 机器学习概述"></a>0. 机器学习概述</h2><h4 id="机器学习基本任务"><a href="#机器学习基本任务" class="headerlink" title="机器学习基本任务:"></a>机器学习基本任务:</h4><ul><li><strong>回归</strong>：<ul><li>能解决分类、预测问题。</li><li>eg. 年龄估计、表情分析<a id="more"></a></li></ul></li><li><strong>分类</strong>：<ul><li>分类、识别、检测</li></ul></li><li><strong>聚类</strong>：<ul><li>分割(图像、视频)、背景建模</li><li>数据挖掘、数据恢复</li><li>字典学习(视觉信息，文本)</li></ul></li><li><strong>表征</strong>：<ul><li>特征提取(便于前三个任务解决)</li><li>数据重构</li><li>信息检索</li></ul></li></ul><h4 id="方法分类-根据学习形式"><a href="#方法分类-根据学习形式" class="headerlink" title="方法分类(根据学习形式)"></a>方法分类(根据学习形式)</h4><ul><li><strong>有监督学习</strong><ul><li>数据都有明确的标签，根据机器学习产生的模型可以将新数据分到一个明确的类或得到一个预测值。</li><li>eg. 支持向量机、贝叶斯分类器、决策树、线性判别分析…….</li></ul></li><li><strong>无监督学习</strong><ul><li>数据没有标签，机器学习出的模型是从数据中提取出来的模式(提取决定性特征或者聚类等)</li><li>eg. K均值、Meanshift、主成分分析、典型相关分析</li></ul></li><li><strong>半监督学习</strong><ul><li>部分数据有明确的标签，根据机器学习产生的模型可以将新数据分到一个明确的类或得到一个预测值。</li><li>eg. 图直推学习、超图直推学习……</li></ul></li></ul><h4 id="数据划分"><a href="#数据划分" class="headerlink" title="数据划分"></a>数据划分</h4><ul><li>训练集：用来训练模型或确定模型参数。</li><li>测试集：测试已经训练好的模型的推广能力。</li><li>验证集(可选)：用来做模型选择，即做模型的最终优化及确定的。</li></ul><h4 id="误差与精度"><a href="#误差与精度" class="headerlink" title="误差与精度"></a>误差与精度</h4><ul><li>误差：学习器的实际预测输出与 样本的真实输出之间的差异。</li><li>错误率：被错误分类的样本在总样本中的比例。</li><li>精度：被正确分类的样本在总样本中的比例，即1 – error rate。</li><li>训练误差：学习器在训练集上的误差。</li><li>经验误差：即训练误差</li><li>泛化误差：在新样本的误差，实际误差!</li><li>测试误差：学习器在测试集上的误差，用来近似泛化误差。</li></ul><h4 id="过拟合与欠拟合"><a href="#过拟合与欠拟合" class="headerlink" title="过拟合与欠拟合"></a>过拟合与欠拟合</h4><ul><li>过拟合(Overfitting): 为了得到一致假设而使假设变得<strong>过度严格</strong>。</li><li>欠拟合(Underfitting): 模型没有很好地捕捉到数据特征，<strong>不能够很好地</strong>拟合数据</li></ul><h4 id="数据集划分策略"><a href="#数据集划分策略" class="headerlink" title="数据集划分策略"></a>数据集划分策略</h4><ul><li>数据集划分策略：利用测试集或验证集评估学习器的泛化 误差，进而进行模型优化与选择，避免 过拟合。</li><li>常见划分策略:<ul><li>留出法</li><li>交叉验证法</li><li>自助法</li></ul></li><li>数据集划分各子集之间<strong>不能有重合</strong>。</li><li><strong><code>留出法</code></strong><ul><li>直接将数据集D划分为两个互斥的集合，分别为训练集S与测试集T，即 D = S T， S T =  。</li><li>训练/测试集划分尽量保持数据一致性。</li><li>采用合理的采样，合理控制训练集与测试集比例。</li><li>多次使用留出法，重复进行试验评估，求均值，减少数据分布差异造成的偏差。</li></ul></li><li><strong><code>交叉验证法</code></strong><ul><li>n-折交叉验证法：数据集等 分为n份相互不重叠的子集，每次以其中1份子集作为 测试集，其余n-1份子集作为训练集，重复n次，<strong>直至所有子集都作为测试集进行过一次实验评估</strong>，最后返 回n次实验评估的平均结果。常见n取值2、5、10、20。</li><li>交叉验证是最常见数据集划分方法。</li></ul></li><li><strong><code>留一法</code></strong><ul><li>特殊的交叉验证法，每个被划分的子集只有一个样本。</li><li>优点：训练集比例高，训练出来模型与用所有数据进行训练的模型<strong>相似度高</strong>。</li><li>缺点：评估开销大；测试集比例太低，模型调参不便。 </li></ul></li><li><strong><code>自助法</code></strong><ul><li>假设一个由m个样本组成数据集D，对其进行m次<strong>随机采样</strong>构造一个由m个样本组成新数据集D’, 由于m次随机采样可能会对D中部分样本重复采样，所以D’中有部分样本是完全相同，而D中 有部分样本是没有被采样到数据集D’中。因此我们可以把D中这部分<strong>没有被采样到样本D\D’构造测试集， 而D’作为训练集。</strong></li><li>这种没被采样到样本在数据集D中比例一般占 25%~36.8%之间。</li><li>自助法通常用于<strong>数据集较小或难以有效划分训练/测试集情况。</strong></li></ul></li></ul><h4 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h4><ul><li>真正例TP 真反例TN 假正例FP 假反例FN<ul><li>(TP+FN)+(TN+FP) = P + N = 样本总数</li></ul></li><li><strong>均方误差</strong>：多用于度量学习器解决<strong>回归任务</strong>的性能。</li><li><strong>错误率与精度</strong>：多用于评估分类任务的性能。</li><li><strong>查准率、查全率与F1</strong> ：<ul><li>查准率：被正确分类的正例样本在被学习器分类为正例样本中所占的比例。</li><li>查全率：被正确分类的正例样本在正例样本中的比例。</li><li>查全率与查准率是一对相互矛盾的度量。</li></ul></li><li><strong>ROC与AUC</strong><ul><li>二分类问题的性能度量：根据置信度对样本进行降序排序… </li><li>受试者工作特征(ROC)曲线</li><li>AUC：ROC曲线下的面积</li></ul></li></ul><h2 id="1-线性回归"><a href="#1-线性回归" class="headerlink" title="1. 线性回归"></a>1. 线性回归</h2><ul><li>损失函数<ul><li>平方损失函数</li><li>绝对损失函数</li><li>平均损失函数</li></ul></li><li><strong><code>单变量回归模型</code></strong><br><img src="/ml/线性1.png" width="50%"><img src="/ml/线性3.png" width="50%"></li><li><strong><code>多元线性回归</code></strong><br><img src="/ml/线性2.png" width="50%"><br><img src="/ml/线性4.png" width="50%"><img src="/ml/线性5.png" width="50%"></li><li>概率解释<ul><li>似然函数</li><li><strong>极大似然法</strong>：令每个样本x<sub>i</sub>输出为y<sub>i</sub>的概率越大越好。</li></ul></li><li>回归任务的思想：分析变量之间的关系</li><li>定义了损失函数来评估线性回归模型的好坏：平方损失函数、极大似然函数。</li><li>线性回归函数中两个参数的显示表达：最小二乘法(向量与矩阵形式)</li><li>线性回归算法可以对数据进行分析、预测。</li><li>线性回归的概率解释：极大似然法</li></ul><h2 id="2-逻辑回归"><a href="#2-逻辑回归" class="headerlink" title="2. 逻辑回归"></a>2. 逻辑回归</h2><ul><li>逻辑回归与线性回归的区别与联系：<ul><li>逻辑回归是用于解决二分类问题的机器学习方法。</li><li>线性回归要求因变量是连续性数值变量，逻辑回归要求因变量是分类型变量。</li></ul></li><li>逻辑回归的损失函数：<strong>分类损失函数</strong> </li><li><strong>求解无约束优化问题</strong>：<ul><li>数值方法I：<strong>牛顿法</strong> -&gt; 方程求根问题 / 最小化问题</li><li>数值方法II：<strong>梯度下降法</strong> y<sub>n</sub>是第n步下降时选取的步长，也称学习旅率。</li></ul></li><li>掌握梯度下降法、牛顿法的基本原理与迭代公式：<br><img src="/ml/牛顿.png" width="50%">  </li></ul><h2 id="3-决策树"><a href="#3-决策树" class="headerlink" title="3. 决策树"></a>3. 决策树</h2><ul><li>决策树：构建一个基于属性的<strong>树形分类器</strong>。<ul><li>每个非叶节点表示一个特征属性上的测试(分割)。</li><li>每个分支代表这个特征属性在某个值域上的输出。</li><li>每个叶节点存放一个类别。</li></ul></li><li>使用决策树进行决策的过程：<ul><li>从根节点开始，测试待分类项中相应的特征属性，并按照其值选择输出分支，直到到达叶子节点，将叶子节点存放的类别作为决策结果。</li></ul></li><li>决策树构建：<strong>分治法思想(递归)</strong></li><li>对于当前结点<strong>返回递归条件</strong> / <strong>递归结束条件</strong>:<ul><li>当前结点样本均属于同一类别，无需划分。</li><li>当前属性集为空。</li><li>所有样本在当前属性集上取值相同，无法划分。 </li><li>当前结点包含的样本集合为空，不能划分。</li></ul></li></ul><h4 id="决策树的核心"><a href="#决策树的核心" class="headerlink" title="决策树的核心"></a>决策树的核心</h4><ul><li>定义最佳划分属性:<ul><li>经过属性划分后，不同类样本被更好的分离。</li><li>理想情况:划分后样本被完美分类。即每个分支的样本都属于同一类。</li><li>实际情况:不可能完美划分。尽量使得每个分支某一类样本比例尽量高，即尽量提高划分后子集的纯度(purity)。</li></ul></li><li>最佳划分属性目标: <ul><li>提升划分后子集的纯度</li><li>降低划分后子集的不纯度</li></ul></li></ul><h4 id="ID3决策树算法"><a href="#ID3决策树算法" class="headerlink" title="ID3决策树算法"></a>ID3决策树算法</h4><ul><li>我们希望决策树的分支节点所包含的样本尽可能属于同一类别，即结点的“纯度”越来越高。</li><li>纯度 ↑ = 确定性 ↑ = 信息量 ↓ </li><li><strong><code>信息熵</code></strong>：<strong>度量样本集合纯度</strong>最常用的一种指标。<ul><li>假定当前样本集合D中第k类样本所占的比例为p<sub>k</sub>(k = 1, 2, …, |y|)，则D的信息熵为：<br><img src="/ml/信息熵.png" width="30%"></li><li>信息熵用来度量信息量，<strong>信息熵值越小，说明样本集的纯度越高。</strong></li></ul></li><li><strong><code>信息增益</code></strong>：<br><img src="/ml/信息增益.png" width="50%"></li><li>ID3决策树算法：<strong>利用</strong>划分后的<strong>信息增量来判断</strong>属性划分的优劣性。<ul><li><strong>信息增益越大，说明当前划分效果越好。</strong></li><li>信息增量准则对可取值数目较多的属性有所偏好。 eg. 每个学号因为只有一个样本，纯度都很高。</li></ul></li></ul><h4 id="C4-5决策树算法"><a href="#C4-5决策树算法" class="headerlink" title="C4.5决策树算法"></a>C4.5决策树算法</h4><ul><li><strong><code>增益率</code></strong>：越大越好<br><img src="/ml/增益率.png" width="50%"></li><li>采用此新准则的方法称为C4.5决策树算法。</li></ul><h4 id="CART决策树算法"><a href="#CART决策树算法" class="headerlink" title="CART决策树算法"></a>CART决策树算法</h4><ul><li><strong><code>基尼指数</code></strong>：越小 -&gt; 纯度越高 -&gt; 越好<br><img src="/ml/gini.png" width="40%"></li></ul><h4 id="决策树的裁剪"><a href="#决策树的裁剪" class="headerlink" title="决策树的裁剪"></a>决策树的裁剪</h4><ul><li>剪枝处理：避免训练<strong>过拟合</strong>。 </li><li><strong><code>预剪枝</code></strong>：指<strong>在决策树生成过程中</strong>，对每个结点在划分前后进行估计，若当前结点划分不能提升决策树泛化性能，则进行裁剪，把结点标记为叶结点。<ul><li>优点: 减少属性划分与测试时间开销。 </li><li>缺点: 可能造成欠拟合。</li></ul></li><li><strong><code>后剪枝</code></strong>：在<strong>生成一颗完整的决策树后</strong>，<strong>自底向上</strong>地对非叶结点进行考察，若将该结点对应的子树被替换为叶节点能提升决策树泛化能力，则进行裁剪。<ul><li>优点: 减少欠拟合风险。 </li><li>缺点: 时间开销大。</li></ul></li></ul><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul><li>决策树ID3算法能不能进一步优化? <ul><li>𝐺𝑎𝑖𝑛𝐷,𝑎 = 𝑬𝒏𝒕𝑫 − 𝐸𝑛𝑡𝐷,𝑎 减少开销</li></ul></li><li>如何设计自己决策树算法?<ul><li>设计自己的划分属性优劣性目标函数。</li></ul></li><li>现有决策树框架的分类是否是全局最优? <ul><li>决策树采用<strong>贪心法则</strong>，只得<strong>局部最优</strong>。</li></ul></li><li>如何提升决策树算法框架的性能?<ul><li>融入随机性，提升泛化能力，Eg.<strong>随机森林</strong>。</li></ul></li><li>划分属性优劣度量(重点) <ul><li>ID3算法：信息增益</li><li>C4.5算法：增益率 </li><li>CART算法：基尼指数</li></ul></li></ul><h2 id="4-感知机"><a href="#4-感知机" class="headerlink" title="4. 感知机"></a>4. 感知机</h2><h4 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h4><ul><li>感知机由两层神经元组成，输入层接受外界输入信号后传递给输出层，输出层是M-<br>本质上, M-P神经元 = <strong>线性二分类</strong>器</li><li>感知机能容易地实现逻辑与、或、非运算。 <strong>P99</strong>(感知机<strong>不能解决异或</strong>这样的非线性可分问题)</li><li>感知机只有输出神经元进行激活函数处理，即只拥有一层功能神经元。<ul><li>只能解决线性可分问题：存在一个线性超平面将他们分开，感知机的学习过程收敛。</li><li>否则感知机学习过程会发生振荡。</li></ul></li></ul><h4 id="多层神经网络"><a href="#多层神经网络" class="headerlink" title="多层神经网络"></a>多层神经网络</h4><ul><li>非线性可分问题：多层功能神经元。</li><li>多层网络的<strong>权重优化法则</strong>：<strong>误差逆传播(简称BP)算法</strong>。</li></ul><h4 id="BP算法-P101"><a href="#BP算法-P101" class="headerlink" title="BP算法 P101"></a>BP算法 P101</h4><ul><li>基于梯度下降策略，是一个迭代学习算法。</li><li>核心思想：利用前向传播，计算第 𝑛 层输出值。</li><li>优化目标：输出值和实际值的残差。(最小化训练集D上的累积误差)</li><li>计算方法：将残差按影响逐步传递回第 𝑛 −1, 𝑛 − 2, ⋯ , 2层，以修正各层参数。(即所谓的误差逆传播)</li><li>主要工具：链式法则(复合函数求偏导)。</li><li>BP算法局限性<ul><li>容易过拟合 -&gt; 早停、正则化</li><li>容易陷入局部最优 -&gt; 选取多次初值、随机梯度下降法</li><li>难以设置隐层个数 -&gt; 试错法</li></ul></li></ul><h2 id="5-神经网络"><a href="#5-神经网络" class="headerlink" title="5. 神经网络"></a>5. 神经网络</h2><ul><li>神经网络: 神经网络是由具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实世界物体所做的交互反应。<br><img src="/ml/神经元.png" width="60%"><ul><li>Sigmoid函数 ≠ Logistic函数</li><li>Logistic函数 ⊂ Sigmoid函数</li></ul></li></ul><h2 id="6-支持向量机-SVM模型"><a href="#6-支持向量机-SVM模型" class="headerlink" title="6. 支持向量机(SVM模型)"></a>6. 支持向量机(SVM模型)</h2><h4 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h4><ul><li>离分类边界远的样本的置信度高，而离分类边界近的样本置信度低。</li><li>SVM是一个凸的带不等式约束的凸二次规划问题</li><li><strong>基本思想：</strong>寻找两类样本之间最中间的直线。</li><li><strong>目的：</strong>使划分平面对于样本的扰动容忍性好。</li><li>对比：<ul><li>逻辑回归算法是基于全部样本的二分类器：考虑<strong>全部样本的平均似然性</strong>。</li><li>支持向量机算法是基于部分样本的二分类器：考虑<strong>部分靠近边界</strong>的支持向量。</li></ul></li></ul><h4 id="拉格朗日乘子法"><a href="#拉格朗日乘子法" class="headerlink" title="拉格朗日乘子法"></a>拉格朗日乘子法</h4><ul><li>拉格朗日乘子法：求解约束优化问题常用的方法之一。</li><li>基本思想：<strong>求解与之等价的无约束对偶问题</strong>。</li><li>较之原问题来说，对偶问题可能更方便求解。</li><li>较之原问题来说，对偶问题也可能更有意义。</li><li>原问题和对偶问题等价的充分必要条件被称作KKT条件</li></ul><h4 id="SVM对偶模型"><a href="#SVM对偶模型" class="headerlink" title="SVM对偶模型"></a>SVM对偶模型</h4><ul><li>可以利用拉格朗日乘子法得到SVM的对偶模型。</li><li>对偶模型更能反映该问题的特点，只有支持向量才对优化问题起作用。</li><li>求解对偶模型的比求解原问题简单，计算复杂度更低。</li></ul><h4 id="软间隔SVM"><a href="#软间隔SVM" class="headerlink" title="软间隔SVM"></a>软间隔SVM</h4><ul><li>前面的讨论一直假定训练样本在样本空间或者特征空间中是线性可分的，即存在一个超平面能将不同的类的样本完全划分开。</li><li>在现实任务重很难确定合适的核函数使得训练集在特征空间中线性可分。<ul><li>缓解该问题的一个办法是允许支持向量机在一些样本上出错。</li><li>硬间隔：要求所有样本均满足约束。</li><li>软间隔：允许某些样本不满足约束。在最大化间隔的同时，不满足约束的样本应该尽可能少。</li></ul></li><li>软间隔SVM三种常见的替代损失函数：<ul><li>hinge损失</li><li>指数损失</li><li>对率损失</li></ul></li><li>软间隔SVM可以对有outlier的数据分类。<ul><li>软间隔SVM对偶模型与SVM对偶模型非常相似，可以用相同算法求解。</li><li>软间隔SVM模型可以看作是最小化hinge损失函数的正则化模型。</li><li>当参数C趋向无穷大时，软间隔SVM退化成普通的SVM。</li></ul></li></ul><h4 id="SMO算法"><a href="#SMO算法" class="headerlink" title="SMO算法"></a>SMO算法</h4><ul><li>SMO的两个部分:<ul><li>解析地求解两个变量二次规化问题。</li><li>启发式地选择变量。</li></ul></li><li>SMO小结<ul><li>序列极小化优化算法(SMO)是求解SVM模型最高效的算法。</li><li>SMO每次迭代解两个变量的二次优化问题，其最优解可以显式表达。</li><li>SMO利用了启发式算法根据数据点违反KKT条件的大小选取需要迭代的变量。</li></ul></li></ul><h4 id="非线性SVM-核化SVM-P126"><a href="#非线性SVM-核化SVM-P126" class="headerlink" title="非线性SVM / 核化SVM P126"></a>非线性SVM / 核化SVM P126</h4><ul><li>核技巧是处理非线性分布数据处理问题最常见的方法之一。</li><li>核技巧最早出线在SVM模型中，随后在许多机器学习领域都有应用。。</li><li>核化SVM的效果主要取决于核函数的选取。</li></ul><h4 id="支持向量回归SVR-P133"><a href="#支持向量回归SVR-P133" class="headerlink" title="支持向量回归SVR P133"></a>支持向量回归SVR P133</h4><ul><li>线性回归问题<ul><li>寻找最佳直线(超平面)，使得预测值𝒇(𝒙𝒊 )和真实标签的均方误差尽量小。</li></ul></li><li>支持向量机思想<ul><li>寻找最佳直线(超平面)，使得数据点到直线的间隔尽可能的大。</li></ul></li></ul><h2 id="7-K-均值-聚类"><a href="#7-K-均值-聚类" class="headerlink" title="7. K-均值(聚类)"></a>7. K-均值(聚类)</h2><h4 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h4><ul><li>聚类：根据某种<strong>相似性</strong>，把一组数据<strong>划分</strong>成<strong>若干个簇</strong>的过程。<ul><li>难点一:相似性很难精准定义! <strong>各种距离，度量学习</strong>。 </li><li>难点二:可能存在的划分太多! <strong>避免穷举，优化算法</strong>。 </li><li>难点三: 若干个簇 = ? <strong>预先给定，算法自适应</strong>。</li></ul></li></ul><h4 id="K-means-K均值算法"><a href="#K-means-K均值算法" class="headerlink" title="K-means / K均值算法"></a>K-means / K均值算法</h4><ul><li>聚类问题可以通过为每个簇簇的中心寻找合适的中心来实现。</li><li>假设每个簇的中心已经找到， 可以把所有数据点分配到距离它最近的中心所在的簇。</li><li>K-means模型可能的划分数：<strong>非凸组合优化问题</strong>，NP-难</li><li>求解非凸组合优化问题的两种常见方法:<ul><li><strong>启发式方法</strong>: 一个基于直 观或经验构造的算法，在可接受的时间内下 给出待解决组合优化问题每一个实例的一个 可行解，该可行解与最优解的偏离程度一般不能被预计。</li><li><strong>松弛方法</strong>: 对组合优化问题进行适当的松弛，将其转化为多项式时间内可解的优化问题，松弛后问题的解不是原组合优化问题的解，需要适当的后处理。</li></ul></li></ul><h4 id="K-means模型的矩阵形式"><a href="#K-means模型的矩阵形式" class="headerlink" title="K-means模型的矩阵形式"></a>K-means模型的矩阵形式</h4><ul><li>对于任意一种划分都对应一个<strong>标准化示性矩阵 H</strong>(或<strong>均一化邻接矩阵 W</strong> )。</li><li>反之，任意一个标准化示性矩阵 H (或均一化邻接矩阵 W )都对应着<strong>一种划分</strong>。</li><li>本质上说，标准化示性矩阵 H(或均一化邻接矩阵 W ) 的引入并没有简化聚类问题的难度，但是<strong>为求解方法提供了更多的参考和选择</strong>。</li></ul><h4 id="Lloyd算法"><a href="#Lloyd算法" class="headerlink" title="Lloyd算法"></a>Lloyd算法</h4><p> <img src="/ml/lloyd.png" width="50%"><img src="/ml/lloyd2.png" width="50%"></p><ul><li>优势：<ul><li>Lloyd 算法属于EM算法(期望最大化)，可以保证收敛到K-means问题的局部最优解。</li><li>Lloyd 算法的速度快，计算复杂度为O(nk)。</li><li>Lloyd 算法思想简单，容易实现，可拓展性强。</li></ul></li><li>劣势:<ul><li>簇的个数k需要预先给定。</li><li>聚类结果依赖于初值的选取。</li></ul></li></ul><h2 id="8-谱聚类-聚类"><a href="#8-谱聚类-聚类" class="headerlink" title="8. 谱聚类(聚类)"></a>8. 谱聚类(聚类)</h2><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><ul><li>输入: 数据矩阵 X，簇个数 k。<ul><li>构建邻接矩阵W。</li><li>计算<strong>拉普拉斯矩阵L</strong>。 </li><li>计算L最小k个特征值对应的特征向量U。</li><li>对U进行<strong>K-means</strong>聚类。</li></ul></li><li>输出: k 个簇。</li></ul><h4 id="谱聚类和K-means的关系"><a href="#谱聚类和K-means的关系" class="headerlink" title="谱聚类和K-means的关系"></a>谱聚类和K-means的关系</h4><ol><li>相比直接进行K-means聚类，谱聚类有什么不同?<ul><li>相当于<strong>先做了一次特征提取</strong>，再聚类。</li></ul></li><li>谱聚类背后的机理是什么? <ul><li>图论中的<strong>切割图问题。</strong></li></ul></li></ol><h2 id="9-降维"><a href="#9-降维" class="headerlink" title="9. 降维"></a>9. 降维</h2><h4 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h4><ul><li>为什么要降维?<ul><li>去除不相关的特征(去噪、特征提取) </li><li>储存与计算</li><li>可视化</li><li>数据本身具有低维特点</li></ul></li><li>线性降维方法:<ul><li>PCA </li><li>LDA </li><li>SVD </li><li>NMF</li></ul></li><li>非线性降维方法:<ul><li>Kernel PCA </li><li>Isomap</li><li>MDS</li></ul></li></ul><h4 id="主成分分析-PCA"><a href="#主成分分析-PCA" class="headerlink" title="主成分分析 PCA"></a>主成分分析 PCA</h4><blockquote><p><strong>思想</strong>: 假设降维的目的是解决维度灾难，在低维空间进行分类。那么我们希望降维后的样本保持<br>一定的可分性，即经过投影之后，同类样本的投 影点尽可能接近，异类样本的投影点尽可能远离。</p><blockquote><p><strong>解决方案</strong>: 让投影后的<strong>类中心之间的距离尽可能大</strong>，从而增强样本的可分性。</p></blockquote></blockquote><ul><li>PCA: 最大可分性<br><img src="/ml/pca.png" width="50%"><img src="/ml/pca2.png" width="36%"></li><li>PCA在考虑数据降维时候希望在新空间的信息越多 越好，即低维嵌入的方差(协方差矩阵的迹)越大。</li><li>PCA是一个<strong>无监督降维方法</strong>，并没有运用任何有监督信息，这也是PCA算法一个弊端。</li><li>对于一个分类问题，保留信息越多分类效果一定 会更好么?<ul><li>不一定，分类效果完全取决样本在新的子空间下的<strong>可区分度</strong>。</li></ul></li></ul><h4 id="线性判别分析-LDA"><a href="#线性判别分析-LDA" class="headerlink" title="线性判别分析 LDA"></a>线性判别分析 LDA</h4><ul><li>对于二维数据来说，线性判别分析(Linear Discriminant Analysis)同时最大化类间散度矩阵，最小化类内散度矩阵。</li><li><strong>目标函数</strong>通常被成为<strong>广义瑞利商</strong>，最优解为广义特征值问题。<ul><li>可以构建拉格朗日函数 -&gt; 𝓛对变量𝒘求偏导 -&gt; 对偶问题</li></ul></li><li>此模型的<strong>最优解有无穷多个</strong>(对最优解w进行任意缩放)。<ul><li>如何<strong>定义聚合程度和扩散程度</strong>?   方差<strong>(协方差矩阵)</strong></li><li>如何保证样本点尽量聚合？  所有点接近<strong>中心点</strong>。</li><li>如何便于分类? <strong>同类样本应具有较好的聚合度，而类别之间应该具有较好的扩散度。</strong></li></ul></li><li>LDA算法流程：<br><img src="/ml/lda.png" width="36%"> </li></ul><h4 id="LDA-vs-PCA"><a href="#LDA-vs-PCA" class="headerlink" title="LDA vs PCA"></a>LDA vs PCA</h4><ul><li>相同点:<ul><li>都属于降维方法。</li><li>都转化为求解特征值问题。 </li><li>都可以使用核化技巧。</li></ul></li><li>不同点:<ul><li>PCA是非监督降维，LDA是监督降维。</li><li>PCA效率比LDA更高</li><li>PCA旨在寻找一组子坐标系(定义一个子空间)<strong>使得样本点的方差最大</strong>，即信息量保留越多。LDA旨在寻找一组子坐标系(定义一个子空间)<strong>使得样本点类内散度越小</strong>，类间散度越大。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-机器学习概述&quot;&gt;&lt;a href=&quot;#0-机器学习概述&quot; class=&quot;headerlink&quot; title=&quot;0. 机器学习概述&quot;&gt;&lt;/a&gt;0. 机器学习概述&lt;/h2&gt;&lt;h4 id=&quot;机器学习基本任务&quot;&gt;&lt;a href=&quot;#机器学习基本任务&quot; class=&quot;headerlink&quot; title=&quot;机器学习基本任务:&quot;&gt;&lt;/a&gt;机器学习基本任务:&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;回归&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;能解决分类、预测问题。&lt;/li&gt;
&lt;li&gt;eg. 年龄估计、表情分析&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="软件工程" scheme="https://daisine.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="note" scheme="https://daisine.github.io/tags/note/"/>
    
      <category term="机器学习" scheme="https://daisine.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学笔记及练习</title>
    <link href="https://daisine.github.io/CG/"/>
    <id>https://daisine.github.io/CG/</id>
    <published>2018-12-21T03:01:18.000Z</published>
    <updated>2019-05-10T10:55:48.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-计算机图形学概述"><a href="#1-计算机图形学概述" class="headerlink" title="1. 计算机图形学概述"></a>1. 计算机图形学概述</h2><h3 id="1-1-研究内容"><a href="#1-1-研究内容" class="headerlink" title="1.1 研究内容"></a>1.1 研究内容</h3><ul><li><code>图形</code>含有几何属性，或者说更强调场景的集合表示，是由场景的几何模型和警务的物理属性共同组成。（矢量/参数）</li><li><code>图像</code>是指计算机内以位图形式存在的灰度信息。（位图）</li><li><code>计算机图形学</code>：利用计算机研究一系列原理、方法与技术的学科。<a id="more"></a> <ul><li>图形的表示和生成：如何对数据建模，并将数据转换为图像？</li><li>图形的处理和显示：如何在专门的显示设备上显示图形？</li></ul></li><li>一个完整的图形处理过程包括：<ul><li>图形的输入</li><li>图形的处理</li><li>图形的输出</li></ul></li></ul><h3 id="1-2-计算机图形学的发展历史"><a href="#1-2-计算机图形学的发展历史" class="headerlink" title="1.2 计算机图形学的发展历史"></a>1.2 计算机图形学的发展历史</h3><ul><li>50年代，CTR的出现为计算机生成和显示图形提供了可能。</li><li>50年代末期，MIT的林肯实验室在“旋风”计算机上开发SAGE空中防御体系，通过光笔在屏幕上指点与系统交互，<strong>标志着交互式图形技术的诞生。</strong></li><li>60年代<ul><li>MIT林肯实验室的<strong>I. E. Sutherland</strong>发表了一片题为“<strong>Sketchpad：一个人机交互通信的图形系统</strong>”的博士论文，确定了交互图形学作为一个学科分支。</li><li>法国雷诺汽车公司的工程师Pierre Bezier提出 Bezier曲线、曲面的理论，而称为计算机辅助几何设计(CAGD)的先驱。</li><li>MIT的教书 Steven A. Coons提出了超限插值的新思想，通过插值四条任意便捷的曲线来构造曲面，</li></ul></li><li>70年代<ul><li>光栅图形学迅速发展</li><li>图形软件标准化：ISO发布CGI、CGM、GKS、PHIGS</li><li>真实感图形学和实体造型技术：(1970)Bouknight提出第一个光反射模型；(1971)Gourand提出“漫反射模型 + 插值”的思想，被称为Gourand明暗处理；(1975)Phong提出著名的简单光照模型-Phong模型。</li></ul></li></ul><h3 id="1-3-图形软件发展及软件标准的形成"><a href="#1-3-图形软件发展及软件标准的形成" class="headerlink" title="1.3 图形软件发展及软件标准的形成"></a>1.3 图形软件发展及软件标准的形成</h3><ul><li>近二十年，国际标准化组织ISO已经批准和正在讨论的与计算机图形有关的标准有：<ul><li>GKS、GKS-3D、PHIGS、CGM、CGI、IGES、STEP</li></ul></li><li>事实标准<ul><li>SGI的OpenGL，微软的Direct X，Adobe的Postscript等。  </li></ul></li></ul><h3 id="1-4-当前研究热点"><a href="#1-4-当前研究热点" class="headerlink" title="1.4 当前研究热点"></a>1.4 当前研究热点</h3><ul><li>造型技术</li><li>真实感图形绘制技术</li><li>人机交互技术</li><li>与计算机网络技术的紧密结合<ul><li>远程导航与维修</li><li>远程教育</li></ul></li><li>图像生成技术与图像处理的结合</li><li>虚拟现实技术</li></ul><h3 id="1-5-图形系统"><a href="#1-5-图形系统" class="headerlink" title="1.5 图形系统"></a>1.5 图形系统</h3><p>一个图形系统通常由：图形处理器、图形输入设备和图形输出设备构成。</p><h5 id="图形输入设备"><a href="#图形输入设备" class="headerlink" title="图形输入设备"></a>图形输入设备</h5><ul><li>鼠标</li><li>键盘：输入控制命令，利用光标指示对象与位置。</li><li>光笔：一种检测光的装置。P13 <strong>考核原理，判断正误</strong></li><li>数字化仪：数控板/手写板</li><li>扫描仪：直接把图形和图像扫描到计算机中以像素信息进行存储的设备。 <ul><li>光学信号 -&gt; 模拟信号 -&gt; 数字信号</li></ul></li><li>触摸屏，3D图形输入设备</li></ul><h5 id="图形处理器-显卡"><a href="#图形处理器-显卡" class="headerlink" title="图形处理器(显卡)"></a>图形处理器(显卡)</h5><ul><li>显示主芯片是显卡的核心，俗称GPU</li><li>显存用于存储将要现实的图形信息及保存图形运算的中间数据。</li></ul><h5 id="图形显示设备"><a href="#图形显示设备" class="headerlink" title="图形显示设备"></a>图形显示设备</h5><ul><li>图形输出包括图形的显示和图形的绘制<ul><li><code>图形显示</code>指的是在屏幕上输出图形。</li><li><code>图形绘制</code>通常指把图形画在纸上(硬拷贝)，如打印机和绘图仪</li></ul></li><li>显示器分类：<ul><li>CRT显示器</li><li>平板显示器</li></ul></li></ul><h5 id="阴极射线管-CRT-P9"><a href="#阴极射线管-CRT-P9" class="headerlink" title="阴极射线管(CRT) P9"></a>阴极射线管(CRT) P9</h5><ul><li>CRT显示器分类<ul><li>视觉属性：单色CRT，彩色CRT</li><li>偏转系统：偏转电场式，偏转磁场式</li><li>扫描方式：随机扫描，光栅扫描  </li></ul></li><li>组成：<ul><li>电子枪</li><li>聚焦系统</li><li>加速电极</li><li>偏转系统</li><li>荧光屏</li></ul></li><li>工作原理<ul><li>电子枪发射电子束</li><li>经过聚焦系统、加速电极、偏转系统，轰击到荧光屏的不同部位，被其表面的荧光物质吸收，发光产生可见的图形。</li><li>为要保持一幅稳定的画面，必须不断地发射电子束(<strong>不断刷新</strong>)，以抵消亮度的衰减。 </li></ul></li><li>电子枪 <ul><li>阴极：电流通过，灯丝加热，发出电子束。</li><li>控制栅：通过调节负电压来控制电子数量，即控制荧光屏上相应点的亮度。</li></ul></li><li>聚焦系统：通过电场和磁场控制电子束变细，保证亮点足够小，提高分辨率。</li><li>加速电极：加正的高电压(几万伏)，使电子达到轰击激发荧光屏应有的速度</li><li>偏转系统<ul><li>控制静电场或磁场，使电子束偏转。</li><li>最大的偏转角是系统性能的最重要的指标，显示器长短与此有关。</li><li>CRT显示器屏幕越大，整个显像管就越长。</li></ul></li><li>荧光屏<ul><li>荧光物质：吸收电子束而发光</li><li>余辉时间：持续发光时间。电子束离开某点后，该点的亮度值衰减到初始值。</li><li>刷新：为了让荧光物质保持在一个稳定的亮度值。</li><li>刷新频率：每秒重绘屏幕次数，显示器更新图像的速率。  </li><li>光点：电子束打在荧光屏上，显示器能显示的最小的发光点。</li><li>像素：构成屏幕的最小元素。</li><li>图形显示在屏幕上时，按当前的图形显示分辨率所能提供的最小元素点。像素点可看做光点的集合，其最小尺寸等于光点。</li><li>屏幕分辨率/光栅分辨率：是物理分辨率，CRT在水平或者竖直方向单位长度上能识别的最大像素个数，单位通常为dip。</li><li>显示分辨率：计算机显示控制器所提供的显示模式分辨率。</li></ul></li></ul><blockquote><p>P9 <strong>考点</strong> 假设荧光物质的持续发光时间为40ms 则，CRT产生稳定图像所需要的<strong>最小刷新频率 = 1秒/荧光物质的持续发光时间= 1000/40ms = 25 Hz</strong><br>只有刷新频率高达一定值后，图像才能稳定显示，约为每秒60帧(60Hz)。一般必须要有85Hz以上的刷新频率。</p></blockquote><h5 id="彩色阴极射线管"><a href="#彩色阴极射线管" class="headerlink" title="彩色阴极射线管"></a>彩色阴极射线管</h5><ul><li>彩色CRT：通过将能发不同颜色的光的荧光物质进行组合而产生彩色。<ul><li><strong>渗透性 - 射线穿透法</strong>：常用于随机扫描显示器。</li><li><strong>多枪型 - 影孔板法</strong>：常用于光栅扫描显示器。</li></ul></li></ul><h5 id="射线穿透法"><a href="#射线穿透法" class="headerlink" title="射线穿透法"></a>射线穿透法</h5><ul><li>屏幕内表面涂有两层荧光涂层。红色光和绿色光两种发光物质，不同速度电子束穿透荧光层的深浅，决定所产生的颜色。</li><li>应用：主要用于画线显示器</li><li>优点：成本低</li><li>缺点：只能产生有限几种颜色</li></ul><h5 id="影孔板法-P10"><a href="#影孔板法-P10" class="headerlink" title="影孔板法 P10"></a>影孔板法 P10</h5><ul><li>影孔板被安装在荧光屏的内表面，用于精确定位像素的位置。</li><li>分类： <ul><li><strong>点阵式</strong>：球面显像管。</li><li><strong>栅线式</strong>：柱面显像管，如日本索尼公司的特丽珑管，三菱公司的钻石龙管。</li><li><strong>栅格式/沟槽式</strong>：LG的未来窗显像管。</li></ul></li><li>工作原理：<ul><li>三基色(红绿蓝)，三色荧光点，三只电子枪。</li><li>电子枪、影孔板中的一个小孔和对应的荧光点呈一直线。</li><li>每个小孔与一个像素（即三个荧光点）对应。</li><li>调节各电子枪发生的电子束中所含电子的数目，即可控制各色光点亮度。<br><img src="/CG/影孔板.png" width="30%"></li></ul></li><li>显示器能同时显示的颜色个数：如果每支电子枪发出的电子束的强度有256个等级，则显示 器能同时显示<code>256*256*256=16M</code>种颜色，称为真彩系统。</li></ul><h5 id="栅线式-vs-点阵式"><a href="#栅线式-vs-点阵式" class="headerlink" title="栅线式 vs 点阵式"></a>栅线式 vs 点阵式</h5><ul><li>原理的区别：光线的选择方式和荧光点的排列不同</li><li>点阵式的缺点：<ul><li>用于球面荧光屏，几何失真大。</li><li>三角形的荧光点排列，即使很密很细也不会特别清晰。</li></ul></li><li>栅线式的优点：<ul><li>亮度更高，色彩也更鲜艳。</li><li>用于高分辨率的柱面和平面显示器。</li><li>电子束通过率有很大的提高。 </li></ul></li></ul><h5 id="荫罩式显示器的固有缺陷"><a href="#荫罩式显示器的固有缺陷" class="headerlink" title="荫罩式显示器的固有缺陷"></a>荫罩式显示器的固有缺陷</h5><ul><li>由合金钢板制成的荫罩<strong>易磁化</strong></li><li>受热受冲击时<strong>易变形</strong><ul><li>显像管内射向荧光屏的电子束中有75% 以上被荫罩阻挡，转变成热量浪费了</li></ul></li><li>屏幕尺寸越大或清晰度越高，就越难制造， <strong>生产成本高</strong>，成品率偏低，价格过高</li><li>制约彩色显像管<strong>清晰度</strong>提高的技术<strong>瓶颈</strong>是彩色显像管中的荫罩</li></ul><h5 id="随机扫描显示系统特点"><a href="#随机扫描显示系统特点" class="headerlink" title="随机扫描显示系统特点"></a>随机扫描显示系统特点</h5><ul><li>数据表示：矢量表示，只有端点信息，无线段中间点</li><li>扫描方式：电子束像一支快速移动的画笔，在任意方向上自由移动，<br>按照显示命令用画线的方式绘出图形</li><li>显示图形：几何属性为主，线框图形</li><li>别称：矢量扫描显示器，画线显示器</li><li>优点：扫描速度快，分辨率高，线条质量好，易修改，交互性好，<br>动态性能好</li><li>缺点：价格贵，只能显示线框图形，应用于军事、CAD领域</li></ul><h5 id="光栅扫描的显示系统特点"><a href="#光栅扫描的显示系统特点" class="headerlink" title="光栅扫描的显示系统特点"></a>光栅扫描的显示系统特点</h5><ul><li>数据表示：像素矩阵，像素数组</li><li>扫描方式：从上到下，从左到右，与电视工作原理类似</li><li>显示图形：几何属性＋视觉属性(Visual attribute) , 真实<br>感图形</li></ul><h5 id="光栅图形显示系统"><a href="#光栅图形显示系统" class="headerlink" title="光栅图形显示系统"></a>光栅图形显示系统</h5><ul><li>显示处理器：主要任务是将应用程序定义为一组像素强度值，存放在帧缓冲存储器中。</li><li>帧缓冲存储器：俗称<strong>显存</strong>，保存了对应屏幕所有亮点的亮度值。</li><li>视频控制器：建立帧缓存与屏幕像素之间一一对应，负责刷新。</li><li>CRT显示器</li></ul><p><img src="/CG/光栅图形.png" width="50%"></p><h5 id="帧缓存与显示器分辨率的关系"><a href="#帧缓存与显示器分辨率的关系" class="headerlink" title="帧缓存与显示器分辨率的关系"></a>帧缓存与显示器分辨率的关系</h5><ul><li>帧缓存的大小 =  显示器分辨率的大小 * 帧缓存的位平面数 / 8</li><li>eg. 分辨率为640x480、1280x1024、1024x1024的显示器各需要多少字节位平面数为24的帧缓存？ans: 分辨率*24/8</li></ul><h5 id="显存问题"><a href="#显存问题" class="headerlink" title="显存问题"></a>显存问题</h5><ul><li>高分辨率和真彩要求有大的显存：1024x1024真彩模式需要3M字节显存。</li><li>解决办法：<ul><li>采用<strong>查色表</strong>或者称彩色表机制。</li><li>采用<strong>隔行扫描</strong>的方法。</li></ul></li></ul><h5 id="带宽问题"><a href="#带宽问题" class="headerlink" title="带宽问题"></a>带宽问题</h5><ul><li>带宽T与分辨率(M<em>N)、帧频(刷新频率)F的关系：`T &gt;= M </em> N * F`</li><li>高分辨率和高刷新频率要求高带宽</li><li>解决办法：<ul><li>隔行扫描(现在一般用逐行扫描)</li><li>对Z缓冲期内容进行压缩和快速清除。</li></ul></li></ul><h5 id="光栅显示系统的特点"><a href="#光栅显示系统的特点" class="headerlink" title="光栅显示系统的特点"></a>光栅显示系统的特点</h5><ul><li>优点<ul><li>成本低</li><li>易于绘制填充图形</li><li>色彩丰富</li><li>刷新频率一定，与图形的复杂度无关</li><li>易于修改图形</li></ul></li><li>缺点<ul><li>需要扫描转换</li><li>扫描转换速度偏低，交互操作响应慢</li><li>分辨率偏低，有阶梯效应，会产生走样  </li></ul></li></ul><h5 id="LCD显示器"><a href="#LCD显示器" class="headerlink" title="LCD显示器"></a>LCD显示器</h5><ul><li>优点<ul><li>外观小巧精致，厚度只有6.5-Bcm左右</li><li>响应速度快、无闪烁、无干扰</li><li>工作电压低，功耗小，省电</li><li>没有电磁辐射，对人体健康没有任何影响</li></ul></li><li>缺点<ul><li>成品率偏低导致成本偏高，冷阴极荧光灯的使用寿命井不算太长，可<br>视角度有限</li></ul></li></ul><h3 id="1-6-计算机图形学的应用及研究前沿"><a href="#1-6-计算机图形学的应用及研究前沿" class="headerlink" title="1.6 计算机图形学的应用及研究前沿"></a>1.6 计算机图形学的应用及研究前沿</h3><ul><li>计算机辅助设计与制造</li><li>可视化</li><li>真实感图形实时绘制与自然景物仿真 </li><li>计算机动画</li><li>用户接口</li><li>计算机艺术</li></ul><h2 id="2-基本图形的生成算法"><a href="#2-基本图形的生成算法" class="headerlink" title="2.基本图形的生成算法"></a>2.基本图形的生成算法</h2><p><img src="/CG/基本图形.png" width="60%"></p><h3 id="2-1-直线绘制算法"><a href="#2-1-直线绘制算法" class="headerlink" title="2.1 直线绘制算法"></a>2.1 直线绘制算法</h3><ul><li>光栅平面的显示图形<ul><li>在光栅显示平面上，我们只能用二维光栅网格上<strong>尽可能靠近</strong>这条直线的象素集合来表示它。</li><li>每个象素具有一定的尺寸，是显示平面上可被访问的最小单位，</li><li>它的<strong>坐标x和y只能是整数</strong>，也就是说相邻象素的坐标值是阶跃的而不是连续的。</li></ul></li></ul><h5 id="直线段的扫描转换"><a href="#直线段的扫描转换" class="headerlink" title="直线段的扫描转换"></a>直线段的扫描转换</h5><ul><li>两点确定一条直线</li><li>通过直线的两个点的坐标计算出斜率和截距，确定直线方程。</li><li>通过x值确定每一个y的值，并舍入y的值。</li></ul><h5 id="数值微分-DDA-算法"><a href="#数值微分-DDA-算法" class="headerlink" title="数值微分(DDA)算法"></a>数值微分(DDA)算法</h5><ul><li>基本思想： <ul><li>假设直线段的宽度为1,直线段的斜率: |k| ≤ 1</li><li>已知过端点P<sub>0</sub>(x<sub>0</sub>, y<sub>0</sub>), P<sub>1</sub>(x<sub>1</sub>, y<sub>1</sub>)的直线L：y = kx + b。</li><li>直线斜率 k = (y<sub>1</sub> - y<sub>0</sub>) / (x<sub>0</sub> - x<sub>0</sub>)</li><li>当x的增量D<sub>x</sub> = 1， y<sub>i+1</sub> = y<sub>i</sub> + k</li></ul></li><li>当x每递增1，y递增k(即直线斜率)；取象素点(x, round(y))作为当前点的坐标。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DDALine(x0,y0,x1,y1,color) </span><br><span class="line"><span class="keyword">int</span> x0,y0,x1,y1,color;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x</span><br><span class="line"><span class="keyword">float</span> dx,dy,k,y</span><br><span class="line">dx=x1-x0; dy=y1-y0; </span><br><span class="line">k=dy/dx;</span><br><span class="line">y=y0;</span><br><span class="line"><span class="keyword">for</span>(x=x0;x&lt;=x1;x++)</span><br><span class="line">&#123;</span><br><span class="line">drawpixel(x,<span class="keyword">int</span>(y+<span class="number">0.5</span>),color); </span><br><span class="line">y=y+k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：<ul><li>当|k| ≤ 1时，x每增加1，y最多变化1。</li><li>当|k| &gt; 1时，必须把x与y的地位互换。</li></ul></li><li><strong>DDA算法的特点</strong> 以|k| ≤ 1为例<ul><li>y与k必须用浮点数表示</li><li>每一步都要对y进行四舍五入后取整</li><li>不利于硬件实现</li></ul></li></ul><h5 id="中点算法"><a href="#中点算法" class="headerlink" title="中点算法"></a>中点算法</h5><ul><li>基本原理<ul><li>通过在每列(行)象素中确定与理想直线最接近的象素来进行扫描转换</li><li>考虑直线斜率k在0~1之间</li><li>当前象素点为P（x<sub>p</sub>,y<sub>p</sub>），则下一个象素点有两种可选择点<br>P<sub>1</sub>（x<sub>p</sub>+1,y<sub>p</sub>）, P<sub>2</sub>（x<sub>p</sub>+1,y<sub>p+1</sub>）</li><li>P1与P2的中点（x<sub>p</sub>+1,y<sub>p</sub>+0.5）称为M</li><li>Q为理想直线与x = x<sub>p</sub>+1垂线的交点<br>当M在Q的下方时，则取P<sub>2</sub>应为下一个象素点<br>当M在Q的上方时，则取P<sub>1</sub>为下一个象素点<br><img src="/CG/中点算法.png" width="40%"> </li></ul></li><li>算法实现<ul><li>过点(x<sub>0</sub>,y<sub>0</sub>)、(x<sub>1</sub>, y<sub>1</sub>)的直线段L的方程式为：F(x, y)=ax+by+c=0</li><li><strong>其中，a = y<sub>0</sub> - y<sub>1</sub>, b = x<sub>1</sub> - x<sub>0</sub>, c = x<sub>0</sub>y<sub>1</sub> - x<sub>1</sub>y<sub>0</sub></strong></li><li>欲判断中点M在交点Q点的上方还是下方，只要把M代入F（x，y），并判断它的符号即可</li><li>构造判别式：d=F(M)=F(x<sub>p</sub>+1, yp+0.5)=a(x<sub>p</sub>+1)+b(y<sub>p</sub>+0.5)+c    </li><li>当d&lt;0时，M在L(Q点)下方，取P2为下一个象素        </li><li>当d&gt;0时，M在L(Q点)上方，取P1为下一个象素      </li><li>当d=0时，选P1或P2均可，约定取P1为下一个象素  </li></ul></li></ul><h5 id="增量法改进："><a href="#增量法改进：" class="headerlink" title="增量法改进："></a>增量法改进：</h5><ul><li>注意到d是x<sub>p</sub>, y<sub>p</sub>的线性函数，可采用增量计算，提高运算效率 <ul><li>d = F(M)=F(x<sub>p</sub>+1, y<sub>p</sub>+0.5) = a(x<sub>p</sub>+1)+b(y<sub>p</sub>+0.5)+c </li></ul></li><li>若当前象素（P的下一个像素）处于d≥0情况，则取P的正右方象素P1(x<sub>p</sub>+1, y<sub>p</sub>)，再下一个象素位置的判别式：<ul><li>d<sub>1</sub> = F(x<sub>p</sub>+2, y<sub>p</sub>+0.5) = a(x<sub>p</sub>+2)+b(y<sub>p</sub>+0.5)+c = d+a</li><li><strong>增量为a</strong></li></ul></li><li>若当前象素（P的下一个像素） d&lt;0时，则取右上方象素P2(x<sub>p</sub>+1, y<sub>p</sub>+1)，再下一个像素位置的判别式：<ul><li>d<sub>2</sub> = F(x<sub>p</sub>+2, y<sub>p</sub>+1.5) = a(x<sub>p</sub>+2)+b(y<sub>p</sub>+1.5)+c = d+a+b</li><li><strong>增量为a＋b</strong></li></ul></li><li><strong>初值计算</strong><ul><li>画线从(x<sub>0</sub>, y<sub>0</sub>)开始， F(x<sub>0</sub>, y<sub>0</sub>) = 0</li><li>d的初值：起始点(x0, y0) 下一个像素的判别式：</li><li>d<sub>0</sub> = F(x<sub>0</sub>+1, y<sub>0</sub>+0.5)+c = F(x<sub>0</sub>, y<sub>0</sub>)+a+0.5b = 0 + a+0.5b = a+0.5b</li></ul></li><li><strong>摆脱小数计算</strong><ul><li>我们使用的只是d的符号</li><li>d的增量都是整数，只是初始值包含小数</li><li>可以用2d代替d来摆脱小数</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> Midpoint <span class="title">Line</span> <span class="params">(<span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> x1, <span class="keyword">int</span> y1,<span class="keyword">int</span> color)</span></span>&#123; </span><br><span class="line"><span class="keyword">int</span> a, b, d1, d2, d, x, y;a=y0-y1； b=x1-x0；d=<span class="number">2</span>*a+b; <span class="comment">//初值</span>d1=<span class="number">2</span>*a； d2=<span class="number">2</span>* (a+b);x=x0；y=y0;drawpixel(x, y, color);<span class="keyword">while</span> (x&lt;x1)&#123; </span><br><span class="line"><span class="keyword">if</span> (d&lt;<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">x++;</span><br><span class="line">y++；;</span><br><span class="line">d+=d2; </span><br><span class="line">&#125;<span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">x++;</span><br><span class="line">d+=d1;</span><br><span class="line">&#125;drawpixel (x, y, color);&#125; &#125;</span><br></pre></td></tr></table></figure><h5 id="Bresenham算法"><a href="#Bresenham算法" class="headerlink" title="Bresenham算法"></a>Bresenham算法</h5><ul><li>基本思想：<ul><li>过各行各列象素中心构造一组虚拟网格线</li><li>按直线从起点到终点的顺序计算直线与各垂直网格线的<strong>交点</strong></li><li>然后根据<strong>误差项的符号</strong>确定该列象素中与此交点最近的象素</li><li>采用<strong>增量计算</strong>，使得对于每一列，只要检查一个误差项的<strong>符号</strong>，就<br>可以确定该列的所求象素<br><img src="/CG/Bresenham.png" width="30%"></li></ul></li><li>算法实现<ul><li>先考虑斜率k=dy/dx≤1的直线，直线方程可以表示为</li><li>假设当前像素的x坐标已经确定为x<sub>i</sub>，其y坐标为y<sub>i</sub></li><li>由于坐标(x<sub>i</sub>, y<sub>i</sub>)只能取整数，下一个像素的x坐标为</li><li>而y<sub>i</sub>＋1的坐标有两种可能：保持不变，即y<sub>i</sub>＋1＝y<sub>i</sub>；y坐标递增1，即y<sub>i</sub>＋1＝y<sub>i</sub>＋1<br><img src="/CG/Bresenham1.png" width="20%"></li><li>设A为CD边的中点，若B点在A点上方，选择D点； 否则，选C点。</li></ul></li><li>具体实现<ul><li>如果直线的<strong>起始点在象素中心</strong>，所以误差项d的初值<strong>d<sub>0</sub>＝0</strong>。</li><li>x下标每增加1，d的值相应递增直线的斜率值k，<strong>即d＝d＋k</strong>。</li><li>一旦d≥1，就把它减去1，这样<strong>保证d在0与1之间</strong>。<br>①当d≥0.5时，最接近于当前象素的右上方象素（x<sub>i</sub>+1, y<sub>i</sub>+1）<br>②当d&lt;0.5时，更接近于右下方象素（x<sub>i</sub>+1, y<sub>i</sub>）</li><li>为方便计算，<strong>令e＝d-0.5</strong></li><li>e的初值为-0.5 (d0 = 0)，增量为k<br>①当e≥0时，最接近于当前象素的右上方象素（x<sub>i</sub>+1, y<sub>i</sub>+1）<br>②当e&lt;0时，更接近于右方象素（x<sub>i</sub>+1, y<sub>i</sub>）</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bresenhamline</span> <span class="params">(<span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> x1, <span class="keyword">int</span> y1,<span class="keyword">int</span> color)</span></span>&#123;<span class="keyword">int</span> x, y, dx, dy;<span class="keyword">float</span> k, e;dx = x1-x0, dy = y1- y0, k=dy/dx;e=<span class="number">-0.5</span>, x=x0, y=y0;<span class="keyword">for</span> (i=<span class="number">0</span>; i≤dx; i++)&#123;drawpixel (x, y, color);x=x+<span class="number">1</span>, e=e+k;<span class="keyword">if</span> (e≥<span class="number">0</span>)&#123; </span><br><span class="line">y++, e=e<span class="number">-1</span>;</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Bresenham画线算法优点</strong>：<ul><li>快速增量算法</li><li>仅使用整数计算</li><li>效率高，易于用硬件实现</li></ul></li><li>与DDA算法相比，DDA算法的问题：<ul><li>误差的累积会使直线远离真实的结果</li><li>四舍五入运算和浮点运算耗时</li></ul></li></ul><h5 id="改进的Bresenham算法"><a href="#改进的Bresenham算法" class="headerlink" title="改进的Bresenham算法"></a>改进的Bresenham算法</h5><ul><li>可以改用整数以避免除法。由于算法中只用到误差项的符号，因此可作如下替换：<ul><li>e’ = 2 <em> e </em> dx 即用2 <em> dx </em> e代替原有的e。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InterBresenhamline</span> <span class="params">(<span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> x1, <span class="keyword">int</span> y1,<span class="keyword">int</span> color)</span></span>&#123;dx = x1-x0, dy = y1- y0；e=-dx; x=x0; y=y0;<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;dx; i++)&#123;drawpixel (x, y, color）x++； e=e+<span class="number">2</span>*dy;<span class="keyword">if</span> (e&gt;=<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"> y++; </span><br><span class="line"> e=e<span class="number">-2</span>*dx;</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-圆的生成"><a href="#2-2-圆的生成" class="headerlink" title="2.2 圆的生成"></a>2.2 圆的生成</h3><ul><li>八等分圆：可以同时绘制八分对称的点。<br><img src="/CG/八等分.png" width="30%"> <ul><li>八分对称性同时解决了“绘制点稀疏”的问题。</li><li>只需绘制右上八分之一的圆弧。</li><li>①切线斜率|dy/dx| ≤ 1 ②y的变化慢于x ③x每递增1，y最多最多改变一个像素单位 ④不会产生像素空隙 ⑤会有更多的像素拟合圆弧 ⑥使圆弧拟合更精确。</li></ul></li></ul><h5 id="中点画圆法"><a href="#中点画圆法" class="headerlink" title="中点画圆法"></a>中点画圆法</h5><ul><li>构造判别式(圆方程)：F(x, y) = x<sup>2</sup> + y<sup>2</sup> - R<sup>2</sup></li><li>判断点在圆内(F &lt; 0)、圆上(F = 0)、圆外(F &gt; 0)</li><li>M(x<sub>p</sub> + 1,y<sub>p</sub> - 0.5)是P1和P2的中点</li><li>d = F(M) = F(x<sub>p</sub> + 1,y<sub>p</sub> - 0.5) = (x<sub>p</sub> + 1)<sup>2</sup> + (y<sub>p</sub> - 0.5)<sup>2</sup> - R<sup>2</sup><br><img src="/CG/中点画圆.png" width="30%"> <ul><li>八分之一圆弧（如半径R=20），初始象素坐标(0, R)</li><li>下一个像素的绘制位置(1, R) 或(1, R-1)</li><li>得到中点坐标(1, R-0.5)</li><li>构造判别式d<sub>0</sub> = F(M) -&gt; d<sub>1</sub>, d<sub>2</sub>…</li></ul></li></ul><h5 id="增量算法避免重复计算"><a href="#增量算法避免重复计算" class="headerlink" title="增量算法避免重复计算"></a>增量算法避免重复计算</h5><p><img src="/CG/中点画圆增量.png" width="60%"> </p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MidPointCircle(<span class="keyword">int</span> R <span class="keyword">int</span> color)&#123;<span class="keyword">int</span> x,y;<span class="keyword">float</span> d;x=<span class="number">0</span>; y=R; d=<span class="number">1.25</span>-R;CirclePoints (x,y,color); <span class="comment">//显示圆弧上的八个对称点</span><span class="keyword">while</span>(x&lt;=y)&#123;<span class="keyword">if</span>(d&lt;<span class="number">0</span>) </span><br><span class="line">d+=<span class="number">2</span>*x+<span class="number">3</span>;<span class="keyword">else</span> </span><br><span class="line">&#123; </span><br><span class="line">d+=<span class="number">2</span>*(x-y)+<span class="number">5</span>; </span><br><span class="line">y--; </span><br><span class="line">&#125;x++;CirclePoints(x,y,color); <span class="comment">//显示圆弧上的八个对称点</span>&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>为了进一步提高算法的效率，可以将上面的算法中的浮点数改写成整数，将乘法运算改成加法运算，即仅用整数实现中点画<br>圆法。</li><li>初始化运算使用 Q:为什么可以去掉0.25？<ul><li>d’= d - 0.25 = 1.25 – R – 0.25 = 1 – R 代替 d = 1.25 - R</li></ul></li></ul><h5 id="中点算法小结"><a href="#中点算法小结" class="headerlink" title="中点算法小结"></a>中点算法小结</h5><ul><li>圆弧各点切线斜率绝对值<1 -=""> 从x扫描至x+1，y的备选绘制点为y, y-1</1></li><li>适当利用对称性提高效率<ul><li>利用圆的八分对称性 -&gt; 只需绘制圆右上八分之一圆弧</li></ul></li><li>利用中点判别法选择绘制点<ul><li>联合圆方程 + 每一步的两个备选绘图点的中点 -&gt; 构造判别式</li></ul></li><li>设计增量算法 -&gt; 避免重复计算</li><li>符号判别 -&gt; 简化浮点运算为整数运算</li></ul><h5 id="生成圆弧的Bresenham法"><a href="#生成圆弧的Bresenham法" class="headerlink" title="生成圆弧的Bresenham法"></a>生成圆弧的Bresenham法</h5><ul><li>以点(0, R) 为起点按顺时针方向生成圆，则在第一象限内（四分之一圆弧）y是x的单调递减函的单调递减函。</li><li>假设圆心和起点均精确地落在像素中心上。如果已经知道圆弧上的一点 (x<sub>i</sub>,y<sub>i</sub> )，下一像素的选取有三种可能：<br>①正右方像素H ②右下角像素D ③正下方像素V<br><img src="/CG/圆弧.png" width="20%"></li><li>构造函数：F(x<sub>p</sub> + 1,y<sub>p</sub> - 0.5) = (x<sub>p</sub> + 1)<sup>2</sup> + (y<sub>p</sub> - 0.5)<sup>2</sup> - R<sup>2</sup>  </li><li>这三个像素的偏差的平方为：<br><img src="/CG/偏差.png" width="20%"><br><img src="/CG/偏差2.png" width="50%"><img src="/CG/偏差3.png" width="50%"><br><img src="/CG/偏差4.png" width="55%"></li></ul><h3 id="2-3-椭圆的生成"><a href="#2-3-椭圆的生成" class="headerlink" title="2.3 椭圆的生成"></a>2.3 椭圆的生成</h3><ul><li>F(x,y) = b<sup>2</sup>x<sup>2</sup>+a<sup>2</sup>y<sup>2</sup>-a<sup>2</sup>b<sup>2</sup>=0</li><li>椭圆的对称性：<ul><li>只考虑第一象限椭圆弧生成 只考虑第一象限椭圆弧生成 ，分上下两部分</li><li><strong>以切线斜率为-1的点作为分界的点。</strong></li></ul></li><li>椭圆上一点处的法向量：N(x,y) = (F)’ x i+(F)’ y j = 2b<sup>2</sup>x i+2a<sup>2</sup>y j<ul><li>在上部分，法向量的y向分量较大，斜率K满足 |k|&lt; 1,|△x| ＞|△y| ，所以 x方向为主位移方向。</li><li>在下部分，法向量的x向分量较大，斜率K满足 |k|&gt; 1,|△y| ＞|△x| ，所以 y方向为主位移方向。</li></ul></li><li>与圆弧中点算法类似：确定一个象素后，接着在两个候选象素的中点计算一个判别式的值，由判别式的符号确定更近的点。</li><li>先讨论椭圆弧的上部分：<ul><li>(x<sub>p</sub>, y<sub>p</sub>)的中点(x<sub>p</sub> + 1, y<sub>p</sub> - 0.5)</li><li>d<sub>1</sub> = F(x<sub>p</sub> + 1, y<sub>p</sub> - 0.5)<br><img src="/CG/椭圆.png" width="75%"><br><img src="/CG/椭圆2.png" width="60%"><br><img src="/CG/椭圆3.png" width="50%"><br><img src="/CG/椭圆4.png" width="50%"> <img src="/CG/椭圆5.png" width="50%"> </li></ul></li><li>算法步骤：<ol><li>输入椭圆的长半轴 a 和短半轴 b。</li><li>计算初始值 d=b<sup>2</sup>+a<sup>2</sup>(-b+ 0.25 )，x= 0，y=b 。</li><li>绘制点 (x, y )及其在四分象限上的另外三个对称点。</li><li>判断 d 的符号。若d≤ 0，则先将d更新为d+b<sup>2</sup>(2x + 3)，再将 ( x, y)更新为 (x+ 1,y)；否则先将d更新为 d+b<sup>2</sup>(2x + 3) + a<sup>2</sup>(-2y + 2)，再将 ( x, y )更新为 (x + 1, y - 1)。</li><li>当b<sup>2</sup>(x+1) &lt; a<sup>2</sup>(y - 0.5)时，重复步骤 3 和 4 。否则转到步骤 6 。</li><li>用上半部分计算的最后点 ( x, y )来计算下半部分中d的初值：d = b<sup>2</sup>(x + 0.5)<sup>2</sup> + a<sup>2</sup> (y - 1)<sup>2</sup> - a<sup>2</sup> b<sup>2</sup></li></ol></li></ul><h3 id="2-4-多边形的扫描转换"><a href="#2-4-多边形的扫描转换" class="headerlink" title="2.4 多边形的扫描转换"></a>2.4 多边形的扫描转换</h3><h5 id="1-实区域填充算法"><a href="#1-实区域填充算法" class="headerlink" title="1. 实区域填充算法"></a>1. 实区域填充算法</h5><ul><li>点在多边形内的包含性检验<ul><li><strong>检验夹角之和</strong>：若夹角和为0，则点p在多边形外；若夹角和为360°，则点p在多边形内。</li><li><strong>射线法检验交点数</strong>：交点数 = 偶数(包括0) -&gt; 点在多边形之外；交点数 = 奇数 -&gt; 点在多边形之内</li></ul></li><li>逐点测试：效率低不实用。 <ul><li>解决办法：<strong>包围盒法</strong>。</li></ul></li><li>分类<ul><li>扫描线填充算法：按扫描线顺序，测试点的连贯性</li><li>种子填充算法：从内部一个种子点出发，测试点的连贯性。</li></ul></li></ul><h5 id="2-多边形种类"><a href="#2-多边形种类" class="headerlink" title="2. 多边形种类"></a>2. 多边形种类</h5><ul><li>多边形 :由一系列首尾相连的直线段构成的图形称为多边形。 <ul><li><strong>凸多边形</strong>是指任意两顶点间的连线均在多边形内;</li><li><strong>凹多边形</strong>是指任意两顶点间的连线有不在多边形内的部分;</li><li><strong>含内环的多边形</strong>则是指多边形内再套有多边形，多边形内的多边形也叫内环，内环之间不能相交。</li></ul></li></ul><h5 id="3-如何表示多边形"><a href="#3-如何表示多边形" class="headerlink" title="3. 如何表示多边形"></a>3. 如何表示多边形</h5><ul><li><strong>顶点表示</strong>是用多边形的顶点序列来表示多边形。<ul><li>表示直观、几何意义强、占内存少，易于进行几何变换，被广泛用于各种几何造型系统中;</li></ul></li><li><strong>点阵表示</strong>是用位于多边形内的象素集合来刻画多边形。<ul><li>丢失了许多几何信息(如边界、顶点)，但它是光栅显示图形所需要的表示形式。</li></ul></li><li><strong>多边形的扫描转换处理对象</strong>：非自交多边形 (边与边之间除了顶点外无其它交点)</li></ul><h5 id="4-多边形的扫描转换-扫描线算法-多边形的有序边表法"><a href="#4-多边形的扫描转换-扫描线算法-多边形的有序边表法" class="headerlink" title="4. 多边形的扫描转换 / 扫描线算法 / 多边形的有序边表法"></a>4. 多边形的扫描转换 / 扫描线算法 / 多边形的有序边表法</h5><ul><li>4个基本步骤：<ul><li><strong>求交</strong>：计算扫描线与多边形各边的交点</li><li><strong>排序</strong>：把所有交点按x值递增顺序排序</li><li><strong>配对</strong>：将第一个与第二个、第三个与第四个等交点配对，每对交点代表扫描线与多边形的一个相交区间。</li><li><strong>填色</strong>：把相交区间内的像素置成多边形的颜色，相交区间外的颜色置成背景色。</li></ul></li><li><strong>顶点交点的计数问题：</strong><ul><li>思路1: 局部最高点和局部最低点：计偶数次交点</li><li>思路2: 检查交于该顶点的两条边的另外两个端点的y坐标值：大于该顶点y坐标值的个数</li></ul></li><li><strong>填充扩大化问题</strong> <ul><li>取中心扫描线 y+0.5<br>– 检查交点右方像素的中心是否落在区间内：x<sub>l</sub> ≤ x + 0.5 ≤ x<sub>r</sub></li></ul></li><li><strong>效率问题：</strong><ul><li>影响算法效率的因素：<strong>求交和交点排序</strong></li><li>把多边形所有边放在一个表中，按顺序取出，分别计算与当前扫描线求交点。</li><li>为了减少和简化求交点计算，对每条扫描线，建立一个<strong>活性边表</strong>：把所有与当前扫描线有交点的边放到一个表中存储。(活性边：仅与当前扫描线有交点的边)</li></ul></li><li><strong>活性边表 AET</strong>：<ul><li>结点信息：<br>① x:当前扫描线与边的交点<br>②△x:从当前扫描线到下一条扫描线之间的x增量<br>③ymax:边所交的最高扫描线号</li><li>活性边表的更新：<br>①结点信息的更新  <strong>x’ = x + △ x</strong><br>②旧边的删除<br>③新边的插入 </li></ul></li><li><strong>新边表 NET</strong><ul><li>为解决新边插入的问题，对每条扫描线建立一个新边表。</li><li>扫描线与边的交点应为扫描线与边的初始交点</li><li>结点信息<br>①x<sub>0</sub>:扫描线与边的初始交点。（若采用中心扫描线，则需将活性边的较低端点的x坐标值加上0.5△x作为x0）<br>②△x:从当前扫描线到下一条扫描线之间的x增量<br>③ymax:边所交的最高扫描线号<br><img src="/CG/扫描线.png" width="70%"></li></ul></li><li>优点: <ul><li>对每个像素只访问一次 </li><li>与设备无关</li></ul></li><li>缺点:<ul><li>数据结构复杂，表的维护、排序开销大</li><li>只适合软件实现</li></ul></li></ul><h5 id="扫描线算法步骤"><a href="#扫描线算法步骤" class="headerlink" title="扫描线算法步骤"></a>扫描线算法步骤</h5><ol><li>根据给出的多边形顶点坐标，建立NET表;<br>求出顶点坐标中最大y值ymax和最小y值ymin。</li><li>初始化AET表指针，使它为空。</li><li>执行下列步骤直至NET和AET都为空.<ol><li>如NET中的第y类非空，则将其中的所有边取出并插入AET中;</li><li>如果有新边插入AET，则对AET中各边排序;</li><li>对AET中的边两两配对，(1和2为一对，3和4为一对，…)，将每对边中x坐标按规则取整，获得有效的填充区段，再填充.</li><li>当前扫描线纵坐标y值递值1;</li><li>如果AET表中某记录的ymax=yj，则删除该记录(因为每条边被看作下闭上开的);</li><li>对AET中剩下的每一条边的x递增1/k，即x = x+ 1/k .</li></ol></li></ol><h5 id="边填充算法"><a href="#边填充算法" class="headerlink" title="边填充算法"></a>边填充算法</h5><ul><li>无需复杂的链表结构</li><li>涉及到屏幕像素的异或写操作<ul><li>第一次异或写操作，像素被置为前景色</li><li>第二次异或写操作，像素被置为背景色</li></ul></li><li>边填充算法的基本思想<ul><li>对每一条与多边形相交的中心扫描线</li><li>将像素中心位于交点右方的全部像素取补 (异或写)</li></ul></li><li>分类：<ul><li>算法1：<strong>以扫描线为中心</strong>的边缘填充算法</li><li>算法2：<strong>以边为中心</strong>的边缘填充算法</li></ul></li><li>边填充算法的优点:<ul><li>最适合于有帧缓存的显示器</li><li>可按任意顺序处理多边形的边</li><li>仅访问与该边有交点的扫描线上右方的像素，算法简单</li></ul></li><li>缺点: <ul><li>对复杂图形，每一像素可能被访问多次，输入/输出量大</li><li><strong>图形输出不能与扫描同步进行</strong>，只有全部画完才能打印</li></ul></li></ul><h5 id="边界标志法-P27"><a href="#边界标志法-P27" class="headerlink" title="边界标志法 P27"></a>边界标志法 P27</h5><ul><li>在帧缓冲器中对多边形的每条边进行<strong>直线扫描转换</strong>，亦即对多边形边界所经过的象素打上标志。</li><li>对每条与多边形相交的扫描线依从左到右的顺序，逐个访问该扫描线上的象素。</li><li>使用一个<strong>布尔量inside</strong>来指示当前点是否在多边形内的状态。<ul><li>Inside的初值为假，每当当前访问的象素为被打上边标志的点，就把inside取反。 </li><li>对未打标志的象素，inside不变。</li><li>若访问当前象素时，inside为真，说明该象素在多边形内，则把该象素置为填充颜色。</li></ul></li><li>用软件实现时，有序边表算法(扫描线算法)与边界标志算法的执行速度几乎相同。</li><li>但由于边界标志算法<strong>不必建立维护边表以及对它进行排序，所以边界标志算法更适合硬件实现</strong>，这时它的执行速度比有序边表算法快一至两个数量级。</li></ul><h3 id="2-5-区域-种子-填充算法"><a href="#2-5-区域-种子-填充算法" class="headerlink" title="2.5  区域(种子)填充算法"></a>2.5  区域(种子)填充算法</h3><h5 id="区域填充"><a href="#区域填充" class="headerlink" title="区域填充"></a>区域填充</h5><ul><li><strong>区域</strong>：指已经表示成<strong>点阵形式</strong>的填充图形，它是象素的集合。</li><li>表示方法: 内点表示、边界表示</li><li><strong>内点表示</strong><ul><li>枚举处区域内部的所有像素</li><li>内部的所有像素着同一个颜色</li><li>边界像素着与内部像素不同的颜色</li></ul></li><li><strong>边界表示</strong><ul><li>枚举出边界上所有的像素</li><li>边界上的所有像素着同一颜色</li><li>内部像素着与边界像素不同的颜色</li></ul></li><li>种子填充算法的另外一种思路: <ul><li>假设多边形区域内至少有一个像素已知 </li><li>由该像素出发找出区域内部的所有像素</li></ul></li><li><strong>区域连通方式</strong><ul><li>4连通区域(4个方向运动：上下左右)</li><li>8连通区域(8个方向运动)</li></ul></li></ul><h5 id="种子填充的一种非递归-栈-算法"><a href="#种子填充的一种非递归-栈-算法" class="headerlink" title="种子填充的一种非递归(栈)算法"></a>种子填充的一种非递归(栈)算法</h5><ul><li>以4连通边界为例</li><li>种子像素入栈</li><li>当栈非空时，重复以下步骤: <ul><li>栈顶像素出栈</li><li>将出栈象素置成填充色</li><li>按左、上、右、下顺序检查与出栈象素相邻的四象素，若其中某象素不在边界上且未被置成填充色，则将其入栈</li></ul></li><li>特点: 每个像素都需要压栈，耗内存，费时间<br><img src="/CG/种子.png" width="40%"></li></ul><h5 id="种子填充的扫描线算法"><a href="#种子填充的扫描线算法" class="headerlink" title="种子填充的扫描线算法"></a>种子填充的扫描线算法</h5><ul><li>基本思想:<ul><li>利用扫描线的连贯性，每次<strong>填充一行像素</strong></li><li>减少压入堆栈的像素数目</li></ul></li><li>种子像素入栈</li><li>当栈非空时，重复以下步骤:<ul><li>栈顶像素出栈</li><li>沿扫描线对出栈像素的左右像素进行填充，直到遇到边界像素为止</li><li>将上述区间内最左、最右像素记为x<sub>l</sub>,和x<sub>r</sub></li><li>在区间[x<sub>l</sub>,x<sub>r</sub>]中检查与当前扫描线相邻的上下两条扫描线是否全为边界像素、或已填充的像素，若为非边界、未填充的像素，则<strong>把每一区间的最右像素取为种子像素入栈</strong>。(后进先出)</li></ul></li><li><strong>扫描线种子填充算法的特点</strong><ul><li>适用于边界定义的区域</li><li>四连通边界定义的区域既可以是凸的，也可以是凹的，还可以是有孔的。</li><li>算法减少了每个像素的访问次数</li><li>所需堆栈深度较浅</li><li>每次递归填充一行像素，因而速度较快</li></ul></li></ul><h5 id="多边形扫描转换-A-与区域填充方法-B-比较"><a href="#多边形扫描转换-A-与区域填充方法-B-比较" class="headerlink" title="多边形扫描转换(A)与区域填充方法(B)比较"></a>多边形扫描转换(A)与区域填充方法(B)比较</h5><ul><li>都是光栅图形面着色， 用千真实感图形显示。</li><li>可相互转换。</li><li>不同点：</li></ul><ol><li>基本思想不同；<ul><li>A用于将顶点表示转换成点阵表示；</li><li>B只改变区域内填充颜色，没有改变表示方法。</li></ul></li><li>对边界的要求不同<ul><li>A：只要求扫描线与多边形边界交点个数为偶数。</li><li>B：区域封闭，防止递归填充跨界。</li></ul></li><li>基本的条件不同<ul><li>A：从边界顶点信息出发。</li><li>B：区域内种子点。</li></ul></li></ol><h3 id="2-6-字符"><a href="#2-6-字符" class="headerlink" title="2.6 字符"></a>2.6 字符</h3><h5 id="字符的表示和输出"><a href="#字符的表示和输出" class="headerlink" title="字符的表示和输出"></a>字符的表示和输出</h5><ul><li><strong>字符</strong>：数字、字母、汉字， 计算机中字符由一个数字编码唯一标识。</li><li><strong>字符集</strong>：<ul><li>ASCII码：美国信息交换标准代码。</li><li>ISO 8859：是国际标准化组织(ISO)及国际电工委员会(IEC)联合制定的一系列8位字符集的标准， 现时定义了15个字符集。增加、加192个字母及符号， 附加符号的拉丁字母语言</li><li>GB2312/GBK, 这就是汉字的国标码， 专门用来表示汉字， 是双字节编码，</li><li>Unicode可以用来表示所有语言的字符， 而且是定长双字节（也有四字节的）编码， 包括英文字母在内。</li><li>UTF可以用来表示所有语言的字符， utf编码是不定长编码， 每一个字符的长度从1-6个字节不等。另外， utf编码自带简单的校验功能。一般来讲， 英文字母都是用一个字节<br>表示， 而汉字使用三个字节。</li></ul></li><li><strong>字库</strong>：字库中存储了每个字符的形状信息，字库分为<strong>矢量和点阵型</strong>两种。</li><li><strong>点阵字符</strong>：<ul><li>在点阵表示中，每一个字符由一个点阵位图来表示。点阵字符的存储是<strong>按行或者按列进行编码</strong>。</li><li>显示时，形成字符的像素图案。</li></ul></li><li>矢量字符<ul><li>采用直线和曲线段来描述字符形状，矢量字符库中记录的是笔划信息(存的是<strong>顶点的位置信息</strong>)。</li><li>显示时，解释字符的每个笔划信息</li></ul></li></ul><h3 id="2-7-反走样"><a href="#2-7-反走样" class="headerlink" title="2.7 反走样"></a>2.7 反走样</h3><ul><li>什么是反走样?<ul><li>把<strong>由离散量表示连续量引起的失真</strong>称为走样;</li><li>把减少或克服走样效果的技术称为反走样技术，简称反走样。 </li></ul></li><li>光栅图形的走样有如下几种:<ul><li>产生阶梯或锯齿形;</li><li>狭小图形遗失;细节失真</li><li>实时动画忽隐忽现、闪烁跳跃。 </li></ul></li><li><strong>常用的反走样的主要方法</strong> <strong>P41</strong><ul><li>提高分辨率方法(硬件技术)</li><li>非加权区域采样：改变直线段的模型，由此产生算法。将直线段看作具有一定宽度的狭长矩形。<strong>缺点</strong>是直线离像素中心点越近，贡献越大。</li><li>加权区域采样：使相交区域对象亮度的贡献依赖于该区域与像素中心的距离。</li></ul></li></ul><h2 id="3-三维图形的剪裁"><a href="#3-三维图形的剪裁" class="headerlink" title="3. 三维图形的剪裁"></a>3. 三维图形的剪裁</h2><ul><li>场景由世界坐标中指定的对象集合组成</li><li>当我们显示场景时，仅显示特定窗口中的那些对象</li><li>因为将内容绘制到显示器需要时间，我们会剪切窗口外的所有内容</li><li>设窗口的边界为wx<sub>min</sub>, wy<sub>min</sub>, wx<sub>max</sub>, wy<sub>max</sub><ul><li>当一个点(x, y)满足：wx<sub>min</sub> &lt; x &lt; wx<sub>max</sub> &amp;&amp; wy<sub>min</sub> &lt; y &lt; wy<sub>max</sub> 则不需要被剪裁</li><li>否则被剪裁。</li></ul></li></ul><h3 id="3-1-直线段裁剪"><a href="#3-1-直线段裁剪" class="headerlink" title="3.1 直线段裁剪"></a>3.1 直线段裁剪</h3><h5 id="Cohen-Sutherland算法"><a href="#Cohen-Sutherland算法" class="headerlink" title="Cohen-Sutherland算法"></a>Cohen-Sutherland算法</h5><ul><li>优点：减少了必须计算的线与窗口的交点的数量。</li><li>世界空间根据窗口边界划分为区域：<ul><li>每个区域具有唯一的四位区域码。</li><li>区域码表<strong>示区域相对于窗口的位置</strong>。<br>&lt;img src = “区域码.png” width =50%”&gt;</li></ul></li><li>判别方法：设线段的两个端点为P1(x1，y1)和P2(x2，y2)， 根据上述规则，可以求出P1和P2所在区域的分区代码C1和C2。<ul><li>C1 = C2 = 0，表明两端点全在窗口内，因而整个线段也在窗内，应予保留。</li><li>C1 And C2 ≠ 0(两端点代码<strong>按位作逻辑乘</strong>不为0)，即C1和C2至少有某一位同时为1，表明两端点必定处于某一边界的同一外侧，因而整个线段全在窗外，应予舍弃。</li><li>不属于上面两种情况，均需要求交点。</li></ul></li><li>注意：求的交点可能是<strong>延长线上的交点</strong>。</li><li>求交点：<ul><li>使用直线的方程计算与窗口边界的交点</li><li>假设一条直线具有端点(x1, y1), (x2, y2)</li><li>与垂直窗口边界的交点坐标为 y = y<sub>1</sub> + m(x<sub>边界</sub> - x<sub>1</sub>), x<sub>边界</sub>可以为x<sub>min</sub>或者x<sub>max</sub></li><li>与水平窗口边界的交点坐标 x = x<sub>1</sub> + (y<sub>边界</sub> - x<sub>1</sub>) / m</li><li>m = (y<sub>2</sub> - y<sub>1</sub>) / (x<sub>2</sub> - x<sub>1</sub>)</li></ul></li></ul><h5 id="中点分割剪裁算法"><a href="#中点分割剪裁算法" class="headerlink" title="中点分割剪裁算法"></a>中点分割剪裁算法</h5><ul><li>注意：求的交点是<strong>真实的交点</strong>。</li><li><strong>基本思想</strong>：<ul><li>P( (x<sub>1</sub> + x<sub>2</sub>) / 2 , (y<sub>1</sub> + y<sub>2</sub>) / 2 )</li><li>如果P1与P同侧，移动P1点。即可能的交点只能出现在PP2段 <code>if((C1&amp;C)!=0) P1=P</code>;</li><li>如果P1与P不同侧，移动P2点。即可能的交点只能出现在P1P段 <code>if((C1&amp;C)= =0) P2=P</code>;<br>&lt;img src = “中点分割.png” width =22%”&gt;</li></ul></li><li><strong>算法步骤</strong>：<ul><li><strong>将直线的两端点P1、P2编码得：C1、C2。</strong></li><li><strong>根据C1和C2的具体值，可以有三种情况：</strong><br>①C1=C2=0，表明两端点全在窗口内，因而整个线段也在窗内，应予保留。<br>②C1&amp;C2≠0，表明两端点必定处于某一边界的同一外侧，因而整个线段全在窗外，应予舍弃。<br>③不属于上面两种情况，均需要求交点。</li><li><strong>求交点</strong><br>①令窗外端点为P1，如果窗外点不是P1，则P1和P2交换端点。保留窗内端点P2到暂存器里。<br>②对P1编码为C1，用中点公式求出中点 ，并编码得C。按照中点算法的求交规则：<br>若P1和P同侧，移动P1点<code>if((C1&amp;C)!=0) P1=P</code>; 否则，移动P2点 <code>else P2=P</code><br>③流程转②，直到P1和P2相差一个单位时:令交点为P2，取出暂存器的端点赋给P1，然后转向流程①</li></ul></li><li><strong>算法特点</strong>：<ul><li>求交点的次数(n)与线段长度(L)有关，其关系为: <strong>L = 2<sup>n</sup></strong> 例如：线段长度为256，则求交点的次数为8。</li><li>中点分割法求出的交点是<strong>边界上的有效交点</strong>，而不是边界及其延长线上的交点。而Cohen-Sutherland直线裁剪算法求出的则是<strong>边界上或者边界的延长线上的交点</strong>。</li></ul></li></ul><h3 id="3-2-多边形裁剪"><a href="#3-2-多边形裁剪" class="headerlink" title="3.2 多边形裁剪"></a>3.2 多边形裁剪</h3><h5 id="Sutlerland-Hodgman算法-逐边裁剪算法"><a href="#Sutlerland-Hodgman算法-逐边裁剪算法" class="headerlink" title="Sutlerland-Hodgman算法 / 逐边裁剪算法"></a>Sutlerland-Hodgman算法 / 逐边裁剪算法</h5><ul><li>窗口的一条边以及延长线构成的裁剪线该线把平面分成两个部分：可见一侧；不可见一侧。</li><li>简单地通过依次将多边形与每个边界进行比较来修剪多边形。</li><li>多边形的各条边的两端点S、P。它们与裁剪线的位置关系只有四种：<ul><li>S，P均在可见一侧 → 输出P</li><li>S，P均在不可见一侧 → 无输出</li><li>S可见，P不可见 → 输出SP与裁剪线的交点I</li><li>S不可见，P可见  → 输出SP与裁剪的交点I和P<br><img src="/CG/裁剪.jpeg" width="45%"></li></ul></li><li><strong>特点：</strong><ul><li>裁剪算法采用流水线方式， <strong>适合硬件实现。</strong></li><li>可推广到<strong>任意凸多边形裁剪窗口</strong></li></ul></li></ul><h5 id="Weiler-Atherton算法"><a href="#Weiler-Atherton算法" class="headerlink" title="Weiler-Atherton算法"></a>Weiler-Atherton算法</h5><ul><li><strong>特点：</strong><ul><li>裁剪窗口为<strong>任意多边形(凸、凹、带内环)</strong>的情况:</li></ul></li><li>内裁减与外裁剪：<ul><li>内裁剪: 即通常意义上的裁剪，取图元位于窗口之内的部分</li><li>外裁剪: 取图元位于窗口之外的部分。</li></ul></li><li>如果主多边形与裁剪多边形有交点，则<strong>交点成对出现</strong>。它们被分为如下两类:<ul><li>一类称“入”点。即被裁剪多边形由此点进入裁剪窗口，如图中a、c、e。</li><li>一类称“出”点。即被裁剪多边形由此点离开裁剪窗口，如图中b、d、f。</li></ul></li><li>Weiler-Atherton算法步骤<ol><li>建顶点表 </li><li>求交点</li><li>裁剪<br><img src="/CG/wa.png" width="75%"></li></ol></li><li><strong>详细步骤</strong><ol><li><strong>顺时针</strong>输入被裁剪多边形顶点序列 I 放入数组1中。</li><li><strong>顺时针</strong>输入裁剪窗口顶点序列II放入数组2中。</li><li>求出被裁剪多边形和裁剪窗口相交的所有交点，并给每个交点打上 “入”、“出”标记。 然后将交点按顺序插入序列I得到新的顶点序列 III ，并放入数组3中;同样也将交点按顺序插入序列II得到新的顶点序列 IV ，放入数组4中; </li><li>初始化输出数组Q，令数组Q为空。接着从数组3中寻找“入”点。如果“入”点没找到，程序结束。 </li><li>如果找到“入”点，则将“入”点放入S中暂存。</li><li>将“入”点录入到输出数组Q中。并从数组 3 中将该“入”点的“入” 点标记删去。 </li><li>沿数组 3 顺序取顶点: 如果顶点是“出点”，则将顶点录入到输出数组Q中，流程转第7步。否则，流程转第8步。</li><li>沿数组4顺序取顶点:如果顶点是“入点”，则将顶点录入到输出数组Q中，流程转第8步。 否则，流程转第9步。</li><li><strong>如果顶点不等于起始点S，流程转第6步，继续跟踪数组3</strong>。 否则，将数组Q输出。</li><li>流程转第4步，寻找可能存在的分裂多边形。 算法在第4步：满足“入”点没找到的条件时，算法结束。</li></ol></li><li><strong>交点的奇异情况处理</strong><ul><li>与裁剪多边形边重合的主多边形的边不参与求交点;</li><li>对于顶点落在裁剪多边形的边上的主多边形的边，如果落在该裁<br>剪边的内侧，将该顶点算作交点;而如果这条边落在该裁剪边<br>的外侧，将该顶点不看作交点。<br><img src="/CG/奇异.png" width="60%"></li></ul></li></ul><h3 id="3-3-字符裁剪"><a href="#3-3-字符裁剪" class="headerlink" title="3.3 字符裁剪"></a>3.3 字符裁剪</h3><ul><li><strong>基于字符串</strong>：将包围字符串的外接矩形对窗口作裁剪。当字符串外接矩形整个在 窗口内时予以显示，否则不显示。</li><li><strong>基于字符</strong>：将包围字符的外接矩形对窗口作<br>裁剪，如某个字符外接矩形整个落<br>在窗口内予以显示，否则不显示。</li><li><strong>基于构成字符的最小元素 / 像素</strong>：点阵字符：点裁剪 ；矢量字符：线裁剪<br><img src="/CG/字符.png" width="80%"></li></ul><h2 id="4-图形的变换"><a href="#4-图形的变换" class="headerlink" title="4. 图形的变换"></a>4. 图形的变换</h2><h3 id="4-1-图形变换的数学基础"><a href="#4-1-图形变换的数学基础" class="headerlink" title="4.1 图形变换的数学基础"></a>4.1 图形变换的数学基础</h3><ul><li><strong>图形几何变换</strong>：几何图形按照某种法则或规律变换成另一种几何图形的过程。</li><li>矩阵及其运算 P203</li></ul><h3 id="4-2-二维几何变换"><a href="#4-2-二维几何变换" class="headerlink" title="4.2 二维几何变换"></a>4.2 二维几何变换</h3><h5 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h5><ul><li>齐次坐标：所谓齐次坐标, 就是将一个原本是n维的向量用一个n+1 维向量来表示。<ul><li>例如, 向量(x<sub>1</sub>, x<sub>2</sub>, …, x<sub>n</sub>)的齐次坐标表示为<br>(H<sub>x<sub>1</sub></sub>, H<sub>x<sub>2</sub></sub>, …, H<sub>x<sub>n</sub></sub>, H), 其中H是一个不为0的实数。</li></ul></li><li>由点或向量的齐次坐标(H<sub>x<sub>1</sub></sub>, H<sub>x<sub>2</sub></sub>, …, H<sub>x<sub>n</sub></sub>, H)求它的<strong>规范化齐次坐标</strong>, 可根据如下公式求得：<ul><li>x<sub>1</sub> = H<sub>x<sub>1</sub></sub> / H, x<sub>2</sub> = H<sub>x<sub>2</sub></sub> / H, …, x<sub>n</sub> = H<sub>x<sub>n</sub></sub> / H</li></ul></li><li>齐次坐标表示不是唯一的，通常<strong>当h=1时</strong>，称为<strong>规格化齐次坐标</strong>， 在计算机图形学里面，我们常用的是规格化齐次坐标。</li><li>为什么需要引入齐次坐标？<ul><li>多个变换作用于多个目标</li><li>引入齐次坐标，变换的表示法统一</li></ul></li><li>图形变换具有统一表示形式的优点：<ul><li>便于变换合成 </li><li>便于硬件实现  </li></ul></li></ul><h5 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h5><ul><li><strong>平移、旋转、缩放变换</strong><br><img src="/CG/几何变换.jpg" width="100%"></li><li><strong>对称变换</strong>：<br><img src="/CG/对称.jpg" width="100%"></li><li><p><strong>错切变换</strong>： </p><ul><li>也称为剪切、错位变换，用于产生弹性物体的变形处理。</li><li>错切的变换矩阵<br><img src="/CG/错切.jpg" width="100%"></li><li>(a) 错切角 (b) 沿x方向错切 (c) 沿y方向错切<br><img src="/CG/错切3.png" width="50%"></li></ul></li><li><p><strong>仿射变换</strong></p><ul><li>变换的坐标x’和y’都是原始坐标x和y的线性函数。</li><li>仿射变换具有平行线转换成平行线和有限点映射到有限点的一般特性。</li><li><strong>平移、比例、旋转、对称和错切变换是二维仿射变换的特例</strong>，任何常用的二维仿射变换总可表示为这五种变换的组合。 </li></ul></li></ul><h5 id="复杂变换"><a href="#复杂变换" class="headerlink" title="复杂变换"></a>复杂变换</h5><ul><li>复合变换是指对图形进行一次以上的变换，变换的结果是 每次的变换矩阵相乘。</li><li>任何一组变换都可以表示成一个复合变换矩阵，只需要计算每一个单独<strong>变换矩阵</strong>，并求解出乘积。</li><li>从另一个方面讲，任何一个复杂的几何变换都可以看作基本几何变换的组合形式，也叫复合变换。</li></ul><h3 id="4-3-窗口到视区的变换"><a href="#4-3-窗口到视区的变换" class="headerlink" title="4.3 窗口到视区的变换"></a>4.3 窗口到视区的变换</h3><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ul><li><strong>坐标系</strong>：建立了图形与数之间的对应联系<ul><li><strong>世界坐标系</strong>：用户需要在图形独享所在的控件定义一个坐标系</li><li><strong>用户坐标系</strong>：用户按照自己习惯建立世界坐标系，所以世界坐标系有时也称用户坐标系。</li><li><strong>局部坐标系</strong>：简化图形对象的描述，相对于图形定义</li><li><strong>屏幕坐标系</strong>：屏幕上或绘图纸上定义一个二维直角坐标系，也称为设备坐标系。</li></ul></li><li><strong>窗口</strong>：在计算机图形学中，将在用户坐标系中需要进行观察和处理的一个坐标区域。</li><li><strong>视区</strong>：将窗口映射到显示设备上的坐标区域。 <ul><li>改变视区的位置，可以在输出设备的不同位置显示图形对象。</li><li>改变视区的大小和比例可以改变显示对象的大小和比例。 </li></ul></li><li><strong>裁剪在扫描转换之前</strong><br><img src="/CG/显示.png" width="60%"></li></ul><h5 id="窗口到视区变换"><a href="#窗口到视区变换" class="headerlink" title="窗口到视区变换"></a>窗口到视区变换</h5><ul><li>变换步骤：<ul><li>将窗口左下角点<strong>移至用户系统系的坐标原点</strong></li><li>针对原点进行<strong>比例变换</strong></li><li>进行<strong>反平移</strong></li></ul></li><li>两种情况：<ol><li>窗口区的边与坐标轴平行</li><li>窗口区的边与坐标轴不平行：将窗口左下角点<strong>移至用户系统系的坐标原点</strong>后需要旋转到与坐标轴平行。</li></ol></li></ul><h3 id="4-4-三维几何变换"><a href="#4-4-三维几何变换" class="headerlink" title="4.4 三维几何变换"></a>4.4 三维几何变换</h3><h5 id="三维齐次坐标"><a href="#三维齐次坐标" class="headerlink" title="三维齐次坐标"></a>三维齐次坐标</h5><ul><li>(x, y, z)对应的齐次坐标为(x<sub>h</sub>, y<sub>h</sub>, z<sub>h</sub>, h)<ul><li>标准齐次坐标(x,y,z,1) ==〉用来表示三维空间点(x, y, z)。</li></ul></li><li>使用<strong>右手坐标系</strong>(z轴正方向向外) </li></ul><h5 id="三维几何变换"><a href="#三维几何变换" class="headerlink" title="三维几何变换"></a>三维几何变换</h5><ul><li>三维平移变换、放缩变换</li><li>三维旋转变换<ul><li>是指给定的三维立体绕三维空间某个指定的坐标轴旋转θ角度。 </li><li>旋转后, 立体的空间位置将发生变化, 但形状不变。 </li><li><strong>θ角的正负按右手规则确定</strong>, 右手大姆指指向旋转轴的正向, 其余四个手指指向旋转角的正向。</li></ul></li></ul><p><img src="/CG/3d.jpg" width="100%"></p><ul><li>三维错切变换：是指三维立体在空间沿x、 y、 z三个方向实现错切变形, 三维错切是二维错切变换的一个扩充。</li><li>三维对称变换<br><img src="/CG/3d2.jpg" width="60%"></li></ul><h2 id="5-投影"><a href="#5-投影" class="headerlink" title="5. 投影"></a>5. 投影</h2><h3 id="5-1-三维图形显示的基本问题"><a href="#5-1-三维图形显示的基本问题" class="headerlink" title="5.1 三维图形显示的基本问题"></a>5.1 三维图形显示的基本问题</h3><ol><li><strong>在二维屏幕上如何显示三维物体?</strong><ul><li>显示器屏幕、绘图纸等是二维的，显示对象是三维的</li><li>解决方法：投影</li></ul></li><li><strong>如何表示三维物体?</strong><ul><li>二维形体的表示：直线段, 折线, 曲线段, 多边形区域</li><li>二维形体的输入：<strong>简单</strong>(图形显示设备与形体的维数一致)</li><li>三维形体的表示：空间直线段、折线、曲线段、多边形、曲面片 </li><li>三维形体的输入、运算、有效性保证<strong>(困难)</strong></li><li>解决方法：<strong>各种用于形体表示的理论、模型、方法</strong></li></ul></li><li><strong>如何反映遮挡关系?</strong><ul><li>物体之间或物体的不同部分之间存在相互遮挡关系</li><li>遮挡关系是空间位置关系的重要组成部分</li><li>解决方法：<strong>消除隐藏面与隐藏线</strong></li></ul></li><li><strong>如何产生真实感图形?</strong><ul><li>人们观察现实世界产生的真实感来源于<br>• 空间位置关系：近大远小的透视关系和遮挡关系<br>• 光线传播引起的物体表面颜色的自然分布</li><li>解决方法：<strong>建立光照明模型、开发真实感图形绘制方法</strong></li></ul></li></ol><h5 id="三维图形显示的基本研究内容"><a href="#三维图形显示的基本研究内容" class="headerlink" title="三维图形显示的基本研究内容"></a>三维图形显示的基本研究内容</h5><ul><li>投影</li><li>三维形体的表示</li><li>消除隐藏面与隐藏线</li><li>建立光照明模型、开发真实感图形绘制方法</li></ul><h3 id="5-2-平面几何投影"><a href="#5-2-平面几何投影" class="headerlink" title="5.2 平面几何投影"></a>5.2 平面几何投影</h3><ul><li>投影 — 照相机模型<ul><li>选定投影类型 → <strong>透视投影</strong>与<strong>平行投影</strong></li><li>设置投影参数 → 拍摄方向、距离等</li><li>三维裁剪 → 取景</li><li>投影和显示 → 成像</li></ul></li><li><strong>简单的三维图形显示流程图</strong><br><img src="/CG/3d流程.png" width="40%"> </li><li><strong>投影</strong>：将n维的点变换成小于n维的点。比如将3维的点变换成小于3维的点</li><li><strong>投影中心</strong>(COP: Center of Projection)<ul><li>eg. 视觉系统—观察点、视点; 电影放映机—光源</li></ul></li><li><strong>投影面</strong>：不经过投影中心的面<ul><li>eg. 平面–照相机底片; 曲面—球幕电影,视网膜</li></ul></li><li><strong>投影线：</strong>从投影中心向物体上各点发出的射线<ul><li>eg. 直线—光线; 曲线—喷绘</li></ul></li><li><strong>平面几何投影</strong>：投影面是平面，投影线为直线</li><li><strong>投影变换</strong>：投影过程，投影的数学表示</li><li>平面几何投影的分类<br><img src="/CG/投影.png" width="40%"> </li></ul><h5 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h5><ul><li>投影中心与投影平面之间的距离为有限</li><li>参数：投影中心、投影方向</li><li>eg. 室内白炽灯的投影，视觉系统</li><li><strong>灭点</strong>：不平行于投影平面的平行线，经过透视投影之后收敛于一点，称为灭点。</li><li><strong>主灭点</strong>：坐标轴方向的平行线在投影面上 形成的灭点称作主灭点。<ul><li>一点透视：表现范围广，纵深感强，适合表现庄重、严肃的室内空间或建筑物。比较呆板，与真实效果有一定的距离</li><li>两点透视为：构图画面增加动感，使画面结构丰富。</li><li>三点透视：一般用于超高层建筑俯瞰图或仰视图。<br><img src="/CG/透视.png" width="40%"> </li></ul></li><li><strong>特点</strong>：产生近大远小的视觉效果，由它产生的图形深度强，看起来更加真实。</li></ul><h5 id="平行投影"><a href="#平行投影" class="headerlink" title="平行投影"></a>平行投影</h5><ul><li>投影中心与投影平面之间的距离为无限</li><li>是透视投影的极限状态</li><li>分类:<ul><li>根据投影射线与投影平面的关系，平行投影可分为<strong>正投影和斜投影</strong>。<br><img src="/CG/平行投影.png" width="40%"> </li></ul></li><li>正投影：<ul><li>根据投影面和坐标轴的夹角可分为两类:三视图和正轴测图</li><li>当<strong>投影面与某一坐标轴垂直</strong>时，得到的投影为三视图，这时投影方向和这个坐标轴的方向一致。否则，得到的投影为正轴测图。<br><img src="/CG/正投影.png" width="40%"> </li></ul></li><li><strong>三视图</strong>: 包括<strong>主视图、侧视图和俯视图</strong>三种，投影面分别与X轴、Y轴和Z轴垂直</li><li>正轴侧：当投影平面与三个坐标轴都不垂直时。<ul><li>正轴侧又分为等轴侧、正二侧和正三侧。</li><li>当投影面与<strong>三个</strong>坐标轴之间的<strong>夹角都相等</strong>时为等轴测。</li><li>当投影面与<strong>两个</strong>坐标轴之间的<strong>夹角相等</strong>时为正二测。</li><li>当投影面与<strong>三个</strong>坐标轴之间的<strong>夹角都不相等</strong>时为正三测。</li></ul></li></ul><h5 id="斜投影"><a href="#斜投影" class="headerlink" title="斜投影"></a>斜投影</h5><ul><li><strong>投影方向不垂直于投影面</strong></li><li>分类：<ul><li>斜等侧投影:投影方向和投影面夹角α成45° </li><li>斜二侧投影:投影方向和投影面夹角α=arctan(2)</li></ul></li></ul><h5 id="投影总结"><a href="#投影总结" class="headerlink" title="投影总结"></a>投影总结</h5><ul><li>平行投影:投影中心与投影面间距离为无穷远。</li><li>正平行投影:投影方向和投影面垂直。</li><li>三视图:三个投影面和坐标轴相互垂直。</li><li>正轴侧:投影面和坐标轴呈一定的关系。 </li><li>斜平行投影:投影方向和投影面不垂直。</li><li>透视投影:投影中心与投影面间距离为有限。</li></ul><h3 id="5-3-投影变换-amp-投影举例"><a href="#5-3-投影变换-amp-投影举例" class="headerlink" title="5.3 投影变换 &amp; 投影举例"></a>5.3 投影变换 &amp; 投影举例</h3><ul><li><strong>三维观察变换</strong>所起的作用是完成从用户空间选取的一部分物体描述变换到 显示屏上指定的视窗中的图形描述。<ul><li>简单的三维观察流水线：<br><img src="/CG/流水线.png" width="40%"> </li></ul></li><li><strong>取景变换</strong>:完成从用户坐标系中的描述 -&gt; 观察坐标系中的描述的坐标变换。</li><li><strong>观察坐标系(VRC)</strong>:照相机所在的坐标系</li></ul><h5 id="建立观察坐标系"><a href="#建立观察坐标系" class="headerlink" title="建立观察坐标系"></a>建立观察坐标系</h5><ul><li>挑选一个用户坐标点称为观察参考点VRP(View Reference Point)， 即该点为观察坐标系的原点;</li><li>通过给定观察平面法向量来选择观察坐标系的 Zv轴和观察平面方向;</li><li>指定一观察向上向量，通过该向量来建立 观察坐标系的Yv轴;</li><li>确定观察点又称为投影中心(若为透视投影时) 或确定投影方向(若为平行投影时)</li></ul><h5 id="用户坐标到观察坐标的变换"><a href="#用户坐标到观察坐标的变换" class="headerlink" title="用户坐标到观察坐标的变换"></a>用户坐标到观察坐标的变换</h5><ul><li>在物体描述投影到观察平面之前，必须将其转换成观察坐标。该变换顺序是:    <ul><li>平移观察参考点VRP(x0,y0,z0)到用户坐标系原点; </li><li>进行旋转分别让Xv,Yv和Zv轴对应到用户坐标系的x、y、和z轴。 一旦景物中物体的用户坐标描述转换到观察坐标后，我们就可以将三维<br>物体投影到二维观察平面上。<br><img src="/CG/观察坐标.png" width="50%"> </li></ul></li><li>为使剪取处理简单和规范化(即单位化)，需要利用坐标变换将<strong>视见体规范化</strong>。</li></ul><h5 id="视见体-View-Port"><a href="#视见体-View-Port" class="headerlink" title="视见体(View Port)"></a>视见体(View Port)</h5><ul><li>视见体是三维裁剪窗口。</li><li>建立步骤：<ul><li>定义窗口 → 发出射线 → 形成观察空间 → 前后剪裁面 → 形成视见体</li></ul></li><li>需注意，对于透视投影，<strong>前截面必须在投影中心和后截面之间。</strong></li><li>投影参考点(PRP: Projection Reference Point)<br><img src="/CG/视见体.png" width="50%"> <ul><li>透视投影: COP==PRP;</li><li>平行投影: 投影方向DOP= CW-PRP</li><li>透视投影: 观察空间为四棱锥</li><li>平行投影: 观察空间为四棱柱</li></ul></li></ul><h5 id="透视投影变换"><a href="#透视投影变换" class="headerlink" title="透视投影变换"></a>透视投影变换</h5><ul><li>问题：在uvn中，投影平面为n=0，投影中心为(0，0，d)， 待投影点为P(u<sub>p</sub>，v<sub>p</sub>，n<sub>p</sub>)，求投影点Q (u<sub>Q</sub>，v<sub>Q</sub>，n<sub>Q</sub>)<br><img src="/CG/透视投影变换.png" width="25%"><br><img src="/CG/透视投影变换2.png" width="25%"></li><li>透视投影变换矩阵:作用就是将三维物体变换成二维透视投影。</li></ul><h5 id="斜平行投影"><a href="#斜平行投影" class="headerlink" title="斜平行投影"></a>斜平行投影</h5><ul><li>投影方向不垂直于投影平面的平行投影被称为斜平行投影。</li></ul><h5 id="从世界坐标系到观察坐标系的变换"><a href="#从世界坐标系到观察坐标系的变换" class="headerlink" title="从世界坐标系到观察坐标系的变换"></a>从世界坐标系到观察坐标系的变换</h5><p><img src="/CG/变换.png" width="25%"></p><h3 id="5-4-规范视见体变换-规范裁剪空间"><a href="#5-4-规范视见体变换-规范裁剪空间" class="headerlink" title="5.4 规范视见体变换 / 规范裁剪空间"></a>5.4 规范视见体变换 / 规范裁剪空间</h3><ul><li>为什么引入规范视见体?<ul><li>使裁剪算法非常容易、直观</li><li>有助于隐藏线和隐藏面的消除。</li></ul></li><li>规范化变换：将任意视见体变换成规范视见体的变换</li><li>三维图形的显示流程图<br><img src="/CG/2.png" width="45%"></li><li>采用视见体变换的三维图形显示流程图<br><img src="/CG/1.png" width="45%"><ul><li>观察变换：从世界坐标系到观察坐标系的变换</li></ul></li></ul><h5 id="何时裁剪"><a href="#何时裁剪" class="headerlink" title="何时裁剪"></a>何时裁剪</h5><ul><li><strong>投影之前裁剪 三维裁剪</strong><ul><li>优点：只对可见的物体进行投影变换</li><li>缺点：三维裁剪相对复杂</li></ul></li><li><strong>投影之后裁剪 二维裁剪</strong><ul><li>优点：二维裁剪相对容易</li><li>缺点：需要对所有的物体进行投影变换</li></ul></li><li>采用投影后裁剪的三维图形显示流程图<br><img src="/CG/3.png" width="45%"></li><li>在投影之前裁剪的理由<ul><li>三维物体的表面通常被离散表示成多边形或折线，而对这类简单图元，三维裁剪同样比较简单。</li><li>三维图形<strong>在显示过程中需要被消隐</strong>，做这个工作要有图形的深度信息，所以必须在投影之前完成。 消隐很费时，如果在此之前裁剪 (或部分裁剪)掉不可见的图形，可使需要消隐的图形减至最小。</li></ul></li></ul><h2 id="6-隐藏面的消除"><a href="#6-隐藏面的消除" class="headerlink" title="6. 隐藏面的消除"></a>6. 隐藏面的消除</h2><h3 id="6-1-基本概念"><a href="#6-1-基本概念" class="headerlink" title="6.1 基本概念"></a>6.1 基本概念</h3><ul><li>要画出确定的、立体感很强的三维图形，就必须将那些被不透明的面<br>(或物体)所遮挡的线段(或面)移去，这就是隐藏线或隐藏面的消隐处理。</li><li><strong>按消隐对象</strong>将三维物体消隐分为两类: <ul><li><strong><code>线消隐</code></strong>：其消隐对象是物体上的边, 消除的是<strong>物体上不可见的边</strong>，用于线框图。</li><li><strong><code>面消隐</code></strong>：其消隐对象是物体上的面, 消除的是<strong>物体上不可见的面</strong>，用于填色图。</li></ul></li><li><strong>根据消隐空间</strong>的不同，将消隐算法分为3类：<ul><li>物体空间的消隐算法：将场景中每一个面与其它每个面比较, 求出所有点、边、面的遮挡关系。算法精度较高。如<strong>光线投射</strong>等。</li><li>图像空间的消隐算法：对屏幕上每个像素进行判断, 决定哪个多边形在该像素可见。 如：<strong>Z-buffer、扫描线</strong>等。</li><li>物体空间和图像控件的消隐算法：在物体空间中预先计算面的可见性优先级, 再在图像空间中生成 消隐图。如：<strong>画家算法</strong>等。</li></ul></li></ul><h3 id="6-2-提高消隐算法效率的常见方法"><a href="#6-2-提高消隐算法效率的常见方法" class="headerlink" title="6.2 提高消隐算法效率的常见方法"></a>6.2 提高消隐算法效率的常见方法</h3><ol><li>利用连贯性<ul><li>物体的连贯性</li><li>面的连贯性</li><li>区域的连贯性 </li><li>扫描线的连贯性</li></ul></li><li>将透视投影转换成平行投影 <ul><li>消隐与投影方式有关 (消隐必须在投影之前完成)</li></ul></li></ol><ul><li>包围盒技术：包围目标的简单形体</li><li>背面剔除</li><li>空间分割技术</li><li>物体分层表示  </li></ul><h5 id="包含消隐的三维图形显示流程图："><a href="#包含消隐的三维图形显示流程图：" class="headerlink" title="包含消隐的三维图形显示流程图："></a>包含消隐的三维图形显示流程图：</h5><p><img src="/CG/4.png" width="45%"></p><h5 id="消隐的基本-核心-问题-排序"><a href="#消隐的基本-核心-问题-排序" class="headerlink" title="消隐的基本(核心)问题:排序"></a>消隐的基本(核心)问题:排序</h5><ul><li>整体排序: 画家算法</li><li>点排序: Z-Buffer算法、光线投射算法 </li><li>区间排序: 扫描线算法</li><li>区域排序: 区域子分算法</li></ul><h3 id="6-3-画家算法"><a href="#6-3-画家算法" class="headerlink" title="6.3 画家算法"></a>6.3 画家算法</h3><ul><li>基本思想 <ul><li>先将场景中的物体按其距观察点的远近进行排序，结果放在一张线性表中;</li><li>线性表构造:距观察点远的称优先级低，放在表头;距观察点近的称优先级高， 放在表尾。该表称为深度优先级表</li><li>然后按照从表头到表尾的顺序逐个绘制物体。</li></ul></li><li>基本步骤<ul><li>对场景中的多边形按深度进行排序，</li><li>形成深度优先级表;</li><li>按从远到近的顺序显示多边形;</li></ul></li><li>画家算法不能处理的情况<ul><li>多边形循环遮挡</li><li>多边形相互穿透</li></ul></li><li>解决办法: 沿多边形所在平面之间的交线循环地分割这些多边形，直至最终可建立确定的优先级表。</li></ul><h3 id="6-4-Z缓冲器算法"><a href="#6-4-Z缓冲器算法" class="headerlink" title="6.4 Z缓冲器算法"></a>6.4 Z缓冲器算法</h3><ul><li>基本思想<ul><li>先将Z缓冲器中个单元的初始值置为-1 (规范视见体的最小n值)。</li><li>当要改变某个像素的颜色值时，首先检查当前<strong>多边形的深度值</strong>是否大于该像素<br>原来的深度值(保存在该像素所对应的Z缓冲器的单元中);</li><li><strong>如果大于，说明当前多边形更靠近观察点</strong>，用它的颜色替换像素原来的颜色;</li><li>否则说明在当前像素处，当前多边形被前面所绘制的多边形遮挡了，是不可见的，像素的颜色值不改变。</li></ul></li><li><strong>优点</strong><ul><li>算法简单、稳定</li><li>便于硬件加速</li><li>不需要整个场景的几何数据</li></ul></li><li><strong>缺点</strong><ul><li>需要Z缓冲器 <strong>改进: 扫描线Z缓冲器算法</strong> </li><li>计算复杂度大 <strong>改进:区域子分算法</strong></li></ul></li></ul><blockquote><p> 需要计算的像素深度值次数 = 多边形个数 * 多边形平均占据的像素个数</p></blockquote><h3 id="6-5-扫描线Z缓冲器算法"><a href="#6-5-扫描线Z缓冲器算法" class="headerlink" title="6.5 扫描线Z缓冲器算法"></a>6.5 扫描线Z缓冲器算法</h3><ul><li>改进一: 将窗口分割成扫描线<ul><li>缺点：在每一个被多边形覆盖像素处需要计算深度值；被多个多边形覆盖的像素需要多次计算深度值</li></ul></li><li>改进二：利用扫描线的连贯性计算深度 (增量法)</li><li>改进三：采用多边形分类表(PT)、活化多边形表 (APT)<strong>避免多边形与扫描线的盲目求交</strong></li><li>改进四：利用边、边的分类表(ET)、边对、活化边对表(AEPT)<strong>避免边与扫描线的盲目求交</strong></li></ul><h3 id="6-6-区间扫描线算法"><a href="#6-6-区间扫描线算法" class="headerlink" title="6.6 区间扫描线算法"></a>6.6 区间扫描线算法</h3><ul><li><strong>要求多边形不能相互贯穿</strong></li><li>该算法可以看作是边相关扫描线填充算法的延伸。</li><li>不同的是在消隐算法中处理的是多个面片，而多边形填充中是对单个多边形面进行填充。</li><li>它是把当前扫描线与各多边形在投影平面的投影的交点进行排序后，使扫描线分为若干子区间。因此，只要在区间任一点处找出在该 处z值最大的一个面，这个区间上的每一个象素就用这个面的颜色来显示。</li><li>改进：<ul><li>在一条扫描线上，以区间为单位确定多边形的可见性</li><li>不需要Z-Buffer</li></ul></li></ul><h3 id="6-7-区域子分割算法"><a href="#6-7-区域子分割算法" class="headerlink" title="6.7 区域子分割算法"></a>6.7 区域子分割算法</h3><ul><li>首先将场景中的多边形投影到绘图窗口内(假设它为边长为k的正方形)</li><li>判断窗口是否足够简单，若是则算法结束;</li><li>否则将窗口进一步分为四块(左上，右上，左下，右下)。</li><li>对此四个小窗口重复上述过程，直到窗口仅为一个像素大小。</li><li>此时可能有多个多边形覆盖了该像素，计算它们的深度值，以最近的颜色 显示该像素即可。</li></ul><h3 id="6-8-光线投射算法"><a href="#6-8-光线投射算法" class="headerlink" title="6.8 光线投射算法"></a>6.8 光线投射算法</h3><ul><li>考察<strong>由视点出发穿过观察屏幕</strong>的一像素而射入场景的一条射线,则可确定出场景中与该射线相交的物体。 </li><li>在计算出光线与物体表面的交点之后, 离像素最近的交点的所在面片的颜色为该像素的颜色; 如果没有交点, 说明没有多边形的投影覆盖此像素, 用背景色显示它即可。</li></ul><h2 id="7-真实感图形的生成"><a href="#7-真实感图形的生成" class="headerlink" title="7. 真实感图形的生成"></a>7. 真实感图形的生成</h2><ul><li>当光照射到物体表面时，光线可能被<strong>吸收</strong>、<strong>反射</strong>和<strong>透射</strong>。被物体吸收的部分转化为热，反射、透射的光进入 人的视觉系统，使我们能看见物体。</li><li>为模拟这一现象，我们建立一些数学模型来替代复杂的物理模型，这些模型就称为明暗效应模型或者光照明模型。三维形体的图形经过消隐后，再进行明暗效应的处 理，可以进一步提高图形的真实感。</li></ul><h3 id="7-1-简单光照明模型"><a href="#7-1-简单光照明模型" class="headerlink" title="7.1 简单光照明模型"></a>7.1 简单光照明模型</h3><ul><li>光照射到物体表面，主要发生:<ul><li>反射 </li><li>透射(对透明物体) </li><li>部分被吸收成热能 </li></ul></li><li>反射光和透射光的<strong>光谱分布</strong>——决定景物表面的<strong>颜色</strong></li><li>反射光和透射光的<strong>强弱</strong>——决定景物表面的<strong>明暗程度</strong></li><li><strong>环境光</strong>：在空间中近似均匀分布，即在任何位置、任何方向<br>上强度一样</li><li><strong>点光源</strong>:几何形状为一个点，位于空间中的某个位置，向周围所有的方向上辐射等强度的光。<ul><li>在物体的不同部分其亮度也不同，亮度的大小依赖于物体的朝向及它与点光源之间的距离。</li></ul></li><li><strong>漫反射</strong>：粗糙、无光泽物体(如粉笔，墙面)表面对光的反射<ul><li>各点反射光的强度只与①点光源强度、入射角 ②物体表面的反射系数  ③物体各表面的朝向 有关</li><li><strong>与观察者的观察方向无关</strong></li></ul></li><li><strong>镜面反射</strong>: 光滑物体(如金属或塑料)表面对光的反射<ul><li>n为镜面反射(高光)指数，n越大，则Is(镜面反射光强)随α的增大衰减的越快  </li><li><strong>n的取值与表面粗糙程度有关</strong><br>①n越大，表面越平滑(散射现象少，稍一偏离，明暗亮度急剧下降)<br>②n越小，表面越毛糙(散射现象严重)</li></ul></li><li>高光: 入射光在光滑物体表面形成的特别亮的区域</li></ul><h5 id="Phong光照明模型"><a href="#Phong光照明模型" class="headerlink" title="Phong光照明模型"></a>Phong光照明模型</h5><ul><li>由物体表面上一点P反射到视点的光强 I 为<strong>环境光的反射光强</strong> I<sub>e</sub>， <strong>理想漫反射光强</strong> I<sub>d</sub>，和<strong>镜面反射光</strong>I<sub>s</sub>的总和。</li><li>Phong光照明模型是真实感图形学中提出的第一个有影响的光照明模型</li><li>经验模型，Phong模型存在不足:<ul><li>显示出的物体象塑料，<strong>无质感变化</strong></li><li><strong>没有考虑物体间相互反射光</strong></li><li>镜面反射颜色与材质无关</li><li>镜面反射大入射角失真现象</li></ul></li></ul><h3 id="7-2-多边形表示的明暗处理"><a href="#7-2-多边形表示的明暗处理" class="headerlink" title="7.2 多边形表示的明暗处理"></a>7.2 多边形表示的明暗处理</h3><h5 id="Gouraud明暗处理-双线性光强插值"><a href="#Gouraud明暗处理-双线性光强插值" class="headerlink" title="Gouraud明暗处理(双线性光强插值)"></a>Gouraud明暗处理(双线性光强插值)</h5><ul><li>先计算物体表面多边形各顶点的光强, 然后用双线性插值, 求出多边形内部区域中各点的光强。</li><li><strong>基本算法描述</strong>:<ol><li>计算多边形顶点的平均法向;</li><li>计算顶点的平均光强;</li><li>插值计算离散边上的各点光强;</li><li>插值计算多边形内域中各点的光强。</li></ol></li><li><strong>优点</strong><ul><li>简单易行，计算量小</li><li>只需已知顶点的法向量 </li></ul></li><li><strong>缺点</strong><ul><li>只适用于简单的漫反射光照模型，不能正确模 拟镜面反射高光形状</li><li>用于动态显示物体时，物体表面明暗以不规则方式进行变化，高光显示问题</li><li>光亮度变化不连续的边界处出现过亮或过暗的条纹</li><li>公共顶点处颜色不连续，顶点方向不具代表性</li></ul></li><li><strong>在Gouraud提出明暗处理方法时，Phong模型还没有出现</strong></li></ul><h5 id="Phong明暗处理-双线性法向插值"><a href="#Phong明暗处理-双线性法向插值" class="headerlink" title="Phong明暗处理 (双线性法向插值)"></a>Phong明暗处理 (双线性法向插值)</h5><ul><li>与双线性光强插值相比, 该方法有如下特点:<ul><li>保留双线性插值, 对多边形边上的点和内域各点, 采用增量法。</li><li>对顶点的法向量进行插值, 而顶点的法向量, 用相邻的多边形的法向作平均。</li><li>由插值得到的法向, 计算每个像素的光亮度。</li><li>假定光源与视点均在无穷远处, 光强只是法向量的函数。</li></ul></li><li>优点<ul><li>Phong方法绘制的图形比Gouraud方法更真实</li></ul></li><li>缺点<ul><li>计算量远大于Gouraud方法</li></ul></li></ul><h5 id="阴影的生成"><a href="#阴影的生成" class="headerlink" title="阴影的生成"></a>阴影的生成</h5><ul><li>阴影<ul><li>光源不能直接照射的区域</li><li>对光源来说，不可见的面(隐藏面)</li></ul></li></ul><h3 id="7-3-透明"><a href="#7-3-透明" class="headerlink" title="7.3 透明"></a>7.3 透明</h3><ul><li>现实世界中有许多透明物体，如玻璃等。透过透明物体，可以观察到其后面的景物。</li><li>产生简单透明效果的方法<ul><li>插值透明方法</li><li>过滤透明方法</li></ul></li></ul><h5 id="Whitted光透射模型"><a href="#Whitted光透射模型" class="headerlink" title="Whitted光透射模型"></a>Whitted光透射模型</h5><ul><li>基于经验、理论，不是严格的物理模型。</li></ul><h5 id="Hall光透射模型"><a href="#Hall光透射模型" class="headerlink" title="Hall光透射模型"></a>Hall光透射模型</h5><ul><li>在Whitted光透射模型的基础上推广而来。<ul><li>加入光源引起的规则透射分量。</li><li>可以处理理想的漫透射。</li></ul></li></ul><h3 id="7-4-整体光照明模型"><a href="#7-4-整体光照明模型" class="headerlink" title="7.4 整体光照明模型"></a>7.4 整体光照明模型</h3><ul><li><strong>五个组成部分：</strong><ul><li></li></ul></li><li>简单光照模型是一种局部光照模型，不考虑周围环境对当前 景物表面的光照明影响，<strong>忽略了光在环境景物之间的传递</strong>，很难表现自然界复杂场景的高质量真实感图形。</li><li>基于简单光照明模型的<strong>光透射模型</strong>，虽然可以模拟光的折射，但是这种折射的计算范围很小，不能很好的模拟多个透明 体之间的复杂光照明现象。</li><li>对于上述的这些问题，就必须要有一个更精确的光照明模型。<strong>整体光照明模型</strong>就是这样的一种模型，它是相对于局部光照明模型而言的。</li></ul><h3 id="7-5-光线跟踪算法-P149"><a href="#7-5-光线跟踪算法-P149" class="headerlink" title="7.5 光线跟踪算法 P149"></a>7.5 光线跟踪算法 P149</h3><ul><li><strong>四种光线</strong><ul><li>视线：由视点与象素(x，y)发出的射线</li><li>阴影测试线：物体表面上点与光源的连线</li><li>反射光线 </li><li>折射光线</li></ul></li><li>无论是Gouraud还是Phong明暗绘制算法，都只能模拟局部光照明效果。</li><li>如果场景中存在<strong>光亮的镜面物体和透明物体，则光线会在物体之间反射和折射</strong>，这些都是上述算法所无法模拟的。还不能产生阴影效果。如果必须模拟这些效果，则我们可以采用光线跟踪算法或辐射度算法。</li><li><strong>自然界中光线的传播过程</strong>：光源 -&gt; 物体表面 -&gt; 物体表面 -&gt; 人眼</li><li><p>光线跟踪过程：<strong>光线传播的逆过程(视线跟踪)</strong></p><ul><li>光源发出光线，经反射与折射，只有很少部分可以进入人的眼睛。因此直接从光源出发，沿光的传播方向进行光 线跟踪是不现实的，也是不必要的。</li><li>实际上，<strong>光线跟踪算法的跟踪方向与光传播的方向是相反的，是视线跟踪</strong>。<br><img src="/CG/光线.png" width="45%"></li></ul></li><li><p><strong>优点</strong>: 能够方便的产生阴影，模拟镜面反射与折射现象。 </p></li><li><strong>缺点</strong>: 计算量大，每一条光线都要与场景中的物体进行求交、计算光照模型等。</li></ul><h5 id="递归终止条件"><a href="#递归终止条件" class="headerlink" title="递归终止条件"></a>递归终止条件</h5><ol><li>该光线未碰到任何物体。</li><li>该光线碰到了背景。</li><li>光线在经过许多次反射和折射以后，就会产生衰减，光线对于视点的光强贡献很小(小于某个设定值)。</li><li>光线反射或折射次数即跟踪深度大于一定值。</li></ol><h3 id="7-6-纹理"><a href="#7-6-纹理" class="headerlink" title="7.6 纹理"></a>7.6 纹理</h3><ul><li><strong>颜色纹理</strong>：光滑表面的花纹、图案。</li><li><strong>几何纹理</strong>：粗糙的表面(如桔子表面的皱纹), 是基于物体表面的微观几何形状的表面纹理。</li><li>两种方法来定义纹理:<ul><li>图像纹理</li><li>函数纹理</li></ul></li></ul><ol><li>分辨率为1024x1024的显示器各需要多少字节位平面<br>数为24的帧缓存？<br>A) 512KB ; B) 1 MB ; C) 2MB ; D) 3MB  </li><li>哪一个不是国际标准化组织(ISO)批准的图形标准？<br>A) GKS ; B) PHIGS ; C) CGM ; D) DXF</li><li>在计算机图形学的发展历史上，是谁确立了计算机图形学作为一门新学科的地位，他的哪些技术直到今天还在使用？</li><li>计算机图形系统的硬件设备有哪些？</li><li>光栅扫描显示器中，屏幕图形是依靠帧缓存进行刷新的，帧缓存里存放的是什么？</li><li>简述随机扫描显示器和光栅扫描显示器的简单工作原理和各自的特点。</li><li>用中点画线方法扫描转换连接两点P0（0,0）和P1（5,2）的直线段。<br>a = y0 - y1 = -2<br>b = x1 - x0 = 5<br>d0 = 2 <em> a + b = 1<br>d1 = 2 </em> a = -4<br>d2 = 2 * (a+b) = 6<br><img src="/CG/中点.png" width="45%"></li></ol><h2 id="图形学题目"><a href="#图形学题目" class="headerlink" title="图形学题目"></a>图形学题目</h2><ol><li>Breenham算法：<br><img src="/CG/bre.png" width="20%">  <img src="/CG/bre1.png" width="20%"></li><li>中点画圆算法<br><img src="/CG/中点画圆1.png" width="70%"></li><li><p>用边相关扫描线填充算法将顶点为P1 (2，2)，P2 (5，1)， P3(10，3)， P4(8，8)，P5(5，5)，P6(2，7)的多边形填充。请说明如何建立新边表NET和活动边表AET并写出该多边形填充的新边表NET和活动边表AET。<br><img src="/CG/扫描.png" width="60%"> </p></li><li><p>用数值微分DDA算法、中点算法和Bresenham算法扫描转换直线段(1,1)–(5,3)，<br>写出扫描转换的结果:写出每一步递推过程的x，y坐标及判别式d的值，图示计<br>算结果。</p></li><li>图中有两条圆弧A和B，假定当前取点为(xi，yi)，那么下一点只能是正<br>右方的 E(xi+1，yi)或右下方的SE(xi+1，yi-1)两者之一。 假设M是E和SE的中点，即，利用中点画圆算法，回答下列问题:<ul><li>当F(M) &lt; 0时，下一点应取哪个点? <strong>E点</strong> </li><li>当F(M) &gt; 0时，下一点应取哪个点? <strong>SE点</strong></li><li>当F(M) = 0时，下一点应取哪个点?  <strong>在E与SE之中随便取一个 即可，我们约定取SE点。</strong><br><img src="/CG/选点.png" width="30%"> </li></ul></li><li>裁剪的实质是什么?<ul><li>ans：裁剪的实质就是决定图形中哪些点、线段、文字、以及多边形在窗口之内。 </li></ul></li><li>已知窗口左下角坐标(50，50)，右上角坐标(400，400) 直线的端点坐标P1(40，100)和P2(500，420)， 试用Cohen-Sutherland直线编码裁剪算法，结合编码图示， 求出P1和P2所在区域的分区代码C1和C2。<ul><li>C1为0001; C2为1010 。 </li></ul></li><li>当线段与窗口边界有交点时，如果线段的长度为1024， 用中点分割算法求交点的次数是多少?<ul><li>10次。</li></ul></li><li>用Weiler-Atherton算法完成内裁剪和外裁剪。DCBA为裁剪窗口，dcba为要裁剪的多边形。<br><img src="/CG/wa题.png" width="50%"> </li><li>一个由顶点(10，20)，(20，20)和(15，30)所定义的三角形，让它相对于点Q(5，25)正向旋转30°，求其变换后的三角形。<br><img src="/CG/几何1.png" width="60%"> </li><li>推导以直线ax+by+c=0为对称轴的二维对称变换矩阵。<br><img src="/CG/几何2.png" width="70%"> </li><li>在坐标系oxyz中，求一个变换将P(1,1,1)Q(2,2,2)变换到z 轴上:P在坐标原点，Q在z轴正半轴。<br><img src="/CG/3dt.png" width="70%"> </li><li>如图所示三角形ABC，将其关于A点逆时针旋转90度，写 出其变换矩阵和变换后图形各点的规范化齐次坐标。<br><img src="/CG/3dti.png" width="40%"> </li><li>下列有关平面几何投影的叙述，错误的是( )<br>A)透视投影又可分为一点透视、二点透视、三点透视;<br>B)斜投影又可分为斜等测、斜二测;<br>C)正轴测又可分为正一测、正二测、正三测;<br>D)三视图又可分为正视图、侧视图、俯视图。</li><li>下列有关平面几何投影的叙述语句中，正确的论述为( )<br>A)在平面几何投影中，若投影中心移到距离投影面无穷远 处，则成为平行投影;<br>B)透视投影与平行投影相比，视觉效果更有真实感，而且 能真实地反映物体的精确的尺寸和形状;<br>C)透视投影变换中，一组平行线投影在与之平行的投影面 上，可以产生灭点;<br>D)在三维空间中的物体进行透视投影变换，可能产生三个 或者更多的主灭点。  </li><li>用下列二维图形变换矩阵:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;0&nbsp;1&nbsp;<br>T&nbsp;=&nbsp;0&nbsp;1&nbsp;1&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    0&nbsp;0&nbsp;1  &nbsp;<br>将产生变换的结果为( )<br>A) 图形放大2倍;<br>B) 图形放大2倍，同时沿X、Y坐标轴方向各移动1个绘图单位;<br>C) 沿X坐标轴方向各移动2个绘图单位;<br>D) 沿X坐标轴方向放大2倍，同时沿X、Y坐标轴方向各平移1个 绘图单位。</li><li>下列有关透视投影的叙述，错误的是( )<br>A)投影线从视点出发;<br>B)投影线不平行;<br>C)任何一束不平行于投影面的平行线的透视投影将汇成一点;<br>D)主灭点有无数个。  </li><li>请解释平面几何投影的含义。</li><li>何为“透视投影”?并说明“灭点”和“主灭点”是如何产生的?</li><li>什么是观察坐标系?为什么要建立观察坐标系?</li><li>已知投影面为xoy坐标平面，投影中心在z轴的正向、z=d的 位置上，求透视投影变换矩阵。</li><li>描述Z缓存器消隐算法的基本原理和算法实现;</li><li>光线跟踪算法的跟踪方向与光传播的方向是相同的，是视线 跟踪。( )</li><li>双线性法向插值算法先计算出曲面在各多边形顶点处的光强 ，然后再采用双线性插值方法确定在扫描线上每个像素处的 光强值，得到多边形的光滑颜色分布。( )</li><li>非理想镜面反射中，镜面反射指数n模拟镜面反射光在空间 中的汇聚程度，n越大，表面越粗糙( )。</li><li>粗糙的物体表面能够将反射光向各个方向散射， 称为( )。</li><li>比较Gouraud明暗处理算法和Phong明暗处理算法的优缺点。</li><li>何谓“光线跟踪算法”?请简要叙述光线跟踪算法的基本思想。</li></ol><ul><li>CRT的原理简单了解</li><li>光栅图形显示系统：4部分 每一部分具体是做什么用的 </li><li>中点算法增量法的改进 为什么可以摆脱小数计算</li><li>扫面线算法 四个步骤，交点的计数问题</li><li>字符的两种类型 和存储的信息分别是什么</li><li>Cyrus Beck Line Clipping 梁八子算法不作要求</li><li>消隐算法的分类 要能判断。画家算法 Z-Buffer及它的改进 要能描述清楚，其余的了解基本思想和优缺点</li><li>物体对光产生<strong>反射、投射</strong>和部分<strong>吸收</strong>成热能，填空</li><li>两种投影类型 正轴测投影的分类，透视投影变换要会推导</li><li>三维图像的显示流程（剪裁和投影的前后关系）</li><li>光线跟踪算法的递归终止条件 简答题</li><li>为什么引入齐次坐标 ？把加法变成乘法；统一的表达方式；无穷？？</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-计算机图形学概述&quot;&gt;&lt;a href=&quot;#1-计算机图形学概述&quot; class=&quot;headerlink&quot; title=&quot;1. 计算机图形学概述&quot;&gt;&lt;/a&gt;1. 计算机图形学概述&lt;/h2&gt;&lt;h3 id=&quot;1-1-研究内容&quot;&gt;&lt;a href=&quot;#1-1-研究内容&quot; class=&quot;headerlink&quot; title=&quot;1.1 研究内容&quot;&gt;&lt;/a&gt;1.1 研究内容&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;图形&lt;/code&gt;含有几何属性，或者说更强调场景的集合表示，是由场景的几何模型和警务的物理属性共同组成。（矢量/参数）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;图像&lt;/code&gt;是指计算机内以位图形式存在的灰度信息。（位图）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;计算机图形学&lt;/code&gt;：利用计算机研究一系列原理、方法与技术的学科。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="https://daisine.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="note" scheme="https://daisine.github.io/tags/note/"/>
    
      <category term="图形学" scheme="https://daisine.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>UML</title>
    <link href="https://daisine.github.io/uml/"/>
    <id>https://daisine.github.io/uml/</id>
    <published>2018-12-13T03:51:47.000Z</published>
    <updated>2019-05-10T10:52:18.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-面向对象技术概述"><a href="#1-面向对象技术概述" class="headerlink" title="1. 面向对象技术概述"></a>1. 面向对象技术概述</h2><h5 id="1-1-软件危机及软件工程"><a href="#1-1-软件危机及软件工程" class="headerlink" title="1.1 软件危机及软件工程　"></a>1.1 软件危机及软件工程　</h5><ul><li><strong>软件危机，软件工程</strong>的提出<ul><li>软件危机是指落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。<a id="more"></a></li><li>软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。</li></ul></li><li><strong>软件工程的目的</strong>就是在规定的时间、规定的开发费用内开发出满足用户需求的高质量的软件系统。<ul><li>高质量不只是指错误率低，还包括好用、易用、可移植、易维护等。</li></ul></li></ul><h5 id="1-2-对软件开发的基本认识"><a href="#1-2-对软件开发的基本认识" class="headerlink" title="1.2 对软件开发的基本认识　"></a>1.2 对软件开发的基本认识　</h5><ul><li><strong>软件是一个逻辑部件</strong>，而不是一个物理部件，所以软件具有与硬件不同的特点：<ul><li>表现形式不同</li><li>生产方式不同</li><li>产品要求不同</li><li>维护方式不同</li></ul></li></ul><h5 id="1-3-软件的固有复杂性"><a href="#1-3-软件的固有复杂性" class="headerlink" title="1.3 软件的固有复杂性　"></a>1.3 软件的固有复杂性　</h5><ul><li>著名的计算机专家、被称之为IBM 360系列计算机之父的F. Brooks认为软件的复杂性是固有的，软件可能是人类所能制造出来的最复杂的实体。 </li><li>软件固有复杂性使得开发成员之间的通讯变得困难，开发费用超支、开发时间延期等；也导致产品有缺陷、不易理解、不可靠、难以使用、功能难以扩充等。</li><li><strong>软件的复杂性是固有的</strong>，即不能采用某种方法彻底消除软件的复杂性，因此软件危机只能是通过控制复杂性的方法解决。</li></ul><h5 id="1-4-控制软件复杂性的基本方法"><a href="#1-4-控制软件复杂性的基本方法" class="headerlink" title="1.4 控制软件复杂性的基本方法"></a>1.4 控制软件复杂性的基本方法</h5><ul><li><strong>分解</strong><ul><li>对复杂系统采用“各个击破”的策略</li></ul></li><li><strong>抽象</strong><ul><li>抽取系统中的基本特性而忽略非基本的部分</li></ul></li><li><strong>模块化</strong><ul><li>高内聚（cohesion），低耦合（coupling）</li><li>高内聚指的是在一个模块中应尽量多地汇集逻辑上相关的计算资源；低耦合指的是模块之间的相互作用应尽量少。</li></ul></li><li><strong>信息隐蔽</strong><ul><li>也称封装</li><li>模块内部的实现细节与外界隔离</li></ul></li></ul><h5 id="1-5-面向对象技术"><a href="#1-5-面向对象技术" class="headerlink" title="1.5 面向对象技术"></a>1.5 面向对象技术</h5><ul><li>对象（object）  行动或思考时作为目标的人或事物对象。</li><li>对象是系统中用来描述客观事物的一个实体，它是构成系统的一个基本单位。</li><li>一个对象由<strong>一组属性（特性）和对这组属性进行操作的一组操作（方法）</strong>组成。属性和操作合起来被称为特征（feature）</li><li><strong><code>类</code></strong>是具有相同属性和方法的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，其内部包括属性和方法两个主要部分。</li><li>对象是一个类（种类）的实例。类是用来创建对象的模板。</li></ul><h5 id="1-6-面向对象领域中的基本概念"><a href="#1-6-面向对象领域中的基本概念" class="headerlink" title="1.6 面向对象领域中的基本概念"></a>1.6 面向对象领域中的基本概念</h5><ul><li><strong>继承(子类，超类)</strong><ul><li>特殊类的对象拥有其一般类的全部属性与方法，称作特殊类对一般类的继承。</li><li>一般类/特殊类；父类/子类；超类/子类；基类/派生类等是相同的概念。</li><li>子类都继承了父类的特征。</li></ul></li><li><strong>多态性</strong><ul><li>在面向对象技术中，多态指的是使一个实体在不同的上下文条件下具有不同意义或用法的能力。</li><li>不同的类中可以有同名的操作，每个类中发生的操作各不相同。</li></ul></li><li><strong>封装 / 信息隐藏</strong><ul><li>把对象的属性和方法结合成一个独立的系统单位，并尽可能隐蔽对象的内部细节。</li></ul></li><li><strong>接口</strong></li><li><strong>消息传递</strong><ul><li><code>消息</code>：就是向对象发出的服务请求，它包含下述信息：提供服务的对象标识、服务（方法）标识、输入信息和回答信息。</li><li>对象之间的协作是通过相互发送消息。</li><li>一个对象发送一个操作消息（或请求）给另一个对象，接受消息的对象就执行这个操作。</li></ul></li><li><strong>关联</strong><ul><li>对象之间通常以某种方式发生关联。</li><li>对象之间有时能以多种方式发生关联</li><li>一个类可以和多个类关联。</li><li>多重性：用于说明在关联中一个类的对象可以对应另一个类的多少对象。</li></ul></li><li><strong>聚集</strong><ul><li>聚集的一种形式是聚集对象和它的组成对象之间具有强关联。<br>一个典型的计算机系统就是聚集的一个例子——它由许多不同类型的对象组合而成。</li><li>组成的关键特征是部分对象<strong>只能</strong>存在于组成对象之中。在组成体中，部分对象有时可能先于组成体消亡。<br>树叶可能先于树而消亡。衬衫是衬衫主体、衣领、衣袖、纽扣..的组成体。</li></ul></li></ul><h5 id="1-7-小结-P29"><a href="#1-7-小结-P29" class="headerlink" title="1.7 小结 P29"></a>1.7 小结 P29</h5><ul><li>面向对象是一种依赖于几个基本原则的思维方法。对象是类的实例。类是具有相同属性和操作的一类对象集。当你创建了一个对象后，对象的属性和操作数目由你所处理的问题域确定。</li><li><strong>继承</strong>是面向对象中的一个重要方面。对象继承了所属类的属性和操作。类同样也可以继承其它类的属性和操作。</li><li><strong>多态性</strong>是另一个重要的方面，它是指不同的类中可以有相同名字的操作，并且这个操作在每个类中都能以各自不同的方式执行。</li><li>对象对其他对象和外部世界隐藏了其操作的执行过程。每个对象都要提供一个让其他对象（和人）用来执行该对象中操作的接口。</li><li>对象通过相互之间的消息传递协同工作。消息是执行操作的请求。</li><li>对象通常要和其他对象发生关联。关联可以具有多种形式。一个类的对象可能和多个其他类的对象同时发生关联。</li><li><strong>聚集是关联的一种</strong>，聚集对象由部分构成。<strong>组成又是一种特殊的聚集</strong>。在一个组成对象中，部分对象只能作为组成对象的一部分与组成对象同时存在。</li></ul><h2 id="2-UML概述"><a href="#2-UML概述" class="headerlink" title="2. UML概述"></a>2. UML概述</h2><h5 id="2-1-为什么要学习UML？"><a href="#2-1-为什么要学习UML？" class="headerlink" title="2.1 为什么要学习UML？"></a>2.1 为什么要学习UML？</h5><ul><li>什么是UML？<ul><li>UML是Unified Modeling Language（统一建模语言）的简称。</li><li>UML是对软件密集型系统中的制品（软件开发过程中产生的各种各样的产物，如模型、源代码、测试用例等）进行可视化、详述、构造和文档化的语言。</li></ul></li><li>模型<ul><li>模型是用文字、图表、符号、关系式以及实体模样等描述所认识到的客观对象的一种简化表示形式。它是人们为了研究和解决客观世界中存在的各种问题而对客观现实经过思维抽象后得到的。简单地说，模型就是所描述客观对象的抽象表示。</li><li>一般来讲，模型都包含一个完整的概念集合、一套相应的表示方法以及必要的规则约束，它们为人们抽象地表达客观对象提供了一个参考性的框架环境。</li></ul></li><li>建立模型的优点<ul><li>使用模型可以更好地理解问题 </li><li>使用模型可以加强人员之间的沟通 </li><li>使用模型可以更早地发现错误或疏漏的地方 </li><li>使用模型可以获取设计结果 </li><li>模型为最后的代码生成提供依据 </li></ul></li></ul><h5 id="2-2-UML的历史"><a href="#2-2-UML的历史" class="headerlink" title="2.2 UML的历史"></a>2.2 UML的历史</h5><ul><li>UML是由世界著名的面向对象技术专家G. Booch, J. Rumbaugh 和 I. Jacobson发起，在Booch方法，OMT方法和OOSE方法的基础上，广泛征求意见，集众家之长，几经修改而完成的。</li><li>为什么UML能得到广泛的应用<ul><li>图形化的建模语言</li><li>开发者用来为面向对象系统建立模型</li><li>具有灵活性与可扩展性</li></ul></li><li>由Object Management Group (OMG)推荐成为国际标准。目前最新的UML规范说明是2003年3月发布的1.5版本（<a href="http://uml.org）" target="_blank" rel="noopener">http://uml.org）</a></li></ul><h5 id="2-3-UML的特点"><a href="#2-3-UML的特点" class="headerlink" title="2.3 UML的特点"></a>2.3 UML的特点</h5><ul><li>UML的主要特点： <ul><li>统一的标准：UML已被OMG接受为标准的建模语言</li><li>面向对象</li><li>可视化、表示能力强大</li><li>独立于过程</li><li>概念明确，建模表示法简洁，图形结构清晰，容易掌握使用</li></ul></li><li>UML和程序设计语言的关系<ul><li>用Java，C++ 等 programming language是用编码实现一个系统</li><li>用UML是对一个系统建立模型</li><li>一些软件工具可以根据 UML所建立的系统模型来产生Java, C++ 或其它程序设计语言代码框架。</li></ul></li></ul><h5 id="2-4-UML的构成"><a href="#2-4-UML的构成" class="headerlink" title="2.4 UML的构成"></a>2.4 UML的构成</h5><ul><li><strong><code>类图</code></strong></li><li>对象图</li><li><strong><code>用例图</code></strong></li><li><strong><code>顺序图</code></strong></li><li>协作图</li><li>状态图</li><li><strong><code>活动图</code></strong></li><li>构件图</li><li>配置图</li></ul><p><img src="/uml/图关系.png" width="60%"><img src="/uml/4+1.png" width="40%">  </p><h5 id="2-5-UML中的视图"><a href="#2-5-UML中的视图" class="headerlink" title="2.5 UML中的视图"></a>2.5 UML中的视图</h5><ul><li>UML中的视图包括：（这5个视图被称为“4+1”视图）<ul><li>用例视图</li><li>逻辑视图：用于表示系统的概念设计和子系统结构等。</li><li>实现视图：用于说明代码的结构。</li><li>进程视图：用于说明系统中并发执行和同步的情况。</li><li>部署视图：用于定义硬件节点的物理结构。</li></ul></li></ul><h5 id="2-6-UML在系统开发各阶段的应用"><a href="#2-6-UML在系统开发各阶段的应用" class="headerlink" title="2.6 UML在系统开发各阶段的应用"></a>2.6 UML在系统开发各阶段的应用</h5><ul><li>在<strong>分析阶段</strong>，用户的需求用UML模型来描述。</li><li>在<strong>设计阶段</strong>，引入定义软件系统中技术细节的类（如处理用户接口、数据库、通信和并行性等问题的类）。</li><li>在<strong>实现阶段</strong>，用面向对象程序设计语言将来自设计阶段的类转换成实际的代码。</li><li>UML模型还是<strong>测试阶段</strong>的依据<ul><li>单元测试使用类图和类规格说明。</li><li>集成测试使用构件图和协作图。</li><li>系统测试使用用例图来验证系统的行为。</li></ul></li></ul><h2 id="3-UML各种图简介"><a href="#3-UML各种图简介" class="headerlink" title="3. UML各种图简介"></a>3. UML各种图简介</h2><h5 id="3-1-类图与对象图"><a href="#3-1-类图与对象图" class="headerlink" title="3.1 类图与对象图"></a>3.1 类图与对象图</h5><ul><li>类是一类或者一组具有类似属性和共同行为的事物。</li><li>UML类图的特点：<ul><li>矩形方框</li><li>被分为三个区域：类名、类的属性、类的操作</li><li>类名由多个单词组成；每个单词的首字母要大写，单词之间不用空格</li><li>属性名和操作名也类似，但首字母不用大写 </li><li>每个操作名的后面都有一对括号<br><img src="/uml/类图标.png" width="22%">  <img src="/uml/对象图标.png" width="65%"> </li></ul></li><li>对象是一个类的实例，是具有具体属性值的一个具体事物。<ul><li>矩形方框</li><li>对象名首字母为小写，对象名下面要带下划线</li><li>冒号左边为实例名，冒号右边为类名；对象也可以是匿名</li></ul></li></ul><h5 id="3-2-用例图"><a href="#3-2-用例图" class="headerlink" title="3.2 用例图"></a>3.2 用例图</h5><ul><li>用例是从用户的观点对系统行为的一个描述；它是用来从用户的观察角度收集系统需求的主要技术。</li><li>用例图的特点：<ul><li>直立小人被称为参与者（actor）；参与者可以是一个人，也可以是另一个系统.</li><li>椭圆形代表用例。</li><li>矩形代表系统。<br><img src="/uml/用例图.png" width="35%">   <img src="/uml/状态图.png" width="20%"></li></ul></li></ul><h5 id="3-3-状态图"><a href="#3-3-状态图" class="headerlink" title="3.3 状态图"></a>3.3 状态图</h5><ul><li>在任一给定的时刻，一个对象总是处于某一特定的<strong>状态</strong>。</li><li>UML状态图的特点：<ul><li>圆角矩形</li><li>最顶端的符号（实心圆）代表起始状态，而最底端的符号（眼形圆）表示终止状态</li></ul></li></ul><h5 id="3-4-顺序图"><a href="#3-4-顺序图" class="headerlink" title="3.4 顺序图"></a>3.4 顺序图</h5><ul><li>顺序：类图和对象图表达的是系统的静态结构。在一个运行的系统中，对象之间要发生交互，并且这些交互要经历一定的时间。UML顺序图所表达的正是这种<strong>基于时间的动态交互</strong>。</li><li>顺序图的特点：<ul><li>横坐标为系统中的对象</li><li>每个对象都有一个或多个操作</li><li>对象间通过相互传递消息来协同工作</li><li>纵坐标为时间序列<br><img src="/uml/顺序图2.png" width="50%">  </li></ul></li></ul><h5 id="3-5-活动图"><a href="#3-5-活动图" class="headerlink" title="3.5 活动图"></a>3.5 活动图</h5><ul><li>活动即工作步骤。</li><li>活动图的特点：<ul><li>和流程图很接近</li><li>圆角矩形（比状态图更窄，更接近与椭圆）</li><li>箭头表示活动的转移 </li><li>实心圆代表起点，眼形圆代表终点<br><img src="/uml/活动图.png" width="35%">   <img src="/uml/协作图.png" width="50%"> </li></ul></li></ul><h5 id="3-6-协作图"><a href="#3-6-协作图" class="headerlink" title="3.6 协作图"></a>3.6 协作图</h5><ul><li>协作图用于展示对象之间的交互关系。<ul><li>对象图展示出对象之间的静态关系。协作图是对对象图的扩展。协作图除了展示对象之间的关联，还显示出对象之间的消息传递。</li></ul></li><li>协作图的特点：<ul><li>关联线附近的箭头线表示对象之间传递的消息，箭头指向消息接收对象</li><li>消息名称和消息序号附在箭头线附近</li><li>顺序图和协作图之间可以相互转换  </li></ul></li></ul><h5 id="3-7-构件图"><a href="#3-7-构件图" class="headerlink" title="3.7 构件图"></a>3.7 构件图</h5><ul><li>软件构件是软件系统的一个物理单元。在UML中，数据文件、表格、可执行文件、文档和动态链接库等都被定义为构件。</li><li>构件图和部署图与整个计算机系统密切相关。</li><li>构件图的特点：<ul><li>一个左侧附有两个小矩形的大矩形框。</li><li>也可以用一个顶部带关键字 &lt;<component>&gt;的矩形表示。<br><img src="/uml/构件图1.png" width="40%"> <img src="/uml/构件图2.png" width="30%"> </component></li></ul></li></ul><h5 id="3-8-部署图"><a href="#3-8-部署图" class="headerlink" title="3.8 部署图"></a>3.8 部署图</h5><ul><li>部署图的用途：UML部署图显示了基于计算机系统的物理体系结构。</li><li>部署图的特点：<ul><li>立方体图标</li><li>立方体之间的连线表示体系之间的关系<br><img src="/uml/部署图.png" width="40%"></li></ul></li></ul><h5 id="3-9-其他特征"><a href="#3-9-其他特征" class="headerlink" title="3.9 其他特征"></a>3.9 其他特征</h5><ul><li>注释：通过附加注释来做解释说明。</li><li>符号特征：<ul><li>带折角的矩形，矩形中是解释性文字。</li><li>注释和被注释的图元素之间用一条虚线连接。</li></ul></li><li>构造型（版型）<ul><li>版型是建模人员在已有的构造块上派生出的新构造块，这些新构造块是和特定问题相关的。</li><li>版型可以应用于所有类型的模型元素，包括类、节点、构件、注解、关系、包、操作等。</li></ul></li><li>关键字<ul><li>版型用两对尖括号括起来的一个名称来表示，这个括号叫做双尖括号（guillemots）。这个被括起来的名称叫做关键字。</li><li>如<code>&lt;&lt;Interface&gt;&gt;，&lt;&lt;entity&gt;&gt;</code></li></ul></li></ul><h5 id="3-10-为什么需要这么多种图"><a href="#3-10-为什么需要这么多种图" class="headerlink" title="3.10 为什么需要这么多种图"></a>3.10 为什么需要这么多种图</h5><ul><li>每一种UML图都提供一种组成特殊视图的方式。采用多视角的目标是为了能够和每一类风险承担人良好地沟通。</li><li>UML是一套表示法系统。</li><li>UML由一组图组成，它使得系统分析员可以利用这一标准来建立能够和客户、程序员以及任何参与程序开发的人员理解的多视角的系统蓝图。不同的风险承担人通常使用不同类型的图相互交流。</li><li>UML模型<strong>只说明一个系统应该做什么</strong>，并没有告诉我们系统应该怎么做。</li></ul><h2 id="4-关系"><a href="#4-关系" class="headerlink" title="4. 关系"></a>4. 关系</h2><h5 id="4-1-关联"><a href="#4-1-关联" class="headerlink" title="4.1 关联"></a>4.1 关联</h5><ul><li><strong>关联</strong>：当类之间在概念上有连接关系时，类之间的连接叫做关联。<ul><li>用一条线连接两个类，并把关联的名字放在这个连线上</li><li>关联的方向用一<strong>个实心三角形箭头</strong>来指明<br><img src="/uml/关联.png" width="50%">  <img src="/uml/关联1.png" width="35%"> <img src="/uml/关联.png" width="50%">  </li></ul></li><li><strong>关系上的约束</strong>：两个类之间的一个关联随后就有一个规则，可以通过关联线附近加注一个约束来说明这个规则。<ul><li>花括号、虚线（或关系）</li></ul></li><li><strong>关联类</strong>：和类一样，关联也可以有自己的属性和操作，称为关联类。<ul><li>用虚线将关联类和对应的关联线连接起来。</li></ul></li><li><strong>链</strong>：关联类的实例叫做链。（类的实例是对象）<ul><li>用一条线连接两个对象，并把链的名字放在这个连线上。</li><li>链的名字也要加下划线。<br><img src="/uml/约束.png" width="35%"> <img src="/uml/链.png" width="50%"><br><img src="/uml/关联类.png" width="50%"></li></ul></li></ul><h5 id="4-2-多重性"><a href="#4-2-多重性" class="headerlink" title="4.2 多重性"></a>4.2 多重性</h5><ul><li>多重性：某个类有多个对象可以和另一个类的多个对象关联。<ul><li>符号特征：在参与关联的类附近的关联线上注明多重性数值。UML使用 <code>*</code> 来代表许多；<code>1..*</code> 代表一个或多个；<code>,</code> 代表”或”关系<br><img src="/uml/多重性.png" width="50%"></li></ul></li></ul><h5 id="4-3-限定关联"><a href="#4-3-限定关联" class="headerlink" title="4.3 限定关联"></a>4.3 限定关联</h5><ul><li>在UML中，标识符ID（identification）信息叫做限定符。<ul><li>符号特征：一个小矩形框<br><img src="/uml/限定关联.png" width="50%"></li></ul></li></ul><h5 id="4-4-自身关联"><a href="#4-4-自身关联" class="headerlink" title="4.4 自身关联"></a>4.4 自身关联</h5><ul><li>一个类可能与它自己发生关联，这样的关联被称为自身关联。<br><img src="/uml/自身关联.png" width="50%"></li></ul><h5 id="4-5-继承与泛化"><a href="#4-5-继承与泛化" class="headerlink" title="4.5 继承与泛化"></a>4.5 继承与泛化</h5><ul><li><p>继承：如果你知道某物所属的种类，你自然就会知道同类的其他事物也具有该事物的一些特征。在面向对象术语中，这种关系被称为继承。<strong>在UML中，则被称为泛化</strong>。  </p><blockquote><p>基类或根类 —— 叶类<br>单继承 —— 多继承   </p></blockquote><ul><li>符号特征： <strong>指向父类一端</strong>带有一个空心三角箭头<br><img src="/uml/泛化.png" width="35%"></li></ul></li><li>抽象类：不提供实例对象的类被称为抽象类。 <ul><li>符号特征：类名<strong>用斜体书写</strong></li></ul></li></ul><h5 id="4-6-依赖"><a href="#4-6-依赖" class="headerlink" title="4.6 依赖"></a>4.6 依赖</h5><ul><li>依赖：如果一个类使用了另一个类，这种关系称之为依赖。<ul><li>符号特征：在有依赖关系的类之间画上一条带箭头的虚线<br><img src="/uml/依赖.png" width="45%"></li></ul></li></ul><h5 id="4-7-类图和对象图"><a href="#4-7-类图和对象图" class="headerlink" title="4.7 类图和对象图"></a>4.7 类图和对象图</h5><ul><li><p>类图给出的是多个类以及类之间的关系，它描述的是一般性的、定义性的信息</p><ul><li>类图包括类以及类之间的关联；</li><li>类图用来表现系统的静态构成；</li><li>一个系统的静态构成可以由<strong>多张类图</strong>来共同描述，不同的类图描述了系统的不同层面、角度及范围。</li></ul></li><li><p>对象图则在某个特定时刻多个具体实例以及它们如何联系起来的信息。<br><img src="/uml/类图.png" width="45%"> <img src="/uml/对象图.png" width="45%"> </p></li></ul><h2 id="5-聚集、组成、接口和实现"><a href="#5-聚集、组成、接口和实现" class="headerlink" title="5. 聚集、组成、接口和实现"></a>5. 聚集、组成、接口和实现</h2><h5 id="5-1-聚集"><a href="#5-1-聚集" class="headerlink" title="5.1 聚集"></a>5.1 聚集</h5><ul><li>聚集：一个类有时是由几个部分类构成，这种特殊类型的关系被称为聚集。部分类和由它们组成的类之间是一种整体－部分（part-whole）关联。<ul><li>符号特征：关联线上有一个<strong>空心菱形箭头</strong>，箭头的方向是从部分指向整体。<br><img src="/uml/聚集.png" width="55%"> </li></ul></li><li>聚集上的约束：可以在聚集上施加一个“or”约束，它表示某个整体包含一个或另一个部分。<br><img src="/uml/聚集约束.png" width="55%"> </li></ul><h5 id="5-2-组成"><a href="#5-2-组成" class="headerlink" title="5.2 组成"></a>5.2 组成</h5><ul><li>组成：组成是强类型的聚集。聚集中每个部分体只能属于一个整体。<ul><li>符号特征：关联线上有一个实心菱形箭头，箭头的方向是从部分指向整体。<br><img src="/uml/组成.png" width="55%"> </li></ul></li></ul><h5 id="5-3-组成结构图"><a href="#5-3-组成结构图" class="headerlink" title="5.3 组成结构图"></a>5.3 组成结构图</h5><ul><li>组成是展示一个类的构件的一种方式。通过组成结构图可以展示<strong>类的内部结构</strong>。<br><img src="/uml/组成结构图.png" width="50%"></li></ul><h5 id="5-4-接口和实现"><a href="#5-4-接口和实现" class="headerlink" title="5.4 接口和实现"></a>5.4 接口和实现</h5><ul><li><strong>接口</strong>是描述类的部分行为的一组操作，它也是一个类提供给另一个类的一组操作。<ul><li>符号特征：和类相似，都是用一个矩形图标来代表。接口只是一组操作，没有属性。</li></ul></li><li><strong>实现</strong>：一个类和它的接口之间的关系叫做实现。<ul><li>符号特征：和继承符号相似，但它是一个带空心三角形的箭头的虚线表示，箭头的方向指向接口。省略表示法是将接口表示为一个小圆圈，并和实现它的类用一条线连起来</li></ul></li></ul><p><img src="/uml/接口1.png" width="55%">  <img src="/uml/接口2.png" width="30%"><br><img src="/uml/接口3.png" width="50%">  <img src="/uml/接口4.png" width="40%"> </p><h5 id="5-5-接口和端口"><a href="#5-5-接口和端口" class="headerlink" title="5.5 接口和端口"></a>5.5 接口和端口</h5><ul><li>端口<ul><li>符号特征：位于类符号边缘上的一个小方格，这个小方格连接到接口<br><img src="/uml/端口.png" width="40%"> </li></ul></li></ul><h5 id="5-6-可见性"><a href="#5-6-可见性" class="headerlink" title="5.6 可见性"></a>5.6 可见性</h5><ul><li><strong>可见性</strong>可应用于属性或操作，它说明在给定类的属性和操作（或者接口的操作）的情况下，其他类可以访问到的属性和操作的范围。</li><li><strong>可见性有三个层次</strong>（级别）：<ul><li>公有层次上，其他类可以直接访问这个层次中的属性和操作。</li><li>受保护层次上，只有继承类这些属性和操作的子类可以访问最初类的属性和操作。</li><li>私有层次上，只有最初的类才能访问这些属性和操作。</li></ul></li><li>符号特征<ul><li><code>+</code> 表示该操作或属性是公有的（其它类可访问）</li><li><code>#</code> 表示该操作或属性是受保护的（子类才可访问）</li><li><code>-</code> 表示该操作或属性是私有的（最初类才可访问）</li></ul></li></ul><h5 id="5-7-作用域"><a href="#5-7-作用域" class="headerlink" title="5.7 作用域"></a>5.7 作用域</h5><ul><li>作用域是与属性和操作相关的又一个重要概念。存在两种可能的作用域：<ul><li>实例作用域：类的每个实例对象都有自己的属性值和操作。</li><li>分类符作用域：一个类的所有实例只存在一个属性值和操作。</li></ul></li></ul><h2 id="6-用例图"><a href="#6-用例图" class="headerlink" title="6. 用例图"></a>6. 用例图</h2><h5 id="6-1-什么是用例"><a href="#6-1-什么是用例" class="headerlink" title="6.1 什么是用例"></a>6.1 什么是用例</h5><ul><li>用例的定义：<ul><li>用例是系统的一组使用场景。每个场景描述了一个事件的序列。每个序列是由一个人、另一个系统、一台硬件设备或者某段时间的流逝所发起。</li><li>这些发起事件序列的实体叫做<strong>参与者</strong>。</li><li>用例是对一个<strong>参与者</strong>使用系统的一项功能时所进行的交互过程的一个文字描述序列。<br><img src="/uml/用例图1.png" width="40%"> </li></ul></li></ul><h5 id="6-2-用例模型的表示法"><a href="#6-2-用例模型的表示法" class="headerlink" title="6.2 用例模型的表示法"></a>6.2 用例模型的表示法</h5><ul><li>用例模型（use case model）<ul><li>用户知道的比他们清楚表达出来的要多，用例能帮助用户解决表达问题。</li><li>用例是由参与者发起的，参与者（或许是发起者，但不是必须的）能够从用例的执行中获得有价值的事物。</li><li>参与者、用例和互连线共同组成了用例模型。</li></ul></li><li>每个用例是一组场景的组合，而每个场景又是一个步骤序列。</li><li><p>用例描述的主要内容：</p><ul><li>用例的目标</li><li>用例是怎样启动的</li><li>参与者和用例之间的消息是如何传递的</li><li>用例中除了主路径外，其它路径是什么</li><li>用例结束后的系统状态</li><li>其它需要描述的内容</li></ul></li><li><p>符号特征：</p><ul><li>用例用一个椭圆形表示。</li><li>参与者用直立人形图标表示。</li><li>用例的发起参与者在用例图的左侧，接收参与者在用例图的右侧。</li><li>关联线连接参与者和用例并且表示参与者与用例之间有通信关系；关联线是实线。</li></ul><p><img src="/uml/用例图2.png" width="40%">  </p></li></ul><h5 id="6-3-用例之间关系的可视化表示"><a href="#6-3-用例之间关系的可视化表示" class="headerlink" title="6.3 用例之间关系的可视化表示"></a>6.3 用例之间关系的可视化表示</h5><ul><li><strong><code>包含</code></strong>：在一个用例中重用另一个用例中的步骤<ul><li>符号特征：虚线箭头，箭头指向被包含的用例，在虚线上加关键字<code>&lt;&lt;include&gt;&gt;</code><br><img src="/uml/用例包含.png" width="40%"> </li></ul></li><li><strong><code>扩展</code></strong>：通过对已有用例增加步骤创建一个新的用例<ul><li>基用例：新用例扩展了原来的用例，因为它在原来的用例上增加了新的步骤序列，因此原用例被称作基用例。</li><li>扩展点：扩展只能发生在基用例的序列中某个具体指定点上，这个点叫做扩展点。</li><li>符号特征：虚线箭头，箭头指向基用例，在虚线上加关键字<code>&lt;&lt;extend&gt;&gt;</code>，在基用例中注明扩展点的发生位置。<br><img src="/uml/用例扩展包含.png" width="40%"> </li></ul></li><li><strong><code>泛化</code></strong>：子用例可以继承父用例的行为和含义，还可以增加自己的行为。任何父用例出现的地方子用例也可以出现。</li><li><p><strong><code>分组</code></strong>：当一个系统包含很多子系统时。最直接的办法就是把相关的用例<strong>放在一个包中</strong>组织起来。</p><ul><li>符号特征：包用一个一边突起的文件夹形的矩形框表示，一组用例可以出现在一个文件夹框中。</li></ul><p><img src="/uml/泛化1.png" width="40%">  <img src="/uml/泛化2.png" width="40%"> </p></li></ul><h5 id="6-4-运用用例模型的实例-P75"><a href="#6-4-运用用例模型的实例-P75" class="headerlink" title="6.4 运用用例模型的实例 P75"></a>6.4 运用用例模型的实例 P75</h5><ul><li>《银行系统的分析与设计》中的用例图<br><img src="/uml/银行用例.png" width="40%"></li></ul><h5 id="6-5-用例的一些特点"><a href="#6-5-用例的一些特点" class="headerlink" title="6.5 用例的一些特点"></a>6.5 用例的一些特点</h5><ul><li>Use case从使用系统的角度描述系统中的信息，即站在系统外部察看系统功能，并不考虑系统内部对该功能的具体实现方式。</li><li>使用use case可以促进与用户沟通，理解正确的需求，同时也可以用来划分系统与外部实体的界限，是OO系统设计的起点，是类、对象、操作的来源。</li><li>用例描述了用户提出的一些可见的需求；用例可大可小；用例对应一个具体的用户目标</li><li>理论上可以把一个软件系统的所有Use Case画出来，但实际运用时只需把重要的、交互过程复杂的那些画出来。</li></ul><h2 id="7-顺序图"><a href="#7-顺序图" class="headerlink" title="7. 顺序图"></a>7. 顺序图</h2><h5 id="7-1-什么是顺序图"><a href="#7-1-什么是顺序图" class="headerlink" title="7.1 什么是顺序图"></a>7.1 什么是顺序图</h5><ul><li>关键思想<ul><li>对象之间的交互是<strong>按照特定的顺序发生</strong>的，这些按特定顺序发生的交互序列从开始到结束需要一定的时间。</li><li>当建立一个系统时，必须要指明这种交互序列，顺序图就是用来完成这项工作的UML组件。</li></ul></li><li>符号特征<ul><li><strong>对象</strong>用矩形表示，其中是带下划线的对象名。</li><li><strong>时间</strong>用垂直虚线表示。</li><li><strong>消息</strong>用带箭头的直线表示。</li><li><strong>激活</strong>用窄矩形条表示。<br><img src="/uml/顺序图.png" width="30%">   <img src="/uml/顺序图对象.png" width="30%"> </li></ul></li><li>建立顺序图的步骤 P93<ol><li>确定交互过程的上下文。</li><li>识别参与交互过程的对象。</li><li>为每个对象设置生命线，即确定哪些对象存在于整个交互过程中，哪些对象在交互过程中被创建和撤销。</li><li>从引发这个交互过程的初始消息开始，在生命线之间从顶到下依次画出随后的各个消息。</li><li>如果需要表示消息的嵌套，或/和表示消息发生时的时间点，则采用激活。</li><li>如果需要说明时间约束，则在消息旁边加上约束说明。</li><li>如果需要，可以为每个消息附上前置条件和后置条件。</li></ol></li></ul><h5 id="7-2-顺序图的组成部分"><a href="#7-2-顺序图的组成部分" class="headerlink" title="7.2 顺序图的组成部分"></a>7.2 顺序图的组成部分</h5><ul><li><strong><code>对象</code></strong><ul><li>从左到右布置在顺序图的顶部</li><li>匿名对象</li><li>生命线（lifeline）</li><li>激活（activation）＝控制焦点（focus of control，FOC）</li></ul></li><li><strong><code>消息</code></strong>：一个对象到另一个对象的消息用跨越对象生命线的消息线表示<ul><li><strong>调用消息</strong>：消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息接收者放弃或返回控制。一般地，调用消息的接收者必须是一个被动对象，即它是一个需要通过消息驱动才能执行动作的对象。</li><li><strong>返回消息</strong>：调用消息必有一个配对的返回消息，为了图的简洁和清晰，与调用消息配对的返回消息可以不用画出。如果为非过程调用，如果有返回消息，则必须明确表示出来。</li><li><strong>同步消息</strong>：调用消息。由于发送者等待接受者，调用消息又称为同步消息。</li><li><strong>异步消息</strong>：发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接收者返回消息或控制。异步消息的接收者和发送者是并发工作的。</li><li>其它：阻止消息，超时消息，反身消息<br><img src="/uml/消息符号1.png" width="40%">  <img src="/uml/消息符号2.png" width="40%"></li></ul></li><li><strong><code>时间</code></strong>：顺序图中垂直方向代表时间维，时间流逝的方向为自顶而下。</li></ul><h5 id="顺序图-汽车和车钥匙-P93"><a href="#顺序图-汽车和车钥匙-P93" class="headerlink" title="顺序图 - 汽车和车钥匙 P93"></a>顺序图 - 汽车和车钥匙 P93</h5><h5 id="顺序图-饮料销售机-P95"><a href="#顺序图-饮料销售机-P95" class="headerlink" title="顺序图 - 饮料销售机 P95"></a>顺序图 - 饮料销售机 P95</h5><h5 id="顺序图-一般顺序图-P97"><a href="#顺序图-一般顺序图-P97" class="headerlink" title="顺序图 - 一般顺序图 P97"></a>顺序图 - 一般顺序图 P97</h5><h5 id="顺序图-帧化顺序图-P100"><a href="#顺序图-帧化顺序图-P100" class="headerlink" title="顺序图 - 帧化顺序图 P100"></a>顺序图 - 帧化顺序图 P100</h5><ul><li>在UML2.0，帧化一个顺序图：用一个边框包围它并在左上角添加一个间隔区。这个间隔区包含了识别该顺序图的信息。</li><li>其中一小段信息是<strong>操作符</strong>，间隔区还包括了<strong>图所描述的交互的名字</strong>。</li><li>操作符：<ul><li><strong>顺序图</strong>：操作符为sd（sequence diagram）</li><li><strong>交互事件</strong>：操作符为ref（reference）</li><li><strong>交互片断的组合</strong>：操作符有alt（alternation）和par（parallel） <strong>P102</strong></li></ul></li></ul><h2 id="8-协作图"><a href="#8-协作图" class="headerlink" title="8. 协作图"></a>8. 协作图</h2><h5 id="8-1-协作图"><a href="#8-1-协作图" class="headerlink" title="8.1 协作图"></a>8.1 协作图</h5><ul><li>协作图的作用<ul><li>对象图展示的是对象之间的静态关系。</li><li>协作图是对象图的扩展。协作图除了展示出对象之间的关联，还显示出对象之间的消息传递。</li><li>对象图是一个快照；而协作图是一部电影。  </li></ul></li><li>协作图与顺序图两者之间是语意等价的。<ul><li>两种图表达的同一种信息，两者之间可以相互转换。</li></ul></li><li>顺序图与协作图之间的不同<ul><li>顺序图强调的是交互的时间顺序；</li><li>协作图强调的是交互的过程和参与交互的对象的整体组织。</li></ul></li></ul><h5 id="8-2-协作图-饮料销售机-P111"><a href="#8-2-协作图-饮料销售机-P111" class="headerlink" title="8.2 协作图 - 饮料销售机 P111"></a>8.2 协作图 - 饮料销售机 P111</h5><h2 id="9-状态图"><a href="#9-状态图" class="headerlink" title="9. 状态图"></a>9. 状态图</h2><h5 id="9-1-什么是状态图"><a href="#9-1-什么是状态图" class="headerlink" title="9.1 什么是状态图"></a>9.1 什么是状态图</h5><ul><li>状态图的概念：<ul><li>人或事物表现出来的形态。</li><li>当系统与用户（也可能是其它系统）交互的时候，组成系统的对象为了适应交互需要经历必要的变化。如果要对系统建立模型，那么模型中必须要反映出这种变化。</li></ul></li><li><strong>状态图与类图、对象图和用例图的本质区别</strong><ul><li>状态图只是对单个对象建立模型</li></ul></li><li>符号特征<ul><li>状态用圆角矩形表示</li><li>状态间带箭头的实线代表状态的迁移（转移），箭头指向目标状态</li><li>实心圆代表状态转移的起点，眼形圆圈代表终点<br><img src="/uml/状态图符号.png" width="50%"><img src="/uml/状态图区域.png" width="50%"></li></ul></li><li>增加状态图的细节<ul><li>常用的活动（入口动作；出口动作；动作）<br><img src="/uml/状态图例子.png" width="45%"></li></ul></li><li>增加转移的细节：事件和动作<ul><li>触发器事件：状态转移线可以指明引起转移发生的事件和引起状态发生变化所需之行的计算。</li><li>无触发器转移：有时候一个事件会引起没有相关动作的状态转移，或者一个转移是由于某个状态完成了它的活动所引起（而不是由于事件引起）</li><li>保护条件：当满足这个条件时，转移才能发生。<br><img src="/uml/状态图触发器.png" width="50%"></li></ul></li></ul><h5 id="8-2-子状态"><a href="#8-2-子状态" class="headerlink" title="8.2 子状态"></a>8.2 子状态</h5><ul><li>顺序子状态：按照顺序一个接着一个出现。</li><li><strong>并发子状态</strong>：在处于working状态时，GUI并不是<br><img src="/uml/子状态.png" width="35%"></li></ul><h2 id="9-活动图"><a href="#9-活动图" class="headerlink" title="9. 活动图"></a>9. 活动图</h2><h5 id="9-1-什么是活动图"><a href="#9-1-什么是活动图" class="headerlink" title="9.1 什么是活动图"></a>9.1 什么是活动图</h5><ul><li>活动图：被设计用于简化描述一个过程或者操作的工作步骤。</li><li>符号特征<ul><li>活动用圆角矩形表示（更接近椭圆）</li><li>箭头表示从一个活动转移到下一个活动</li><li>活动图中的起点用一个实心圆表示，终点用一个眼形圆表示<br><img src="/uml/活动图1.png" width="35%"></li></ul></li></ul><h5 id="9-2-活动图的组成"><a href="#9-2-活动图的组成" class="headerlink" title="9.2 活动图的组成"></a>9.2 活动图的组成</h5><ul><li><strong>判定(分支)</strong>：if-else    / if(无else)<br><img src="/uml/判断.png" width="35%"></li><li><strong>并发路径</strong>：两个单独的同时（并发）执行的路径。</li><li><strong>信号</strong>：活动序列中的活动可以发送信号。当信号被接受时，会引起另一个活动的发生<br><img src="/uml/并发1.png" width="22%"><img src="/uml/并发.png" width="33%"></li><li><strong>泳道</strong>：将活动图按执行的角色分割成多个平行的段，这些段被称为泳道。每个泳道的顶部显示出角色名，每个角色负责的活动放在各个角色的泳道中。<br><img src="/uml/泳道无.png" width="40%"><img src="/uml/泳道.png" width="50%"> </li><li>混合图：P122 对活动的描述更为具体、细化。</li></ul><h5 id="9-3-活动图-银行系统分析"><a href="#9-3-活动图-银行系统分析" class="headerlink" title="9.3 活动图 - 银行系统分析"></a>9.3 活动图 - 银行系统分析</h5><p><img src="/uml/登录.png" width="40%"><img src="/uml/存款.png" width="40%"></p><h2 id="10-构件图"><a href="#10-构件图" class="headerlink" title="10. 构件图"></a>10. 构件图</h2><h5 id="10-1-什么是构件"><a href="#10-1-什么是构件" class="headerlink" title="10.1 什么是构件"></a>10.1 什么是构件</h5><ul><li><strong>构件</strong>是系统中遵从一组接口且提供其实现的物理的、可替换的部分。</li><li><strong>构件图</strong>则显示一组构件以及他们之间的相互关系，包括编译、链接或执行时构件之间的依赖关系。<ul><li>构件图和部署图用于在OO系统中实现物理方面的建模</li></ul></li><li><strong>构件的类型</strong>：(构件就是一个实际文件，可以有以下几种类型)<ul><li><strong>部署构件</strong>，如dll文件、exe文件、COM+对象、动态Web页、数据库表等</li><li><strong>工作产品构</strong>件，如源代码文件、数据文件等，这些构件可以用来产生部署构件</li><li><strong>执行构件</strong>，也就是系统执行后得到的构件</li></ul></li><li><strong>构件与类的区别：</strong><ul><li>类是逻辑抽象，构件是物理抽象</li><li>构件是对其它逻辑元素，如类，协作的<strong>物理实现</strong></li><li>类可以有属性和操作；构件通常只有操作，而且这些操作只能通过构件的接口才能使用</li></ul></li><li>为什么要对构件和构件的关系建立模型<ul><li>使客户能够看到最终系统的结构和功能</li><li>让开发者有一个工作目标</li><li>让编写技术文档和帮助文件的技术人员能够理解所写的文档是关于哪方面的内容</li><li>利于复用</li></ul></li><li>符号特征：<ul><li>左侧附有两个小矩形的大矩形框；也可以用一个顶部带关键字<code>&lt;&lt;Component&gt;&gt;</code>的矩形表示</li><li>构件有自己的名称。如果构件属于一个包，可以在构件名称前面加上包名</li><li>可以在构件图标中列出构件的操作<br><img src="/uml/构件图标.png" width="50%"><img src="/uml/构件图标2.png" width="25%"> </li></ul></li></ul><h5 id="10-2-构件的接口表示法"><a href="#10-2-构件的接口表示法" class="headerlink" title="10.2 构件的接口表示法"></a>10.2 构件的接口表示法</h5><ul><li>可以用一个包含信息的矩形来表示接口，并用实现关系箭头和构件相连。</li><li>也可以用小圆圈表示接口，并用实现连接构件。<br><img src="/uml/构件接口.png" width="50%"></li></ul><h2 id="11-部署图"><a href="#11-部署图" class="headerlink" title="11. 部署图"></a>11. 部署图</h2><h5 id="11-1-什么是部署图"><a href="#11-1-什么是部署图" class="headerlink" title="11.1 什么是部署图"></a>11.1 什么是部署图</h5><ul><li>部署图的用途<ul><li>部署图用来描述系统硬件的物理拓扑结构以及在此结构上执行的软构件</li><li>部署图也称配置图，实施图。常常用于帮助理解分布式系统</li><li>部署图由体系结构设计师，网络工程师，系统工程师等描述</li></ul></li></ul><h5 id="11-2节点与连接"><a href="#11-2节点与连接" class="headerlink" title="11.2节点与连接"></a>11.2节点与连接</h5><ul><li>节点：<ul><li>节点代表一个物理设备以及其上运行的软件系统，如一台Unix主机、一个PC终端、一台打印机、一个传感器等</li><li>节点之间的连线表示系统之间进行交互的通信路径，在UML中称为连接。</li></ul></li><li>节点的划分<ul><li>处理器：能够执行软件构件的节点</li><li>设备：不能执行软件构件的外围硬件，但它通常都具备某种形式的与外部世界的接口。如modem、终端。</li></ul></li><li>符号特征：<ul><li>用立方体表示</li><li>加关键字<code>&lt;&lt;Device&gt;&gt;</code><br><img src="/uml/节点.png" width="25%"></li></ul></li><li>连接<ul><li>连接两个节点的一条线，表示了两个节点相连（但不一定要是一段电线或电缆）<br><img src="/uml/连接.png" width="25%"></li></ul></li></ul><h5 id="11-3-应用部署图-P147"><a href="#11-3-应用部署图-P147" class="headerlink" title="11.3 应用部署图 P147"></a>11.3 应用部署图 P147</h5><ul><li>家用计算机系统</li><li>令牌环网</li><li>ARCnet</li><li>细缆以太网</li><li>Ricochet无线网</li></ul><h5 id="11-4-部署图建模风格"><a href="#11-4-部署图建模风格" class="headerlink" title="11.4 部署图建模风格"></a>11.4 部署图建模风格</h5><ul><li>只对重要的软构件建模<ul><li>事实上，每个节点可能有几十甚至几百个软构件部署在上面，建模人员的目标不是把所有软构件都描绘出来，而是只描绘那些对理解系统来说至关重要的构件。</li><li>如果要探究软构件之间的关系，则采用UML构件图而不是部署图。</li></ul></li><li>对节点使用可视化的版型<ul><li>目前还没有关于如何在UML部署图中使用可视化版型的标准，但一般的经验法则是使用能找到的最合适的剪贴图。</li></ul></li></ul><h2 id="12-在开发过程中运用UML"><a href="#12-在开发过程中运用UML" class="headerlink" title="12. 在开发过程中运用UML"></a>12. 在开发过程中运用UML</h2><h5 id="12-1-开发过程方法学"><a href="#12-1-开发过程方法学" class="headerlink" title="12.1 开发过程方法学"></a>12.1 开发过程方法学</h5><ul><li>在进行程序设计前，开发人员必须要充分理解所要解决的问题，这需要专门有人负责需求的分析。在完成需求分析后，还必须有人将分析的产品转化为设计产品。然后，程序员再根据设计进行产品编制代码，这些代码在经过测试和部署后，最终称为目标系统。</li><li>传统的开发过程方法学：“瀑布”模型 <strong>分析 -&gt; 设计 -&gt; 编码 -&gt; 部署</strong></li><li>新的开发过程方法学：强调无缝集成</li><li>开发方式的变化<ul><li>个人→大型团队，短期→长期，交互与反馈，并行</li></ul></li><li>团队组成<ul><li>系统分析员：与客户交流，理解客户的问题</li><li>设计人员：设计问题的解决方案</li><li>程序设计人员：将解决方案编制成代码</li><li>系统工程师：将代码部署到硬件上运行</li></ul></li><li>一个开发方法学必须要能够做到：<ul><li>保证开发小组对所要解决的问题有个坚实的理解</li><li>要考虑到开发小组是由不同角色完成</li><li>能够在小组的不同角色成员之间培养良好的通信关系</li><li>考虑到跨越阶段的开发过程的反馈信息</li><li>开发出能够向客户反映出开发进度的工作产品，但是要避免产生过多的纸面制品</li></ul></li></ul><h5 id="12-2-GRAPPLE-快速应用工程指导原则"><a href="#12-2-GRAPPLE-快速应用工程指导原则" class="headerlink" title="12.2 GRAPPLE 快速应用工程指导原则"></a>12.2 GRAPPLE 快速应用工程指导原则</h5><ul><li>GRAPPLE的含义<ul><li>快速应用工程指导原则（Guidelines for Rapid APPLication Engineering）</li><li>强调可自适应的、灵活的开发思想</li></ul></li><li>GRAPPLE的结构：RADDD / RAD<sup>3</sup><ul><li>需求收集（requirements gathering）</li><li>分析（analysis）</li><li>设计（design）</li><li>开发（development）</li><li>部署（deployment）</li></ul></li><li><code>需求收集（一）</code><ul><li><strong>发现领域过程</strong>：获得客户业务领域词汇；活动图</li><li><strong>领域分析</strong>：高层类图</li><li><strong>识别协作系统</strong>：系统关系；部署图</li><li><strong>发现系统需求</strong>：联合应用开发会议；包图（每个包代表了一个系统功能的高层领域；每个包中包括了一组用例）</li><li><strong>将结果提交给用户</strong></li></ul></li><li><code>分析（二）</code><ul><li><strong>理解系统的用法</strong>：明确用例，开发新用例</li><li><strong>充实用例</strong>：分析出每个用例的步骤序列</li><li><strong>细化类图</strong>：关联名，抽象类，多重性，泛化，聚集</li><li><strong>分析对象状态变化</strong>：（对象）状态图</li><li><strong>定义对象之间的交互</strong>：顺序图，协作图</li><li><strong>分析与协作系统的集成</strong>：系统工程师完成</li></ul></li><li><code>设计（三）</code><ul><li><strong>开发和细化对象图</strong>：对象图，活动图</li><li><strong>开发构件图</strong>：构件图</li><li><strong>制定部署计划</strong>：部署图</li><li><strong>设计和开发用户界面原型</strong>：屏幕界面原型快照</li><li><strong>测试设计</strong>：外部专家</li><li><strong>开始编制文档</strong>：文档的高层结构</li></ul></li><li><code>开发（四）</code><ul><li><strong>编制代码</strong>：根据类图、对象图、活动图、构件图</li><li><strong>测试代码</strong></li><li><strong>构建用户界面和用户界面到代码的连接和测试</strong></li><li><strong>完成文档</strong></li></ul></li><li>部署（五）<ul><li><strong>编制备份和恢复计划</strong></li><li><strong>在硬件上安装最终系统</strong></li><li><strong>测试安装后的系统</strong></li><li>庆贺</li></ul></li></ul><h5 id="12-3-学习案例介绍-发现业务过程-P183"><a href="#12-3-学习案例介绍-发现业务过程-P183" class="headerlink" title="12.3 学习案例介绍 - 发现业务过程 P183"></a>12.3 学习案例介绍 - 发现业务过程 P183</h5><h2 id="13-领域分析"><a href="#13-领域分析" class="headerlink" title="13. 领域分析"></a>13. 领域分析</h2><h5 id="13-1-分析业务过程会谈"><a href="#13-1-分析业务过程会谈" class="headerlink" title="13.1 分析业务过程会谈"></a>13.1 分析业务过程会谈</h5><ul><li>概念性任务：运用技术来使外出就餐的人们感到更加满意</li><li>会谈目标<ul><li>建立领域词典（模型词典，初步类图）</li><li>通过谈话记录中整理名词、动词以及动词短语。其中的一些名词将可能成为模型中的类，另一些名词将成为类的属性。动词或者动词短语可能成为类的操作或类之间的关联标记。</li></ul></li></ul><h5 id="13-2-开发初步类图-P195"><a href="#13-2-开发初步类图-P195" class="headerlink" title="13.2 开发初步类图 P195"></a>13.2 开发初步类图 P195</h5><h5 id="13-3-对类分组"><a href="#13-3-对类分组" class="headerlink" title="13.3 对类分组"></a>13.3 对类分组</h5><h5 id="13-4-形成关联"><a href="#13-4-形成关联" class="headerlink" title="13.4 形成关联"></a>13.4 形成关联</h5><h5 id="13-5-形成聚集和组成"><a href="#13-5-形成聚集和组成" class="headerlink" title="13.5 形成聚集和组成"></a>13.5 形成聚集和组成</h5><h5 id="13-6-填充类的信息"><a href="#13-6-填充类的信息" class="headerlink" title="13.6 填充类的信息"></a>13.6 填充类的信息</h5><h2 id="14-收集系统需求"><a href="#14-收集系统需求" class="headerlink" title="14. 收集系统需求"></a>14. 收集系统需求</h2><ul><li>产生能反映系统功能的包图，每个包代表系统的一个功能模块，其中包含了详细说明该功能模块的若干个用例。<ul><li>系统部署图 </li><li>系统的功能包图 P219</li><li>新的类图（反映角色之间的静态关系） </li></ul></li></ul><h2 id="15-开发用例"><a href="#15-开发用例" class="headerlink" title="15. 开发用例"></a>15. 开发用例</h2><h5 id="15-1-用例分析"><a href="#15-1-用例分析" class="headerlink" title="15.1 用例分析"></a>15.1 用例分析</h5><ul><li>用例是一组场景的集合，每个场景又是由一系列步骤组成<ul><li>系统开发过程是用例驱动的</li><li>详细分析前面所列举出的用例，并开始研究如何将WIN系统中的构件具体化</li></ul></li><li>对于每个用例的每个场景，需要说明的内容有：<ul><li>场景的简单陈述</li><li>关于场景的假设条件</li><li>用例的发起参与者</li><li>场景的前置条件</li><li>场景中与系统相关的步骤序列</li><li>场景完成后的后置条件</li><li>用例的受益参与者</li><li>其它：异常条件，可选的场景流程</li></ul></li></ul><h5 id="15-2-Server包-P225"><a href="#15-2-Server包-P225" class="headerlink" title="15.2 Server包 P225"></a>15.2 Server包 P225</h5><h2 id="16-交互"><a href="#16-交互" class="headerlink" title="16. 交互"></a>16. 交互</h2><h5 id="16-1-系统中的工作部件-P223"><a href="#16-1-系统中的工作部件-P223" class="headerlink" title="16.1 系统中的工作部件 P223"></a>16.1 系统中的工作部件 P223</h5><ul><li>每个用例的背后都隐藏一张顺序图</li><li>绘制用例的顺序图可以帮助我们细化和修改用例</li><li>构件交互分析的结果应该能使程序员更容易地编制实现构件和构件之间通信的代码</li></ul><h2 id="17-设计外观、感觉和部署-P242"><a href="#17-设计外观、感觉和部署-P242" class="headerlink" title="17. 设计外观、感觉和部署 P242"></a>17. 设计外观、感觉和部署 P242</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-面向对象技术概述&quot;&gt;&lt;a href=&quot;#1-面向对象技术概述&quot; class=&quot;headerlink&quot; title=&quot;1. 面向对象技术概述&quot;&gt;&lt;/a&gt;1. 面向对象技术概述&lt;/h2&gt;&lt;h5 id=&quot;1-1-软件危机及软件工程&quot;&gt;&lt;a href=&quot;#1-1-软件危机及软件工程&quot; class=&quot;headerlink&quot; title=&quot;1.1 软件危机及软件工程　&quot;&gt;&lt;/a&gt;1.1 软件危机及软件工程　&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;软件危机，软件工程&lt;/strong&gt;的提出&lt;ul&gt;
&lt;li&gt;软件危机是指落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="软件工程" scheme="https://daisine.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="note" scheme="https://daisine.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>密码学笔记</title>
    <link href="https://daisine.github.io/Cryptography/"/>
    <id>https://daisine.github.io/Cryptography/</id>
    <published>2018-12-01T03:49:14.000Z</published>
    <updated>2019-05-10T10:53:04.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-计算机安全概念"><a href="#1-1-计算机安全概念" class="headerlink" title="1.1 计算机安全概念"></a>1.1 计算机安全概念</h3><p>网络和Internet安全领域涉及阻止、防止、检测和纠正信息传输中出现的安全违规欣慰的措施。<br><a id="more"></a></p><h3 id="1-2-OSI安全框架"><a href="#1-2-OSI安全框架" class="headerlink" title="1.2 OSI安全框架"></a>1.2 OSI安全框架</h3><ul><li>OSI安全框架主要关注：<ul><li>安全攻击：任何危机信息系统安全的行为。</li><li>安全机制：用来检测、阻止攻击或者从攻击状态恢复到正常状态的过程。</li><li>安全服务：加强数据处理系统和信息传输的安全性的一种处理过程或通信服务。</li></ul></li><li>安全在信息系统的范围很广<ul><li>信息安全</li><li>网络安全</li><li>计算机安全</li><li>数据库安全</li><li>软件安全  </li></ul></li></ul><h3 id="1-3-安全攻击"><a href="#1-3-安全攻击" class="headerlink" title="1.3 安全攻击"></a>1.3 安全攻击</h3><h5 id="四种类型"><a href="#四种类型" class="headerlink" title="四种类型"></a>四种类型</h5><ul><li><strong>阻断</strong>：使系统被破坏或者无法使用。<strong>对可用性的攻击</strong>。<ul><li>破环硬件</li><li>切断通信线路</li><li>禁用文件系统</li><li>DOS/DDOS (拒绝服务)</li></ul></li><li><strong>窃听</strong>：未经授权的一方访问信息。<strong>对保密性的攻击</strong>。<ul><li>窃听以捕获网络中的数据</li><li>非法复制文件/程序</li></ul></li><li><strong>修改</strong>：未经授权的一方不仅可以访问还可以修改信息。<strong>对完整性的攻击</strong>。<ul><li>更改文件中的数据</li><li>改变一个程序</li><li>修改消息的内容</li></ul></li><li><strong>伪装</strong>：未经授权的一方将假冒的对象插入到系统中。<strong>对真实性的攻击</strong>。<ul><li>在网络中插入虚假信息</li><li>将记录添加到文件中</li><li>改变程序</li></ul></li></ul><h5 id="两种类型"><a href="#两种类型" class="headerlink" title="两种类型"></a>两种类型</h5><ul><li><strong>主动攻击</strong>：对数据流进行修改或者伪造数据流。<strong>难以绝对地预防但容易检测。</strong><ul><li>伪装</li><li>重放</li><li>篡改</li><li>拒绝服务</li></ul></li><li><strong>被动攻击</strong>：对传输进行窃听和检测。<strong>难以检测但可以预防。</strong> <ul><li>泄密</li><li>流量分析</li></ul></li></ul><h3 id="1-4-安全服务"><a href="#1-4-安全服务" class="headerlink" title="1.4 安全服务"></a>1.4 安全服务</h3><ul><li>保密性：确保隐私或者秘密信息不向非授权者泄露，也不被非授权者所使用。</li><li>真实性：信息和信息的来源是正确的，能够验证用户的身份。</li><li>完整性：防止信息被不恰当修改或破坏。</li><li>可用性：确保信息的及时和可靠的访问和使用。</li><li>防止抵赖：防止发送方或者接收方否认传输或者接受过某条消息。</li><li>可控性：限制和控制那些通过通信连接对主机和应用进行访问。(eg. 读写权限)</li></ul><h3 id="1-5-安全机制-P14-表1-3"><a href="#1-5-安全机制-P14-表1-3" class="headerlink" title="1.5 安全机制 P14 表1.3"></a>1.5 安全机制 P14 表1.3</h3><h3 id="1-6-网络安全模型"><a href="#1-6-网络安全模型" class="headerlink" title="1.6 网络安全模型"></a>1.6 网络安全模型</h3><p><img src="/Cryptography/网络安全模型.png" width="70%"></p><h2 id="2-传统加密技术"><a href="#2-传统加密技术" class="headerlink" title="2. 传统加密技术"></a>2. 传统加密技术</h2><h3 id="2-1-密码学概念"><a href="#2-1-密码学概念" class="headerlink" title="2.1 密码学概念"></a>2.1 密码学概念</h3><h5 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h5><ul><li>密码编码学</li><li>密码分析学</li></ul><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ul><li>明文 <code>P</code>：原始可理解的消息或数据，加密算法的输入。</li><li>加密算法 <code>E</code>：加密算法对明文进行各种代替和变换。</li><li>密钥 <code>K</code>：加密算法的输入。</li><li>密文 <code>C</code>：加密算法的输出。</li><li>解密算法 <code>D</code>： 本质上是加密算法的逆运算。输入密文和密钥，输出原始明文。</li></ul><h5 id="古典加密技术"><a href="#古典加密技术" class="headerlink" title="古典加密技术"></a>古典加密技术</h5><ul><li>置换：置换符号的位置。eg. SPARTAN SCYTALE(密码棒)<ul><li>棱柱侧面的数量{x}</li><li>算法：明文一维数组-&gt;多维数组-行列变换-&gt;密文一维数组密文</li><li>评价：统计</li></ul></li><li>替换：将明文字母替换成其他字母、数字或符号的方法。eg. Caesar密码<ul><li>移位的长度 {S}</li><li>字符编码后的加法运算</li><li>缺点：密钥长度太短 </li></ul></li><li>多表代替密码<ul><li>Auto-key Cipher<br><img src="/Cryptography/Auto-key.png" width="40%"></li><li>Playfair密码：密文仍然完好地保留了明文语言的大部分结构特征。<br><img src="/Cryptography/Playfair.png" width="40%"></li><li>Vigenère密码：破译能否取得进展取决于能否判定密钥词的长度。<br><img src="/Cryptography/Vig.png" width="40%"></li><li>Hill密码：基于线性代数 P30。优点是完全隐藏了单字母频率特性。</li></ul></li></ul><h3 id="2-2-密码学概述"><a href="#2-2-密码学概述" class="headerlink" title="2.2 密码学概述"></a>2.2 密码学概述</h3><h5 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h5><ul><li>Kerckhoff准则：密码系统的安全性不在于算法的保密，而在于当对手获知了算法和密文后分析出密钥或明文的难度。</li><li>混淆：尽可能使密文和加密密钥间的统计关系更加复杂，以阻止攻击者发现密钥。</li><li>扩散：明文的统计特征消散在密文中。</li><li>雪崩效应：明文或密钥的某一位发生变化会导致密文的很多位发生变化。</li></ul><h5 id="分组密码与流密码"><a href="#分组密码与流密码" class="headerlink" title="分组密码与流密码"></a>分组密码与流密码</h5><ul><li>分组密码：将明文分组作为整体加密并且通常得到的是与明文等长的密文分组。</li><li>流密码：每次加密数据流的一位或者一个字节。</li></ul><h5 id="密码破解-分析-P23"><a href="#密码破解-分析-P23" class="headerlink" title="密码破解/分析 P23"></a>密码破解/分析 P23</h5><ul><li>唯密文攻击<ul><li>最容易防范的，攻击者拥有的信息量较少。</li><li>需要获取更多密文进行分析</li></ul></li><li>已知部分明文攻击<ul><li>可能词攻击</li></ul></li><li>选择明文攻击<ul><li>分析者通过某种方式获取信源系统，让发送方在发送的信息中插入一段由他选择的信息。</li></ul></li><li>选择密文攻击</li><li>选择文本攻击</li><li>蛮力攻击：在一个密文中尝试每个可能的密钥直到获得翻译成可理解的明文。一般需要尝试所有可能密钥的一半。</li></ul><h5 id="加密算法的安全"><a href="#加密算法的安全" class="headerlink" title="加密算法的安全"></a>加密算法的安全</h5><ul><li>无条件安全：无论有多少可使用的密文，都不足以唯一确定密文所对应的明文。</li><li>计算上安全：加密体制满足下面两条中任意一条：<ul><li>破译密码的代价超出密文信息的价值。</li><li>破译密码的时间超出密文信息的有效生命期。</li></ul></li><li>可证明安全：破译密码的难度与数学上某个困难问题的难度相同。</li><li>实际安全：包括可证明安全和计算安全</li></ul><h5 id="隐写术-信息隐藏"><a href="#隐写术-信息隐藏" class="headerlink" title="隐写术 / 信息隐藏"></a>隐写术 / 信息隐藏</h5><ul><li>隐写术：隐藏信息的存在。</li><li>密码学：通过对文本信息的不同转换而实现信息的对外不可读。</li></ul><h2 id="3-分组密码原理"><a href="#3-分组密码原理" class="headerlink" title="3. 分组密码原理"></a>3. 分组密码原理</h2><h3 id="3-1-分组密码和数据加密标准-DES"><a href="#3-1-分组密码和数据加密标准-DES" class="headerlink" title="3.1 分组密码和数据加密标准(DES)"></a>3.1 分组密码和数据加密标准(DES)</h3><h5 id="乘积密码"><a href="#乘积密码" class="headerlink" title="乘积密码"></a>乘积密码</h5><ul><li>P-box(置换)<ul><li>直接的P-box是可逆的，压缩和扩张的P-box不可逆。<br><img src="/Cryptography/pbox.png" width="40%"></li></ul></li><li>S-bos(替换)<ul><li>m x n的替换单元，m与n不一定相同。<br><img src="/Cryptography/sbox.png" width="40%"></li></ul></li><li>XOR<ul><li>相同为0不同为1</li><li>A XOR B XOR B = A </li></ul></li><li>循环移位<ul><li><img src="/Cryptography/循环移位.png" width="40%"></li></ul></li><li>交换<ul><li>是循环位移的一个特例，k = N / 2</li></ul></li><li><p>分离/合并 </p><p><img src="/Cryptography/乘积密码.png" width="40%"></p></li></ul><h5 id="Feistel密码"><a href="#Feistel密码" class="headerlink" title="Feistel密码"></a>Feistel密码</h5><ul><li>Feistel密码是对称加密算法在块加密结构中使用的一种密码结构。</li><li>基于可逆的乘积密码。Feistel密码解密是加密的逆过程。</li><li>实现了Shannon的S-P net 概念。</li><li><p>Feistel密码的属性：</p><ul><li>分组长度 </li><li>密钥长度</li><li>迭代轮数：多轮加密可以取得很高的安全性。</li><li>子密钥生成算法</li><li>轮函数F：提供“混乱”，非线性，雪崩效应</li><li>快速软件加 / 解密</li><li>简化分析难度</li></ul><p><img src="/Cryptography/Feistel密码.png" width="50%"></p></li></ul><h5 id="数据加密标准-DES"><a href="#数据加密标准-DES" class="headerlink" title="数据加密标准 DES"></a>数据加密标准 DES</h5><ul><li>DES加密过程：是由2个P-box 初始置换和最终置换、16轮Feistel加密组成。即，除了初始和末尾的置换，DES的结构与Feistel密码结构完全相同。<br><img src="/Cryptography/DES.png" width="40%"><ul><li>初始置换和末尾置换是互逆的</li><li>DES的核心是DES函数，他将一个48位的轮密钥加到32位的左半/右半部分并得到32位的输出。扩展后的右部分和轮密钥都是48位长度，且轮密钥仅在该轮使用。<br><img src="/Cryptography/DESF.png" width="30%"></li><li>DES使用了8个P-box来扩展，每个P-box有4位的输入和6位的输出</li><li>S-box做了真正的混淆。DES使用了8个S-box，且每个都有6位的输入和4位的输出<br><img src="/Cryptography/DESSbox.png" width="50%">  <img src="/Cryptography/DESSbox3.png" width="30%"><br><img src="/Cryptography/DESSbox2.png" width="50%"></li></ul></li><li>DES解密过程<ul><li>与加密过程算法相同</li><li>使用k<sub>1</sub> -&gt; k<sub>16</sub>加密</li><li>使用k<sub>16</sub> -&gt; k<sub>1</sub>解密</li></ul></li><li>DES密钥的生成和扩展<ul><li>64位随机数，丢弃8位重新排列成56位</li><li>轮密钥生成器在56位密钥中生成一个48位的轮密钥<br><img src="/Cryptography/DES密钥.png" width="40%"></li><li>16个子密钥由56位密钥分裂成两半，左右两部分各占一半，然后压缩置换他们，为48位的轮密钥。</li></ul></li><li>DES的弱点：<ul><li>P-box的弱点</li><li>S-box的弱点</li><li>密钥的弱点：56位密钥有 256 = 7.2×1016，随着计算机的发展，蛮力破解能越来越快地破解DES的密文。</li></ul></li><li>DES的密码分析<ul><li>微分密码分析</li><li>线性密码分析</li><li>相关密钥攻击</li></ul></li></ul><h5 id="多重DES"><a href="#多重DES" class="headerlink" title="多重DES"></a>多重DES</h5><ul><li>双重DES：2个密钥k<sub>1</sub>，k<sub>2</sub> <ul><li>C = E<sub>k<sub>1</sub></sub>(D<sub>k<sub>2</sub></sub>(E<sub>k<sub>1</sub></sub>(P)))</li><li>P = D<sub>k<sub>1</sub></sub>(E<sub>k<sub>2</sub></sub>(D<sub>k<sub>1</sub></sub>(C)))</li></ul></li><li>三重DES：3个密钥k<sub>1</sub>，k<sub>2</sub>，k<sub>3</sub><ul><li>C = E<sub>k<sub>3</sub></sub>(D<sub>k<sub>2</sub></sub>(E<sub>k<sub>1</sub></sub>(P)))</li><li>P = D<sub>k<sub>1</sub></sub>(P<sub>k<sub>2</sub></sub>(D<sub>k<sub>3</sub></sub>(P)))</li></ul></li><li>比DES更安全，但成本更高。</li></ul><h3 id="3-2-高级加密标准-AES"><a href="#3-2-高级加密标准-AES" class="headerlink" title="3.2 高级加密标准 AES"></a>3.2 高级加密标准 AES</h3><h5 id="数学基础：有限域算术"><a href="#数学基础：有限域算术" class="headerlink" title="数学基础：有限域算术"></a>数学基础：有限域算术</h5><ul><li>有限域：Galois域GF(2<sup>8</sup>)</li><li>任何一个字节f(x)可以表示为多项式：f(x) = b<sub>7</sub>x<sup>7</sup> + b<sub>6</sub>x<sup>6</sup> + b<sub>5</sub>x<sup>5</sup> + b<sub>4</sub>x<sup>4</sup> + b<sub>3</sub>x<sup>3</sup>+b<sub>2</sub>x<sup>2</sup> + b<sub>1</sub>x + b<sub>0</sub></li><li>1100101 —&gt; x<sup>7</sup> + x<sup>6</sup> +x<sup>3</sup> + 1 <ul><li>eg. 91<sub>hex</sub> = (1001  0001)<sub>bin</sub> = x<sup>7</sup> + x<sup>4&lt;/sup + 1 </sup></li></ul></li><li>加法运算：：a⊕b（XOR）<ul><li>封闭性：a∈F，b∈F =&gt; a⊕b∈F </li><li>交换律：a⊕b=b⊕a</li><li>结合律：a⊕（b⊕c）=（a⊕b）⊕c</li><li>单位元：0，使得a⊕0 = a</li><li>加法逆元：a⊕（-a）= 0（a = -a）</li></ul></li><li>乘法运算：a=f(x), b=g(x), m=m(x), a⊙b=f(x)×g(x) mod m(x)<ul><li>封闭性：a∈F, b∈F  =&gt; a⊙b∈F </li><li>交换律：a⊙b= b⊙a</li><li>结合律：a⊙(b⊙c)= (a⊙b)⊙c</li><li>分配率：a⊙(b⊕c)= (a⊙b)⊕(a⊙c)</li><li>单位元：1 =&gt; a ⊙1=a</li><li>乘法逆元：a⊙a-1= 1 mod m</li></ul></li><li>GF(2<sup>8</sup>)模乘法运算；m(x) = x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1<ul><li>{01} ⊙ { b<sub>7</sub>b<sub>6</sub>b<sub>5</sub>b<sub>4</sub>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub> } = { b<sub>7</sub>b<sub>6</sub>b<sub>5</sub>b<sub>4</sub>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub> }   <strong>被乘数不发生变化</strong></li><li>{02} ⊙ { b<sub>7</sub>b<sub>6</sub>b<sub>5</sub>b<sub>4</sub>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub> } = { b<sub>6</sub>b<sub>5</sub>b<sub>4</sub>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub> } <strong>b7 = 0 的情况</strong></li><li>{02} ⊙ { b<sub>7</sub>b<sub>6</sub>b<sub>5</sub>b<sub>4</sub>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub> } ={ b<sub>6</sub>b<sub>5</sub>b<sub>4</sub>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub> } ⊕ (00011011) <strong>b7 = 1 的情况</strong></li><li>{03} ⊙ {xx } ={xx} ⊕( {02} ⊙ {xx} )</li></ul></li><li>GF(2<sup>8</sup>)模乘法运算 eg. <ul><li>{02} ⊙ {2B} = {02} ⊙ { 0010 1011} = { 0101 0110}</li><li>{02} ⊙ {91}  = {02} ⊙ {1001 0001}  = {0010 0010} ⊕ {00011011}  = 00111001</li><li>{03} ⊙ {6E} = {6E} ⊕( {02}⊙{6E} ) = {0110 1110} ⊕ {10111100} = 10110010</li></ul></li></ul><h5 id="AES的评价标准"><a href="#AES的评价标准" class="headerlink" title="AES的评价标准"></a>AES的评价标准</h5><ul><li>NIST于1997年发出了AES的请求，NIST定义的选择AES的标准氛围三个方面：安全、成本、实施。</li><li>1998年6月接受了15名候选人。</li><li>1999年5个被选入名单：<ul><li>MARS􏰥IBM􏰦(IBM):􏱪􏲨 扩展Feistel密码， 􏰁􏰂􏰏128位分组，􏱉􏰚􏰷􏰏128-1248位密钥。复杂、快速，安全系数高。</li><li>RC6􏰥(USA)：􏰦􏱠128位分组，􏱉􏰚􏰷􏰏128-256位密钥。非常简单、快速，安全系数低。 􏱉􏰁􏰝􏰢􏳹􏰶􏲻􏲇􏰏􏳹􏰶􏳶􏰢􏰆􏰇􏰃􏰻􏳺􏰢 􏱉􏰁􏰝􏰢􏱨􏱩􏲕􏳶􏳷􏰢􏰆􏰇􏰃􏰻􏳸􏰢 􏱉􏰁􏰝􏰢􏱨􏱩􏲕􏳶􏳷􏰢􏰆􏰇􏰃􏰻􏳸􏰢</li><li>Rijndael􏰥(Belgium􏰦)：􏱠128位分组，􏱉􏰚􏰷􏰏128 - 256位密钥。干净、快，安全系数良好。</li><li>Serpent􏰥(Euro)：复杂、干净，安全系数非常高。</li><li>Twofish(􏰥USA􏰦􏱠􏱨􏱩􏲕􏳹􏰶􏳶􏰢􏰆􏰇􏰃􏰻􏳸􏰦􏱠􏳽􏲕􏳻􏳼􏰢􏰆􏰇􏰃􏰻􏳹􏰶􏳸􏰢)：复杂、非常快，安全系数高。</li></ul></li></ul><h5 id="AES算法加密过程"><a href="#AES算法加密过程" class="headerlink" title="AES算法加密过程"></a>AES算法加密过程</h5><ul><li>明文分组长度：128位 / 16字节</li><li>密钥长度：16字节(128位)，24字节(192位)或32字节(256位)。  </li><li>轮数：10 / 12 / 14</li><li>轮密钥长度：128位<ul><li>在<strong>第一轮开始前添加轮密钥</strong></li><li>在<strong>最后一回合没有列混淆</strong><br><img src="/Cryptography/AES.png" width="48%"><img src="/Cryptography/AES2.png" width="52%"><img src="/Cryptography/AES4.png" width="30%"></li></ul></li><li>加密和解密算法的输入是一个128位分组，这个分组被描述为4 * 4 的字节方阵。这个分组被复制到<strong>状态数组</strong>，并在加密或解密的各个阶段被修改。</li><li>四个不同的阶段<ul><li>字节替换：加密S盒，解密S盒<sup>-1</sup>，S盒必须是可逆的。S盒不是自逆的。   <strong>P103 S盒的构造</strong><br><img src="/Cryptography/AESS.png" width="30%"></li><li>行移位(<strong>以字节为单位</strong>)：第1行：不移，第2行：左移1字节，第3行，左移2字节，第4行：左移3字节。</li><li>列混淆：<br><img src="/Cryptography/AESC.png" width="40%"><img src="/Cryptography/AESC2.png" width="50%"></li><li>轮密钥加：加密过程中，每轮的输入与轮密钥异或一次（当前分组和扩展密钥的一部分进行按位异或）；因为二进制数连续异或一个数结果是不变的，所以在解密时再异或上该轮的密钥即可恢复输入。 轮密钥加是自逆的</li></ul></li></ul><h5 id="AES算法解密过程"><a href="#AES算法解密过程" class="headerlink" title="AES算法解密过程"></a>AES算法解密过程</h5><ul><li>是加密过程的逆。</li><li>字节变换：加密S盒，解密S盒<sup>-1</sup></li><li>列混淆：矩阵C进行加密，矩阵C<sup>-1</sup>解密。</li><li>反向轮密钥。</li></ul><h5 id="AES密钥扩展"><a href="#AES密钥扩展" class="headerlink" title="AES密钥扩展"></a>AES密钥扩展</h5><ul><li>AES使用密码扩展算法创建每一轮的轮密钥。如果轮数为Nr，密钥扩展算法会为一个128位(= 16个字节 = 4个字)的加密密钥输出 Nr+1 个轮密钥。</li><li>AES密钥扩展算法的输入值是4个字(16字节)，输出是44个字组成的一维线性数组。<br><img src="/Cryptography/AESkey.png" width="50%"></li></ul><h5 id="AES的实现"><a href="#AES的实现" class="headerlink" title="AES的实现"></a>AES的实现</h5><ul><li>AES可以在软件，硬件和固件中实现。 实现可以使用表查找过程或使用明确定义的代数结构的例程。</li><li>AES中使用的算法非常简单，可以使用廉价的处理器和最少的内存来轻松实现。</li></ul><h5 id="AES的安全性"><a href="#AES的安全性" class="headerlink" title="AES的安全性"></a>AES的安全性</h5><ul><li>AES是在DES之后设计的。 大多数针对DES的已知攻击已经在AES上进行了测试。</li><li>蛮力攻击：由于密钥较大，AES肯定比DES更安全。</li><li>统计攻击：许多测试未能成功对密文进行统计分析。</li><li>差分和线性攻击：目前还没有对AES的差异和线性攻击。</li></ul><h3 id="3-3-分组密码的工作模式"><a href="#3-3-分组密码的工作模式" class="headerlink" title="3.3 分组密码的工作模式"></a>3.3 分组密码的工作模式</h3><h5 id="更先进的对称密码"><a href="#更先进的对称密码" class="headerlink" title="更先进的对称密码"></a>更先进的对称密码</h5><ul><li>IDEA: International Data Encryption Algorithm<ul><li>1992, Lai Xuejia (来学嘉)</li><li>64位分组大小，128位密钥, 8轮<br><img src="/Cryptography/IDEA.png" width="50%"></li></ul></li><li>Blowfish<ul><li>Bruce Schneier, 1993 </li><li>Feistel密码结构</li><li>64位分组大小，32–448位密钥, 16轮</li><li>继承者: Twofish</li><li>Key Generator</li><li>complex<br><img src="/Cryptography/Blowfish.png" width="50%"></li></ul></li><li>RC5<ul><li>可变分组大小（32,64或128位），可变密钥大小（0到2040位）和可变轮次数（0到255）。 </li><li>最初建议的参数选择是块大小为64位，128位密钥和12轮。</li><li>继承者：RC6<br><img src="/Cryptography/RC5.png" width="15%"></li></ul></li><li>高级分组密码的特点<ul><li>可变性：密钥长度，分组大小，轮数，S盒，圆函数</li><li>复杂的轮函数生成</li><li>执行密钥的更多角色：S盒，圆形移位</li></ul></li></ul><h5 id="分组密码的操作模式"><a href="#分组密码的操作模式" class="headerlink" title="分组密码的操作模式"></a>分组密码的操作模式</h5><ul><li>对称加密模式可以使用现代分组密码完成。</li><li>操作模式已经被设计以使用DES或AES加密任何大小的文本。</li><li>实质上，工作模式是一项增强密码算法或者使算法适应具体应用的技术。</li></ul><h5 id="电子密码本-ECB"><a href="#电子密码本-ECB" class="headerlink" title="电子密码本 ECB"></a>电子密码本 ECB</h5><ul><li>一次处理一组明文分块，每次使用相同的密钥加密。<br><img src="/Cryptography/ECB.png" width="55%"></li><li>ECB评价<ul><li>消息中若有几个相同的明文组，那么密文也将出现几个相同的密文分组。</li><li>􏲒􏰍􏳿􏴀􏱺􏱮􏳾􏰅􏴁􏱅􏴂􏴃􏲒􏰍􏳿􏴀􏱺􏱮􏳾􏰅􏴁􏱅􏴂􏴃无法阻止长消息的修改攻击，</li><li>无错误传播：传输中的单个错误可能会在相应块的多个位中产生错误。但该错误对于其他块没有任何影响。（why：因为ECB一次处理一个明文分块，每个明文块使用相同的密钥独立编码。）</li></ul></li><li>ECB适用于：<ul><li>单个数据的安全传输</li><li>eg. 加密 密钥，口令 </li></ul></li></ul><h5 id="密码分组链接模式-CBC"><a href="#密码分组链接模式-CBC" class="headerlink" title="密码分组链接模式 CBC"></a>密码分组链接模式 CBC</h5><ul><li>为了克服ECB的弱点，我们需要将重复的明文文组加密成不同的密文分组。</li><li>CBC的输入是当前明文组的上一个密文组的异或，使用的密钥是相同的。  </li><li>IV 初始向量：为了产生密文的第一个密文块，初始向量IV与第一个明文块进行异或。</li><li>IV必须为收发双方共享，但第三方不能预测。为了最大限度的安全。IV不能不经授权而修改。<br><img src="/Cryptography/CBC.png" width="55%"></li><li>CBC的加密和解密是互逆的。</li><li>CBC方式要求如果最后的分组不是完整的分组，则需要填充至b位的满分组。<ul><li>P<sub>i</sub> = D<sub>K</sub>(C<sub>i</sub>)⊕C<sub>i-1</sub>= D<sub>K</sub>(E<sub>K</sub>(P<sub>i</sub>⊕C<sub>i-1</sub>))⊕C<sub>i-1</sub> = P<sub>i</sub>⊕C<sub>i-1</sub>⊕C<sub>i-1</sub></li></ul></li><li>CBC适用于：<ul><li>面向分组的通用传输</li><li>消息鉴别 / 认证</li></ul></li></ul><h5 id="密码反馈模式-CFB"><a href="#密码反馈模式-CFB" class="headerlink" title="密码反馈模式 CFB"></a>密码反馈模式 CFB</h5><ul><li>实时地传输长消息。</li><li>解密与加密使用相同的办法，只有一点不同：将收到的密文单元与加密函数的输出异或得到明文单元。这里使用的是加密函数而非解密函数。 </li><li>与明文异或的位流是<strong>与明文相关的</strong>。<br><img src="/Cryptography/CFB.png" width="50%">  <img src="/Cryptography/CFB2.png" width="50%"></li><li>CFB：错误传播<ul><li>消息认证</li><li>在<strong>可靠的信道</strong></li></ul></li><li>CFB适用于：<ul><li>面向<strong>数据流</strong>的通用传输  </li><li>认证 </li></ul></li></ul><h5 id="输出反馈模式-OFB"><a href="#输出反馈模式-OFB" class="headerlink" title="输出反馈模式 OFB"></a>输出反馈模式 OFB</h5><ul><li>没有错误传播：传输过程中某位上发生的错误不会影响其他位。OFB作为流密码，可以在<strong>不可靠信道</strong>使用。</li><li>不需要将明文填充到长度是分组长度的整数倍。</li><li>缺点：抗消息流篡改攻击能力不如CFB<br><img src="/Cryptography/OFB.png" width="50%">  <img src="/Cryptography/OFB2.png" width="50%"></li><li>OFB适用于<ul><li>噪声信道上<strong>的数据流传输</strong>，瑞卫星通信</li></ul></li></ul><h5 id="计数器模式-CTR"><a href="#计数器模式-CTR" class="headerlink" title="计数器模式 CTR"></a>计数器模式 CTR</h5><ul><li>没有反馈。</li><li>密钥流的伪随机用计数器来实现。<br><img src="/Cryptography/CTR.png" width="50%">  <img src="/Cryptography/CTR2.png" width="50%"></li><li>CTR适用于<ul><li>面向分组的通用传输，属于数据流的传输</li><li>用于高速需求</li></ul></li></ul><h2 id="4-流密码"><a href="#4-流密码" class="headerlink" title="4. 流密码"></a>4. 流密码</h2><h3 id="4-1-流密码概述"><a href="#4-1-流密码概述" class="headerlink" title="4.1 流密码概述"></a>4.1 流密码概述</h3><ul><li>一个典型的流密码每次加密一个字节的明文，产生伪随机密钥流，与明文流的每个字节进行按位异或运算，得到一个密文字节。</li><li>“一次一密”使用的是真正的随机数流，而流密码使用的是伪随机数流。</li><li>流密码的随机性完全破坏了消息中的统计的性质。</li><li>不能重复使用流密码，否则能够恢复消息。而分组密码可以重复使用密钥。<br><img src="/Cryptography/stream.png" width="60%"></li><li>一些需要考虑的方面：<ul><li>长时间没有重复</li><li>统计学上随机</li><li>取决于足够大的密钥的线形复杂性</li><li>正确设计，可以像具有相同大小密钥的分组密码一样安全，但通常更简单、快速。</li></ul></li><li>流密码：使用分组密码模式——OFB</li></ul><h3 id="RC4算法"><a href="#RC4算法" class="headerlink" title="RC4算法"></a>RC4算法</h3><h5 id="RC4概述"><a href="#RC4概述" class="headerlink" title="RC4概述"></a>RC4概述</h5><ul><li>RC4是流密码，RC5是分组加密算法</li><li>RC4是一个面向字节的流密码，其中明文的一个字节与一个密钥字节进行X-存储，以产生一个密文字节。</li><li>RSA DSI的私有的密码</li><li>另一个是Ron Rivest设计于1987年，简单、有效：<ul><li>可变长度的密钥，面向字节的流密码</li><li>广泛使用（网络SSL / TLS，无线WEP）</li><li>密钥形成所有8位数的随机排列，使用该排列来搅乱一次处理一个字节的输入信息</li></ul></li></ul><h5 id="RC4算法-1"><a href="#RC4算法-1" class="headerlink" title="RC4算法"></a>RC4算法</h5><ul><li>基本描述<ul><li>可变长度密钥K：1-256个字节(8-2048位)。密钥K的长度keylen与明文长度、密钥流长度无关，通常取16字节(128bits)</li><li>状态向量S：256个字节，S的元素记为S[0], S[1], … , S[256]。<strong>从始至终置换后的S包含从0-255的8位数，只不过位置发生了变化</strong></li><li>临时向量T：256个字节，每个单元也是一个字节。如果密钥K的长度是256字节，则直接把密钥的值赋给T，否则轮转地将密钥的每个字节赋给T。</li><li>密钥流：密钥流的长度和明文的长度是对应的(相等)<br><img src="/Cryptography/RC4.png" width="60%"></li></ul></li><li>RC4算法具体描述：<ul><li>初始化S和T</li><li>S的初始置换</li><li>密钥流的生成</li><li><strong>加密</strong>时将k的值与明文的下一字节<strong>异或</strong>；<strong>解密</strong>时将k的值与密文的下一个字节<strong>异或</strong>。</li></ul></li><li>RC4的安全性<ul><li>声称可以抵御已知攻击</li><li>有一些分析，没有实际意义</li><li>结果是非线性</li><li>由于RC4是流密码，因此不能用重复的密钥</li><li>关注WEP，但由于是密钥处理而不是RC4本身</li></ul></li></ul><h5 id="RC4-3bits"><a href="#RC4-3bits" class="headerlink" title="RC4 3bits"></a>RC4 3bits</h5><ul><li>是RC4算法的一个变体。</li><li>可变长度的密钥：3位 - 24位</li><li>24位的状态向量<strong>S</strong>的元素：S[0], S[1], … , S[8]</li><li>eg.<ul><li>明文：(7 2 5 1 5)<sub>oct</sub>     = {111 010 101 001 101}<sub>bin</sub></li><li>密钥：(7 4 3 2)<sub>oct</sub> = {111 100 011 010}<sub>bin</sub>   (密钥长度 = 4*3bit=12) </li><li>初始化：<br><img src="/Cryptography/初始化.png" width="60%"></li><li>初始置换：<br><img src="/Cryptography/初始置换.png" width="60%"><br><img src="/Cryptography/初始置换2.png" width="60%"></li><li>密钥流的生成：<br><img src="/Cryptography/流密钥1.png" width="60%"><br><img src="/Cryptography/流密钥2.png" width="60%"></li></ul></li></ul><h2 id="5-密钥管理和分发"><a href="#5-密钥管理和分发" class="headerlink" title="5. 密钥管理和分发"></a>5. 密钥管理和分发</h2><h5 id="密钥分发历史"><a href="#密钥分发历史" class="headerlink" title="密钥分发历史"></a>密钥分发历史</h5><ul><li>在第二次世界大战期间，德国高级司令部不得不将其每月的日记账分发给其所有谜运营商。而且，U型船往往需要长时间远离开基地，不得不以某种方式获得定期供应的钥匙。</li><li>美国政府的密钥由COMSEC管理和分发。在20世纪70年代，COMSEC负责每天运输大量的钥匙。当携带COMSEC材料的船舶进入码头时，密码管理机构将在船上行进，收集成堆的卡片，纸带，软盘，然后将它们交付给目标收件人。</li></ul><h5 id="密钥分发模型-P319"><a href="#密钥分发模型-P319" class="headerlink" title="密钥分发模型 P319"></a>密钥分发模型 P319</h5><ol><li>A选择一个密钥后以物理的方式(安全)传递给B。</li><li>第三方选择密钥后物理地传递给A和B。</li><li>如果A和B先前或者最近使用过一个密钥，则一方可以将新密钥用旧密钥加密后发送给另一方。</li><li>如果A和B到第三方C有加密连接，C可以在加密连接上传送密钥给A和B。</li><li>第三方加密：<strong>密钥分发中心(KDC)</strong>负责根据用户的需要来分发密钥。</li></ol><h5 id="密钥分发中心-KDC"><a href="#密钥分发中心-KDC" class="headerlink" title="密钥分发中心 KDC"></a>密钥分发中心 KDC</h5><ul><li>密钥分发中心是基于密钥层次体系的，最少需要两个密钥层。<ul><li>会话密钥：用于持续时间的逻辑连接，如帧的转发或传输连接，然后随着连接的断开而丢弃。</li><li>主密钥：用户和KDC共享的唯一的主密钥。用于会话密钥的加密分发。</li><li>主密钥的分发可以通过一些不加密的方式完成，如物理传递</li></ul></li><li>评价：<ul><li>在两个人可以交换秘密之前，他们必须已经分享了一个秘密。</li><li>大量的会话密钥通过互联网进行分发。</li></ul></li></ul><h5 id="密钥分配方案"><a href="#密钥分配方案" class="headerlink" title="密钥分配方案"></a>密钥分配方案</h5><ul><li>Needham/Schreoder 认证协议：KDC <strong>P321</strong><br><img src="/Cryptography/KDC.png" width="55%"></li><li>Denning认证协议 : timestamps<br><img src="/Cryptography/timestamps.png" width="55%"></li><li>Neuman协议：<br><img src="/Cryptography/Neuman.png" width="55%"></li></ul><h5 id="层次密钥控制"><a href="#层次密钥控制" class="headerlink" title="层次密钥控制"></a>层次密钥控制</h5><ul><li>对于大型网络，需要建立KDC的层次体系。<ul><li>同一个本地域的各个实体相互通信，由本地KDC负责密钥分发。</li><li>两个实体在不同域，由两个相对应的本地KDC通过全局KDC协商产生共享密钥。</li></ul></li><li>层次策略使得主密钥分发的开销最小化。</li></ul><h5 id="会话密钥的生命周期"><a href="#会话密钥的生命周期" class="headerlink" title="会话密钥的生命周期"></a>会话密钥的生命周期</h5><ul><li>会话密钥交换得越频繁就越安全。密钥分发会延迟交换的开始时间，增加网络负担。</li><li>对于<strong>面向连接的协议</strong>，在会话的整个生命周期中使用同一个会话密钥。</li><li>对于<strong>无连接的协议</strong>，没有明确的连接初始和终止。最安全的方法是每次都使用新的会话密钥，但开销变大。</li></ul><h5 id="控制密钥的使用"><a href="#控制密钥的使用" class="headerlink" title="控制密钥的使用"></a>控制密钥的使用</h5><ul><li>数据加密密钥，用于网络中通用通信</li><li>PIN加密密钥，用于电子资金过户的销售点应用的个人识别码(PIN)</li><li>文件加密密钥：用于存储可公开访问的加密文件。</li></ul><h2 id="6-密钥交换"><a href="#6-密钥交换" class="headerlink" title="6. 密钥交换"></a>6. 密钥交换</h2><h3 id="6-1-Diffie-Hellman-密钥交换"><a href="#6-1-Diffie-Hellman-密钥交换" class="headerlink" title="6.1 Diffie-Hellman 密钥交换"></a>6.1 Diffie-Hellman 密钥交换</h3><ul><li>加密和解密的密钥不同。(私钥和公钥)</li><li>相比对称加密的密钥分发，不用等待获取会话密钥，然后才能加密和发送消息。</li><li>基于一个单向函数：K = ( Y<sub>B</sub> )<sup>X<sub>A</sub></sup> mod q = ( Y<sub>A</sub> )<sup>X<sub>B</sub></sup> mod q</li><li>Diffie-Hellman算法的有效性建立在<strong>计算离散对数是很困难的</strong>这一基础上。</li><li>算法流程：  <strong>P218 具体计算</strong><br><img src="/Cryptography/Diffie-Hellman.png" width="62%"></li><li>缺点：不能抵抗所谓的中间人攻击。<br><img src="/Cryptography/中间人攻击.png" width="48%"></li></ul><h3 id="6-2-RSA算法"><a href="#6-2-RSA算法" class="headerlink" title="6.2 RSA算法"></a>6.2 RSA算法</h3><h5 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h5><ul><li>数论的核心问题：<strong>质数</strong></li><li><strong>因子分解定律</strong>：任何大于1的整数a都可以被这样分解：a = p<sub>1</sub><sup>a<sub>1</sub></sup> x p<sub>2</sub><sup>a<sub>2</sub></sup> x … x p<sub>k</sub><sup>a<sub>k</sub></sup>，p<sub>1</sub> &gt; p<sub>2</sub> &gt; … &gt; p<sub>k</sub> <ul><li>eg. 11011 = 7 x 11<sup>2</sup> x 13</li></ul></li><li><strong>素数有无限多个 </strong></li><li><strong>同模</strong>：两个整数如果a mod n = b mod n，则称a与b同模<ul><li>eg. 73 mod 23 = 4, 73 = 4 mod 23，则称4与73同模。 </li></ul></li><li>模运算的性质：<ul><li>定义：a mod n = b mod n → a ≡ b mod n</li><li>交换律：a ≡ b mod n → b ≡ a mod n</li><li>传递律：a ≡ b mod n &amp; b ≡ c mod n → a ≡ c mod n</li><li>有前提条件的消除律：如果a与n互质，则a x b  ≡ a x c mod n  → b ≡ c mod n </li></ul></li><li><strong>gcd(a, b)</strong>：表示a和b的最大公约数。</li><li>a与b互质，则gcd(a, b) = 1</li><li><strong>模乘的逆</strong>：<ul><li>定义Z<sub>n</sub>为正整数小于n的集合：Z<sub>n</sub> = {0, 1, …, (n-1)}</li><li>模乘的逆w<sup>-1</sup> ：对于每个w ∈ Z<sub>p</sub>，ョz，w * z  ≡ 1 mod p ，称z为w<sup>-1</sup></li></ul></li><li><strong>费马定理 / 费马小定理</strong>：<ul><li>p是一个质数，a是一个不能被p整除的正整数， 则a<sup>p-1</sup> = 1 mod p</li><li>eg. a = 6, p = 7, 6<sup>7-1</sup> ≡ 1 mod 7</li><li>另一种形式：p是一个质数，a是一个正整数。则a<sup>p</sup> = a mod p</li><li>eg. a = 3, p = 5, 3<sup>5</sup> = 243 ≡ 3 mod 5</li></ul></li><li><strong>欧拉函数</strong><ul><li>定义 φ(n) 为小于n且与n互质的正整数。</li><li>如果p为一个素数，那么φ(p) = p - 1</li><li>如果n = p<sub>1</sub><sup>a<sub>1</sub></sup> p<sub>2</sub><sup>a<sub>2</sub></sup> … p<sub>k</sub><sup>a<sub>k</sub></sup> 是素数分解的n，那么<img src="/Cryptography/oula.png" width="30%"></li></ul></li><li><strong>欧拉定理</strong><ul><li>对于任何互质的a和n，a<sup>φ(n)</sup> ≡ 1 mod n，或者 a<sup>φ(n)+1</sup> ≡ a mod n</li></ul></li><li><strong>欧拉定理的推论</strong><ul><li>给定两个素数p和q，以及整数n = pq，且0 &lt; m &lt; n</li><li>m<sup>φ(n)+1</sup> = m<sup>(p - 1)(q - 1) + 1 </sup> ≡ m mod n</li><li>对任意整数k有：[m<sup>φ(n)</sup>]<sup>k</sup> ≡ 1 mod n 或 m<sup>kφ(n)</sup>  ≡ 1 mod n</li><li>m<sup>kφ(n)+1</sup> = m<sup>k (p - 1)(q - 1) + 1 </sup> ≡ m mod n</li></ul></li></ul><h5 id="RSA算法描述"><a href="#RSA算法描述" class="headerlink" title="RSA算法描述"></a>RSA算法描述</h5><ul><li>对于<code>明文分组M</code>和<code>密文分组C</code>，加密和解密过程如下：<ul><li>C = M<sup>e</sup> mod n <strong>(加密)</strong></li><li>M = C<sup>d</sup> mod n = (M<sup>e</sup>)<sup>d</sup> mod n = M<sup>ed</sup> mod n <strong>(解密)</strong></li><li>其中，收发双方均已知n，发送方已知e，且<strong>只有接收方已知d</strong>，因此公钥加密算法的公钥PU = { e, n }，私钥PR = { d, n }</li></ul></li><li>必须满足以下条件：d 和 e 是模 φ(n) 的乘法逆元。即 d 与 φ(n) 互质（因此 e 也与 φ(n) 互质）<ul><li><strong>ed = kφ(n)+1</strong></li><li>ed ≡ 1 mod φ(n)</li><li>d ≡ e<sup>-1</sup> mod φ(n)</li><li>gcd( φ(n), d) = 1 ），gcd( φ(n), e) = 1 ）</li></ul></li></ul><h5 id="RSA密钥产生"><a href="#RSA密钥产生" class="headerlink" title="RSA密钥产生"></a>RSA密钥产生</h5><ul><li>选择(大)质数p, q（私有）</li><li>计算 n = p * q</li><li>计算 φ(n) = ( p - 1 )( q - 1 )</li><li>选择 e：gcd( φ(n), e) = 1 ）1 &lt; e &lt; φ(n)</li><li>计算 d ≡ e<sup>-1</sup> mod φ(n)（如何计算d -&gt; 扩展欧基里德算法）</li><li>公钥PU = { e, n }，私钥PR = { <strong>d</strong>, n }</li></ul><h5 id="RSA的安全性"><a href="#RSA的安全性" class="headerlink" title="RSA的安全性"></a>RSA的安全性</h5><ul><li>给定n确定p和q是不可行的</li><li>给定e和d确定d是不可行的</li><li>因子分解问题：对于有大素数因子的数字n，因式分解是个难题。</li><li>RSA密钥非常大所以很安全： 1024 / 2048 位</li><li>1994年，彼得肖尔表明，量子计算机可以将多项式时间（多项式时间）考虑在内，从而打破了RSA。如果n是300位或更短，则可以在个人计算机上在几个小时内计算出来 截至2008年，通用分解算法考虑的最大（已知）数量是663位长（参见RSA-200），使用最先进的分布式实现。下一个记录可能是768位模数<ul><li>RSA 秘密研制于上个世纪60年代初，用于控制战略导弹的发射. 70年代被麻省理工学院等高校的教授独立发明，建立在数论，特别是很难对大素数之积进行因式分解的基础之上。</li><li>一旦量子计算机投入实用，将给目前的公共加密技术带来极大威胁。</li></ul></li></ul><h5 id="公钥算法与对称加密"><a href="#公钥算法与对称加密" class="headerlink" title="公钥算法与对称加密"></a>公钥算法与对称加密</h5><ul><li>从最早开始到现代，虚拟（事实上）所有加密系统都基于替代和排列的基本工具。</li><li>公钥算法基于数学函数而不是替换和置换。</li><li>公钥密码可用于<ul><li>加密/解密</li><li>电子签名</li><li>密钥交换/管理</li></ul></li><li>应该提到一些关于PKC的常见误解（误解）：<ul><li>PKC比对称密钥加密更安全(✕)</li><li>PKC是一种通用技术，传统密码已经过时(✕)</li><li>使用PKC时，密钥分发没有意义(✕)</li></ul></li></ul><h2 id="7-消息认证"><a href="#7-消息认证" class="headerlink" title="7. 消息认证"></a>7. 消息认证</h2><h3 id="7-1-安全服务"><a href="#7-1-安全服务" class="headerlink" title="7.1 安全服务"></a>7.1 安全服务</h3><ul><li>对称密钥密码：使用相同的会话密钥K<sub>s</sub>进行/解密。</li><li>使用非对称密钥密码（RSA）来传递会话密钥K<sub>s</sub>。</li><li>已经被提出的5种信息攻击/安全问题<ul><li>泄露</li><li>流量分析</li><li>冒充</li><li>篡改：内容 / 顺序 / 时间 篡改</li><li>拒绝服务 / 推诿</li></ul></li><li>解决方法：<ul><li>信息保密：泄露，流量分析</li><li>数字签名：拒绝服务/推诿</li><li>消息认证： 冒充，篡改</li></ul></li></ul><h3 id="7-2-消息认证"><a href="#7-2-消息认证" class="headerlink" title="7.2 消息认证"></a>7.2 消息认证</h3><h5 id="消息认证"><a href="#消息认证" class="headerlink" title="消息认证"></a>消息认证</h5><ul><li>消息认证：验证所受到的消息确实是来自真正的发送方，且是未被修改的消息，也可以验证消息的顺序和及时性。 <ul><li>数字签名是消息认证机制之一。</li></ul></li><li>不同级别的消息认证：消息身份验证的两个基本级别部署机制</li><li>基础 - 低级别：身份验证<ul><li>消息加密</li><li>消息认证码(MAC)</li><li>Hash函数</li></ul></li><li>应用 - 高级别：身份认证协议<ul><li>PGP ( Pretty Good Privacy)</li><li>Kerberos </li></ul></li><li>对于对称加密，提供：<ul><li>保密</li><li>消息认证(eg. CBC模式)</li></ul></li><li>对于公钥加密，提供：<ul><li>消息认证：发送方用自己的私钥给消息加密，它提供了数字签名。</li><li>保密：发送方用接收方的公钥给已加密的消息再次加密，提供了保密性。</li></ul></li></ul><h5 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h5><ul><li>利用密钥来生成一个固定长度的<strong>短数据块</strong>，并将该数据块附加在消息之后。</li><li>假设A和B共享一个密钥，当A向B发送消息时：<ul><li>A计算MAC，<strong>它是消息和密钥的函数</strong>：MAC = C<sub>K</sub>(M)</li><li>消息和MAC一起发送给接收方B</li><li>当接收到消息后，B用同样的方式计算出MAC，并与接收到的MAC进行比较：MAC’ = C<sub>K</sub>(M)</li><li>如果MAC = MAC’ 则消息得到认证。</li></ul></li><li>MAC函数与加密类似，但是<strong>MAC算法不要求可逆性</strong>，而加密算法必须可逆。</li><li>MAC函数不能提供数字签名机制。MAC使用对称加密，既然一方能够验证你的MAC，就能够伪造你的MAC，因为发送方和接收方的秘钥是一样的。</li><li><strong>消息摘要与MAC的区别</strong><ul><li><strong>消息摘要只能保证消息的完整性</strong>。攻击者可以将原始消息和摘要都篡改成新的消息和摘要。而MAC由于是消息和密钥的函数，攻击者无法生成与篡改后内容匹配的MAC。</li><li>MAC不仅能够保证完整性，还能够保证真实性</li></ul></li></ul><h5 id="Hash函数-P239"><a href="#Hash函数-P239" class="headerlink" title="Hash函数 P239"></a>Hash函数 P239</h5><ul><li>发送者根据待发送的消息使用Hash函数计算一组Hash值，然后将Hash值和消息一起发送过去。</li><li>使用Hash函数的原因：<ul><li>加密软件速度慢</li><li>加密硬件成本不容忽视</li><li>加密硬件的优化通常是针对大数据的</li><li>加密算法可能受专利保护</li><li>加密算法受美国出口管制</li></ul></li><li>哈希函数的要求 <strong>P245</strong><ol><li>H（x）可以应用于任何大小的数据块x</li><li>H（x）产生固定长度的输出</li><li>3.对于任何给定的x，H（x）相对容易计算，使得硬件和软件实现都是现实的。</li><li>单向性：对于任何给定的代码h，它是计算上的不可能找到x使得H（x）= h。</li><li>弱碰撞阻力：对于任何给定的x，找到y≠x -&gt; H(y) = H(x)在计算上是不可行的。</li><li>6.强抗碰撞性：找到任何（x，y）使得H（x）= H（y）在计算上是不可行的。</li></ol></li><li>两个简单的Hash函数：<ul><li>最简单的Hash函数是每个块的逐位异或：C<sub>i</sub> = b<sub>i1</sub> ⊕ b<sub>i2</sub> ⊕ …  ⊕ b<sub>im</sub></li><li>Hash算法包括重复地使用一个压缩函数f：输入为链接变量(上一步的n位输入)和一个b位的块，产生一个n位的输出。<strong>P248</strong></li></ul></li><li>Hash函数的应用<ul><li>消息摘要</li><li>密码/口令保护</li><li>防止重放攻击：用户和Auth Sever秘密共享一个seed，Hash<sup>N-x(seed)，N是一个很大的初始值，x是登录验证的次数。(<strong><code>重放攻击</code></strong>是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，<strong>主要用于身份认证过程</strong>，破坏认证的正确性。)</sup></li></ul></li></ul><h5 id="安全Hash算法-SHA"><a href="#安全Hash算法-SHA" class="headerlink" title="安全Hash算法 SHA"></a>安全Hash算法 SHA</h5><ul><li>SHA-1 来自 MD4</li><li>SHA-2 family：SHA-224, SHA-256, SHA-384和SHA-512<br><img src="/Cryptography/SHA512.png" width="60%"></li></ul><h5 id="消息摘要"><a href="#消息摘要" class="headerlink" title="消息摘要"></a>消息摘要</h5><ul><li>MD5消息摘要算法<ul><li>MD5消息摘要算法由1990年麻省理工学院的Ron Rivest创建</li><li>它将任意长度的消息(但会分成512bits一组)作为输入并产生<strong>128位消息摘要</strong>作为输出。</li></ul></li></ul><h2 id="8-数字签名"><a href="#8-数字签名" class="headerlink" title="8. 数字签名"></a>8. 数字签名</h2><h3 id="8-1-数字签名简介"><a href="#8-1-数字签名简介" class="headerlink" title="8.1 数字签名简介"></a>8.1 数字签名简介</h3><h5 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h5><ul><li>数字签名或数字签名方案是用于证明数字消息或文档的真实性的数学方案。</li><li>有效的数字签名使接收方有理由相信该消息是由已知接收方创建的，并且该邮件在传输过程中未被更改。</li><li>数字签名通常用于软件分发，金融交易，以及其他情况需要检测修改的情况。</li></ul><h5 id="数字签名的特征"><a href="#数字签名的特征" class="headerlink" title="数字签名的特征"></a>数字签名的特征</h5><ul><li>能验证签名者、签名日期和时间</li><li>能认证被签的消息内容</li><li>签名应能由第三方仲裁，以解决争执</li></ul><h5 id="数字签名需求"><a href="#数字签名需求" class="headerlink" title="数字签名需求"></a>数字签名需求</h5><ul><li>签名必须是与消息相关的二进制串</li><li>签名必须使用发送方某些独有的信息，以防伪造和否认</li><li>产生、识别和验证数字签名比较容易</li><li>伪造数字签名在计算上是不可行的</li><li>保存数字签名副本是可行的</li></ul><p><img src="/Cryptography/数字签名.png" width="55%"></p><h5 id="数字签名过程-P300"><a href="#数字签名过程-P300" class="headerlink" title="数字签名过程 P300"></a>数字签名过程 P300</h5><ul><li>数字签名需要<strong>公钥系统</strong>。</li><li>签名者用他的私钥签名，验证者使用签名者的公钥进行验证。<br><img src="/Cryptography/数字签名1.png" width="55%"><br><img src="/Cryptography/数字签名2.png" width="55%"></li></ul><h5 id="数字签名提供的安全服务"><a href="#数字签名提供的安全服务" class="headerlink" title="数字签名提供的安全服务"></a>数字签名提供的安全服务</h5><ul><li>消息验证</li><li>消息完整性</li><li>防止抵赖</li><li>消息完整性</li></ul><h3 id="8-2-数字签名方案"><a href="#8-2-数字签名方案" class="headerlink" title="8.2 数字签名方案"></a>8.2 数字签名方案</h3><h5 id="RSA数字签名方案-P305"><a href="#RSA数字签名方案-P305" class="headerlink" title="RSA数字签名方案 P305"></a>RSA数字签名方案 P305</h5><p><img src="/Cryptography/RSA.png" width="50%"><br><img src="/Cryptography/DSA.png" width="50%"></p><h3 id="8-3-用户认证协议-P348"><a href="#8-3-用户认证协议-P348" class="headerlink" title="8.3 用户认证协议 P348"></a>8.3 用户认证协议 P348</h3><h5 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h5><ul><li>Kerberos概述：<ul><li>Kerberos是一种计算机网络认证协议，它允许通过非安全网络进行通信的节点以安全的方式相互证明其身份。</li><li>它也是麻省理工学院出版的一套免费软件，它实现了这个协议。</li><li>麻省理工学院开发了Kerberos来保护Project Athena提供的网络服务</li><li>存在多种版本的协议; 版本1-3仅在麻省理工学院内部发生。</li><li>版本4发表于20世纪80年代后期</li><li>版本5在1993年作为RFC 1510出现<br><img src="/Cryptography/Ker.png" width="70%"></li></ul></li><li>一个全方位服务的Kerberos环境包括：<ul><li>1个Kerberos服务器</li><li>多个客户端</li><li>多个应用服务器</li></ul></li><li>Kerberos环境要求：<ul><li>Kerberos服务器必须具有该用户ID和密码</li><li>Kerberos服务器必须与每一个服务器共享密钥  </li></ul></li></ul><blockquote><p>这种环境被称为领域</p></blockquote><h5 id="X-509"><a href="#X-509" class="headerlink" title="X.509"></a>X.509</h5><ul><li>X.509是用于单点登录（SSO）和权益管理基础设施（PMI）的公钥基础设施（PKI）的ITU-T（国际电信联盟）标准。</li><li>X.509除其他外指定了公钥证书，证书撤回列表，属性证书和证书路径确认算法的标准格式。<br>有关X.509的详细信息，请参阅第14.2节或维基百科</li></ul><h3 id="8-4-PGP-P445"><a href="#8-4-PGP-P445" class="headerlink" title="8.4 PGP P445"></a>8.4 PGP P445</h3><h5 id="PGP概述"><a href="#PGP概述" class="headerlink" title="PGP概述"></a>PGP概述</h5><ul><li>Pretty Good Privacy（PGP）是一种提供加密隐私和身份验证的计算机程序。</li><li>PGP通常用于签名，加密和解密电子邮件，以提高电子邮件通信的安全性。<br>它由Philip Zimmermann于1991年创建。<br>PGP和其他类似产品遵循OpenPGP标准（RFC 4880）来加密和解密数据。  </li><li>PGP-用户认证：<strong>P448</strong><br><img src="/Cryptography/PGP.png" width="50%"></li><li>PGP-保密：<br><img src="/Cryptography/PGP2.png" width="50%"></li><li>PGP-保密且认证<br><img src="/Cryptography/PGP3.png" width="60%"> </li></ul><h2 id="9-网络安全"><a href="#9-网络安全" class="headerlink" title="9. 网络安全"></a>9. 网络安全</h2><h3 id="9-1-网络安全概述-P396"><a href="#9-1-网络安全概述-P396" class="headerlink" title="9.1 网络安全概述 P396"></a>9.1 网络安全概述 P396</h3><ul><li>Web现在被广泛使用：政府、企业、个人，但互联网和Web容易受到攻击</li><li>TCP/IP 上的HTTP需要增加安全机制。</li><li>有各种各样的威胁：<ul><li>完整性</li><li>保密性</li><li>拒绝服务</li><li>认证 </li></ul></li><li>在哪里添加安全机制？<br><img src="/Cryptography/网络安全.png" width="40%"> </li></ul><h3 id="9-2-SSL-TLS"><a href="#9-2-SSL-TLS" class="headerlink" title="9.2 SSL / TLS"></a>9.2 SSL / TLS</h3><h5 id="SSL-TLS-P-397"><a href="#SSL-TLS-P-397" class="headerlink" title="SSL / TLS P 397"></a>SSL / TLS P 397</h5><ul><li>SSL：安全套接字层<ul><li>版本：1-3</li><li>最初由Netscape开发</li><li>使用TCP提供可靠和安全的端到端服务</li><li>SSL位于<strong>应用层和传输层之下</strong></li><li>SSL有两层四个协议</li></ul></li><li>TLS：传输层安全协议<ul><li>版本：1.1-1.2</li><li>TLS是SSL的继承者</li><li>成为互联网标准（RFC 2246）</li></ul></li></ul><h5 id="SSL-TLS提供服务："><a href="#SSL-TLS提供服务：" class="headerlink" title="SSL / TLS提供服务："></a>SSL / TLS提供服务：</h5><ul><li>Fragmentation(碎片?分段?)</li><li>压缩</li><li>消息完整性：MAC/HMA, 数字签名(公钥加密)</li><li>保密性：密钥交换(公钥加密)，对称密钥加密</li><li>Framing(取景? 框架？)</li></ul><h5 id="SSL-TLS-安全机制"><a href="#SSL-TLS-安全机制" class="headerlink" title="SSL/TLS 安全机制"></a>SSL/TLS 安全机制</h5><ul><li><p>密钥交换算法  - 保密性<br><img src="/Cryptography/Keyex.png" width="55%"> </p><ul><li>RSA<br><img src="/Cryptography/key1.png" width="55%"> </li><li>Anonymous(匿名的) Diffie-Hellman<br><img src="/Cryptography/key2.png" width="55%"> </li><li>Ephemeral(短暂的) Diffie-Hellman<br><img src="/Cryptography/key3.png" width="55%"></li></ul></li><li><p>对称加密/解密算法 - 保密性<br><img src="/Cryptography/ssl1.png" width="60%"></p></li><li>Hash函数 - 消息完整性<br><img src="/Cryptography/ssl2.png" width="55%"></li></ul><h5 id="SSL-TLS-结构"><a href="#SSL-TLS-结构" class="headerlink" title="SSL/TLS 结构"></a>SSL/TLS 结构</h5><ul><li>2层</li><li>4 个协议<br><img src="/Cryptography/sll3.png" width="40%"></li><li><strong>SSL / TLS 记录协议</strong>(Record Protocol)<ul><li>提供的安全服务：保密性，完整性</li><li>如何利用HMAC算法和会话密钥同意：握手 </li><li><img src="/Cryptography/sslrecord.png" width="55%"></li></ul></li><li><strong>SSL / TLS 握手协议</strong><ul><li>允许服务器和客户端：1. 相互认证 2. 协商加密和MAC算法 3. 协商要使用的加密密钥 </li><li>包括一系列分阶段的消息： 建立安全功能  -&gt; 服务器验证和密钥交换 -&gt; 客户端验证和密钥交换 -&gt; 结束<br><img src="/Cryptography/hs.png" width="50%"> <img src="/Cryptography/hs12.png" width="35%"><br><img src="/Cryptography/hs1.png" width="50%">  <img src="/Cryptography/hs13.png" width="40%">  <img src="/Cryptography/hs2.png" width="50%"><img src="/Cryptography/hs22.png" width="50%"><br><img src="/Cryptography/hs3.png" width="50%">  <img src="/Cryptography/hs32.png" width="50%"></li></ul></li></ul><h3 id="9-3-Wireshark-实验-TLS1-2"><a href="#9-3-Wireshark-实验-TLS1-2" class="headerlink" title="9.3 Wireshark 实验 - TLS1.2"></a>9.3 Wireshark 实验 - TLS1.2</h3><ul><li>POP3 and SMTP <strong>over TCP</strong><br><img src="/Cryptography/tcp1.png" width="30%"><img src="/Cryptography/tcp2.png" width="30%"></li><li>POP3 and SMTP <strong>over TLS</strong><br><img src="/Cryptography/pop31.png" width="30%"><img src="/Cryptography/pop32.png" width="30%"></li><li>Mail Agent(邮件代理): Foxmail 7.x</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;h3 id=&quot;1-1-计算机安全概念&quot;&gt;&lt;a href=&quot;#1-1-计算机安全概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 计算机安全概念&quot;&gt;&lt;/a&gt;1.1 计算机安全概念&lt;/h3&gt;&lt;p&gt;网络和Internet安全领域涉及阻止、防止、检测和纠正信息传输中出现的安全违规欣慰的措施。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件工程" scheme="https://daisine.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="note" scheme="https://daisine.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Web开发笔记</title>
    <link href="https://daisine.github.io/web/"/>
    <id>https://daisine.github.io/web/</id>
    <published>2018-11-05T03:53:00.000Z</published>
    <updated>2019-05-10T10:52:41.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Web开发技术概述"><a href="#1-Web开发技术概述" class="headerlink" title="1. Web开发技术概述"></a>1. Web开发技术概述</h2><h3 id="1-1-Web技术基础知识"><a href="#1-1-Web技术基础知识" class="headerlink" title="1.1 Web技术基础知识"></a>1.1 Web技术基础知识</h3><h5 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h5><ul><li>全称World Wide Web，缩写WWW，译为“万维网”,简称为Web</li><li>是一个可通过互联网来访问的、由许多互相链接的超文本组成的系统<a id="more"></a><blockquote><p>Web不等于Internet，它只是Internet中的一个部分，而且和浏览器有关。Web是Internet中的一个子集或者说Web是互联网提供信息的一种手段。</p></blockquote></li></ul><h5 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h5><ul><li>又称WWW服务器、网站服务器、站点服务器或HTTP服务器</li><li>为用户提供信息浏览和信息处理服务。将信息用超文本（Hypertext）组织，为用户在Internet上搜索和浏览信息提供服务。</li><li>Web服务器实际上就是一个软件系统。但它必须安装在一台高性能和高可靠性的计算机上，所以人们通常将那台计算机就叫做Web服务器。</li><li>常用的Web服务器有： ▪ Microsoft IIS     ▪ IBM  WebSphere ▪ Oracle  WebLogic   ▪ Apache 开源    ▪ Tomcat 开源   ▪ Jboss  开源  ▪ 金蝶公司 Apusic</li><li><code>一台计算机</code>可以安装<code>多个Web服务器</code>。</li></ul><h5 id="Web页面"><a href="#Web页面" class="headerlink" title="Web页面"></a>Web页面</h5><ul><li>Web在提供信息服务之前，所有信息都必须以文件方式事先存放在Web服务器所管辖磁盘中某个文件夹下，其中包含由超文本标记语言（HyperText Markup Language，HTML）组成的文本文件。</li><li>这些文本文件称为超链接文件，又称网页文件或Web页面文件（Web page）<ul><li>Web静态网页扩展名：HTM、HTML</li><li>Web动态网页扩展名：ASP、ASPX、JSP、PHP</li></ul></li><li><code>动态网页</code>/<code>Web服务器页面</code>需要Web服务器对它们进行<strong>重新处理</strong>后，动态生成新的HTML页面再传送给客户端供用户浏览。</li></ul><h5 id="URL-统一资源定位符"><a href="#URL-统一资源定位符" class="headerlink" title="URL(统一资源定位符)"></a>URL(统一资源定位符)</h5><ul><li>信息资源放在Web服务器之后，需要将它的地址告诉给用户，以便让用户来访问，这个地址就叫统一资源定位符（Uniform Resource Locators，URL），俗称为网址。</li><li>URL字串 = 协议名称 + 主机名 + 文件名(包含路径)</li><li>URL地址中的主机名也可直接输入对应的IP地址。手工输入的URL地址只能为绝对地址，相对地址用于网页文档内部的链接地址。</li><li>为什么有时URL地址中没有文件名还能照常显示页面内容呢？这是因为在Web服务器的配置中，可以<strong>事先设定一个或多个默认文件名</strong>，浏览器会<strong>自动查找这些默认的文件名</strong>。<ul><li><code>相对地址</code>：href=“../Shweather.htm” 也可写成   href=“/web/Shweather.htm” </li><li><code>绝对地址</code>：<a href="http://www.yahoo.com.cn/gif/stone.jpg" target="_blank" rel="noopener">http://www.yahoo.com.cn/gif/stone.jpg</a></li></ul></li></ul><blockquote><ul><li>统一资源标识符URI是一个用于标识某一互联网资源名称的字符串。 Web上可用的每种资源 -HTML文档、图像、视频片段、程序等都可由URI来定位。  </li><li>URL网址只是属于URI的一种，用来定位所需访问的网页地址。</li></ul></blockquote><h5 id="浏览器的工作原理及种类"><a href="#浏览器的工作原理及种类" class="headerlink" title="浏览器的工作原理及种类"></a>浏览器的工作原理及种类</h5><ul><li>浏览器就是Web客户端程序，要浏览Web页面必须在本地计算机上安装浏览器软件，用于与Web服务器建立连接，并与之进行通信。</li><li><p>在网络带宽相同的情况下同一台计算机使用不同的浏览器访问同一个网站，<strong>访问速度会不一样</strong></p><ul><li>浏览器是个软件，有软件复杂度的问题，也存在软件运行效率的问题。</li><li>浏览器安全级别设置也会影响访问速度，安全级别越高，访问速度越慢。</li></ul><p><img src="/web/浏览器工作原理.png" width="65%" height="80%"></p></li><li><p>浏览器Cookie：HTTP是一种<strong>无记忆的协议</strong>，有时需要浏览器能够记住一些信息，因此引入Cookie概念。浏览器允许用户通过Cookie读写一些信息，这在一定程度上实现了<strong>浏览器的记忆功能</strong>。</p></li><li>HTTPS即HTTP下加入套接字SSL层，对传输的网页进行加密处理，是以安全为目标的HTTP通道。</li></ul><h5 id="C-S模式与B-S模式"><a href="#C-S模式与B-S模式" class="headerlink" title="C/S模式与B/S模式"></a>C/S模式与B/S模式</h5><p><strong>C/S模式</strong></p><ul><li>几乎所有的应用逻辑都在客户端进行和表达，客户端完成与用户的交互任务。  </li><li>服务器端负责后台数据的查询和管理、大规模的计算等服务。</li><li>通常客户端的任务比较繁重，称作<strong>“肥”客户端</strong>，而服务器端的任务相对较轻，称作<strong>“瘦”服务器</strong>。<br><img src="/web/两层架构模型.png" width="50%" height="80%"></li><li><code>优点</code>：<ul><li>异种平台集成。</li><li>分布式管理。</li><li>能充分发挥客户端PC的处理能力。</li><li>运行安全、稳定、速度快，且在适当情况下可脱机操作。</li></ul></li><li><code>缺点</code>：<ul><li>必须在客户端安装大量的应用程序（客户端软件）。</li><li>需要在客户端安装支持系统运行的动态链接库等。</li><li>存在移植困难、用户界面风格不统一、操作复杂、不利于推广使用、维护和升级过程繁琐、信息内容和形式单一和不易应用新技术等不足。</li></ul></li></ul><p><strong>B/S模式</strong></p><ul><li>基于Web的协同计算模式，是一种三层架构的瘦客户机/肥服务器的计算模式。</li><li>用户工作界面是通过Web浏览器来实现，少部分事务逻辑在前端（浏览器）实现，主要事务逻辑在服务器端实现，形成所谓三层结构。</li><li>简化了客户端电脑载荷，减轻了系统维护与升级的成本和工作量，降低了用户的总体成本）。<br><img src="/web/三层架构.png" width="50%" height="80%"></li><li><code>优点</code>：<ul><li>具有良好的开放性。</li><li>无需下载安装，利用浏览器单一的访问点，用户可在任何时间和地点使用系统。</li><li>系统维护方便，有效地降低了整个系统的运行和维护成本。</li></ul></li><li><code>缺点</code>：<ul><li>运行速度没有C/S模式快，且受网络带宽的影响较大。</li><li>会出现更多安全性问题。</li></ul></li><li>B/S 模式 / Web 应用系统：采用B/S模式构建的应用系统<ul><li>基于Intranet的应用系统</li><li>基于Internet的应用系统</li><li>网站系统</li></ul></li></ul><blockquote><p><strong>需考虑</strong>：浏览器的兼容性；在网络带宽在有限和不稳定的情况下，仍然可被快速访问；互联网上使用的安全性、稳定性、可靠性、有效性等；浏览器的兼容性。</p></blockquote><h5 id="Web的访问原理"><a href="#Web的访问原理" class="headerlink" title="Web的访问原理"></a>Web的访问原理</h5><ul><li>静态网页：<ul><li>只有HTML标记和客户端脚本代码，这种网页以后缀.htm或.html的文件存放。</li><li>也可<strong>实现各种动态的效果</strong>，如.GIF动画、FLASH、滚动字母等，这些动态效果只是视觉上的。</li><li>静态网页<strong>访问速度快</strong>，容易被搜索引擎收录。</li></ul></li><li>动态网页：<ul><li>不仅含有HTML标记和客户端脚本代码，而且含有<strong>需Web服务器进行处理的代码</strong>（文件扩展名一般为ASPX、JSP、PHP等）。</li><li>用户登录、发布新闻、发布公司产品、交流互动、博客、网上调查等都需要动态网页来实现。<br><img src="/web/Web访问原理.png" width="90%" height="90%"> </li></ul></li></ul><h5 id="Web开发平台的组成"><a href="#Web开发平台的组成" class="headerlink" title="Web开发平台的组成"></a>Web开发平台的组成</h5><ul><li>Microsoft <strong>.NET开发平台</strong>：使用多种.NET兼容语言的任意组合来创建一个.NET应    用程序，如C#、VB、J#等</li><li>Oracle <strong>Java EE开发平台</strong>：能开发和部署可移植、健壮、可伸缩且安全的服务器端 Java应用程序</li><li><strong>LAMP</strong>开发平台（Linux+Apache+MySQL+PHP）</li></ul><h5 id="常用的Web开发工具"><a href="#常用的Web开发工具" class="headerlink" title="常用的Web开发工具"></a>常用的Web开发工具</h5><ul><li>常用网页制作工具<ul><li>Dreamweaver是最流行的开发工具之一。</li><li>Fireworks以处理网页图片为特长，并可轻松创作GIF动画。</li><li>FrontPage的主要功能是设计、制作、管理网页或站点。新版本为Expression Web 4.0。</li></ul></li><li>常用Web开发工具<ul><li>VS 用于生成 Web 应用程序、Web服务、桌面应用和移动应用程序等。可用多种编程语言VB、C++、C# 和J# 开发,通过.NET Framework简化Web应用程序和Web服务的开发过程。 </li><li>IBM Eclipse是一种可扩展的开放源代码的IDE（集成开发环境），使用灵活，易于扩展，大有成为Java第一开发工具之势。</li></ul></li></ul><h3 id="1-2-Web基本技术介绍"><a href="#1-2-Web基本技术介绍" class="headerlink" title="1.2 Web基本技术介绍"></a>1.2 Web基本技术介绍</h3><ul><li>Web前端(浏览器端)开发技术：HTML、CSS、DHTML/JavaScript、ActiveX、XML、XHTML</li><li>Web后端(服务器端)开发技术：CGI、PHP、JSP、ASP/ASP.NET、ADO/ADO.NET、Web Service、WCF</li></ul><h5 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h5><ul><li>用HTML来定义网页的结构，用CSS来控制网页显示的格式。</li><li>静态页面的缺点：<ul><li>无法支持后台数据库</li><li>无法有效地对站点信息进行及时的更新</li><li>无法实现动态显示效果</li></ul></li><li>采用 </li></ul><h5 id="DHTML"><a href="#DHTML" class="headerlink" title="DHTML"></a>DHTML</h5><ul><li>DHTML即动态的HTML语言(Dynamic HTML)。除了具有HTML语言的一切性质外，还可在下载网页后仍能实时变换页面元素效果，使人们在浏览网页时看到网页动态效果。</li><li>并不是一门新的语言，它是以下技术、标准或规范的一种集成：<ul><li>HTML</li><li>CSS(层叠样式单)</li><li>CSSL(客户端脚本语言)：JavaScript、Vbscript语言</li><li>HTML DOM(HTML文档对象模型)</li></ul></li><li>DHTML可实现功能：<ul><li>动态交互功能，使网页产生动态效果。</li><li>让用户站点易于维护。</li><li>可减轻服务器负荷，更大发挥网络能力。</li></ul></li></ul><h5 id="Java-Applet"><a href="#Java-Applet" class="headerlink" title="Java Applet"></a>Java Applet</h5><ul><li>Java Applet是指用Java编写的能够在Web页中运行的应用程序。它的可执行代码为class文件。</li><li>具有安全、功能强和跨平台等特性。</li><li>可提供动画、音频和音乐等多媒体服务，并且能产生原本只有CGI(公共网关接口)才能实现的功能。</li></ul><h5 id="JavaScript与VBScript"><a href="#JavaScript与VBScript" class="headerlink" title="JavaScript与VBScript"></a>JavaScript与VBScript</h5><ul><li>JavaScript是<strong>目前使用最广泛的脚本语言</strong>，它是由Netscape公司开发并随Navigator浏览器一起发布的，是一种介于Java与HTML之间、<strong>基于对象</strong>的事件驱动的编程语言。使用JavaScript，不需要Java编译器，而是<strong>直接在Web浏览器中解释执行</strong>。</li><li>VBScript脚本语言是Visual Basic Script（VBS）的简称，它是Microsoft Visual Basic的一个子集，可看作是VB语言的简化版。VBS和Javascript一样都用于创建客户方的脚本程序，并处理页面上的事件及生成动态内容。</li></ul><h5 id="ActiveX"><a href="#ActiveX" class="headerlink" title="ActiveX"></a>ActiveX</h5><ul><li>微软ActiveX控件技术是一种<strong>可重用的</strong>软件技术。</li><li>将一个或一组功能封装起来，以对象方式供开发者使用。</li><li>有大量商用或免费ActiveX控件供开发人员使用，也可用VC、VB等来开发一个ActiveX控件。<strong>ActiveX控件可在页面中直接使用</strong>。</li><li>当浏览的网页遇到ActiveX控件时，会检查用户本地系统的注册表，查看其是否已安装在本地机上。若已安装，浏览器显示该网页并激活控件。若未在用户本地安装，浏览器将查找并安装到本地。下载控件时，浏览器会缺省地显示一个消息框，通知用户将要开始下载，用户可以选择终止下载或继续下载。</li></ul><h5 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h5><ul><li><strong>HTML的不足</strong>：<ul><li>HTML不能适应信息检索和存档要求；</li><li>无法描述矢量图形、科技符号和一些其他特殊显示效果；</li><li>文档结构混乱而缺乏条理，导致浏览器的设计越来越复杂。</li></ul></li><li>XML弥补了HTML的不足：<ul><li>将网络上传输的文档<strong>规范化</strong>，并赋予标记一定的含义，</li><li>与此同时，还要保留其简捷、适于网上传输和浏览的优点。</li><li>XML是标记语言，可根据需要自定义新的标记。XML已在文件配置、数据存储、异构数据交换等众多方面得到广泛应用。</li></ul></li></ul><h5 id="XHTML"><a href="#XHTML" class="headerlink" title="XHTML"></a>XHTML</h5><ul><li>基于XML的标记语言。</li><li>是一个过渡技术，结合了部分XML的强大功能以及大多数HTML的简单特性。<ul><li><code>&lt;div&gt;</code>标记的配对标记是<code>&lt;/div&gt;</code>。在HTML中画横线标记为<code>&lt;hr&gt;</code>，而在XHTML中变成<code>&lt;hr /&gt;</code>。</li><li>在HTML中不配对的标记，在XHTML中必须用“/”结束。标记的属性，例如按钮标记中的type属性，在XHTML中必须放在引号中，而在HTML中则可有可无。</li></ul></li></ul><h5 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h5><ul><li>CGI是公共网关接口（Common Gateway Interface）的缩写，是用于连接WEB页面和应用程序的接口。</li><li>可用VB、VC、Delphi、 Perl语言开发Web Server端运行的可执行程序，由<strong>网页的一个超链接激活</strong>进行调用，并对该程序的返回结果进行处理后，显示在页面上。 </li><li>CGI<strong>编程困难且效率低</strong>，每一次修改程序代码后还须重新编译。</li><li>每一个网上客户在访问CGI程序时，Web服务器都要<strong>单独建立应用进程</strong>，加重了服务器的负荷。</li><li>CGI多用在安全级别要求高的Web应用中。</li></ul><h5 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h5><ul><li>PHP(超文本预处理器)：用开源和<strong>跨平台</strong>的PHP技术可创建动态网站，<ul><li>它包括完整的编程语言、支持因特网的各种协议；</li><li>提供与MYSQL、SQL SERVER、ORACLE等多种数据库的访问能力、支持ODBC数据库连接方式；</li><li>在Unix、GUN/Linux和微软Windows平台上均可运行。PHP的优点是安装方便、学习过程简单、数据库连接方便、兼容性强、扩展性强。</li></ul></li><li>PHP程序需在Apache、Tomcat等Web服务器上运行，Linux + PHP + MySQL + Tomcat + Apache + Dreamweaver是开发中小型企业网站系统的黄金组合，网站的<strong>运行效率佳，安全性高，可靠性和稳定性也非常好</strong>，受到广大开发者的青睐。</li></ul><h5 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h5><ul><li>JSP可用于建立先进、安全和跨平台的动态网页。</li><li>JSP技术是以Java语言作为脚本语言的，使用JSP标识或者Java Servlet小脚本来生成页面上的动态内容。JSP可通过JDBC技术连接数据库。</li><li>JSP代码被编译成Servlet并<strong>由Java虚拟机执行</strong>，这种编译操作仅在对JSP页面的第一次请求时发生。跨平台应用是JSP的最大特色。</li><li>作为Java平台的一部分，JSP拥有Java编程语言<strong>“一次编写，各处运行”</strong>的特点。不少大型企业使用Java EE平台提供的JSP技术构建Web应用系统。</li></ul><h5 id="ASP-ASP-NET"><a href="#ASP-ASP-NET" class="headerlink" title="ASP/ASP.NET"></a>ASP/ASP.NET</h5><ul><li>微软1996年11月推出ASP技术，可用VBScript或JavaScript脚本语言，结合HTML代码，快速完成服务器端动态网页的开发。Web服务器后台解释执行ASP动态网页，<strong>运行效率不高</strong>。</li><li>2002年微软将ASP和.NET技术结合，推出了全新的ASP.NET技术，提供<strong>基于组件、事件驱动的可编程Web窗体</strong>，大大简化了编程，还可以用于建立Web服务。</li><li>ASP.NET与ASP有着本质的不同：<ul><li>ASP.NET<strong>完全基于模块与组件</strong>；</li><li>具有更好的可扩展性与可定制性，数据处理方面引入了许多新技术，技术上远远超越了ASP；</li><li>ASP.NET与Windows Server 家族的完美组合为各种的Web应用提供了一个更为稳定、高效、安全的运行环境。</li></ul></li></ul><h5 id="ADO-ADO-NET"><a href="#ADO-ADO-NET" class="headerlink" title="ADO/ADO.NET"></a>ADO/ADO.NET</h5><ul><li>ADO技术使得客户端应用程序可通过ODBC、OLEDB等方式来访问和操作DB Server，易于使用、速度快、内存支出少、占用磁盘空间少。<ul><li>但它是<strong>面向连接的数据访问方式</strong>，即在操作数据库时，必须与数据库服务器<strong>进行联机操作</strong>。当并发用户操作时，会影响数据库性能。</li></ul></li><li>ADO.NET技术是.NET平台上的全新数据访问方式，数据源的数据可作为XML文档进行传输和存储。在访问数据的时候ADO.NET会利用XML制作数据的一份副本，<ul><li>用户<strong>可断开与数据库服务器的连接直接在副本上进行操作</strong>，最后根据需要再将副本中的数据更新到数据库服务器,以大大<strong>提高数据访问性能</strong>。</li></ul></li></ul><h5 id="Web-Service"><a href="#Web-Service" class="headerlink" title="Web Service"></a>Web Service</h5><ul><li>Web Service可以是一个小粒度的组件完成一个简单功能，也可是一个大粒度的应用程序。不管是作为组件还是应用程序，它都会向外界暴露一个<strong>能够通过Web进行调用的API</strong>，这就是说，能够用编程的方法通过Web访问来使用它。</li><li>用户在调用这些Web服务时，只需要提供输入数据就可得到返回的结果，然后对返回的结果进行加工即可。</li><li>在Web应用程序中<strong>无需下载安装Web服务可直接调用</strong>Web服务提供的方法来实现某个功能，而通过ActiveX控件来实现某个功能时，必须将它下载到客户端，在客户端安装后才可使用。所以Web服务可实现分布式应用。</li></ul><h5 id="WCF-Windows-Communication-Foundation，Windows通讯接口"><a href="#WCF-Windows-Communication-Foundation，Windows通讯接口" class="headerlink" title="WCF(Windows Communication Foundation，Windows通讯接口)"></a>WCF(Windows Communication Foundation，Windows通讯接口)</h5><ul><li>WCF是由微软发展的一组数据通信的应用程序开发接口，它是.NET框架的一部分，由.NET Framework 3.0开始引入，与Windows Presentation Foundation及Windows Workflow Foundation并列为新一代Windows操作系统的三大重要应用程序开发类库。WCF集合了几乎由.NET Framework所提供的所有通讯方法，可利用WCF来创建<strong>面向服务的应用程序</strong>。</li><li><strong>优点</strong>：统一性、互操作性、安全和可信赖、兼容性。</li></ul><h3 id="1-3-Web发展历程"><a href="#1-3-Web发展历程" class="headerlink" title="1.3 Web发展历程"></a>1.3 Web发展历程</h3><h5 id="Web-1-0-获取信息"><a href="#Web-1-0-获取信息" class="headerlink" title="Web 1.0 获取信息"></a>Web 1.0 获取信息</h5><ul><li>大都采用技术创新主导的模式。</li><li>盈利大都基于一个共同点：巨大的点击流量。</li><li>出现了向综合门户合流现象。</li><li>形成了主营与兼营结合的明晰产业结构。</li></ul><h5 id="Web-2-0-用户的交互作用"><a href="#Web-2-0-用户的交互作用" class="headerlink" title="Web 2.0 用户的交互作用"></a>Web 2.0 用户的交互作用</h5><ul><li><code>Ajax</code>（Asynchronous JavaScript and XML，异步JavaScript和XML）最早由Jesse James Garrett提出。区别于传统的Web应用，Ajax应用的主要目的就是提高用户体验：<ul><li>不刷新整个页面，在页面内与服务器通信；</li><li>使用<strong>异步方式</strong>与服务器通信，不需要打断用户的操作，具有更加迅速的的响应能力；</li><li>应用系统不需要由大量页面组成。大部分交互在页面内完成，不需要切换整个页面。</li></ul></li><li>由此可见，Ajax使得Web应用更加动态，带来了更高的智能，并且可以提供表现能力丰富的Ajax UI组件。这样一类新型的Web应用叫做<strong>RIA(Rich Internet Application)应用</strong>。</li><li><code>Blog</code>是一个易于使用的网站，您可以在其中迅速发布想法、与他人交流以及从事其它活动，所有这一切都是免费的。</li><li><code>网摘/网页书签/社会书签</code>：网摘是一种服务，它提供的是一种<strong>收藏、分类、排序、分享互联网信息资源</strong>的方式。</li><li><code>Wiki</code>：是一种多人协作的写作工具。Wiki站点可以有多人，甚至任何访问者维护，每个人都可以发表自己的意见，或者对共同的主题进行扩展或者探讨。<ul><li>Wiki指一种超文本系统。这种超文本系统支持<strong>面向社群的协作式写作</strong>，同时也包括一组支持这种写作的辅助工具。</li></ul></li><li><code>RSS</code>：站点用来和其它站点之间共享内容的一种简易方式（也叫聚合内容，Really Simple Syndication）的技术。<ul><li>RSS搭建了一个<strong>信息迅速传播的技术平台</strong>，使得每个人都成为潜在的信息提供者。</li><li>发布一个RSS文件后，这个RSS Feed中包含的信息就能直接被其它站点调用，而且由于这些数据都是标准的XML格式，所以也能在其它的终端和服务中使用。</li></ul></li></ul><h5 id="Web-3-0"><a href="#Web-3-0" class="headerlink" title="Web 3.0"></a>Web 3.0</h5><ul><li>全新版本的Web3.0纯属理论阶段，实际上目前还无法知道它会怎样工作。</li></ul><p><img src="/web/web发展历程.png" width="50%" height="80%"></p><h2 id="2-Web开发环境的建立"><a href="#2-Web开发环境的建立" class="headerlink" title="2. Web开发环境的建立"></a>2. Web开发环境的建立</h2><h3 id="2-1-如何配置IIS-Web服务器"><a href="#2-1-如何配置IIS-Web服务器" class="headerlink" title="2.1 如何配置IIS Web服务器"></a>2.1 如何配置IIS Web服务器</h3><h5 id="Web站点的配置"><a href="#Web站点的配置" class="headerlink" title="Web站点的配置"></a>Web站点的配置</h5><ul><li>运行在Windows Server操作系统上IIS Web服务器可<strong>创建和管理多个网站</strong>。</li><li>而Windows桌面版操作系统的IIS服务器<strong>一般只支持一个网站</strong>。IIS有IIS 5.1、IIS 6.0和IIS 7.等版本，版本越高，配置的复杂度也越高。</li></ul><h5 id="主目录和虚拟目录的建立"><a href="#主目录和虚拟目录的建立" class="headerlink" title="主目录和虚拟目录的建立"></a>主目录和虚拟目录的建立</h5><ul><li>每个网站的内容都存放在一个物理路径中，这个<code>物理路径</code>也即<code>主目录</code>。</li><li>一个网站所有文件不一定非要将它们全部放在一个目录下，可以<strong>分散存放在不同的硬盘分区</strong>中。</li><li>要从主目录以外的其他目录中发布网站，就必须创建<code>虚拟目录</code>。<ul><li>例如将photo放到F盘中，将student放在E盘中。Web服务器通过<strong>创建虚拟目录</strong>来管理分散存放的网站目录。</li></ul></li><li>虚拟目录的别名可以随意取定，一般就可按照实际文件夹名来取。使用别名的好处：<ul><li>别名可以比实际文件夹路径名短，<strong>便于用户输入</strong>。</li><li><strong>使用别名比较安全</strong>，因为虚拟目录的别名和实际路径之间是映射关系，用户很难知道文件所存放的实际位置。</li><li>虚拟目录对应的<strong>实际路径可以随意搬动</strong>，但用户访问虚拟目录的URL不变。</li></ul></li></ul><h3 id="2-2-VS-2013的使用"><a href="#2-2-VS-2013的使用" class="headerlink" title="2.2 VS 2013的使用"></a>2.2 VS 2013的使用</h3><h5 id="VS-2013中几个重要概念"><a href="#VS-2013中几个重要概念" class="headerlink" title="VS 2013中几个重要概念"></a>VS 2013中几个重要概念</h5><ul><li>微软.NET Framework：用于构建、部署和运行Web服务及应用程序的平台。<ul><li>提供一致的面向对象的编程环境，无论对象代码在哪儿执行。</li><li>提供软件部署和版本控制冲突最小、代码执行安全和运行性能高的代码执行环境。</li><li>减轻开发人员工具使用的复杂性。</li><li>按照工业标准进行，确保.NET Framework 代码可与任何其他代码集成。</li></ul></li><li>三个组成部分：<ul><li><code>CLR（Common Language Runtime，公共语言运行库）</code>：负责管理内存、线程执行、代码执行、代码安全验证、编译和其它系统服务。</li><li><code>托管代码</code>:需要以CLR环境来支撑运行的程序代码；非托管代码:用VB、VC++等工具开发的程序。</li><li><code>.NET Framework 类库</code>：提供很多现成的方法供开发人员编程使用，如复制、移动、删除一个文件、杀死一个进程、连接数据库等</li><li><code>ASP.NET</code>：使用托管代码来开发网站</li></ul></li></ul><h5 id="开发Web应用系统的一般过程"><a href="#开发Web应用系统的一般过程" class="headerlink" title="开发Web应用系统的一般过程"></a>开发Web应用系统的一般过程</h5><ul><li>个人开发</li><li>团队开发：涉及到源代码共享和源代码版本管理问题。</li></ul><h5 id="开发模式对比"><a href="#开发模式对比" class="headerlink" title="开发模式对比"></a>开发模式对比</h5><ul><li>开发模式：<ul><li>传统开发模式</li><li>MVC开发模式</li></ul></li><li>ASP.NET MVC的优势：<ul><li>将页面与业务逻辑进行分离</li><li>限制了ViewState的使用</li><li>最终生成的HTML清洁化，不会生成许多垃圾代码</li><li>客户端和服务器端的处理呈现速度更快</li><li>没有PostBack和页面回传事件机制，表单的提交方式完全采用Web的原生方式，传输的数据内容也更加合理。</li></ul></li><li>ASP.NET MVC的劣势：<ul><li>对大量且复杂的数据处理变得非常困难，没有现成的数据控件可以使用</li><li>不使用视图状态维护状态信息。</li></ul></li></ul><h3 id="2-3-源代码的版本控制"><a href="#2-3-源代码的版本控制" class="headerlink" title="2.3 源代码的版本控制"></a>2.3 源代码的版本控制</h3><ul><li>源代码的版本控制简称为源码控制，它在<strong>多人协作开发环境</strong>中是非常重要的，它包含了对应用程序中每个源文件修改的历史记录，可对多个开发者的行为进行协调。</li><li>在需要比较两种版本的文件或找回早期版本的文件时，源代码的控制是非常有用的。</li><li>常用的源码控制软件有微软的Visual SourceSafe 2005（VSS 2005）、Visual Studio Team Foundation（VSTF）、Dick Grune开发的CVS（Concurrent Versions System）开源软件和CollabNet开发的Subversion（SVN）开源软件等。前两者主要结合微软的开发工具使用，后两者通常在<code>UNIX/Linux</code>或<code>Java开发工具中</code>使用。</li></ul><h3 id="2-4-Web站点的发布"><a href="#2-4-Web站点的发布" class="headerlink" title="2.4 Web站点的发布"></a>2.4 Web站点的发布</h3><ul><li>当一个Web应用系统开发完成后，需要部署到服务器上，让最终用户通过浏览器进行操作，因此必须先将该Web应用系统进行发布，也称Web应用系统的部署。发布Web应用系统主要有：<ul><li>手工发布；</li><li>直接连接到远程服务器上，通过HTTP或者FTP协议等进行发布；</li><li>打包发布。</li></ul></li></ul><h2 id="3-HTML与CSS"><a href="#3-HTML与CSS" class="headerlink" title="3. HTML与CSS"></a>3. HTML与CSS</h2><h3 id="3-1-HTML基础"><a href="#3-1-HTML基础" class="headerlink" title="3.1 HTML基础"></a>3.1 HTML基础</h3><h5 id="HTML文件基本结构"><a href="#HTML文件基本结构" class="headerlink" title="HTML文件基本结构"></a>HTML文件基本结构</h5><ul><li>文档类型：&lt;!DOCTYPE HTML&gt;</li><li>标识这是一个HTML文档：<html>  …… </html>    </li><li>网页头部标识：<head>  …… </head>   </li><li>网页内容：<body> ……  </body></li><li>浏览器窗口标题：<title> 窗口标题</title><ul><li>标题是头元素的一部分</li><li>标题会出现在浏览器窗口标题栏上</li></ul></li><li>注释：<!-- ……  --></li><li>标记的属性：用来描述标记的外观、行为方式及内在表现<ul><li><code>&lt;a id=&quot;mylink&quot; href=&quot;aa.html title = &quot;it&#39;s me&quot;&gt;</code></li><li>id为超链接定义一个标识，因为HTML页面文档中可能有很多个超链接，通过ID可以确定是哪个超链接。title属性实现了将鼠标指针放在该超链接标记上时，会显示一个动态文本提示框“It’s me”。id、title属性是为大多数标记所共有的属性。每个标记有很多属性，但有许多是共有的属性</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>浏览器窗口标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Hello！</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="文本和格式标记"><a href="#文本和格式标记" class="headerlink" title="文本和格式标记"></a>文本和格式标记</h5><ul><li>换行标记： <br>   强制换行</li><li>段落标记：<code>&lt;p align=“center”&gt;…&lt;/p&gt;</code>  align的值可为“ left ”(左对齐)、“ center ”(居中)和“ right ”(右对齐)</li><li>文本缩进标记：<code>&lt;blockquote&gt;…&lt;/blockquote&gt;</code>在浏览器中按两边缩进的方式显示文本</li><li>文本居中标记：<center>…</center> 将文本居中显示  </li><li>特殊符号： 空格 <code>&amp;nbsp;</code>  版权符号 <code>&amp;copy;</code>   注册商标 <code>&amp;reg;</code>   小于号 <code>&amp;lt;</code>  大于号 <code>&amp;gt;</code></li><li>列表标记   <code>&lt;dl&gt;…&lt;/dl&gt;</code>、<code>&lt;dt&gt;…&lt;/dt&gt;</code>和<code>&lt;dd&gt;…&lt;/dd&gt;</code></li><li>列表标记  <code>&lt;ol&gt;…&lt;/ol&gt;</code>、<code>&lt;ul&gt;…&lt;/ul&gt;</code>和<code>&lt;li&gt;…&lt;/li&gt;</code></li><li>文本块标记   <code>&lt;div&gt;…&lt;/div&gt;</code>  <code>&lt;span&gt;…&lt;/span&gt;</code>  <code>&lt;p&gt;…&lt;/p&gt;</code><ul><li><code>&lt;span&gt;`</code><div><code></code><p>`均可用作放置一个文本块。</p></div></li><li>div和span标记除可用作文本容器外，还可用作其他HTML标记的容器。网页上的漂浮物就是用Div实现的。</li><li><code>&lt;address&gt;…&lt;/address&gt;</code>标记与<code>&lt;div&gt;</code>标记作用相似，就是显示一块文本，但里面的<strong>字体只能是斜体</strong>，主要用来在网页上放置<strong>署名信息</strong>。</li></ul></li></ul><h5 id="超链接标记和表格标记"><a href="#超链接标记和表格标记" class="headerlink" title="超链接标记和表格标记"></a>超链接标记和表格标记</h5><ul><li>超链接标记  <code>&lt;a&gt;…&lt;/a&gt;</code>  <ul><li>超链接标记是HTML标记最重要的标记，用属性href（hot reference）来指定锚点的链接信息，可为URL网址或文本、声音、图像等的URI地址。例如：<br><code>&lt;a href=&quot;http://www.cqu.edu.cn&quot;&gt; 重庆大学 &lt;/a&gt;</code></li></ul></li><li>表格标记：表格可简洁和一目了然地表现内容。表格标记由<code>&lt;table&gt;</code>和<code>&lt;/table&gt;</code>组成。<ul><li>表格的行标记<code>&lt;tr&gt;</code>是Table Row的缩写</li><li>表格的列标记<code>&lt;td&gt;</code>是Table Data的缩写</li></ul></li></ul><h5 id="图像、视频与动画、声音处理标记"><a href="#图像、视频与动画、声音处理标记" class="headerlink" title="图像、视频与动画、声音处理标记"></a>图像、视频与动画、声音处理标记</h5><ul><li>图像标记：<br><code>&lt;img src=“夜景.jpg” height=“100” width=“10%”  border=“10” &gt;</code></li><li>视频和动画标记：<ul><li><code>dynsrc</code>表示视频与动画来源文件所在的URL地址，其它标记内容同图像显示标记。</li><li>start = fileopen表示页面一被装入便播放；</li><li>start = onmouseover表示当鼠标从该区域滑过时才播放。</li><li>loop表示视频或动画播放的重复次数，为infinite或为负数时表示无限循环。</li></ul></li></ul><h5 id="控件标记"><a href="#控件标记" class="headerlink" title="控件标记"></a>控件标记</h5><ul><li>表单<code>form</code>标记：从用户收集信息，然后将这些信息提交给服务器进行处理。表单中可包含允许用户<strong>进行交互的各种控件</strong>，例如: 文本框、列表框、复选框和单选按钮等。用户在表单中输入或选择数据之后将其提交，<strong>该数据就会送交给表单处理程序进行处理</strong>。<ul><li>用户界面，提供用户输入数据的元件；</li><li>处理程序，可以是客户端程序，在浏览器中执行，也可以是服务器处理程序，处理用户提交的数据，返回结果。</li></ul></li></ul><h5 id="帧标记和iframe标记"><a href="#帧标记和iframe标记" class="headerlink" title="帧标记和iframe标记"></a>帧标记和iframe标记</h5><ul><li>帧标记/框架标记 Frame<ul><li>将浏览器显示部分分成多个区域，每个区域可显示各不相同的网页。</li><li>点击某个区域中的网页超链接，可在其他区域显示超链接对应的网页。</li></ul></li><li>Iframe标记/浮动帧标记 <ul><li>当前页面中设置<strong>多个浮动帧标记</strong>，每一个浮动帧标记都<strong>加载各自的网页</strong>，可实现浏览器网页加载的<strong>并发处理</strong>。</li></ul></li></ul><h5 id="HTML5介绍"><a href="#HTML5介绍" class="headerlink" title="HTML5介绍"></a>HTML5介绍</h5><ul><li>新一代超文本标记语言<strong>HTML5仍处于不断发展</strong>中。之前的HTML版本在功能上有限，例如无绘图处理功能等。</li><li>HTML5添加了许多新语法特性，包括用于媒介回放的 <code>video</code>和 <code>audio</code> 元素、用于绘画的 canvas 元素、其它新的元素包括<code>&lt;section&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;header&gt;</code>和<code>&lt;nav&gt;</code>，主要是为了丰富文档的<strong>数据内容</strong>。</li><li>一些标记添加了新属性，也有一些属性和元素<strong>被移除掉</strong>了，还有一些元素如<code>&lt;a&gt;</code>，<code>&lt;cite&gt;</code>和<code>&lt;menu&gt;</code>被修改，重新定义或标准化。同时<strong>应用程序接口API和文档对象模型DOM已成为HTML5中的基础部分</strong>。</li><li>HTML5特性：<ul><li><strong>语义特性</strong>：HTML5可使网页有更好的结构，标签更为丰富。</li><li><strong>本地存储特性</strong>：本地存储功能使HTML5网页运行更快，占用带宽更少。</li><li><strong>设备兼容特性</strong>：可获取地理位置；使外部应用与浏览器内部数据直接连接，例如视频影音可直接与麦克风及摄像头相联。</li><li><strong>连接特性</strong>：Server-Sent Event和WebSockets可实现服务器将数据“推送”到客户端。</li><li><strong>网页多媒体特性</strong>：提供Audio、Video等多媒体功能。</li><li><strong>三维、图像及特效特性</strong>：提供SVG、Canvas、WebGL及CSS 3的3D功能，用户会惊叹于在浏览器中所呈现的惊人视觉效果。</li><li><strong>性能与集成特性</strong>：通过XMLHttpRequest2等技术，帮助Web应用和网站在多样化的环境中更快速地工作。</li><li><strong>CSS 3 特性</strong>：在不牺牲性能和语义结构的前提下，CSS 3提供了更多的风格和更强的效果。</li></ul></li></ul><h3 id="3-2-CSS-层叠样式表"><a href="#3-2-CSS-层叠样式表" class="headerlink" title="3.2 CSS 层叠样式表"></a>3.2 CSS 层叠样式表</h3><ul><li>CSS是为弥补HTML在显示属性设定上的不足而制定的一套扩展样式标准。到98年，W3C在原有草案的基础上进行了扩展，建立了CSS2规范。</li><li>HTML注重的是内容本身，而不是显示方式。CSS注重解决网页字体大小、颜色、边框等格式问题，以提供给用户尽量美观、易读的网页。</li></ul><h5 id="CSS的特点"><a href="#CSS的特点" class="headerlink" title="CSS的特点"></a>CSS的特点</h5><ul><li>简化了网页的格式代码，外链样式还可以被浏览器保存在缓存里，加快了网页下载速度。</li><li>只要修改保存着网页格式的CSS样式表文件就可以改变整个站点的风格特色，保证了网站显示风格的一致。避免了一个个网页的修改，大大减少了重复工作量。</li></ul><h5 id="CSS的定义"><a href="#CSS的定义" class="headerlink" title="CSS的定义"></a>CSS的定义</h5><ul><li>样式格式为：<ul><li>选择符{ 属性1：值1；属性2：值2；……}</li><li>简写为：选择符{属性值对 }<br><code>div{font-family: 宋体; font-size: 12pt;}</code></li></ul></li></ul><h5 id="CSS中的选择符"><a href="#CSS中的选择符" class="headerlink" title="CSS中的选择符"></a>CSS中的选择符</h5><ul><li>HTML标记类选择符：直接用HTML标记或HTML元素名称作为CSS选择符</li><li>具有上下文关系的HTML标记类选择符<ul><li>包含在div内有一个input，div和input之间就有上下文关系；div内有span，span内有B，它们之间也构成了上下文关系。</li><li>这种上下文关系可以嵌套任意层次。</li><li>用div span b {color:yellow}表示了div标记中的span标记中的B元素用黄颜色显示。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS选择符问题 <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        input &#123; color: white; &#125;</span></span><br><span class="line"><span class="undefined">        div input &#123; color: red; &#125;</span></span><br><span class="line"><span class="undefined">        div span b &#123;color: yellow; &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"change me"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"change me"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>I'm a <span class="tag">&lt;<span class="name">b</span>&gt;</span>good <span class="tag">&lt;/<span class="name">b</span>&gt;</span>student <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>用户定义的类选择符</li><li>ID选择符<ul><li>每一个标记都可有ID属性，可唯一识别该标记元素。</li><li>可以用这个ID来作为样式的选择符，样式中必须在ID前加一个<code>#</code>，而不是点号。</li><li>一个ID选择符样式<strong>只能在HTML文件内被引用一次</strong>，而类选择符样式则可以多次被引用。</li><li>若有些较特别的标记需要应用较为特殊的样式，则建议使用ID选择符。</li></ul></li><li>虚类：虚类是一种特殊的类选择符，虚类的形式为：<ul><li>选择符:虚类{ 属性值对 }</li><li>虚类主要针对超链接A标记来使用，可指定超链接标记A以不同的方式显示链接。</li><li>超链接有4种不同的样式状态： </li><li>a:link    链接访问前的样式</li><li>a:visited 链接访问后的样式</li><li>a:active  链接活动时的样式</li><li>a:hover   鼠标在链接上的样式</li><li>可将虚类和自定义类名组合起来使用，以实现页面中各个超链接按不同样式来呈现。</li></ul></li><li>虚元素<ul><li>有2个特殊的选择符first-letter和first-line，用于P、div、span等<strong>块级元素的首字母和首行效果</strong>。格式为：</li><li>选择符:first-letter {属性值对}</li><li>选择符.类:first-letter {属性值对}</li></ul></li></ul><h5 id="CSS的使用方式"><a href="#CSS的使用方式" class="headerlink" title="CSS的使用方式"></a>CSS的使用方式</h5><ul><li>4种方式<ul><li>链入外部样式表：<code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;</code></li><li>导入外部样式表：<code>&lt;!-- @import &quot;mystyle.css&quot;; --&gt;</code></li><li>联入样式表：利用<code>&lt;style&gt;</code>标记将样式表联入HTML文件的头部</li><li>内联样式：是混合在HTML标记里使用的，用这种方法，可以很简单地对某个元素单独定义样式。<br><code>&lt;p style = &quot;color: red; background-color: yellow&quot;&gt;</code></li></ul></li><li>多重样式表的叠加的<strong>优先级</strong><ul><li>依优先级最高的是内联样式，其次是联入样式表，然后是导入外部样式表。外链样式和联入样式中，最后定义的样式优先级最高。</li><li>内联样式会向标记中添加更多属性及内容，对于网页设计者来说很难维护，应尽<strong>量减少使用内联样式。</strong></li></ul></li></ul><h5 id="用CSS控制Web元素的显示外观"><a href="#用CSS控制Web元素的显示外观" class="headerlink" title="用CSS控制Web元素的显示外观"></a>用CSS控制Web元素的显示外观</h5><ol><li><p>控制文字字体属性  </p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.myfont1</span> &#123;</span><br><span class="line">          <span class="attribute">font-family</span>: 宋体, Arial; <span class="comment">/*字体*/</span></span><br><span class="line">          <span class="attribute">font-size</span>: <span class="number">12px</span>; <span class="comment">/*字号*/</span></span><br><span class="line">          <span class="attribute">font-weight</span>: bold; <span class="comment">/*字体加粗*/</span></span><br><span class="line">          <span class="attribute">font-style</span>: italic; <span class="comment">/*字体风格*/</span></span><br><span class="line">          <span class="attribute">text-transform</span>: uppercase; <span class="comment">/*字体转换*/</span></span><br><span class="line">          <span class="attribute">color</span>: <span class="number">#FF0000</span>; <span class="comment">/*字体颜色*/</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><p>文本属性</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.myfont1</span> &#123;</span><br><span class="line">          <span class="attribute">letter-spacing</span>: <span class="number">2px</span>; <span class="comment">/*字符间隔*/</span></span><br><span class="line">          <span class="attribute">text-align</span>: left; <span class="comment">/*对齐方式*/</span></span><br><span class="line">          <span class="attribute">text-decoration</span>: underline line-through overline;<span class="comment">/*文本修饰*/</span></span><br><span class="line">          <span class="attribute">text-indent</span>: <span class="number">20pt</span>; <span class="comment">/*文本缩进*/</span></span><br><span class="line">          <span class="attribute">line-height</span>: <span class="number">22px</span>; <span class="comment">/*文本行间距*/</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><p>控制颜色和背景属性</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.mycolor</span> &#123;</span><br><span class="line">          <span class="attribute">color</span>: <span class="number">#FFFF00</span>;</span><br><span class="line">          <span class="attribute">background-color</span>: <span class="number">#FF0000</span>; <span class="comment">/*文本块、网页、几何形状等背景颜色*/</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><p>边框属性</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.myborder</span> &#123;</span><br><span class="line">          <span class="attribute">border-style</span>: double solid solid double; <span class="comment">/*边界线样式*/</span></span><br><span class="line">          <span class="attribute">border-width</span>: <span class="number">5px</span> <span class="number">5px</span> <span class="number">2px</span> <span class="number">5px</span>; <span class="comment">/*边界宽度*/</span></span><br><span class="line">          <span class="attribute">border-color</span>: <span class="number">#0000FF</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><p>列表属性： 设置列表标记(<code>&lt;ol&gt;</code>和<code>&lt;ul&gt;</code>)的显示样式</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">   ol &#123;</span></span><br><span class="line"><span class="css">   <span class="selector-tag">list-style-type</span><span class="selector-pseudo">:upper-alpha</span>;</span></span><br><span class="line"><span class="undefined">   &#125;</span></span><br><span class="line"><span class="undefined">   ul &#123;</span></span><br><span class="line"><span class="css">   <span class="selector-tag">list-style-type</span><span class="selector-pseudo">:circle</span>;  </span></span><br><span class="line"><span class="undefined">   &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span> <span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">计算机的六个逻辑部件为： <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>  输入部件 <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>   输出部件 <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>   存储器  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span> 算术逻辑部件(ALU)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span> 辅助存储器 <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>中央处理器(CPU)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>辅助存储器 <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>定位属性</p><ul><li>static：默认值。位置设置为static的元素，它始终会处于文档流给予的位置。</li><li>relative：生成相对定位的元素，<strong>相对于该元素在文档中的初始位置进行定位</strong>。</li><li>absolute：生成绝对定位的元素，<strong>相对于距该元素最近的已定位的父元素</strong>进行定位。</li><li>fixed：元生成绝对定位的元素。默认情况下，可定位于<strong>相对于浏览器窗口</strong>的指定坐标。</li></ul></li><li><p>控制鼠标形状</p><ul><li>hand：手型 <code>&lt;a href=&quot;#&quot; style=&quot;cursor:hand&quot;&gt;CSS鼠标手型效果&lt;/a&gt;</code></li><li>pointer：手型，推荐使用这种，可以在多种浏览器下使用。</li><li>crosshair：十字型</li><li>help：问号</li><li>text：移动到文本上</li><li>wait：等待，沙漏型</li><li>default：默认效果</li><li>e-resize：向右的箭头</li><li>ne-resize：向右上的箭头</li><li>n-resize：向上的箭头</li><li>nw-resize：向左上的箭头</li><li>w-resize：向左的箭头</li><li>sw-resize：左下的箭头</li><li>s-resize：向下的箭头</li><li>se-resize：向右下的箭头</li><li>auto：由系统自动给出效果</li></ul></li><li><p>滤镜</p><ul><li>alpha</li><li>blur</li><li>dropshadow</li><li>glow</li><li>chroma</li><li>flipH 与 flipV</li><li>wave</li><li>shadow</li><li>mask</li><li>light</li><li>gray / invert / xray</li></ul></li></ol><h2 id="4-DHTML"><a href="#4-DHTML" class="headerlink" title="4. DHTML"></a>4. DHTML</h2><h3 id="4-1-JavaScript编程技术"><a href="#4-1-JavaScript编程技术" class="headerlink" title="4.1 JavaScript编程技术"></a>4.1 JavaScript编程技术</h3><h5 id="JavaScript语言简述"><a href="#JavaScript语言简述" class="headerlink" title="JavaScript语言简述"></a>JavaScript语言简述</h5><ul><li>JavaScript嵌入在HTML文件中，能对鼠标点击、表单提交等用户事件做出反应和处理。</li><li>特点：<ul><li><code>简单性</code>：JS是简化的编程语言，变量类型简单，不声明也能使用。</li><li><code>基于对象</code>：JS<strong>不完全面向对象</strong>，不支持类和继承，是基于对象而不是面向对象的语言</li><li><code>可移植性</code>：JS可在浏览器上不经修改直接运行。</li><li><code>动态性</code>：可用来设计客户端交互式动态页面。</li><li><code>安全性</code>：JS是一种安全性语言，对本地资源的访问和操作有限，只能通过浏览器实现信息浏览或动态交互。</li></ul></li></ul><h5 id="JavaScript编程基础"><a href="#JavaScript编程基础" class="headerlink" title="JavaScript编程基础"></a>JavaScript编程基础</h5><ul><li>将JavaScript程序嵌入HTML文件的方法：<br><code>&lt;script scr=&quot;clock.js type=&quot;text/javascript&quot;</code></li><li>数据类型：<ol><li>字符型</li><li>数值型：整数和浮点值没有差别</li><li>布尔型</li></ol></li><li>常量</li><li>变量：<ul><li>变量声明：var关键字来进行变量声明。</li><li>变量命名：JavaScript是一种<strong>区分大小写</strong>的语言。</li></ul></li><li>运算符和表达式</li><li>函数：当函数没有返回值时，可以不用return语句。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">形式参数表</span>)</span>&#123;</span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>流程控制：if语句；for循环语句</li><li>事件驱动及事件处理<br><img src="/web/事件驱动.png" width="60%"></li></ul><h5 id="JavaScript对象编程技术"><a href="#JavaScript对象编程技术" class="headerlink" title="JavaScript对象编程技术"></a>JavaScript对象编程技术</h5><ul><li>JS语言是基于对象的语言，并非面向对象的语言，<strong>JS中没有类，只有对象</strong>，它没有提供抽象、继承、封装等面向对象的基本属性。</li><li>我们不能像在传统的语言里那样用class来定义类, 但我们可利用JS的<strong>闭包封装机制</strong>来实现JS中的类。</li><li>JavaScript的自定义对象<ul><li>把函数function当成对象</li><li>用prototype对象来实现js的自定义对象</li></ul></li></ul><ol><li>Array对象 <ul><li>可用Array对象创建数组。数组是若干元素的集合，每个数组都用一个名字作为标识。</li><li>JavaScript中没有提供明显的数组类型，可通过JavaScript内建对象Array和使用自定义对象的方式创建数组对象。</li></ul></li><li>String对象<ul><li>JS内置对象string只有一个属性，即length属性，包含了字符串中的字符数。</li><li>string 对象内置方法有30多种。例如anchor、link、substring、indexOf、replace、 fromCharCode等。</li></ul></li><li>Math对象<ul><li>Math对象提供了常用的数学常数和运算，如三角函数、对数函数、指数函数等。</li><li>Math中提供了６个属性。主要方法有绝对值abs()、正弦sin()、余弦cos()、反正弦asin()、反余弦acos()、正切tan()、反正切atan()、四舍五入round()、平方根sqrt() 等。</li></ul></li><li>Date对象<ul><li>JS内置对象Date可用来获取当前的年月日、时分秒以及星期几，它基于GMT 格林威治标准时间的，另外还有一个世界统一时间UTC，Universal Coordinated Time，正替代GMT的使用。</li></ul></li><li>Number对象</li><li>JavaScript中的与定义函数：与任何对象无关的预定义函数，不需创建实例就可直接使用。<ul><li>返回字符串表达式中的值。<br><code>eval（字符串表达式），例：test=eval(&quot;8+9+5/2&quot;)</code></li><li>返回字符的编码。<br><code>escape(string) //用 %xx 16进制形式编码</code><br><code>unescape(string) //将用escape编码过的字串复原</code> </li><li>返回实数。<br><code>parseFloat(floatstring) //字符数字变成实数</code></li><li>返回不同进制的数。<br><code>parseInt(numbestring,radix) //radix是数的进制，               numbestring字符串数。字符数字按进制变成整数</code></li></ul></li></ol><h5 id="JavaScript-ActiveX编程技术"><a href="#JavaScript-ActiveX编程技术" class="headerlink" title="JavaScript ActiveX编程技术"></a>JavaScript ActiveX编程技术</h5><ul><li>HTML页面可使用ActiveX控件播放声音和flash，如何在JS中进行ActiveX控件的编程？</li><li>计算机装上各种软件后，一些ActiveX控件就会安装在计算机上，可以利用这些ActiveX控件来实现我们所要的功能。<ul><li>例如FileSystemObject 控件对象提供对计算机文件系统的访问；Excel.Application和Word.Application提供对Excel和Word的控制和操作。</li></ul></li></ul><h3 id="4-2-HTML-DOM-程序设计初步"><a href="#4-2-HTML-DOM-程序设计初步" class="headerlink" title="4.2 HTML DOM 程序设计初步"></a>4.2 HTML DOM 程序设计初步</h3><h5 id="HTML-文档对象模型"><a href="#HTML-文档对象模型" class="headerlink" title="HTML 文档对象模型"></a>HTML 文档对象模型</h5><ul><li>HTML DOM 是一个可让脚本程序动态访问和更新HTML文档内容、结构和样式的技术。</li><li>它是<strong>跨平台</strong>、可适应不同程序语言的文件对象模型，采用直观一致的方式，将HTML文档进行模型化处理，是一种提供存取和更新文档内容、结构和样式的编程接口。<br><img src="/web/文档对象模型.png" width="90%"></li><li>使用DOM技术，不仅可访问和更新页面的内容及结构，而且还能<strong>操纵文档的风格样式</strong>，它将网页中的各个HTML元素看作一个个对象，从而使网页中的元素可以被JS等语言获取或者编辑。</li><li>DOM规范在不断发展中，<strong>各种浏览器对DOM的支持有所差异</strong>。经常看到在某个浏览器下显示正常的页面在另一浏览器下显示不正常，为什么？是浏览器对DOM的支持有所不同。</li><li>对于专业的大型网站，开发人员会编码识别浏览器类型，针对浏览器的不同而进行相应代码的处理，保证网页在各种浏览器上正常显示。</li></ul><h5 id="通过DOM操纵HTML元素"><a href="#通过DOM操纵HTML元素" class="headerlink" title="通过DOM操纵HTML元素"></a>通过DOM操纵HTML元素</h5><ul><li>通过DOM操控HTML元素，必须设置其唯一标识ID属性。一般不用HTML元素的name属性了。可以把HTML元素的ID属性看成是该控件的名称。</li><li>HTML DOM提供了同一访问HTML元素的6种方法：<ul><li>document.<strong>all.item</strong>(“HTML元素的id”)</li><li>document.<strong>getElementById</strong>(“HTML元素的id”)</li><li>document.<strong>getElementByName</strong>(“HTML元素的name”)</li><li>document.<strong>all.namedItem</strong>(“HTML元素的id或name”)</li><li>document.<strong>getElementByTagName</strong>(“HTML元素的<strong>标记名称</strong>“)</li></ul></li><li>当HTML元素无ID或Name属性时，可用getElementsByTagName方法进行访问。</li></ul><h5 id="HTML-DOM主要对象介绍"><a href="#HTML-DOM主要对象介绍" class="headerlink" title="HTML DOM主要对象介绍"></a>HTML DOM主要对象介绍</h5><p><strong>1. 窗口对象 window</strong></p><ul><li>组成<ul><li>浏览器窗口对象Window处于DOM对象模型的最顶端，它封装了各种属性、方法、事件和子对象。</li><li>window对象的子对象包括位置对象location、历史对象history、事件对象event、文档对象document等。</li></ul></li><li>使用<ul><li>prompt、alert、confirm方法实现对话框功能，其中prompt为接受用户输入字符串的对话框；confirm实现具有确认和取消按钮的对话框；alert为仅输出文本对话框。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> test = <span class="built_in">window</span>.prompy(<span class="string">"请输入数据"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> YorN = confirm(<span class="string">"你输入的数据是"</span>+test+<span class="string">",确定吗"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span>(YorN) alert(<span class="string">"输入正确"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">else</span> alert(<span class="string">"输入不正确"</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2. 浏览器对象 navigator</strong></p><ul><li>window的子对象浏览器对象navigator可用于提供浏览器名称、版本、客户端支持的MIME类型属性等浏览器环境信息。<br><img src="/web/navigator.png" width="30%"></li></ul><p><strong>3. 位置对象 location</strong></p><ul><li>window子对象location提供对当前页面URL进行操作的一些方法和属性。<br><img src="/web/location.png" width="30%"></li><li><p>使用</p><ul><li>通过href或url传递参数到另一个页面:</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">window.location.href="1.html?x=5;y=6;z=7";</span><br><span class="line">window.navigate("1.html?x=5;y=6;z=7");</span><br></pre></td></tr></table></figure></li></ul><p><strong>4. 历史对象 history</strong></p><ul><li>window子对象history历史对象提供了浏览器的浏览历史信息。用户在浏览器中通过点击超链接或其他方式跳转到新的页面，如果要后退看前面已经访问过的网页历史，可以在浏览器工具条单击“后退”。通过history对象可以在网页中进行控制。<br><img src="/web/history.png" width="30%"></li></ul><p><strong>5. 事件对象 event</strong></p><ul><li>window子对象事件对象event，用来获取或设置产生事件的对象是哪个对象、键盘按键的状态、当前鼠标指针的位置、鼠标按键的状态等等。<br><img src="/web/event.png" width="60%"></li><li>使用<ul><li>event.x:设置或者是得到鼠标相对于目标事件的父元素的外边界在x坐标上的位置。</li><li>event.clientX:相对于客户区域的x坐标位置，不包括滚动条，放置正文区域。</li><li>event.offsetx：设置或得到鼠标相对于目标事件的父元素的内边界在x坐标上的位置。</li><li>event.screenX:相对于用户屏幕。</li></ul></li></ul> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">  </span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">"event.x:"</span> + event.x + <span class="string">"\nevent.y:"</span> + event.y + <span class="string">"\nevent.clientX:"</span> + event.clientX + <span class="string">"\nevent.clientY:"</span> + event.clientY + <span class="string">"\nevent.offsetX:"</span> + event.offsetX + <span class="string">"\nevent.offsetY:"</span> + event.offsetY + <span class="string">"\nevent.screenX:"</span> + event.screenX + <span class="string">"\nevent.screenY:"</span> + event.screenY);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">style</span>=<span class="string">"position: relative; left: 100; top: 100"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">"show()"</span> <span class="attr">style</span>=<span class="string">"background: silver; cursor: hand"</span>&gt;</span></span><br><span class="line">       Click here to show.   <span class="tag">&lt;/<span class="name">div</span>&gt;</span>    <span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>6. 文档对象 document</strong></p><ul><li>document对象是浏览器对象的核心子对象，主要作用就是对网页显示区域的各个HTML元素进行处理。document对象对实现Web页面信息交互起关键作用。HTML5: 属性+方法+事件  255个<br><img src="/web/document.png" width="60%"></li><li>文档对象的属性 cookie<ul><li>cookie可用来存放当前页面的参数信息，也可用来存放同一网站打开的多个页面间的共享信息。</li><li>可以对cookie设置失效期限，既可永久保留，也可关闭网站后就删除，也可在指定时间内失效。</li><li>expires指定cookie的失效日期，当没有失效日期时，关闭浏览器即失效。</li><li><code>name=wcl;sex=male;color=red; expires=Sun May 27 22:04:25 UTC+0800 2008</code></li></ul></li><li>文档对象的方法<ul><li>有了Document对象的write方法，给我们带来了很大的方便。我们不需要事先将网页制作好，做一个死板的网页，而是可以通过脚本程序自动动态生成出来。</li></ul></li><li>文档对象的事件<ul><li>文档对象的事件除了响应键盘、鼠标常规操作事件外，还增加了其他大量事件，例如鼠标的拖拉操作事件、浏览器鼠标右键快捷菜单事件oncontextmenu等。</li></ul></li><li>docment的对象<ul><li>document有all、anchors、applets、childNodes、embeds、forms、frames、images、links、namespaces、scripts、styleSheets等集合对象。</li></ul></li></ul><h5 id="HTML-DOM树介绍"><a href="#HTML-DOM树介绍" class="headerlink" title="HTML DOM树介绍"></a>HTML DOM树介绍</h5><ul><li>HTML DOM是一种结构化的对象模型，采用DOM技术访问和更新HTML页面内容时，可依据HTML源代码，建立页面的树型结构模型，然后按照树型结构的层次关系来操纵Web页面。  </li><li>结构：<br><img src="/web/domtree.png" width="30%"></li><li>在DOM树型结构中，每个节点都是一个对象，各节点对象都有属性和方法。</li><li>DOM树型结构节点有<strong>只读属性</strong>和<strong>读写属性</strong>两类。通过只读属性可以浏览节点，并可获得节点的类型及名称等信息；通过读写属性可以访问文字节点的内容。</li><li>用DOM树方法可以<strong>动态创建html文档或html元素</strong>，并可通过JS程序随时改变文档的节点结构或内容，建立动态的网页生成效果。</li><li></li></ul><h3 id="4-3-如何用jQuery简化JavaScript开发"><a href="#4-3-如何用jQuery简化JavaScript开发" class="headerlink" title="4.3 如何用jQuery简化JavaScript开发"></a>4.3 如何用jQuery简化JavaScript开发</h3><h5 id="jQuery简介"><a href="#jQuery简介" class="headerlink" title="jQuery简介"></a>jQuery简介</h5><ul><li>把一些通用的函数事先写好，放在外部单独JS文件中，在手工编写网页代码时，就可重复使用这些通用函数，大大简化网页代码的编写工作，提高网页开发的效率。</li><li>jQuery是一个快捷、小巧和特性丰富的JavaScript库，凭借简洁语法和跨平台的兼容性，大大简化了JS开发人员遍历HTML文档、操作DOM、处理事件、执行动画和开发Ajax的操作。其独特而优雅的代码风格改变了JS程序员的设计思路和编写程序的方式。</li><li>jQuery主要功能：<ul><li><strong>获取文档中的元素。</strong>jQuery为准确地获取需要检查或操作的文档元素，提供了可靠而富有效率的选择符机制。</li><li>修改页面外观。jQuery提供了跨浏览器的标准解决方案，即使在页面呈现以后，仍能改变文档中某个部分的类或者个别的样式属性。</li><li><strong>改变文档的内容。</strong>jQuery能够影响的范围并不局限于简单的外观变化，使用少量的代码，jQuery就能改变文档的内容。</li><li><strong>响应用户的交互操作。</strong>jQuery提供了形形色色的页面事件的适当方式，而不需要使用事件处理程序使HTML代码看起来杂乱。此外，它的事件处理API也消除了经常困扰Web开发人员的浏览器不一致性问题。</li><li><strong>为页面添加动态效果。</strong>为了实现某种交互行为，设计者必须向用户提供视觉上的反馈。jQuery内置的一批淡入、擦除之类的效果，以及制作新效果的工具包，为此提供了便利。</li><li><strong>无需刷新页面从服务器获取信息。</strong>这种编程模式就是众所周知的AJAX，它能帮助Web开发人员创建出反应敏感、功能丰富的网站。jQuery通过消除这一过程中的浏览器特定的复杂性，使开发人员得以专注于服务器的功能设计。</li><li><strong>简化常用的JavaScript任务。</strong>除了这些完全针对文档的特性之外，jQuery也提供了对基本的JavaScript结构（例如迭代和数组操作等）的增强。</li></ul></li></ul><h5 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h5><ol><li><p>元素选择器</p><ul><li>采用元素名称如a、img、  input作为选择器。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(“div”)表示选择所有div元素$(“img”)表示选择所有img </span><br><span class="line">$(“tr”)表示选择所有tr元素</span><br></pre></td></tr></table></figure></li><li><p>ID选择器</p><ul><li><p>用元素ID作为选择器。<br><code>$(“#button1”)将选择ID为button1的元素。</code></p></li><li><p>ID选择器有时也和元素选择器一起使用：<br><code>$(“div #main”)选中ID为main的div元素。</code></p></li></ul></li><li><p>类选择器</p><ul><li>元素的class属性。类选择器的语法是以.开头，紧接着是CSS类名。<br><code>$(“.important”)将选择页面上所有应用了important类的元素。</code></li></ul></li><li><p>后代选择器</p><ul><li>若在一个选择器后面有一个空格，再跟另外一个选择器，则表示选择包含在第一个选择器中的第二个选择器。    <code>$(”div p”)将选择div中出现的所有p元素。</code></li></ul></li><li>子元素选择器<ul><li>若一个选择器后面是一个大于号 &gt; ，后面再跟另一个选择器，则表示选择直接包在第一个选择器中的第二个选择器。<br><code>$(‘#ss &gt; li’)  选择Id为SS元素中的所有li元素。</code></li></ul></li></ol><h5 id="jQuery中关于DOM的操作"><a href="#jQuery中关于DOM的操作" class="headerlink" title="jQuery中关于DOM的操作"></a>jQuery中关于DOM的操作</h5><p><img src="/web/jQuertdom.png" width="60%"><br><img src="/web/jQuertdom2.png" width="60%"></p><h5 id="jQuery事件"><a href="#jQuery事件" class="headerlink" title="jQuery事件"></a>jQuery事件</h5><h3 id="4-4-DHTML综合编程实例"><a href="#4-4-DHTML综合编程实例" class="headerlink" title="4.4 DHTML综合编程实例"></a>4.4 DHTML综合编程实例</h3><h5 id="广告条定时滚动"><a href="#广告条定时滚动" class="headerlink" title="广告条定时滚动"></a>广告条定时滚动</h5><h5 id="通过URL传递参数"><a href="#通过URL传递参数" class="headerlink" title="通过URL传递参数"></a>通过URL传递参数</h5><h5 id="超文本编辑器及其与Word的互操作"><a href="#超文本编辑器及其与Word的互操作" class="headerlink" title="超文本编辑器及其与Word的互操作"></a>超文本编辑器及其与Word的互操作</h5><h5 id="表格的美化"><a href="#表格的美化" class="headerlink" title="表格的美化"></a>表格的美化</h5><h2 id="5-XML"><a href="#5-XML" class="headerlink" title="5. XML"></a>5. XML</h2><h3 id="5-1-什么是XML？"><a href="#5-1-什么是XML？" class="headerlink" title="5.1 什么是XML？"></a>5.1 什么是XML？</h3><h5 id="XML-Extensible-Markup-Language-可扩展标记语言"><a href="#XML-Extensible-Markup-Language-可扩展标记语言" class="headerlink" title="XML  Extensible Markup Language 可扩展标记语言"></a>XML  Extensible Markup Language 可扩展标记语言</h5><ul><li>XML是一种类似于HTML的标记语言</li><li>XML是用来描述数据</li><li>XML的标记非预先定义，须<strong>自行定义标记</strong></li></ul><h5 id="XML的特点"><a href="#XML的特点" class="headerlink" title="XML的特点"></a>XML的特点</h5><ul><li><strong>XML的可扩展性</strong>：<ul><li>XML中，可建立任何需要的标记。可充分发挥想象力给文档起一些好记的标记名称。</li></ul></li><li><strong>标记的自描述性</strong>：<ul><li>标记（tag）又叫标识，也称元素名，用于描述数据，标识文档中的元素。通过标记，XML文档才便于阅读和理解。</li></ul></li><li><strong>XML语言的规则性</strong>：<ul><li>标记区分大小写，须配对且合理嵌套；属性须用引号括起来；名字不能以下划线开头，不能有空格，可有字母、数字及下划线；不能用XML等保留字。</li></ul></li><li><strong>文档的结构化</strong>：<ul><li>所有的信息按某种关系排列。</li></ul></li><li><strong>允许Meta数据(元数据)</strong>：<ul><li>可用XML描述你的信息在哪里，可通过meta来验证信息、执行搜索、强制显示或者处理其它的数据。</li></ul></li><li><strong>XML文档的多样显示</strong>：<ul><li>可通过CSS或者XSL可扩展样式语言（Extensible Stylesheet Language）在浏览器中呈现XML文档内容。</li></ul></li><li><strong>允许XML DOM操作</strong>：<ul><li>XML DOM的作用就是使用脚本语言如何对XML文档的节点和数据进行增删查改等各项操作。</li></ul></li></ul><h5 id="XML中有关名词的相互关系"><a href="#XML中有关名词的相互关系" class="headerlink" title="XML中有关名词的相互关系"></a>XML中有关名词的相互关系</h5><ul><li>XML DTD用以说明XML文档中数据的类型和格式，既可放在单独文件中，又可直接放在XML文档中。</li><li>由于XML DTD本身非XML文档结构，其对XML文档数据类型和格式的描述过于复杂，用户在使用时较难掌握，目前已被XML Schema所替代。</li><li>XML Schema中对XML文档中数据类型和格式的描述采用了XML文档结构，可以定义复杂数据类型。CSS和XSL用来实现XML文档在浏览器中的显示。<br><img src="/web/xml.png" width="70%"></li></ul><h5 id="XML文档结构"><a href="#XML文档结构" class="headerlink" title="XML文档结构"></a>XML文档结构</h5><ol><li>XML文档声明<ul><li>version：XML文档所遵循的XML规范的版本号；</li><li>可选项encoding：XML处理器使用的字符集，默认为UFT-8；</li><li>可选参数standalone：yes或no，默认值为yes，申明该文档为一个独立文档，无需DTD文档来验证其中的标识是否有效。<br><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;GB-2312 standalone=&quot;yes&quot;?&gt;</code></li></ul></li><li>文档显示方式或者文档类型定义的声明部分</li><li>XML标识的文档内容</li></ol><h5 id="XML文档内容的结构"><a href="#XML文档内容的结构" class="headerlink" title="XML文档内容的结构"></a>XML文档内容的结构</h5><ol><li>声明根元素：<ul><li>每一个有效的XML文档有且仅有一个根元素。</li><li><code>&lt;rootElementName&gt;...&lt;/rootElementName&gt;</code></li></ul></li><li>声明非根元素</li><li>数据元素属性<ul><li>一个数据元素可以有若干属性，属性必须在一个元素的起始标记中声明</li></ul></li><li><p>定义名称空间</p><ul><li>在XML中，用户可以自己定义标记名称也即元素名称， 因此，如果把多个XML文件合并为一个，就很可能出现名称冲突。</li><li>解决这一问题的方法就是使用名称空间。</li></ul></li><li><p>包含非标准文本</p><ul><li>在具体应用中，XML文档往往包含一些特殊符号和文本块，而这些特殊符号不需要应用程序或格式转换程序做任何处理，只需照原样输出时，称之为非标准文本，又称非解析数据(Character DATA)。 </li><li>XML文档的基本结构中用CDATA来表示。CDATA节的一般形式为：<code>&lt;![CDATA[text]]&gt;</code></li></ul></li></ol><h3 id="5-2-用CSS控制XML文档在浏览器中的显示"><a href="#5-2-用CSS控制XML文档在浏览器中的显示" class="headerlink" title="5.2 用CSS控制XML文档在浏览器中的显示"></a>5.2 用CSS控制XML文档在浏览器中的显示</h3><h5 id="XML文档的4中css样式定义方式"><a href="#XML文档的4中css样式定义方式" class="headerlink" title="XML文档的4中css样式定义方式"></a>XML文档的4中css样式定义方式</h5><ul><li>元素名称选择符</li><li>用户自定义类选择符</li><li>用户定义的ID选择符</li><li>成组选择符</li></ul><h5 id="CSS样式和XML文档的联系方式"><a href="#CSS样式和XML文档的联系方式" class="headerlink" title="CSS样式和XML文档的联系方式"></a>CSS样式和XML文档的联系方式</h5><ol><li>将定义的CSS样式表置于XML文档中</li><li>将CSS样式表放在单独的扩展名为css的文件中，然后在XML文档声明部分引用css文件</li><li>将上述两种方式结合起来</li></ol><h3 id="5-3-用XSL控制XML文档在浏览器中的显示"><a href="#5-3-用XSL控制XML文档在浏览器中的显示" class="headerlink" title="5.3 用XSL控制XML文档在浏览器中的显示"></a>5.3 用XSL控制XML文档在浏览器中的显示</h3><h5 id="XSL概述"><a href="#XSL概述" class="headerlink" title="XSL概述"></a>XSL概述</h5><ul><li>XSL(eXtensible Stylesheet Languge， 可扩展样式单语言)是由W3C 1999年11月制定的。XSL自提出以来争议颇多，前后经过了几番大的修改。</li><li>2007年1月 W3C 发布了修改后的XSLT 2.0 版本（<a href="http://www.w3.org/TR/xslt20/）。" target="_blank" rel="noopener">http://www.w3.org/TR/xslt20/）。</a> 2013年12月 发布 XSLT 3.0，它仍然在进一步修改完善中。 </li><li>XSLT能将XML文档<strong>转换</strong>成一个新的文档（包括HTML文档），通过浏览器或其它应用程序就可以显示出来。</li></ul><h5 id="XSL的组成"><a href="#XSL的组成" class="headerlink" title="XSL的组成"></a>XSL的组成</h5><ul><li>XSLT ： XSL Transformation，用于转换 XML 文档的语言。</li><li>Xpath： 用于在XML文档中选择元素的语言。</li><li>格式化符号集XSL-FO -：定义应用XML数据的复杂的格式化规则。用于格式化 XML 文档的语言。</li></ul><h5 id="XSL与CSS的异同"><a href="#XSL与CSS的异同" class="headerlink" title="XSL与CSS的异同"></a>XSL与CSS的异同</h5><ul><li>XSL与CSS在功能上类似，但XSL比CSS功能强大、复杂度高。</li><li>CSS只允许格式化XML元素内容，不允许改变或安排这些内容。但XSL没有这些限制，可提取元素、属性值、注释文本等各种文档内容。在XML领域，用XSL来格式化文档是未来发展的方向。</li><li>CSS样式描述格式不遵从XML的语法规范。而XSL遵守XML语法规则，是XML的一种具体应用，也即XSL本身就是一个XML文档，系统可使用同一个XML解释器对XML文档及其相关的XSL文档进行解释处理。</li></ul><h5 id="XSL模板元素"><a href="#XSL模板元素" class="headerlink" title="XSL模板元素"></a>XSL模板元素</h5><ul><li>在XSL中，数据的显示格式被设计细化成一个个模板，最后再将这些模板组合成一个完整的XSL。</li><li>这种方法可以使用户先从整体上考虑整个XSL的设计，然后将一些表现形式细化成不同的模板，再具体设计若干模板，最后将它们整合在一起。</li><li>由于XML的数据保存在具有严格层次结构的各个元素中，这种结构非常适合采用模板化的格式样式。  </li><li>模板定义好后，可通过call-template或apply-templates来调用模板，其过程就如同我们在C语言中定义了一个函数，就可在程序中需要的地方进行函数调用。<br><img src="/web/xsl.png" width="80%"></li><li>定义模板的语法结构：<br><code>&lt;xsl: template match=&quot;node-context&quot; name=&quot;template name&quot;&gt;...&lt;/xsl: template&gt;</code><ul><li>match确定什么样的情况下执行此模板，其中最上层的模板必须将match设为”/”。在一个XSL文档中必须有一个根模板，而且是唯一的。</li><li><code>&lt;xsl:template&gt;</code>元素用match属性从XML文档中选取满足条件的节点，针对这些特定的节点形成一个特定输出形式的模板。</li><li>name属性即是为定义的模板取一个用户自定义的名称。只能通过<code>&lt;xsl:call-template&gt;</code>元素来调用模板。</li></ul></li></ul><h5 id="XSL选择元素"><a href="#XSL选择元素" class="headerlink" title="XSL选择元素"></a>XSL选择元素</h5><ul><li>用选择的方式将满足条件的数据从XML文档中提取出来<br><img src="/web/select.png" width="80%"></li></ul><h5 id="XSL常用运算符"><a href="#XSL常用运算符" class="headerlink" title="XSL常用运算符"></a>XSL常用运算符</h5><p><img src="/web/operation.png" width="80%"></p><ul><li><code>&lt;xsl:for-each select=&quot;*/resume&quot;&gt;</code>  此处用通配符*代替了document元素名称。对每个resume 循环处理</li><li><code>&lt;xsl:for-each select=&quot;//resume [@id=&#39;008&#39;]&quot;&gt;</code> 对简历中具有Id属性编号为“0008”的人进行处理</li><li><code>&lt;xsl:for-each select=&quot;*/resume [cellphone]&quot;&gt;</code> 对简历中具有“cellph手机one”元素的人进行处理，也即对简历中提供了号码的人进行处理。</li><li><code>&lt;xsl:for-each select=&quot;*/resume [cellphone]&quot;&gt;</code> 对简历中具有“cellphone”元素的人进行处理，也即对简历中提供了手机号码的人进行处理。</li><li><code>&lt;xsl:for-each select=&quot;*/resume [skill=&#39;Web开发&#39;]&quot;&gt;</code> 对简历中具有”Web开发”技能的所有人进行处理</li></ul><h5 id="XSL常用内置函数"><a href="#XSL常用内置函数" class="headerlink" title="XSL常用内置函数"></a>XSL常用内置函数</h5><p><img src="/web/function.png" width="80%"></p><h5 id="XSL常用处理元素语法"><a href="#XSL常用处理元素语法" class="headerlink" title="XSL常用处理元素语法"></a>XSL常用处理元素语法</h5><p><img src="/web/other.png" width="80%"></p><h3 id="5-4-XML-DOM编程基础"><a href="#5-4-XML-DOM编程基础" class="headerlink" title="5.4 XML DOM编程基础"></a>5.4 XML DOM编程基础</h3><h5 id="XML-DOM简介"><a href="#XML-DOM简介" class="headerlink" title="XML DOM简介"></a>XML DOM简介</h5><ul><li>对于XML文档，可利用CSS的样式或XSLT格式转换后利用浏览器解析和浏览它，如何对XML文档进行数据的添加、删除、修改、查询等操作，就需要使用XML DOM技术了。 </li><li>XML DOM实际上就是访问XML文档的标准应用程序接口。</li><li>XML DOM是W3C提出的针对XML的文档对象模型，是一个与语言无关、与平台无关的标准接口规范，定义了一套标准的用于XML的对象和一种标准的访问与处理XML文档的方法。</li><li>对于XML应用开发来说，DOM 就是一个对象化的XML数据接口，它定义了XML文档的逻辑结构，可动态创建XML文档；遍历文档结构；添加、修改、删除文档内容；改变文档的显示方式等。无论是在浏览器里还是在浏览器外，无论是在服务器还是在客户端，只要有用到XML的地方，都可利用DOM接口进行编程应用。</li><li><strong>DOM将XML文档作为树结构来看待。</strong>XML文档中的每个成分都是一个节点。例如整个文档是一个文档根节点；每个XML标记是一个元素节点；包含在XML元素中的文本是文本节点；每一个XML属性是一个属性节点；注释属于注释节点。</li></ul><h5 id="XML-DOM与-SAX"><a href="#XML-DOM与-SAX" class="headerlink" title="XML DOM与 SAX"></a>XML DOM与 SAX</h5><ul><li>访问XML文档的标准应用程序接口有两种：DOM（Document Object Model）和SAX（Simple API for XML）。</li><li>DOM接口中的XML分析器，在对XML文档进行分析之后，不管这个文档有多简单或者多复杂，<strong>其中的信息都会被转化成一棵对象节点树——DOM 树</strong>。在这棵节点树中，有一个Document根节点，所有其他的节点都是根节点的后代节点。节点树生成之后，就可通过XML DOM接口访问、修改、添加、删除树中的节点和属性以及文本内容等。应用程序可在任何时候访问XML文档中的任何一部分数据，也即可随机访问。</li><li>与XML DOM不同，SAX提供的访问模式是一种顺序模式，这是一种快速读写XML数据的方式。当使用SAX分析器对XML文档进行分析时，会触发一系列事件，并激活相应的事件处理函数，应用程序通过编写的事件处理函数实现对XML文档的访问，因而SAX接口也被称作事件驱动接口。</li><li>由于DOM分析器把整个XML文档转化成DOM树放在了内存中，当XML文档很大或结构比较复杂时，对内存的需求就比较高。SAX分析器在对XML文档进行分析时，触发了一系列的事件，由于事件触发本身是有时序性的，SAX提供的是一种顺序访问机制，对于分析过的部分，不能再倒回去重新处理，因此SAX分析器缺乏灵活性但实现简单，对内存要求比较低。</li></ul><h5 id="XML-DOM对象"><a href="#XML-DOM对象" class="headerlink" title="XML DOM对象"></a>XML DOM对象</h5><ul><li><strong>Document对象</strong><ul><li>Document对象代表了整个XML文档，因此，它是整棵DOM树的根，提供了对文档中的数据进行访问和操作的入口。</li><li>通过Document节点，可以访问到文档中的其它节点，如处理指令、注释、文档类型以及XML文档的根元素节点等等。</li></ul></li><li><strong>Node对象：</strong>Node对象代表了树中的一个节点。子对象有Document、Element、Attribute、Text、Comment等。<ul><li><code>Element对象</code>：表示一个XML文档中的某个元素。元素可包含属性和文本。某个元素含有文本，则此文本就是一个文本节点。文本永远被存储于文本节点中。<code>&lt;year&gt;2005&lt;/year&gt;</code>其中year为一个元素节点，此节点之下存在一个文本节点，其中含有文本2005。由于元素对象也是一种Node，因此它继承了Node对象的属性和方法。</li><li><code>Attr对象</code>：表示某个Element对象的一个属性。Attr对象也是一种节点，因此它可继承Node对象的属性和方法。不过属性无法拥有父节点，同时属性也不被认为是元素的子节点。</li><li><code>Text对象</code>：Text对象表示元素或属性的文本内容。</li></ul></li><li><strong>Node List对象</strong><ul><li>NodeList对象表示节点的集合，它包含了某个节点中的所有子节点对象，可用于表示有顺序关系的一组节点（例如某个节点的子节点序列）。</li><li>可用GetNodeByName方法返回节点的值。可通过节点列表中的节点索引号来访问列表中的节点（索引号由0开始）。若节点列表或XML文档中的某个元素被删除或添加，列表会被自动更新。</li><li>NodeList对象的属性length可返回某个节点列表中的节点数目，方法item可返回节点列表中处于某个指定的索引号的节点。</li></ul></li><li><strong>NamedNodeMap对象</strong><ul><li>NamedNodeMap对象也表示节点的集合，利用该对象可建立节点名和节点之间的一一映射关系，从而利用节点名可以直接访问特定的节点。 </li><li>NamedNodeMap<strong>通过名称来描述节点</strong>，而不是通过序数索引。 </li></ul></li></ul><h3 id="5-5-XML与数据库"><a href="#5-5-XML与数据库" class="headerlink" title="5.5 XML与数据库"></a>5.5 XML与数据库</h3><h5 id="XML与数据库的关系"><a href="#XML与数据库的关系" class="headerlink" title="XML与数据库的关系"></a>XML与数据库的关系</h5><ul><li>XML不是数据库，数据库系统有它自己的一套管理模式，而XML仅仅是用来存放数据的文件，<strong>一个XML文档相当于数据库中的一个表</strong>。因此XML不可能取代数据库，但将数据库和XML结合起来，能够完成很多以前无法完成的工作，例如异构数据交换、应用系统集成等。</li><li>数据若放在数据库中共享，则受到数据库连接请求失败、防火墙隔离等各种限制。</li><li>XML是文本文件，可以穿透任何防火墙进行传输，已成为互联网上的事实数据交换标准。</li><li>随着XML的广泛应用，<strong>各数据库产品都被重新设计，使之能很好支持XML，</strong>如Oracle、SQL Server、DB2、Sybase、MySQL等。另外还出现了支持native（原生） XML文档进行存储管理的专属XML数据库系统，如X-Hive、XML Repository、eXcelon、BaseX、 Sedna、 XMLDB等，提供对标签和路径的操作，文档存储和检索迅捷，可提供高质量的全文搜索。</li><li>开发一个访问数据库的XML应用系统需要<strong>同时借助XML编程接口和数据库编程接口</strong>，前者用于对XML文档的解析、定位和查询，所需技术包括DOM和SAX；后者则是用于访问数据库，如数据库中数据的更新和检索等等，需要利用的技术有ODBC、JDBC、ADO/ADO.NET等。</li><li>XML文档可通过A<strong>DO.NET等各种数据接口方式</strong>存放到数据库中，也可将数据表中的数据形成一个XML文档通过XSL来呈现。</li></ul><h5 id="SQL-Server-对XML的支持"><a href="#SQL-Server-对XML的支持" class="headerlink" title="SQL Server 对XML的支持"></a>SQL Server 对XML的支持</h5><ol><li>使用SELECT语句中的FOR XML子句得到XML文档格式的数据：<br><code>select * from Northwind.dbo.customers  for xml auto</code></li><li>简单的HTTP URL请求<br><code>http://localhost/web?sql=select * from Northwind.dbo.customers  for xml auto</code></li><li>OPENXML函数可以让你像操作一个表那样来运用XML数据，可以将它们转换成内存中的一个行记录集。需调用<code>sp_xml_ preparedocument</code>存储过程完成。</li><li>通过SQLXML功能（包含有<code>updategram</code>和<code>XML BulkLoad</code>功能）</li><li>SQL SERVER支持基于XPath 表达式的XQuery语言，该语言被设计用来查询 XML 数据，作用类似 SQL语言对数据库的查询。SQL Server引入了 xml 数据类型，提供了用于对存储在列或变量中的 XML 数据执行操作的大量方法。</li><li>SQL Server支持在insert表达式中的 xml 变量向现有 XML 结构插入 XML 数据的支持。</li></ol><h5 id="关于JSON"><a href="#关于JSON" class="headerlink" title="关于JSON"></a>关于JSON</h5><ul><li>在XML中，需要许多开始标记和结束标记来标识数据，在互联网网上传输数据时效率不高，出现了JSON(JavaScript Object Notation) 轻量级的数据交换格式，易于阅读和编写，同时也易于机器解析和生成， 作为XML文档的一种有力补充。</li></ul><h2 id="6-NET-Web应用程序开发"><a href="#6-NET-Web应用程序开发" class="headerlink" title="6. NET Web应用程序开发"></a>6. NET Web应用程序开发</h2><h3 id="6-1-C-语言初步"><a href="#6-1-C-语言初步" class="headerlink" title="6.1 C#语言初步"></a>6.1 C#语言初步</h3><h5 id="ASP-NET的体系结构"><a href="#ASP-NET的体系结构" class="headerlink" title="ASP.NET的体系结构"></a>ASP.NET的体系结构</h5><ul><li>ASP.NET是微软.NET Framework的一部分，是开发Web应用程序的全新编程模式，可使Web开发人员更快捷和方便地开发Web应用程序。</li><li>图为ASP.NET的体系结构。ASP.NET页面通过ISAPI与IIS通信，有一个用作页面的缓存cache，以提高性能。</li><li>ASP.NET中采用强类型语言VB.NET、C#等，采用完全面向对象方式编程。C#是由C和C++发展而来的面向对象和类型安全的编程语言。C#读作C Sharp，它和Java非常相近。<br><img src="/web/ASP.NET.png" width="80%"></li></ul><h5 id="C-程序的基本结构"><a href="#C-程序的基本结构" class="headerlink" title="C#程序的基本结构"></a>C#程序的基本结构</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System  //名称空间</span><br><span class="line">class Hello&#123;</span><br><span class="line">static void Main()&#123;</span><br><span class="line">Console.WriteLine(&quot;Hello, World&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>using System使用了由Microsoft.NET类库中提供的System名称空间，用来组织类库的分层。分层的类库之间用操作符“.”表示上下级分层关系。</li><li>使用“using”后，就可无障碍地使用名称空间中的各种类型成员，名称空间提供了一种用来组织一个类库的分层方法。</li><li>名称空间除具有避免名称冲突之功能外，更重要的是在引用名称空间后，就可在程序代码中方便地使用系统提供的各种类库成员。</li></ul><h5 id="C-中的数据类型"><a href="#C-中的数据类型" class="headerlink" title="C#中的数据类型"></a>C#中的数据类型</h5><ul><li>数据类型<ul><li>简单类型</li><li>枚举类型</li><li>结构类型</li></ul></li><li>引用类型：对于引用类型，两个变量可引用相同的对象，因而可能出现对一个变量的操作影响到其他变量所引用对象的情况<ul><li>类类型</li><li>接口类型</li><li>代表类型</li><li>数组类型 </li></ul></li></ul><h5 id="C-变量声明及其初始化"><a href="#C-变量声明及其初始化" class="headerlink" title="C#变量声明及其初始化"></a>C#变量声明及其初始化</h5><ul><li>C#语言是一种强类型的语言，在使用变量前必须对该变量的类型进行声明，建议在声明变量时就对变量进行初始化。</li><li>变量名必须以英文字母或@开头，由字母、数字、下划线组成，不能有空格、标点、运算符号、C#中关键字名、C#中库函数名，且大小写敏感。<br><img src="/web/variable.png" width="80%"></li></ul><h5 id="C-枚举类型"><a href="#C-枚举类型" class="headerlink" title="C#枚举类型"></a>C#枚举类型</h5><ul><li>C#中定义常量用const修饰符，例如“public const double y=1.234;”。枚举类型是由一组特定常量构成的一种数据结构，是值类型的特殊形式。</li><li>当需要一个有指定常量集合组成的数据类型时，可使用枚举类型。</li><li>枚举类型不能实现接口、不能定义方法、属性、事件。</li></ul><h5 id="C-表达式"><a href="#C-表达式" class="headerlink" title="C#表达式"></a>C#表达式</h5><ul><li>算数表达式<ul><li>用算术操作符把数值连接在一起的、符合C#语法的表达式称为算术表达式。</li><li>算术操作符：+、–、*、/、%、++、– –</li><li>二进制操作符：&amp;（与）、|（或）、^（异或）、～（补）、&lt;&lt;（左移）、&gt;&gt;（右移）</li></ul></li><li>赋值表达式<ul><li>赋值操作符用于为变量、属性、事件或索引器元素赋予新值。</li><li>赋值操作符的运算对象、运算法则及运算结果如下：<br><img src="/web/list.png" width="80%"></li></ul></li><li>关系表达式<ul><li>= =、!=、&lt;、&gt;、&lt;=和&gt;=等操作符称为关系操作符。用关系操作符把运算对象连接起来并符合C#语法的式子称为关系表达式。关系表达式要么返回true要么返回false。C#中还定义了is操作符，其格式为：A(值) is B(类型)，意义是如果A是B类型或者A可以转化为B类型则返回true，否则为false。</li></ul></li><li>逻辑表达式<ul><li>（&amp;&amp;（and）、||（or）和!（not）操作符称为逻辑操作符。用逻辑操作符把运算对象连接起来并符合C#语法的式子称为逻辑表达式。 </li></ul></li></ul><h5 id="C-控制语句"><a href="#C-控制语句" class="headerlink" title="C#控制语句"></a>C#控制语句</h5><ul><li>分支语句3种：<ul><li>三元运算符，例如：a=(b&gt;5)?100:10表示b&gt;5时a=100，否则a=10；</li><li>if语句（一次仅测试一个条件）；</li><li>switch语句（一次将测试变量与多个值比较）。</li></ul></li><li>循环语句4种：<ul><li>可用break和continue语句</li><li>跳出循环或继续执行循环。</li><li>foreach语句可以遍历一个集合中的所有元素。</li><li>try-catch-finally语句用来捕捉异常，使用语法与JavaScript语言<br>中的相似。在Web开发中应尽量少用捕捉异常来实现某些功能。<br><img src="/web/iffor.png" width="80%"></li></ul></li></ul><h5 id="C-类声明"><a href="#C-类声明" class="headerlink" title="C#类声明"></a>C#类声明</h5><ul><li>类声明就是定义新的引用类型。类是一种将数据成员、函数成员和嵌套类型等进行封装的数据结构，一个类可从其他类继承。其数据成员可以是常量或域，函数成员可以是方法、属性、索引、事件、操作符或静态构造函数和析构函数。构造函数在创建对象时被自动调用，用来执行对象的初始化操作，其函数名总是与类名相同。析构函数在释放对象时被调用，用来删除对象前做一些清理工作。</li><li>类中的每个成员都必须定义其被访问的范围，用类的访问修饰符来表示访问这个成员的程序文本的区域。类的访问修饰符有五种形式：</li></ul><h3 id="6-2-ASP-NET常用控件的使用介绍"><a href="#6-2-ASP-NET常用控件的使用介绍" class="headerlink" title="6.2 ASP.NET常用控件的使用介绍"></a>6.2 ASP.NET常用控件的使用介绍</h3><h5 id="ASP-NET控件"><a href="#ASP-NET控件" class="headerlink" title="ASP.NET控件"></a>ASP.NET控件</h5><ul><li>客户端控件：Web服务器对客户端控件不做任何处理，交由客户端浏览器来处理。</li><li>服务器端控件：需要占用Web服务器的内存、CPU等系统资源等来处理服务端控件，最终转变成客户端控件，再交由客户端浏览器来处理。</li><li>为提供网页访问速度，页面中<strong>尽量使用客户端控件</strong>。</li></ul><h5 id="服务器端标准控件"><a href="#服务器端标准控件" class="headerlink" title="服务器端标准控件"></a>服务器端标准控件</h5><ul><li>服务器端控件的常见属性<br><img src="/web/service.png" width="80%"></li><li>当某控件的EnableViewState属性为true时，表示该控件的值在页面刷新或回传重新显示页面后不会丢失，但却耗费网络资源和服务器资源。因此当页面回传后无须保值处理时应设为false</li></ul><ol><li>Label和Literal控件<ul><li>Label用来放置文本串，通过Text属性设置和显示文本。Text中可以包含其他HTML标记。<br><code>&lt;asp:Label ID=&quot;Lable1&quot; runat=&quot;server&quot; Text=&quot;Lable&quot;&gt;&lt;/asp:Lable&gt;</code></li><li>Literal和Label类似，text文本中不能添加任何HTML标记。<br><code>&lt;asp:Literal ID=&quot;Literall&quot; runat=&quot;server&quot;&gt;&lt;/asp:Literal</code></li></ul></li><li>TextBox文本框控件<ul><li>该控件用于获取用户输入的文本或显示文本。<br><code>&lt;asp:TextBox ID=&quot;TextBox1&quot; runat=&quot;server&quot;&gt;&lt;/asp:TextBox&gt;</code></li></ul></li><li>Image控件<ul><li>该控件是用来插入图片。<br><code>&lt;asp:Image ID=&quot;Image1&quot; runat=&quot;server&quot;&gt;</code></li></ul></li><li><p>Button、LinkButton、ImageButton控件</p><ul><li>分别表示普通按钮、超链接形式的按钮和图像按钮。允许用户通过单击来执行操作。每当用户单击按钮时，即调用Click事件处理程序。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;asp:Button ID=&quot;Button1&quot; runat=&quot;server&quot; Text=&quot;Button&quot; /&gt;</span><br><span class="line">&lt;asp:LinkButton ID=&quot;LinkButton1&quot; runat=&quot;server&quot;&gt;LinkButton&lt;/asp:LinkButton&gt;</span><br><span class="line">&lt;asp:ImageButton ID=&quot;ImageButton1&quot; runat=&quot;server&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>HyperLink控件</p><ul><li>用于制作文本或图片超级链接。<br><code>&lt;asap:hyperlink runat=&quot;server&quot;&gt;HyperLink&lt;/asp:hyperlink&gt;</code></li></ul></li><li><p>RadioButton和RadioButtonList单选按钮</p><ul><li>为用户提供由两个或多个互斥选项组成的选项集。</li><li>当用户选择某单选按钮时，同一组中的其他单选按钮不能同时被选定。</li><li>当单击RadioButton按钮时，其Checked属性设置为true，并且调用Click事件处理程序。</li><li>当Checked属性的值更改时，将引发Checked- Changed事件。用户可以通过用Text属性设置控件内显示的文本。<br><code>&lt;asp:hyperlink runat=&quot;server&quot;&gt;HyperLink&lt;/asp:hyperlink&gt;</code></li></ul></li><li><p>CheckBox、CheckBoxlist复选框</p><ul><li>该控件通常是成组使用，完成多重选项的目的。</li><li>这个控件与RadionButton控件相比，它们的相似之处在于都是用于指示用户所选的选项，不同之处在于，单选框一次只能选一个按钮，而复选框则可以选择任意数量。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;asp:checkbox runat=&quot;server&quot;&gt;&lt;/asp:checkbox&gt;</span><br><span class="line">&lt;asp:checkboxlist runat=&quot;server&quot;&gt;&lt;/asp:checkboxlist&gt;</span><br></pre></td></tr></table></figure></li><li><p>DropDownList控件</p><ul><li>使用户可以从下拉列表框中进行选择。其选择项列表在用户单击下拉按钮前一直保持隐藏状态，同时它不支持多重选择。<br><code>&lt;asp:dropdownlist runat=&quot;server&quot;&gt;&lt;/asp:dropdownlist&gt;</code></li></ul></li><li><p>ListBox列表框</p><ul><li>列表框通过显示多个选项供用户选择达到与用户对话的目的，如果候选项较多的时候它还可以自动地加上滚动条。</li><li>可通过设置列表框的Items属性来添加列表框的内容。在属性菜单中找到Items选项，鼠标单击右边的按钮，会弹出的ListItem集合编辑器，就可方便添加列表框中的每一项。<br><code>&lt;asp:listbox runat=&quot;server&quot;&gt;&lt;/asp:listbox&gt;</code></li></ul></li><li>FileUpload文件上载控件<ul><li>该控件可实现让用户在客户端选择一个文件,然后放到Web服务器的某个指定的文件夹下。<br><code>&lt;asp:fileupload runat=&quot;server&quot;&gt;&lt;/asp:fileupload&gt;</code></li></ul></li><li><p>Panel和Placeholder控件</p><ul><li>Panel和Placeholder控件都属于容器控件。容器控件是指该控件可以动态容纳其他控件或HTML元素。利用容器控件即可实现运行时刻动态添加内容到Web页中。</li><li>Panel和Placeholder控件（占位控件）转换成客户端HTML代码后，呈现为div元素。</li><li>Placeholder控件可将空的容器控件放置到页内，然后在运行时动态添加、删除子元素等。该控件只呈现其子元素，不呈现容器外观。</li><li>Panel控件在设计页面时就可添加其他控件，而且在运行过程中也允许动态添加控件。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;asp:panel runat=&quot;server&quot;&gt;&lt;/asp:panel&gt;</span><br><span class="line">&lt;asp:placeholder runat=&quot;server&quot;&gt;&lt;/asp:placeholder&gt;</span><br></pre></td></tr></table></figure></li><li><p>服务器端验证控件</p><ul><li>当用户输入不合法或输入错误时，验证控件可以显示错误信息。验证控件在正常工作情况下是不可见的，只有当用户输入数据有误时，它们才是可见的。</li></ul></li><li>数据访问空间<ul><li>数据源控件：实现对不同数据源的数据访问，主要包括连接数据源，使用SQL语句获取数据。</li><li>数据绑定控件：将数据源控件与数据绑定控件结合起来，以多种方式将数据显示在页面上。<br><img src="/web/data1.png" width="80%"><br><img src="/web/data2.png" width="80%"></li></ul></li></ol><h5 id="服务端控件使用注意事项"><a href="#服务端控件使用注意事项" class="headerlink" title="服务端控件使用注意事项"></a>服务端控件使用注意事项</h5><ul><li>使用控件进行Web开发的初学者很容易产生对服务器控件的依赖，几乎所有页面都采用服务器控件，HTML控件（客户端控件）被束之高阁，当然这是一种简便的编程方法，但却是一种不考虑运行效率的做法。</li><li>服务器控件意味着要消耗更多的网络带宽和服务器资源，而客户端控件的处理逻辑全部在浏览器中进行。因此不能养成使用服务器控件的习惯性思维，在使用控件的时候有必要思考一下采用客户端控件的可能性。</li></ul><h3 id="6-3-ASP-NET内置服务器对象"><a href="#6-3-ASP-NET内置服务器对象" class="headerlink" title="6.3 ASP.NET内置服务器对象"></a>6.3 ASP.NET内置服务器对象</h3><h5 id="常用内置服务器对象"><a href="#常用内置服务器对象" class="headerlink" title="常用内置服务器对象"></a>常用内置服务器对象</h5><ol><li>Page：指代Web窗体，设置或执行与Web窗体有关的属性、方法和事件</li><li>Response(Page的子对象)：决定服务器在什么时候或如何输出数据到客户端</li><li>Request(Page的子对象)：用来捕获由客户端返回到服务器的数据</li><li>Server(Page的子对象)：获取Web服务器对象的各项参数</li><li>Application(Page的子对象)：处理由不同客户端共享的变量</li><li>Session(Page的子对象)：处理由各个客户端专用的共享变量</li><li>Cookies：为Web应用程序保存访问者的信息</li></ol><h3 id="6-4-Web-config与Global-asax"><a href="#6-4-Web-config与Global-asax" class="headerlink" title="6.4 Web.config与Global.asax"></a>6.4 Web.config与Global.asax</h3><h5 id="Web-config-配置文件的使用"><a href="#Web-config-配置文件的使用" class="headerlink" title="Web.config 配置文件的使用"></a>Web.config 配置文件的使用</h5><ul><li>在VS中创建ASP.NET应用程序时会自动生成一个基于XML格式的web.config纯文本文件，可用来放置系统的相关配置信息。</li><li>Web.config可存在于应用程序的各个目录下，它决定了站点所在目录及其子目录的配置信息，并且子目录下的配置信息覆盖其父目录的配置。一般对～/web.config配置即可<h5 id="Global-asax文件的使用"><a href="#Global-asax文件的使用" class="headerlink" title="Global.asax文件的使用"></a>Global.asax文件的使用</h5></li><li>可对Global.asax文件的相关事件进行编程，<strong>实现网站访客数量统计</strong>等。</li></ul><h3 id="6-5-ADO-NET数据库访问技术"><a href="#6-5-ADO-NET数据库访问技术" class="headerlink" title="6.5 ADO.NET数据库访问技术"></a>6.5 ADO.NET数据库访问技术</h3><h5 id="关于ADO-NET"><a href="#关于ADO-NET" class="headerlink" title="关于ADO.NET"></a>关于ADO.NET</h5><ul><li>ADO.NET是.NET平台下的数据库访问技术，提供了断开式的数据访问模型；提供了与XML的紧密集成；提供了与.NET框架的无缝连接。</li><li>ADO.NET中有两个核心组成部分：数据提供程序Data Provider、数据集DataSet</li><li>DataSet是ADO.NET的断开式结构的核心组件，实现独立于任何数据源的数据访问，可用于多种不同的数据源，包括XML数据。它包含一个或多个DataTable对象的集合，这些对象由数据行和数据列以及主键、外键、约束和有关DataTable对象中数据关系组成。</li><li>Data Provider包括4个核心对象<ul><li>Connection：建立与特定数据源的连接</li><li>Command：对数据源执行数据库命令，用于返回和修改数据、运行存储过程等。</li><li>DataReader：从数据源中获取高性能的数据流，例如只进且只读数据流。</li><li>DataAdapter：用数据源填充DataSet，并可处理数据的更新。</li></ul></li><li>ASP.NET数据库应用操作步骤：<br><img src="/web/database.png" width="60%"></li><li>ADO.NET中连接数据库访问常用三种方式：<ul><li>ODBC：可连接各种数据库</li><li>OLEDB：可连接各种数据库</li><li>SQLClient：SQL Server数据库专用连接方式</li></ul></li></ul><h5 id="Connection对象"><a href="#Connection对象" class="headerlink" title="Connection对象"></a>Connection对象</h5><ul><li>建立与数据库的连接</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System.Data;</span><br><span class="line">using System.Data.OleDb;</span><br><span class="line"></span><br><span class="line">//新建一个Connection对象</span><br><span class="line">  OleDbConnection conn = new OleDbConnection();</span><br><span class="line"></span><br><span class="line">  conn.ConnectionString //设置数据库连接的字符串</span><br><span class="line">  conn.ConnectionTimeout //设置数据库连接超时，超过时间连不上数据库则停止连接</span><br><span class="line">  conn.DataSource//获取数据源服务器名或文件名</span><br><span class="line">  conn.State //获取当前数据库连接的状态</span><br><span class="line">  conn.Open  //进行数据库连接</span><br><span class="line">  conn.Close  //断开数据库连接</span><br><span class="line">  conn.Database //返回数据库名称或设置要连接的数据库</span><br><span class="line">  conn.ChangeDatabase//更改当前数据库</span><br><span class="line">  conn.BeginTransaction //开始数据库事务处理</span><br></pre></td></tr></table></figure><h5 id="Command对象"><a href="#Command对象" class="headerlink" title="Command对象"></a>Command对象</h5><ul><li>创建Command对象有四种方法，分别是（P337）：<ol><li>无参数</li><li>使用一个参数</li><li>使用两个参数</li><li>使用Connection对象的CreateCommand方法</li></ol></li></ul><h5 id="DataReader对象"><a href="#DataReader对象" class="headerlink" title="DataReader对象"></a>DataReader对象</h5><ul><li>DataReader对象用来从数据表中检索只读、只进的数据流，占用内存少、访问数据快，不能用它修改数据表记录。–<strong>数据库游标操作</strong></li></ul><h5 id="DataAdapter与Dataset-对象"><a href="#DataAdapter与Dataset-对象" class="headerlink" title="DataAdapter与Dataset 对象"></a>DataAdapter与Dataset 对象</h5><ul><li>DataSet通过DataAdapter填充数据后，可断开数据库的连接来操作其中的数据，而不影响数据库中的实际数据，直到你通过DataAdapter把数据更新到数据库。</li><li>Dataset对象可独立于各种数据源，无论什么类型数据源（数据库、XML文件</li><li>DataSet对象包含DataTable集合对象。通过DataTable又可生成数据视图DataView。</li><li>DataTable不仅是数据行（DataRow）和列（DataColumn）的集合，它包含了表的关系、主键及其约束等信息。</li></ul><h5 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h5><ul><li>Connection对象：只负责数据库连接而不关心结果集的表示。</li><li>Dataset对象：只关心访问操作数据，而不关心数据信息关联哪个Connection对象。</li><li>DataAdapter对象：作为Connection和DataSet对象之间的桥梁。<ul><li>将执行SQL语句后获得的结果集填充到DataSet对象中；将DataSet里增加、修改、更新后的数据返回到数据库中。</li></ul></li></ul><h5 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h5><ul><li>使用Command对象和DataAdapter对象实现不带参数存储过程调用</li><li>使用Command对象实现带参数存储过程调用</li><li>使用DataAdapter对象实现带参数存储过程调用</li></ul><h5 id="执行数据库事务"><a href="#执行数据库事务" class="headerlink" title="执行数据库事务"></a>执行数据库事务</h5><ul><li>数据库事务处理是把一组数据库操作合并为一个逻辑上的工作单元。要么在事务处理中的所有操作都得到执行，要么没有任何操作得到执行。</li></ul><h5 id="数据绑定技术"><a href="#数据绑定技术" class="headerlink" title="数据绑定技术"></a>数据绑定技术</h5><ul><li>数据绑定技术最通常的应用是把Web控件中用于显示的属性跟数据源绑到一起，从而在Web页面上显示数据。此外也可以使用数据绑定技术设置Web控件的其他属性。</li></ul><h3 id="6-6-用Visual-Studio创建和访问Web服务"><a href="#6-6-用Visual-Studio创建和访问Web服务" class="headerlink" title="6.6 用Visual Studio创建和访问Web服务"></a>6.6 用Visual Studio创建和访问Web服务</h3><ul><li>Saas是指软件部署在互联网上，你可免费或购买直接使用，例如我们使用的Gmail Web邮箱、阿里云邮箱、百度云管家就属于Saas的一种。</li><li>另一种Saas的应用就是网上提供的Web服务。Web服务实际上也是一个应用程序，它向外界提供了一个可以通过Web进行调用的API，也就是说可以用编程的方法调用这个程序。</li><li><strong>Web服务是一套标准，它定义了应用程序如何在Web上实现互相操作。</strong>可用任何语言在任何平台上编写Web服务，只要通过Web服务标准对这些服务进行查询和访问就行了（.Net上开发的Web服务，Java平台也可用）。要实现这样的目标，Web服务使用了XML技术和SOAP协议。<ul><li><strong>XML是在Web上传送结构化数据的有效方式</strong>，Web服务要以一种可靠的自动的方式操作数据，XML可以使Web服务方便地处理数据，十分理想地实现数据与表示的分离。</li><li>SOAP协议（Simple Object Access Protocol）是服务需求者向Web服务发送请求并接收应答的协议。<strong>SOAP的数据编码方式是基于XML的</strong>。</li></ul></li></ul><h5 id="Web服务的应用"><a href="#Web服务的应用" class="headerlink" title="Web服务的应用"></a>Web服务的应用</h5><ul><li><strong>实现跨防火墙的应用</strong><ul><li>能突破客户端和Web服务器之间的各种防火墙进行通信，采用传统的分布组件技术如DCOM可能会通信失败。</li></ul></li><li><strong>应用程序集成</strong><ul><li>可通过创建Web Services解决数据的互联互通。B2B大都采用这种方式。</li></ul></li><li><strong>软件和数据重用</strong><ul><li>软件重用最基本的形式是源代码、函数、模块或者类一级的重用，另外就是控件和组件的重用、框架的重用。Web Services不仅可重用代码，还可重用代码背后的数据，例如天气预报数据。</li></ul></li></ul><h3 id="6-7-Web开发中类库的构建与访问"><a href="#6-7-Web开发中类库的构建与访问" class="headerlink" title="6.7 Web开发中类库的构建与访问"></a>6.7 Web开发中类库的构建与访问</h3><ul><li>在Web开发过程中，可将许多通用的完成一定功能的方法或结构等独立出来，放在类库中，编译后形成一个动态链接库DLL文件，在Web应用程序中通过添加引用后，就可实现代码的重用。</li></ul><h2 id="7-AJAX技术"><a href="#7-AJAX技术" class="headerlink" title="7. AJAX技术"></a>7. AJAX技术</h2><h3 id="7-1-Ajax概述及开发案例"><a href="#7-1-Ajax概述及开发案例" class="headerlink" title="7.1 Ajax概述及开发案例"></a>7.1 Ajax概述及开发案例</h3><h5 id="Ajxa概述"><a href="#Ajxa概述" class="headerlink" title="Ajxa概述"></a>Ajxa概述</h5><ul><li>Ajax(Asynchronous Javascript and XML)是Jesse James Garrett于2005年提出的一种技术。</li><li>该技术的目标是让用户动态地与页面进行交互，加快服务器的响应速度，减少用户的等待时间，是一种创建交互式Web应用程序的开发技术。其技术的最简单描述就是实现局部刷新。(<strong>异步执行</strong>)</li><li>Ajax的局部刷新：<ul><li>通过<strong>异步数据交换和处理</strong>，显著提高Web应用程序运行效率。<br>Ajax不是新技术，是各个已有核心技术的创新应用。</li></ul></li><li>Ajax的核心是支持异步请求的XmlHttpRequest对象，使开发者可使用JavaScript向服务器提出异步请求并处理响应。</li><li>实现Ajax技术的应用开发主要有：<ul><li>直接基于XMLHttpRequest对象</li><li>利用各种Ajax框架，简化Ajax开发</li></ul></li></ul><h5 id="XmlHttpRequest对象的属性和方法"><a href="#XmlHttpRequest对象的属性和方法" class="headerlink" title="XmlHttpRequest对象的属性和方法"></a>XmlHttpRequest对象的属性和方法</h5><p><img src="/web/attributes.png" width="60%"><br><img src="/web/method.png" width="60%"></p><h3 id="基于Ajax的Web窗体"><a href="#基于Ajax的Web窗体" class="headerlink" title="基于Ajax的Web窗体"></a>基于Ajax的Web窗体</h3><ul><li>ASP.NET Ajax扩展中，Timer定时器用于定时异步刷新页面，例如定期刷新股票价格或天气情况。<br>UpdateProgress 控件提供一条等待信息让用户知道页面还在工作，最后的请求还在继续处理中，可用来显示“正在处理中，请稍后！”<ul><li>一个页面可包括多个UpdatePanel控件。Ajax技术可用来生成功能丰富、以客户端为中心的Web应用程序，使用户获得更好的用户体验（user experience）。</li><li>传统网站开始转型为单页Web应用（single page web application，SPA），如Gmail、Evernote等，可使用户无需网站地图、免除跳转网页的烦恼，使用户获得流畅的使用体验，这是Web应用程序的开发的一个方向，Ajax扮演重要角色。</li></ul></li></ul><h2 id="8-Web开发环境的建立"><a href="#8-Web开发环境的建立" class="headerlink" title="8. Web开发环境的建立"></a>8. Web开发环境的建立</h2><h3 id="8-1-关于Web站点规划"><a href="#8-1-关于Web站点规划" class="headerlink" title="8.1 关于Web站点规划"></a>8.1 关于Web站点规划</h3><h5 id="Web站点规划所包含的内容"><a href="#Web站点规划所包含的内容" class="headerlink" title="Web站点规划所包含的内容"></a>Web站点规划所包含的内容</h5><ol><li><strong>在Web站点建设前对市场进行分析</strong><ul><li>市场有什么特点？</li><li>是否适合在互联网上开展此业务？</li><li>市场竞争对手情况如何？</li><li>市场优势在哪儿？</li><li>有什么市场竞争力？</li></ul></li><li><strong>确定Web站点的目的和功能</strong><ul><li>要明确Web站点的建设目的是什么？</li><li>Web站点的功能有哪些？</li></ul></li><li><strong>根据Web站点规模确定Web站点建设的技术</strong><ul><li>用什么开发平台？</li><li>用什么开发技术？</li><li>安全性有什么要求？</li></ul></li><li><strong>确定Web站点建设的人力和投入费用</strong><ul><li>需要投入的人力和成本情况如何？</li><li>将来收益情况如何？</li></ul></li><li><strong>确定Web站点的测试方法和维护过程</strong><ul><li>Web站点建好后，要进行哪些测试？</li><li>如何测试？</li><li>站点维护有什么要求？</li></ul></li><li><strong>确定Web站点的推广策略</strong><ul><li>规划Web站点的推广策略？</li><li>广告推广、邮件推广、百度推广、论坛推广？</li></ul></li></ol><h5 id="Web站点的目录结构"><a href="#Web站点的目录结构" class="headerlink" title="Web站点的目录结构"></a>Web站点的目录结构</h5><ul><li>站点目录结构会对站点维护、站点扩充和站点移植带来影响，      Web站点目录结构的建立可遵循以下建议：<ul><li><strong>不要将网站内容全部放在一个目录中</strong>，按菜单栏目内容建立子目录。将网站内容全部放在一个目录中会造成文件管理混乱 <strong>不易于文件查找和维护</strong>。</li><li><strong>目录的层次不要太深</strong>，不超过3层，<strong>尽量用英文命名目录和文件名</strong>。目录路径过深，跳转的URL地址就会变长，增加了页面的链接复杂性。而使用中文命名会可能对网址的正确显示造成困难，尽量使用英文意义明确的目录名和文件名，便于维护和管理。</li></ul></li></ul><h5 id="设计Web站点的一般性原则"><a href="#设计Web站点的一般性原则" class="headerlink" title="设计Web站点的一般性原则"></a>设计Web站点的一般性原则</h5><ol><li><strong>以客户为中心进行Web站点设计</strong><ul><li>建设Web站点的目的是什么？</li><li>为谁提供服务和产品?</li><li>企业能提供什么样的产品和服务？</li><li>Web站点的目标消费者和受众的特点是什么？</li><li>企业产品和服务适合什么样的表现方式或风格？</li></ul></li><li><strong>总体设计方案主题鲜明</strong><ul><li>对Web站点的整体风格和特色做出定位，对Web站点的组织结构进行规划。</li><li>好的Web站点应主题鲜明、要点明确，要充分展现Web站点的个性和情趣，体现Web站点的特色。</li></ul></li><li><strong>网页形式与内容统一</strong><ul><li>运用对比与调和、对称与平衡、节奏与韵律以及留白等手。</li><li>利用空间、文字、图形之间的相互关系来达到整体的均衡以及和谐的美感。</li></ul></li><li><strong>Web站点的结构</strong><ul><li>应遵循结构清晰、导向清楚、使用方便的原则。</li><li>使用一些醒目的标题或文字来突出产品与服务，在导航设计中使用超文本链接或图片链接，且页面之间的链接关系要一目了然。</li></ul></li><li><strong>访问速度</strong><ul><li>通过网页减肥、Ajax技术等来加快访问速度，避免使用过多的图片及尺寸过大的图片</li></ul></li><li><strong>充分利用多媒体技术</strong><ul><li>为了吸引浏览者的注意力，页面内容可采用动画、Flash等形式来表现。</li></ul></li><li><strong>Web站点信息的动态发布</strong><ul><li>站点信息的不断更新，会让浏览者了解企业的最新发展动态和网上服务等，同时也会帮助企业建立良好的形象。</li><li>应在后台建立信息的动态发布机制及时更新企业站点内容。</li></ul></li><li><strong>提供和用户相互沟通的渠道</strong><ul><li>应建立和用户的沟通渠道，例如建立留言板和在线E-mail系统、短消息等</li></ul></li></ol><h3 id="8-2-建设Web站点的一般步骤"><a href="#8-2-建设Web站点的一般步骤" class="headerlink" title="8.2 建设Web站点的一般步骤"></a>8.2 建设Web站点的一般步骤</h3><ol><li><strong>Web站点的准备</strong><ul><li>进行可行性分析，规划出Web站点的大致结构。</li><li>考虑采用哪一种操作系统、Web服务器、邮件服务器、数据库服务器。进行数据库的初步规划，考虑开发和维护Web站点的费用预算。</li></ul></li><li><strong>域名注册</strong><ul><li>域名注册实际上就是申请Web站点的一个名称，以方便人们访问Web站点。</li><li>域名具有唯一性，是“企业的网上商标”。域名中.cn表示中国，.hk表示香港；.edu表示教育机构；.gov表示政府部门；.net表示网络服务部门；.ac表示科研机构。</li></ul></li><li><strong>Web站点的需求分析和总体设计</strong><ul><li>需求分析是网站设计的重要环节。在需求分析的基础上进行总体设计和数据库设计。</li><li>在此过程中确定站点建设所需要的软件和硬件配置、连接因特网的方式、运行和维护费用等。</li></ul></li><li><strong>确定Web站点的组织与风格</strong><ul><li>在上述工作基础上，确定Web站点的主页版面，色彩搭配等，勾画出整个Web站点系统的所有全貌，包括每个页面的版式布局、链接关系、注意事项等。</li><li>一个网页应包含Web站点名称、Web站点logo、网页标题、网页内容、指向主页的链接、指向其他网页的链接、版权陈述、Web站点的E-mail地址和其他联系方法等基本要素。</li></ul></li><li><strong>Web站点开发和运行环境的确定</strong><ul><li>Web站点运行在什么操作系统上？</li><li>采用什么数据库?采用什么样的Web服务器？采用什么开发平台和开发工具？</li></ul></li><li><strong>Web站点的开发和测试</strong><ul><li>Web站点的开发涉及到项目负责人、设计人员、程序员、网页制作人员和美工等，要实现协同开发。各个网页整合成网站后，要进行功能测试、性能测试、安全测试、稳定测试、浏览器兼容性测试、链接测试、压力测试等。</li></ul></li><li><strong>将Web站点接入Internet，并做好网站推广</strong><ul><li>可选择虚拟服务器/主机、服务器租用或托管、铺设专线来接通Internet。</li><li>通过各种有效的手段提高Web站点知名度，提升Web站点访问量。</li></ul></li><li><strong>Web站点的运行安全和维护管理</strong><ul><li>Web站点安全性包括身份窃取、非授权存取、否认、拒绝服务等。及时修复站点服务器操作系统漏洞，精心配置Web服务器、数据库服务器的各项参数。</li><li>Web站点维护包括服务器的维护、站点程序的维护、内容的更新和信息的发布等。</li></ul></li></ol><h3 id="8-3-Web站点性能优化及安全性"><a href="#8-3-Web站点性能优化及安全性" class="headerlink" title="8.3  Web站点性能优化及安全性"></a>8.3  Web站点性能优化及安全性</h3><h5 id="Web站点性能优化"><a href="#Web站点性能优化" class="headerlink" title="Web站点性能优化"></a>Web站点性能优化</h5><ul><li><strong>优化Web服务器硬、软件配置</strong>:<ul><li>为Web服务器增加缓冲代理机制和使用高性能服务器能明显改进Web站点访问速度，包括快速的磁盘、高性能网卡，强劲的CPU、大容量内存等；可通过对数据库服务器和Web服务器的配置在缓冲、压缩、带宽限制、进程限制等方面提高Web站点的性能。</li></ul></li><li><strong>改善Web应用程序的性能</strong>:<ol><li><strong>帮页面减肥</strong>：网页文件字节数越小，下载到浏览器的速度就快。因此将网页中的空格、注解及无用字符清除掉、调整JPEG图片文件大小等均可加快下载速度。有专门的网页减肥器软件可帮助减少网页的大小。</li><li><strong>尽量使用静态HTML页面，减少对Web服务器资源的占用</strong>：不要在Session中存放大的数据对象，当不需要Session时，应尽快将它从服务器内存中释放；由于Application对象一直会占用服务器资源，应少用或及时清理无用的Application对象。</li><li><strong>数据库方面的优化</strong>：数据库连接成功使用后，应及时关闭连接；使用存储过程加快数据处理；优化数据库查询语句以减少执行时间（比如不在查询语句中包含子查询语句、充分利用索引等）。</li><li><strong>其他</strong>：在编写Web应用程序时，采用一些技术手段可提高应用程序的性能。</li></ol></li></ul><h5 id="Web站点的安全性"><a href="#Web站点的安全性" class="headerlink" title="Web站点的安全性"></a>Web站点的安全性</h5><ul><li><strong>Web服务器的安全</strong><ul><li>采用NTFS分区；尽可能安装操作系统的最新服务包和修补程序；增强口令的安全性；停掉或卸载不必要的进程或服务。</li><li>设置Web内容目录的访问权限，授予匿名用户对所提供内容的适当只读访问权限。根据需要设置文件夹的读写访问权限。</li><li>安装防病毒软件和防木马软件等，启用计算机防火墙功能。仅留必要的端口号。</li><li>重要敏感信息通过设置虚拟目录来指定Web访问路径。</li><li>通过对Web访问的日志进行审计，可以发现一些对安全方面有帮助的信息。</li><li>配置URLScan过滤非法url，使其只允许应用程序中使用的扩展集</li></ul></li><li><strong>数据库服务器的安全</strong><ul><li>如应用程序不使用“命名管道”协议，则删除之。</li><li>限制数据库用户只具有用得到的数据库操作权限。</li><li>xp_cmdshell是扩展存储过程，可以执行操作系统级命令，该存储过程的功能通过SQL Server安装目录中的文件MSSQL\Binn\xplog70.dll获得，系统没用到xp_cmdshell则文件换名或删除掉。</li></ul></li><li><strong>Web站点应用程序的安全</strong><ul><li>采用登录名、密码、验证码进行登录，防止注入式攻击。验证码可防止以程序自动方式遍历登录账户和密码。将一串随机产生的数字或符号，生成一幅图片，图片里加上一些干扰像素，由用户肉眼识别其中的验证码信息，输入表单后提交网站进行登录验证。</li><li>在用户登录输入密码的时候，为防止木马程序非法录制按键操作，利用自定义软键盘让用户只能通过单击鼠标输入密码。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Web开发技术概述&quot;&gt;&lt;a href=&quot;#1-Web开发技术概述&quot; class=&quot;headerlink&quot; title=&quot;1. Web开发技术概述&quot;&gt;&lt;/a&gt;1. Web开发技术概述&lt;/h2&gt;&lt;h3 id=&quot;1-1-Web技术基础知识&quot;&gt;&lt;a href=&quot;#1-1-Web技术基础知识&quot; class=&quot;headerlink&quot; title=&quot;1.1 Web技术基础知识&quot;&gt;&lt;/a&gt;1.1 Web技术基础知识&lt;/h3&gt;&lt;h5 id=&quot;Web&quot;&gt;&lt;a href=&quot;#Web&quot; class=&quot;headerlink&quot; title=&quot;Web&quot;&gt;&lt;/a&gt;Web&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;全称World Wide Web，缩写WWW，译为“万维网”,简称为Web&lt;/li&gt;
&lt;li&gt;是一个可通过互联网来访问的、由许多互相链接的超文本组成的系统&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="前端" scheme="https://daisine.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="note" scheme="https://daisine.github.io/tags/note/"/>
    
      <category term="Web" scheme="https://daisine.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS X下连接校园网VPN [L2TP方式]</title>
    <link href="https://daisine.github.io/macvpn/"/>
    <id>https://daisine.github.io/macvpn/</id>
    <published>2018-09-20T00:32:10.000Z</published>
    <updated>2019-05-10T10:56:18.451Z</updated>
    
    <content type="html"><![CDATA[<p>以重庆大学校园网VPN为例，操作系统OS X 10.11.6。</p><ul><li>首先查看<a href="http://net.cqu.edu.cn/info/1025/1255.htm" target="_blank" rel="noopener">重庆大学校园网VPN说明</a>：</li></ul><blockquote><p>重庆大学VPN支持<strong>标准的PPTP和L2TP两种方式</strong>。用户在网络连接的设置中，新增虚拟专网VPN连接。VPN的地址请填写域名vpn.cqu.edu.cn，系统会自动解析相应地址。</p></blockquote> <a id="more"></a> <ul><li>打开<code>系统偏好设置</code> - &gt; <code>网络</code> - &gt; <code>右下角＋号</code>新建VPN服务<ul><li>接口：VPN</li><li>VPN类型：IPSec上的L2TP</li><li>服务名称：CQU VPN</li></ul></li><li>新建VPN完成后，<code>服务器地址</code>填写为<code>vpn.cqu.edu.cn</code>，账户名称为学号。</li><li><p>现在点击<code>链接</code>，输入密码(默认为身份证后六位)会提示，IPSec 共享密钥丢失。需要在终端进行进一步设置：</p><ul><li>在/etc/ppp/下创建options文件：<br><code>sudo vim /etc/ppp/options</code></li><li>在options文件中输入(键入A - &gt; INSERT)并保存(ESC - &gt; wq)</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugin L2TP.ppp</span><br><span class="line">l2tpnoipsec</span><br></pre></td></tr></table></figure></li><li><p>回到VPN设置，选择<code>高级</code>- &gt; <code>选项</code> - &gt; <code>通过VPN连接发送所有流量</code></p></li><li>再次点击连接VPN，连接成功。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以重庆大学校园网VPN为例，操作系统OS X 10.11.6。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先查看&lt;a href=&quot;http://net.cqu.edu.cn/info/1025/1255.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;重庆大学校园网VPN说明&lt;/a&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;重庆大学VPN支持&lt;strong&gt;标准的PPTP和L2TP两种方式&lt;/strong&gt;。用户在网络连接的设置中，新增虚拟专网VPN连接。VPN的地址请填写域名vpn.cqu.edu.cn，系统会自动解析相应地址。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Mac OS X" scheme="https://daisine.github.io/categories/Mac-OS-X/"/>
    
    
  </entry>
  
</feed>
