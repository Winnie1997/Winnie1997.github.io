<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hi, Dai</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://daisine.me/"/>
  <updated>2019-05-10T03:59:12.977Z</updated>
  <id>http://daisine.me/</id>
  
  <author>
    <name>Dai Sine</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件测试笔记</title>
    <link href="http://daisine.me/sftest/"/>
    <id>http://daisine.me/sftest/</id>
    <published>2019-05-10T03:57:44.000Z</published>
    <updated>2019-05-10T03:59:12.977Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-软件测试概述"><a href="#1-软件测试概述" class="headerlink" title="1 软件测试概述"></a>1 软件测试概述</h4><h5 id="故障、错误-amp-失败"><a href="#故障、错误-amp-失败" class="headerlink" title="故障、错误&amp;失败"></a>故障、错误&amp;失败</h5><ul><li>软件故障(fault)：软件中的一个静态的缺陷。</li><li>软件错误(error)：软件运行中一个不正确的内部状态，这是某个故障的表现。</li><li><p>软件失败(failure)：一个与软件需求或者是预期行为描述不相符的、外在的行为。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CSta</span> <span class="params">(<span class="keyword">int</span> [ ] numbers)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> length = numbers.length; <span class="comment">//(PIE Model - 3: int length = numbers.length-1; )</span></span><br><span class="line">   <span class="keyword">double</span> mean, sum; </span><br><span class="line">   sum = <span class="number">0.0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++)**<span class="comment">//i=0** </span></span><br><span class="line">   &#123;</span><br><span class="line">         sum += numbers [ i ]; </span><br><span class="line">   &#125;</span><br><span class="line">   mean = sum / (<span class="keyword">double</span>) length; </span><br><span class="line">   System.out.println (<span class="string">"mean: "</span> + mean); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>软件错误：Input: [3,4,5]  sum=4+5  ( × )</p></li><li>软件失败：Input: [3,4,5]  sum=4+5 mean=3  ( × )</li></ul><h5 id="PIE模型"><a href="#PIE模型" class="headerlink" title="PIE模型"></a>PIE模型</h5><ul><li>Execution/Reachability 执行/可达性：执行必须通过错误的代码。</li><li>Infection 感染：在执行错误代码的时候必须触发出一个错误的中间状态。</li><li>Propagation 传播：错误的中间状态必须传播到最后输出，使得观测到输出结果与预期结果不一致，即失效。</li></ul><blockquote><ol><li>测试可能无法执行故障的位置。</li><li>一个测试执行到包含错误的代码，不一定会产生错误的中间状态。Test Input: [0,4,5] sum=4+5  mean=3</li><li>产生了错误的中间状态，不一定会失效(failure)。Test Input: [3,5,4] sum=3+5 mean=8/2=4</li></ol></blockquote><p>Q: 是否存在一个fault，任何测试都不会将其测试出来？这样还能称之为fault吗？</p><p>A: 存在这样的fault。</p><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><ul><li>测试用例(test case)：所有测试用例的基类，它是软件测试中最基本的组成单元。<ul><li>测试输入：测试数据</li><li>测试预期输出(test oracle)：软件中给定输入的预期输出</li><li>其他：环境</li></ul></li><li>测试预言(test oracle)：软件中给定输入的预期输出，测试用例的一部分。自动测试中最难的问题：测试预言的生成。</li><li>测试夹具(test fixture)：一个固定/已知的环境状态以确保测试可重复并且按照预期方式运行</li><li>测试套件(test suite)：一组测试用例。通常这些测试用例具有相似的先决条件和配置，可以按顺序一起运行。用于不同目的的不同测试套件。</li><li>测试脚本(test script)：自动运行一系列测试用例或测试套件的脚本。</li><li>测试驱动程序(test driver)：可以加载测试用例集或测试套件的软件框架，还可以处理预期输出和实际输出之间的配置和比较。</li><li>测试充分性(test adequacy)：用以判断一个软件的一组测试数据的充分性的规则。eg. 语句/分支覆盖率</li><li>Testing vs. Debugging<ul><li>Testing 是通过执行测试和观察失败来发现一个bug。</li><li>Debugging是通过定位、理解和纠正故障( fault)来修复bug。</li></ul></li><li><strong>Verification vs. Validation</strong><ul><li>Verification：确保产品，服务或系统满足客户和其他确定的利益相关者的<strong>需求</strong>。 </li><li>Validation：评估产品，服务或系统是否符合法规、要求、规范或强制条件。 它通常是一个内部过程。</li></ul></li><li><strong>Static Testing vs. Dynamic Testing</strong><ul><li>静态测试：不运行被测程序本身。</li><li>动态测试：运行被测程序。</li></ul></li><li><strong>Black-box Testing vs. White-box Testing</strong><ul><li>黑盒测试：没有源代码。</li><li>白盒测试：有源代码。</li></ul></li><li>V模型：<br><img src="/sftest/vmodel.png" width="50%"></li></ul><h4 id="C2-单元测试"><a href="#C2-单元测试" class="headerlink" title="C2 单元测试"></a>C2 单元测试</h4><ul><li>单元测试：每个模块的测试。</li><li>集成测试：测试模块之间的交互。</li><li>系统测试：开发人员对整个系统进行测试。</li><li>验收测试：根据需求和用户需要来评估软件。没有正式测试用例的客户根据用户要求验证系统。</li></ul><h5 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h5><ul><li>测试软件的基本模块：功能，类，组件</li><li>揭示典型问题<ul><li>本地数据结构</li><li>算法</li><li>边界条件</li><li>错误处理</li></ul></li><li>为什么单元测试？<ul><li>分而治之的方法：将系统拆分为单位，单独调试单元。</li><li>缩小可能存在错误的地方，不想追逐其他单元的错误。</li></ul></li><li>如何单元测试？<ul><li>分层构建系统：从不依赖于其他的类开始，继续测试已经测试的类</li><li>好处：避免编写模拟类。当测试一个模块时，它所依赖的模块是可靠的。</li></ul></li><li>单元测试框架<ul><li>xUnit</li><li>JUnit</li></ul></li></ul><h4 id="C3-白盒测试"><a href="#C3-白盒测试" class="headerlink" title="C3 白盒测试"></a>C3 白盒测试</h4><h5 id="1-测试中的图"><a href="#1-测试中的图" class="headerlink" title="1. 测试中的图"></a>1. 测试中的图</h5><ul><li><strong>图G</strong>定义如下：G =（V，E）<ul><li>V：有限的非空顶点集V = {v<sub>1</sub>，v<sub>2</sub>，v<sub>3</sub>，v<sub>4</sub>}</li><li>E：一组边（顶点对）E = {（v<sub>1</sub>，v<sub>2</sub>），（v<sub>1</sub>，v<sub>3</sub>），（v<sub>2</sub>，v<sub>4</sub>），（v<sub>3</sub>，v<sub>4</sub>）}</li><li>V<sub>0</sub>：一组初始节点，V<sub>0</sub> = {v<sub>1</sub>}</li><li>V<sub>f</sub>：一组最终节点，Vf = {v4}</li><li>V<sub>0</sub>和V<sub>f</sub>是V的子集</li><li>图中允许存在多个初始节点，至少要有一个终止节点(或者多个)。</li></ul></li><li>Q：一个顶点是一个图吗？(Yes) E可以是一个无限的集合吗？(No)</li><li><p><strong>路径(Path)</strong>：一个节点序列[v<sub>1</sub>，v<sub>2</sub>，… ，v<sub>n</sub>]</p><ul><li>每对邻近节点(v<sub>i</sub>, v<sub>i+1</sub>)都是一条边(属于边集合E)</li><li>路径的长度：边的数量</li><li>长度为0的路径：单个节点的路径。</li><li>子路径：路径p的子路径是p的一个子序列(也可能是p自己)</li></ul></li><li><p><strong>测试路径</strong>：从初始节点(V<sub>0</sub>中某个节点)开始到最终节点(V<sub>f</sub>中某个节点)结束的路径。</p><ul><li>每个测试用例都只游历图G中的一条测试路径。</li><li>一条测试路径可以对应多个测试用例。(多对一)</li><li>一些测试路径不会被任何测试用例执行。(不可达：图G中的节点从V<sub>0</sub>中任何节点开始都无法在语法上到达，也无法满足覆盖准则)</li></ul></li><li><p><strong>测试和测试路径</strong></p><ul><li><strong>path( t )</strong>：测试 t 执行的测试路径</li><li><strong>path( T )</strong>：由一组测试执行的<strong>测试路径集 T</strong> </li></ul></li></ul><h5 id="2-图覆盖准则"><a href="#2-图覆盖准则" class="headerlink" title="2. 图覆盖准则"></a>2. 图覆盖准则</h5><ul><li><p>可达：从一个初始节点开始所有节点和边都语法可达的图。</p><ul><li>v<sub>1</sub>可达v<sub>2</sub>：存在一条路径开始于v<sub>1</sub>，终止于v<sub>2</sub>。</li><li><p>v<sub>1</sub>可达图G’：存在一条路径开始于v<sub>1</sub>，终止于图G中的某个节点。</p></li><li><p><strong>语法可达</strong>：图G中语法上存在一条路径。</p></li><li><strong>语义可达</strong>：存在测试用例执行该路径。</li></ul></li><li><p><strong>覆盖</strong>：</p><ul><li>测试路径p<strong>覆盖节点</strong>v：v在p中</li><li>测试路径p<strong>覆盖边</strong>e：e在p中</li><li>测试路径p<strong>覆盖子路径</strong>p’：p’在p中</li></ul></li><li><p><strong>图覆盖</strong></p><ul><li>结构图覆盖</li><li>数据流覆盖</li></ul></li><li><p>测试需求集<strong>( TR )</strong>：描述测试路径的属性</p></li><li><p>图覆盖：给定一个<strong>图覆盖准则C</strong>所包含的<strong>测试需求集TR</strong>，当且仅当对于TR中的<strong>每个测试需求tr</strong>，<strong>测试路径集path( T )</strong>中都至少存在一个测试路径p满足tr的时候，测试用例集T满足图G的覆盖准则C。</p></li></ul><h5 id="3-结构化的覆盖准则"><a href="#3-结构化的覆盖准则" class="headerlink" title="3. 结构化的覆盖准则"></a>3. 结构化的覆盖准则</h5><ul><li><p><strong>节点覆盖(VC)</strong></p><ul><li>当且仅当对于 V 中每个语法可达的节点 v，测试用例集T满足path( T )存在路径p使得p覆盖v。即测试用例集T在图G上满足节点覆盖。</li><li>TR包含G中的每个可达的节点。</li></ul></li><li><p><strong>边覆盖(EC)</strong></p></li><li><p>当且仅当对于 E 中的每个语法可达边e，测试用例集T满足path( T )中存在路径p使得p覆盖e。即测试用例集T在图G上满足边覆盖。</p></li><li><p>TR包含G中的每个可达的边。<br><img src="/sftest/vcec.png" width="60%"></p></li><li><p><strong>对边覆盖(EPC)</strong>：TR包含G中每个可达的长度小于等于2的路径。</p></li><li><strong>全路径覆盖(CPC)</strong>：TR中包含G中所有的路径。</li><li><p><strong>n-Path Coverage(nPC)</strong>：TR包含每个可达长度小于等于n的路径。</p></li><li><p><strong>包含(Subsume)关系</strong>：</p><ul><li><p>C1包含C2，表示为C1 ≧  C2</p></li><li><p>对任意测试用例集T，假如T满足C1，则T一定满足C2。</p></li><li>C1≧ C2 does not imply that <em>T1</em> satisfying C1 can detect any fault detected by T2 which satisfies C2.</li><li>C1≧ C2不意味着满足C1的T1可以检测到满足C2的T2检测到的故障。<br><img src="/sftest/sce.png" width="80%"></li></ul></li></ul><h5 id="4-控制流图-CFG-及其覆盖"><a href="#4-控制流图-CFG-及其覆盖" class="headerlink" title="4. 控制流图(CFG)及其覆盖"></a>4. 控制流图(CFG)及其覆盖</h5><ul><li><p>控制流图(CFG)</p><ul><li>使用图表符号表示<strong>在执行期间可能遍历程序的所有路径</strong>的表示。</li><li>边与每条可能的分支对应，节点与一系列的语句对应。</li></ul></li><li><p>基本块</p><ul><li>一段最长的可以被同时执行的程序语句序列。如果这个基本块中的一条语句被执行，那么这个块中所有语句都要被执行。</li><li>一个基本块只有一个起始点和一个终点。<br><img src="/sftest/if.png" width="40%"><img src="/sftest/ifreturn.png" width="36%"><img src="/sftest/while.png" width="40%"><img src="/sftest/do.png" width="36%"><img src="/sftest/for.png" width="45%"><img src="/sftest/switch.png" width="45%"><img src="/sftest/bc.png" width="45%"><img src="/sftest/cfg.png" width="80%"></li></ul></li><li><p>语句覆盖率：SCov = 4 / 5 = 80%</p></li><li>分支覆盖率：BCov = 2 / 4 = 50%</li><li>路径覆盖率：PCov = 1 / 4 = 25%</li></ul><p><img src="/sftest/scov.png" width="21%"><img src="/sftest/bcov.png" width="22%"><img src="/sftest/pcov.png" width="49%"></p><ul><li>如果测试套件达到100%分支覆盖率，则一定达到100%语句覆盖率。</li><li><p>如果测试套件达到100%路径覆盖率，则一定达到100%分支覆盖率。反之未必。</p></li><li><p>路径覆盖 -&gt; 分支覆盖 -&gt; 语句覆盖  (路径覆盖严格包含分支覆盖，分支覆盖严格包含语句覆盖) </p><ul><li>路径覆盖：被测试程序中的每一个语句至少被执行一次。<strong>实际运用中语句覆盖很难发现代码中的问题。</strong></li><li>分支覆盖：被测试程序中的每一个分支都至少执行一次。</li><li>语句覆盖：覆盖程序中所有可能的执行路径。</li></ul></li><li><p>基于CFG的覆盖</p><ul><li><p><strong>有效性：</strong>大约65％的错误可以在单元测试中捕获，单元测试由控制流测试方法主导，语句和分支测试在控制流测试中占主导地位。</p></li><li><p><strong>局限性：</strong>某些方面的100％覆盖率不能保证软件没有错误。</p></li><li><p>Test: assertEquals(1, sum(1,0))</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; </span><br><span class="line"><span class="keyword">return</span> x-y; <span class="comment">//should be x+y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="5-主路径覆盖-Prime-Path-Coverage-PPC"><a href="#5-主路径覆盖-Prime-Path-Coverage-PPC" class="headerlink" title="5. 主路径覆盖(Prime Path Coverage, PPC)"></a>5. 主路径覆盖(Prime Path Coverage, PPC)</h5><ul><li>简单路径<ul><li>从n<sub>i</sub>到n<sub>j</sub>的路径，当且仅当在这条路径中没有任何节点出现超过一次(除了初始节点和终止节点相同的情况)</li><li>简单路径可以是一个自环，但它没有内在的循环。<br><img src="/sftest/简单路径.png" width="55%"><img src="/sftest/主路径.png" width="40%"></li></ul></li><li>主路径：<ul><li>一条简单路径，且它不是任何其他简单路径的子路径。</li><li>最大长度的简单路径。</li></ul></li><li>往返路径：长度非0且初始节点和终止节点相同的主路径。</li><li><strong>主路径覆盖(PPC)</strong><ul><li>TR包含G中每条主路径。</li></ul></li><li><strong>简单往返路径(SRTC)</strong><ul><li>对于G中所有可达的，且可以作为往返路径起点和终点的节点，TR包含至少一条往返路径。</li></ul></li><li><p><strong>完全往返路径(CRTC)</strong></p><ul><li>对于G中所有可达的节点，TR包含所有的往返路径。<br><img src="/sftest/PPC.png" width="54%"></li></ul></li><li><p>主路径覆盖练习：<br><img src="/sftest/主路径覆盖.png" width="54%"></p></li></ul><h5 id="6-基本路径覆盖"><a href="#6-基本路径覆盖" class="headerlink" title="6. 基本路径覆盖"></a>6. 基本路径覆盖</h5><ul><li>独立路径：一条独立路径是指和其他的独立路径相比，至少引入一个新处理语句或一个新判断的程序通路。</li><li><strong>圈复杂度(Cyclomatic Complexity, CC)</strong>：<ul><li>一种为程序逻辑复杂性提供定量测度的软件度量，将该度量用于计算程序的基本的独立路径数目，为确保所有语句至少执行一次的测试数量的上界。</li><li>独立路径必须包含一条在定义之前不曾用到的边。</li><li>计算方法：<strong>CC =  E - V + 2  =  P + 1</strong>，E是边数量，V是节点的数量；P是<strong>判定结点</strong>的数量。</li></ul></li><li><strong>基本路径测试步骤</strong>：<ul><li>生成控制流图</li><li>计算圈复杂度</li><li>选择一组基本路径</li><li>生成基本路径的测试用例</li></ul></li><li>全路径测试 ≥ 基本路径测试 ≥ 分支测试</li></ul><h5 id="7-数据流覆盖"><a href="#7-数据流覆盖" class="headerlink" title="7. 数据流覆盖"></a>7. 数据流覆盖</h5><ul><li><strong>定义(def)</strong>：当一个变量的值被存储于内存时变量所处的位置。(写)</li><li><strong>使用(use)</strong>：当获取一个变量的值时变量所处的位置。(读)</li><li><p>数据流测试准则依据：数据值由定义转向使用。这种转移成为<strong>定义使用对/定义-使用/定义使用关联</strong>。<br><img src="/sftest/defuse.png" width="54%"></p></li><li><p><strong>定义使用对(DU Pair)</strong>：(l <sub>i</sub>,  l<sub>j</sub>) ，变量v在l <sub>i</sub>处定义，并在l <sub>j</sub>处使用。</p></li><li><strong>def(n) def(e)  / use(n) use(e)</strong><ul><li>由<strong>节点n</strong>或边e<strong>定义</strong>的变量集</li><li>由<strong>节点n</strong>或边e<strong>使用</strong>的变量集</li></ul></li><li><strong>无重复定义(Def-clear)</strong><ul><li>存在一条由l <sub>i</sub>到l <sub>j</sub>的路径，对于这条路径上的每个节点n<sub>k</sub>和每条边e<sub>k</sub>，k≠i 且 k≠j，变量v不属于def(n<sub>k</sub>)和def(e<sub>k</sub>)，那么这条路径对于变量v是无重复定义的。</li><li>如果变量v存在一条由l <sub>i</sub>到l <sub>j</sub>的无重复定义的路径，我们说处于l<sub>i</sub>的定义到达处于l<sub>j</sub>的使用。</li></ul></li><li><strong>定义使用路径(du-path)</strong><ul><li>定义使用路径是一条简单路径，并且对于变量v这是一条由节点n<sub>i</sub>到另一个节点n<sub>j</sub>的无重复定义路径，v在n<sub>i</sub>中存在于def(n<sub>i</sub>)而在n<sub>j</sub>中存在于use(n<sub>j</sub>)</li><li><em>du</em> (<em>n<sub>i</sub></em>, <em>n<sub>j</sub></em>, <em>v</em>)：变量v的定义使用路径集合，起始于n<sub>i</sub>，终止于n<sub>j</sub>。</li><li><em>du</em> (<em>n<sub>i</sub></em>, <em>v</em>)：对于变量v，定义路径集合是起始于n<sub>i</sub>的定义使用路径的集合。</li></ul></li><li><p><strong>全定义覆盖(ADC)</strong></p><ul><li>对于每个<strong>定义路径</strong>集合<em>S</em> = <em>du</em> (<em>n<sub>i</sub></em>, <em>v</em>)，TR包含S中至少一条路径d。</li></ul></li><li><p><strong>全使用覆盖(AUC)</strong></p><ul><li>对于每个<strong>定义对</strong>集合<em>S</em> = <em>du</em> (<em>n<sub>i</sub></em>, <em>n<sub>j</sub></em>, <em>v</em>)，TR包含S中至少一条路径d。</li></ul></li><li><p><strong>全定义使用路径覆盖(ADUPC)</strong></p><ul><li>对于每个<strong>定义对</strong>集合<em>S</em> = <em>du</em> (<em>n<sub>i</sub></em>, <em>n<sub>j</sub></em>, <em>v</em>)，TR包含S中每一条路径d。<br><img src="/sftest/dutest.png" width="54%"></li></ul></li><li><p>图覆盖准则之间的包含关系<br><img src="/sftest/包含关系.png" width="34%"></p></li></ul><h5 id="8-事件流覆盖"><a href="#8-事件流覆盖" class="headerlink" title="8. 事件流覆盖"></a>8. 事件流覆盖</h5><ul><li><strong>事件流图(EFG)</strong>是一个三元组M = &lt;V, I, E&gt;：<ul><li>V是一组表示对象所有事件的顶点。</li><li>I ⊆ V是一组初始顶点。</li><li>E ⊆ V × V是顶点之间的一组边，当v<sub>j</sub>可以在v<sub>i</sub>之后立即执行，(v<sub>i</sub>, v<sub>j</sub>) ∈ E。</li></ul></li></ul><p><img src="/sftest/event1.png" width="40%"><img src="/sftest/event2.png" width="40%"></p><p>#####9. 变异测试</p><ul><li>变异测试<ul><li>将错误插入程序以测试测试用例是否接收它们的方法。</li><li>是一种对测试集的充分性进行评估的技术。</li></ul></li><li>操作数变异操作符：将单个操作数替换为另一个操作数或常量。</li><li>表达变异操作符：更换一个操作符或者插入一个新的操作符。</li><li><strong>等价变异体</strong><ul><li>存在没有被杀死的变异体，被称为等价变异体</li><li>虽然变异体语法不同，但通过测试难以发现，需要手动检查。</li></ul></li><li><strong><em>Mutation Score = 100 \</em> K / (T - E)*</strong><ul><li>K：被杀死的变异体数</li><li>T：变异体总数</li><li>E：等价的变异体数</li></ul></li><li><p>主管程序员假设</p><ul><li>被测模块由合格的程序员或设计师编写。 因此，如果模块不正确，则它与正确的模块不同，最多只有几个小故障。</li></ul></li><li><p>耦合效应</p><ul><li>由于仅通过简单故障将所有模块与正确模块区分开来的测试套件非常敏感，它还可以隐式区分更复杂的故障。</li></ul></li></ul><p>#####10. 逻辑覆盖</p><ul><li><strong>语句覆盖(SC)</strong></li><li><strong>判定覆盖(DC)</strong><ul><li>判定的true和false至少各执行一次。</li><li>((x&gt;5) &amp;&amp; (y&gt;0)): <em>true</em> and <em>false</em></li></ul></li><li><strong>条件覆盖(CC)</strong><ul><li>每个条件的true和false至少各被执行一次。</li><li>(x&gt;5) 􏰄 <em>true</em> and <em>false</em></li><li>(y&gt;0) 􏰄<em>true</em> and <em>false</em></li></ul></li><li><strong>条件判定覆盖(C/DC)</strong><ul><li>同时满足DC和CC.</li><li>使得判定中的每个条件取到各种可能的值，并使每个判定取到各种可能的结果。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;(6, 1), (1,1)&#125;--DC</span></span><br><span class="line"><span class="comment">// &#123;(6, 0), (0,1)&#125;--CC </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> z = y;</span><br><span class="line"><span class="keyword">if</span> ((x&gt;<span class="number">5</span>) &amp;&amp; (y&gt;<span class="number">0</span>)) &#123;</span><br><span class="line">z = x; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> x*z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SC&amp;DC&amp;CC的包含关系<ul><li>DC ≥ SC</li><li>CC not ≥ SC</li><li>DC not ≥ CC􏰂 CC not ≥ DC</li><li>C/DC ≥ CC </li><li>C/DC ≥ DC</li></ul></li><li><p>MC/DC ≥ C/DC</p></li><li><p><strong>多条件覆盖(MCC)</strong></p><ul><li>使得每个判定中条件的各种可能组合都至少出现一次。<br><img src="/sftest/MCC.png" width="30%"></li></ul></li><li><p><strong>修正条件判定覆盖(MCDC)</strong></p><ul><li>每个条件都要独立影响判定结果(true和false各一次)<br><img src="/sftest/MCDC.png" width="30%"></li></ul></li><li><p>计数</p><ul><li>DC——2</li><li>CC——2*n</li><li>MC/DC——2*n+1</li><li>MCC——2<sup>n</sup></li></ul></li></ul><h4 id="C4-自动化软件测试"><a href="#C4-自动化软件测试" class="headerlink" title="C4 自动化软件测试"></a>C4 自动化软件测试</h4><ul><li>自动化测试<strong>生成</strong><ul><li>测试用例生成</li><li>测试数据生成</li></ul></li><li>自动化测试<strong>执行</strong></li><li>自动化测试<strong>选择</strong><ul><li>针对修改部分的测试</li><li>针对测试需求的用例集约简</li><li>针对测试需求的用例排序</li></ul></li><li>自动化测试修复<ul><li>测试用例修复</li><li>测试用例演化</li></ul></li><li>自动化测试<strong>扩增</strong></li></ul><h4 id="C5-黑盒测试"><a href="#C5-黑盒测试" class="headerlink" title="C5 黑盒测试"></a>C5 黑盒测试</h4><h5 id="5-1-随机测试"><a href="#5-1-随机测试" class="headerlink" title="5.1 随机测试"></a>5.1 随机测试</h5><ul><li>随机测试<ul><li>测试用例完全随机生成</li><li>必须知道输入域</li><li>在输入域中选择随机点</li><li>自动化</li></ul></li><li>ART算法</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* T = &#123;&#125;  是以前执行的一组测试用例*/</span></span><br><span class="line">随机生成输入t </span><br><span class="line">用t作为测试用例测试程序          </span><br><span class="line">将t添加到T     </span><br><span class="line"><span class="keyword">while</span>（未达到停止条件）           </span><br><span class="line">   随机生成下一个k候选c1，c2，…，ck    </span><br><span class="line">   <span class="keyword">for</span> 每个候选Ci </span><br><span class="line">      计算与T的最小距离di  </span><br><span class="line">   end <span class="keyword">for</span></span><br><span class="line">  选择一个具有最小距离的候选t</span><br><span class="line">  将t添加到T           </span><br><span class="line">  用T作为测试用例测试程序    </span><br><span class="line">end <span class="keyword">while</span></span><br></pre></td></tr></table></figure><h5 id="5-2-等价划分"><a href="#5-2-等价划分" class="headerlink" title="5.2 等价划分"></a>5.2 等价划分</h5><ul><li>等价划分<ul><li>可以同等地应用于多个级别的测试(• 单元  • 整合  • 系统)</li><li>相对容易应用，无需自动化</li><li>易于调整程序以获得更多或更少的测试</li></ul></li><li>输入域<ul><li>程序的输入域包含该程序的所有可能输入</li><li>对于即使是小型程序，输入域也是如此之大，以至于它可能是无限的</li><li>测试一般是从输入域中选择有限的值集</li><li>输入参数定义输入域的范围</li><li>每个输入参数的域被划分为区域</li><li>从每个区域至少选择一个值</li></ul></li><li><p>分区域</p><ul><li>域D</li><li>D的分区方案p</li><li>分区p定义了一组块b<sub>1</sub>，b<sub>2</sub>，… b<sub>n</sub></li><li>分区必须满足两个属性：<strong>1.块必须两两之间不相交（不重叠）2.所有块共同覆盖域D（完整）</strong></li></ul></li><li><p>两种方法</p><ul><li>基于接口的方法：直接根据各个输入参数开发特性，简单应用，在某些情况下可以部分自动化。</li><li>基于功能的方法：从被测程序的行为角度发展特征，更难开发，需要更多的设计工作，可以带来更好的测试，或者更少的测试。</li></ul></li><li><p>基于接口的方法：</p><ul><li>三角形有三个输入：q1=第一个边的输入与0的关系：大于，等于，小于</li></ul></li><li>基于功能的方法：<ul><li>三角形的类型：q1 =“几何分类”  b1=不等边  b2=等腰<strong>但不等边</strong>三角形  b3=正三角形  b4=无效</li><li>几何分区q1的可能值：b1= (4, 5, 6)，b2 = (3, 3, 4) ， b3 = (3, 3, 3)， b4 = (3, 4, 8)</li></ul></li></ul><h5 id="5-3-边界值分析"><a href="#5-3-边界值分析" class="headerlink" title="5.3 边界值分析"></a>5.3 边界值分析</h5><ul><li>示例：<ul><li>两个输入变量x1（a≤x1≤b）和x2（c≤x2≤d）。 测试用例包括：</li><li>&lt;x1nom，x2min&gt;，&lt;x1nom，x2min +&gt;，&lt;x1nom，x2nom&gt;，&lt;x1nom，x2max&gt;，&lt;x1nom，x2max-&gt;，&lt;x1min，x2nom&gt;，<x1min +，x2nom="">，&lt;x1max，x2nom&gt;，&lt;x1max-，x2nom&gt;</x1min></li><li>nomal，min，max</li></ul></li><li>弱边界值分析<ul><li>Min-  Min  Min+</li><li>Nom </li><li>Max-  Max  Max+ </li></ul></li></ul><p><img src="/sftest/弱边界1.png" width="40%"><img src="/sftest/弱边界2.png" width="30%"><img src="/sftest/边界.png" width="30%"></p><ul><li><p>强边界分析</p><p><img src="/sftest/强边界1.png" width="30%"><img src="/sftest/强边界2.png" width="35%"></p></li></ul><p><img src="/sftest/强边界3.png" width="35%"><img src="/sftest/强边界4.png" width="35%"></p><h5 id="5-4-组合测试"><a href="#5-4-组合测试" class="headerlink" title="5.4 组合测试"></a>5.4 组合测试</h5><ul><li>弱等价类测试</li><li>强等价类测试</li></ul><h5 id="5-5-测试中的约束"><a href="#5-5-测试中的约束" class="headerlink" title="5.5 测试中的约束"></a>5.5 测试中的约束</h5><ul><li>合并输入变量</li><li>优化输入域</li><li>修改测试用例</li></ul><h5 id="5-6-决策表"><a href="#5-6-决策表" class="headerlink" title="5.6 决策表"></a>5.6 决策表</h5><ul><li>决策表的优点<ul><li>能够将复杂的问题按照各种可能的情况全部列举出来，简明并避免遗漏。</li><li>利用决策表能够设计出完整的测试用例集合。 </li></ul></li><li>决策表通常由以下4部分组成:<ul><li>条件桩：列出问题的所有条件</li><li>条件项：针对条件桩中条件列出所有可能的取值</li><li>动作桩：列出问题规定的可能采取的操作</li><li>动作项：指出条件项各取值情况下应采取的动作</li></ul></li><li>构造决策表的5个步骤: <ol><li>确定规则的个数 ：有n个条件的决策表有2n个规则(每个条件取真、假值) </li><li>列出所有的条件桩和动作桩 </li><li>填入条件项 </li><li>填入动作项，得到初始决策表 </li><li>简化决策表，合并相似规则 </li></ol></li><li>练习：<ul><li>前一日函数DPreate是NextDate的逆函数，即给定一个月份、日期、年，会返回前一天的日期。</li><li>年的取值在1812年到2017年</li><li>日的取值在1日到31日之间</li><li>月的取值在1到12月之间</li><li>条件项(等价类划分)：<br><img src="/sftest/条件项.png" width="40%"></li></ul></li></ul><h4 id="C7-功能、性能、移动应用测试"><a href="#C7-功能、性能、移动应用测试" class="headerlink" title="C7 功能、性能、移动应用测试"></a>C7 功能、性能、移动应用测试</h4><ul><li>功能测试<ul><li>根据产品特性和设计需求，验证一个产品的特性和行为是否满足设计需求。</li><li>正确性、可靠性、易用性。</li></ul></li><li>性能测试<ul><li>验证产品的性能在特定负载和环境条件下使用是否满足性能指标。</li><li>度量方法：响应时间、并发用户数、吞吐量、性能计数器、负载测试、压力测试</li></ul></li><li><p>移动应用测试</p><ul><li>手机系统、型号</li><li>传感器与屏幕(尺寸？)碎片化</li></ul></li><li><p>软件缺陷的􏰀描述</p><ul><li>软件缺陷的生命周期</li><li>严重性和优先级</li><li>缺陷的其它属性</li><li>完整的缺陷信息</li><li>缺陷描述的基本要求</li><li>缺陷报告的示例</li></ul></li><li><p>软件缺陷的生命周期</p><ul><li>一个软件缺陷被发现、报告到 这个缺陷被修复、验证直至最后关闭的完整过程。</li></ul></li><li><p>基本的缺陷生命周期</p><ul><li>发现-打开:测试人员找到软件缺陷并将软件缺陷􏰁交给开发人员。 </li><li>打开-修复:开发人员再现、修复缺陷，然后提交给测试人员去验证。 </li><li>修复-关闭:测试人员验证修复过的软件，关闭已不存在的缺陷。 </li></ul></li><li><p>严重性(severity)：衡量缺陷对客户满意度的影响程度</p><ul><li>致命的(fatal)、严重的(critical)、一般的(major)、微小的(minor)</li></ul></li><li><p>优先级(Priority)：指缺陷被修复的紧急程度。</p></li><li><p><strong>缺陷􏰀述的基本要求</strong></p><ul><li>单一准确</li><li>可以再现</li><li>完整统一</li><li>短小简练</li><li>特定条件</li><li>补充完善</li><li>不做评价 </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-软件测试概述&quot;&gt;&lt;a href=&quot;#1-软件测试概述&quot; class=&quot;headerlink&quot; title=&quot;1 软件测试概述&quot;&gt;&lt;/a&gt;1 软件测试概述&lt;/h4&gt;&lt;h5 id=&quot;故障、错误-amp-失败&quot;&gt;&lt;a href=&quot;#故障、错误-amp-失败&quot; class=&quot;headerlink&quot; title=&quot;故障、错误&amp;amp;失败&quot;&gt;&lt;/a&gt;故障、错误&amp;amp;失败&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;软件故障(fault)：软件中的一个静态的缺陷。&lt;/li&gt;
&lt;li&gt;软件错误(error)：软件运行中一个不正确的内部状态，这是某个故障的表现。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;软件失败(failure)：一个与软件需求或者是预期行为描述不相符的、外在的行为。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UML</title>
    <link href="http://daisine.me/uml/"/>
    <id>http://daisine.me/uml/</id>
    <published>2019-05-10T03:51:47.000Z</published>
    <updated>2019-05-10T04:31:33.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-面向对象技术概述"><a href="#1-面向对象技术概述" class="headerlink" title="1. 面向对象技术概述"></a>1. 面向对象技术概述</h2><h5 id="1-1-软件危机及软件工程"><a href="#1-1-软件危机及软件工程" class="headerlink" title="1.1 软件危机及软件工程　"></a>1.1 软件危机及软件工程　</h5><ul><li><strong>软件危机，软件工程</strong>的提出<ul><li>软件危机是指落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。<a id="more"></a></li><li>软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。</li></ul></li><li><strong>软件工程的目的</strong>就是在规定的时间、规定的开发费用内开发出满足用户需求的高质量的软件系统。<ul><li>高质量不只是指错误率低，还包括好用、易用、可移植、易维护等。</li></ul></li></ul><h5 id="1-2-对软件开发的基本认识"><a href="#1-2-对软件开发的基本认识" class="headerlink" title="1.2 对软件开发的基本认识　"></a>1.2 对软件开发的基本认识　</h5><ul><li><strong>软件是一个逻辑部件</strong>，而不是一个物理部件，所以软件具有与硬件不同的特点：<ul><li>表现形式不同</li><li>生产方式不同</li><li>产品要求不同</li><li>维护方式不同</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-面向对象技术概述&quot;&gt;&lt;a href=&quot;#1-面向对象技术概述&quot; class=&quot;headerlink&quot; title=&quot;1. 面向对象技术概述&quot;&gt;&lt;/a&gt;1. 面向对象技术概述&lt;/h2&gt;&lt;h5 id=&quot;1-1-软件危机及软件工程&quot;&gt;&lt;a href=&quot;#1-1-软件危机及软件工程&quot; class=&quot;headerlink&quot; title=&quot;1.1 软件危机及软件工程　&quot;&gt;&lt;/a&gt;1.1 软件危机及软件工程　&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;软件危机，软件工程&lt;/strong&gt;的提出&lt;ul&gt;
&lt;li&gt;软件危机是指落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>密码学笔记</title>
    <link href="http://daisine.me/Cryptography/"/>
    <id>http://daisine.me/Cryptography/</id>
    <published>2019-05-10T03:49:14.000Z</published>
    <updated>2019-05-10T03:51:13.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-计算机安全概念"><a href="#1-1-计算机安全概念" class="headerlink" title="1.1 计算机安全概念"></a>1.1 计算机安全概念</h3><p>网络和Internet安全领域涉及阻止、防止、检测和纠正信息传输中出现的安全违规欣慰的措施。<br><a id="more"></a></p><h3 id="1-2-OSI安全框架"><a href="#1-2-OSI安全框架" class="headerlink" title="1.2 OSI安全框架"></a>1.2 OSI安全框架</h3><ul><li>OSI安全框架主要关注：<ul><li>安全攻击：任何危机信息系统安全的行为。</li><li>安全机制：用来检测、阻止攻击或者从攻击状态恢复到正常状态的过程。</li><li>安全服务：加强数据处理系统和信息传输的安全性的一种处理过程或通信服务。</li></ul></li><li>安全在信息系统的范围很广<ul><li>信息安全</li><li>网络安全</li><li>计算机安全</li><li>数据库安全</li><li>软件安全  </li></ul></li></ul><h3 id="1-3-安全攻击"><a href="#1-3-安全攻击" class="headerlink" title="1.3 安全攻击"></a>1.3 安全攻击</h3><h5 id="四种类型"><a href="#四种类型" class="headerlink" title="四种类型"></a>四种类型</h5><ul><li><strong>阻断</strong>：使系统被破坏或者无法使用。<strong>对可用性的攻击</strong>。<ul><li>破环硬件</li><li>切断通信线路</li><li>禁用文件系统</li><li>DOS/DDOS (拒绝服务)</li></ul></li><li><strong>窃听</strong>：未经授权的一方访问信息。<strong>对保密性的攻击</strong>。<ul><li>窃听以捕获网络中的数据</li><li>非法复制文件/程序</li></ul></li><li><strong>修改</strong>：未经授权的一方不仅可以访问还可以修改信息。<strong>对完整性的攻击</strong>。<ul><li>更改文件中的数据</li><li>改变一个程序</li><li>修改消息的内容</li></ul></li><li><strong>伪装</strong>：未经授权的一方将假冒的对象插入到系统中。<strong>对真实性的攻击</strong>。<ul><li>在网络中插入虚假信息</li><li>将记录添加到文件中</li><li>改变程序</li></ul></li></ul><h5 id="两种类型"><a href="#两种类型" class="headerlink" title="两种类型"></a>两种类型</h5><ul><li><strong>主动攻击</strong>：对数据流进行修改或者伪造数据流。<strong>难以绝对地预防但容易检测。</strong><ul><li>伪装</li><li>重放</li><li>篡改</li><li>拒绝服务</li></ul></li><li><strong>被动攻击</strong>：对传输进行窃听和检测。<strong>难以检测但可以预防。</strong> <ul><li>泄密</li><li>流量分析</li></ul></li></ul><h3 id="1-4-安全服务"><a href="#1-4-安全服务" class="headerlink" title="1.4 安全服务"></a>1.4 安全服务</h3><ul><li>保密性：确保隐私或者秘密信息不向非授权者泄露，也不被非授权者所使用。</li><li>真实性：信息和信息的来源是正确的，能够验证用户的身份。</li><li>完整性：防止信息被不恰当修改或破坏。</li><li>可用性：确保信息的及时和可靠的访问和使用。</li><li>防止抵赖：防止发送方或者接收方否认传输或者接受过某条消息。</li><li>可控性：限制和控制那些通过通信连接对主机和应用进行访问。(eg. 读写权限)</li></ul><h3 id="1-5-安全机制-P14-表1-3"><a href="#1-5-安全机制-P14-表1-3" class="headerlink" title="1.5 安全机制 P14 表1.3"></a>1.5 安全机制 P14 表1.3</h3><h3 id="1-6-网络安全模型"><a href="#1-6-网络安全模型" class="headerlink" title="1.6 网络安全模型"></a>1.6 网络安全模型</h3><p><img src="/Cryptography/网络安全模型.png" width="70%"></p><h2 id="2-传统加密技术"><a href="#2-传统加密技术" class="headerlink" title="2. 传统加密技术"></a>2. 传统加密技术</h2><h3 id="2-1-密码学概念"><a href="#2-1-密码学概念" class="headerlink" title="2.1 密码学概念"></a>2.1 密码学概念</h3><h5 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h5><ul><li>密码编码学</li><li>密码分析学</li></ul><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ul><li>明文 <code>P</code>：原始可理解的消息或数据，加密算法的输入。</li><li>加密算法 <code>E</code>：加密算法对明文进行各种代替和变换。</li><li>密钥 <code>K</code>：加密算法的输入。</li><li>密文 <code>C</code>：加密算法的输出。</li><li>解密算法 <code>D</code>： 本质上是加密算法的逆运算。输入密文和密钥，输出原始明文。</li></ul><h5 id="古典加密技术"><a href="#古典加密技术" class="headerlink" title="古典加密技术"></a>古典加密技术</h5><ul><li>置换：置换符号的位置。eg. SPARTAN SCYTALE(密码棒)<ul><li>棱柱侧面的数量{x}</li><li>算法：明文一维数组-&gt;多维数组-行列变换-&gt;密文一维数组密文</li><li>评价：统计</li></ul></li><li>替换：将明文字母替换成其他字母、数字或符号的方法。eg. Caesar密码<ul><li>移位的长度 {S}</li><li>字符编码后的加法运算</li><li>缺点：密钥长度太短 </li></ul></li><li>多表代替密码<ul><li>Auto-key Cipher<br><img src="/Cryptography/Auto-key.png" width="40%"></li><li>Playfair密码：密文仍然完好地保留了明文语言的大部分结构特征。<br><img src="/Cryptography/Playfair.png" width="40%"></li><li>Vigenère密码：破译能否取得进展取决于能否判定密钥词的长度。<br><img src="/Cryptography/Vig.png" width="40%"></li><li>Hill密码：基于线性代数 P30。优点是完全隐藏了单字母频率特性。</li></ul></li></ul><h3 id="2-2-密码学概述"><a href="#2-2-密码学概述" class="headerlink" title="2.2 密码学概述"></a>2.2 密码学概述</h3><h5 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h5><ul><li>Kerckhoff准则：密码系统的安全性不在于算法的保密，而在于当对手获知了算法和密文后分析出密钥或明文的难度。</li><li>混淆：尽可能使密文和加密密钥间的统计关系更加复杂，以阻止攻击者发现密钥。</li><li>扩散：明文的统计特征消散在密文中。</li><li>雪崩效应：明文或密钥的某一位发生变化会导致密文的很多位发生变化。</li></ul><h5 id="分组密码与流密码"><a href="#分组密码与流密码" class="headerlink" title="分组密码与流密码"></a>分组密码与流密码</h5><ul><li>分组密码：将明文分组作为整体加密并且通常得到的是与明文等长的密文分组。</li><li>流密码：每次加密数据流的一位或者一个字节。</li></ul><h5 id="密码破解-分析-P23"><a href="#密码破解-分析-P23" class="headerlink" title="密码破解/分析 P23"></a>密码破解/分析 P23</h5><ul><li>唯密文攻击<ul><li>最容易防范的，攻击者拥有的信息量较少。</li><li>需要获取更多密文进行分析</li></ul></li><li>已知部分明文攻击<ul><li>可能词攻击</li></ul></li><li>选择明文攻击<ul><li>分析者通过某种方式获取信源系统，让发送方在发送的信息中插入一段由他选择的信息。</li></ul></li><li>选择密文攻击</li><li>选择文本攻击</li><li>蛮力攻击：在一个密文中尝试每个可能的密钥直到获得翻译成可理解的明文。一般需要尝试所有可能密钥的一半。</li></ul><h5 id="加密算法的安全"><a href="#加密算法的安全" class="headerlink" title="加密算法的安全"></a>加密算法的安全</h5><ul><li>无条件安全：无论有多少可使用的密文，都不足以唯一确定密文所对应的明文。</li><li>计算上安全：加密体制满足下面两条中任意一条：<ul><li>破译密码的代价超出密文信息的价值。</li><li>破译密码的时间超出密文信息的有效生命期。</li></ul></li><li>可证明安全：破译密码的难度与数学上某个困难问题的难度相同。</li><li>实际安全：包括可证明安全和计算安全</li></ul><h5 id="隐写术-信息隐藏"><a href="#隐写术-信息隐藏" class="headerlink" title="隐写术 / 信息隐藏"></a>隐写术 / 信息隐藏</h5><ul><li>隐写术：隐藏信息的存在。</li><li>密码学：通过对文本信息的不同转换而实现信息的对外不可读。</li></ul><h2 id="3-分组密码原理"><a href="#3-分组密码原理" class="headerlink" title="3. 分组密码原理"></a>3. 分组密码原理</h2><h3 id="3-1-分组密码和数据加密标准-DES"><a href="#3-1-分组密码和数据加密标准-DES" class="headerlink" title="3.1 分组密码和数据加密标准(DES)"></a>3.1 分组密码和数据加密标准(DES)</h3><h5 id="乘积密码"><a href="#乘积密码" class="headerlink" title="乘积密码"></a>乘积密码</h5><ul><li>P-box(置换)<ul><li>直接的P-box是可逆的，压缩和扩张的P-box不可逆。<br><img src="/Cryptography/pbox.png" width="40%"></li></ul></li><li>S-bos(替换)<ul><li>m x n的替换单元，m与n不一定相同。<br><img src="/Cryptography/sbox.png" width="40%"></li></ul></li><li>XOR<ul><li>相同为0不同为1</li><li>A XOR B XOR B = A </li></ul></li><li>循环移位<ul><li><img src="/Cryptography/循环移位.png" width="40%"></li></ul></li><li>交换<ul><li>是循环位移的一个特例，k = N / 2</li></ul></li><li><p>分离/合并 </p><p><img src="/Cryptography/乘积密码.png" width="40%"></p></li></ul><h5 id="Feistel密码"><a href="#Feistel密码" class="headerlink" title="Feistel密码"></a>Feistel密码</h5><ul><li>Feistel密码是对称加密算法在块加密结构中使用的一种密码结构。</li><li>基于可逆的乘积密码。Feistel密码解密是加密的逆过程。</li><li>实现了Shannon的S-P net 概念。</li><li><p>Feistel密码的属性：</p><ul><li>分组长度 </li><li>密钥长度</li><li>迭代轮数：多轮加密可以取得很高的安全性。</li><li>子密钥生成算法</li><li>轮函数F：提供“混乱”，非线性，雪崩效应</li><li>快速软件加 / 解密</li><li>简化分析难度</li></ul><p><img src="/Cryptography/Feistel密码.png" width="50%"></p></li></ul><h5 id="数据加密标准-DES"><a href="#数据加密标准-DES" class="headerlink" title="数据加密标准 DES"></a>数据加密标准 DES</h5><ul><li>DES加密过程：是由2个P-box 初始置换和最终置换、16轮Feistel加密组成。即，除了初始和末尾的置换，DES的结构与Feistel密码结构完全相同。<br><img src="/Cryptography/DES.png" width="40%"><ul><li>初始置换和末尾置换是互逆的</li><li>DES的核心是DES函数，他将一个48位的轮密钥加到32位的左半/右半部分并得到32位的输出。扩展后的右部分和轮密钥都是48位长度，且轮密钥仅在该轮使用。<br><img src="/Cryptography/DESF.png" width="30%"></li><li>DES使用了8个P-box来扩展，每个P-box有4位的输入和6位的输出</li><li>S-box做了真正的混淆。DES使用了8个S-box，且每个都有6位的输入和4位的输出<br><img src="/Cryptography/DESSbox.png" width="50%">  <img src="/Cryptography/DESSbox3.png" width="30%"><br><img src="/Cryptography/DESSbox2.png" width="50%"></li></ul></li><li>DES解密过程<ul><li>与加密过程算法相同</li><li>使用k<sub>1</sub> -&gt; k<sub>16</sub>加密</li><li>使用k<sub>16</sub> -&gt; k<sub>1</sub>解密</li></ul></li><li>DES密钥的生成和扩展<ul><li>64位随机数，丢弃8位重新排列成56位</li><li>轮密钥生成器在56位密钥中生成一个48位的轮密钥<br><img src="/Cryptography/DES密钥.png" width="40%"></li><li>16个子密钥由56位密钥分裂成两半，左右两部分各占一半，然后压缩置换他们，为48位的轮密钥。</li></ul></li><li>DES的弱点：<ul><li>P-box的弱点</li><li>S-box的弱点</li><li>密钥的弱点：56位密钥有 256 = 7.2×1016，随着计算机的发展，蛮力破解能越来越快地破解DES的密文。</li></ul></li><li>DES的密码分析<ul><li>微分密码分析</li><li>线性密码分析</li><li>相关密钥攻击</li></ul></li></ul><h5 id="多重DES"><a href="#多重DES" class="headerlink" title="多重DES"></a>多重DES</h5><ul><li>双重DES：2个密钥k<sub>1</sub>，k<sub>2</sub> <ul><li>C = E<sub>k<sub>1</sub></sub>(D<sub>k<sub>2</sub></sub>(E<sub>k<sub>1</sub></sub>(P)))</li><li>P = D<sub>k<sub>1</sub></sub>(E<sub>k<sub>2</sub></sub>(D<sub>k<sub>1</sub></sub>(C)))</li></ul></li><li>三重DES：3个密钥k<sub>1</sub>，k<sub>2</sub>，k<sub>3</sub><ul><li>C = E<sub>k<sub>3</sub></sub>(D<sub>k<sub>2</sub></sub>(E<sub>k<sub>1</sub></sub>(P)))</li><li>P = D<sub>k<sub>1</sub></sub>(P<sub>k<sub>2</sub></sub>(D<sub>k<sub>3</sub></sub>(P)))</li></ul></li><li>比DES更安全，但成本更高。</li></ul><h3 id="3-2-高级加密标准-AES"><a href="#3-2-高级加密标准-AES" class="headerlink" title="3.2 高级加密标准 AES"></a>3.2 高级加密标准 AES</h3><h5 id="数学基础：有限域算术"><a href="#数学基础：有限域算术" class="headerlink" title="数学基础：有限域算术"></a>数学基础：有限域算术</h5><ul><li>有限域：Galois域GF(2<sup>8</sup>)</li><li>任何一个字节f(x)可以表示为多项式：f(x) = b<sub>7</sub>x<sup>7</sup> + b<sub>6</sub>x<sup>6</sup> + b<sub>5</sub>x<sup>5</sup> + b<sub>4</sub>x<sup>4</sup> + b<sub>3</sub>x<sup>3</sup>+b<sub>2</sub>x<sup>2</sup> + b<sub>1</sub>x + b<sub>0</sub></li><li>1100101 —&gt; x<sup>7</sup> + x<sup>6</sup> +x<sup>3</sup> + 1 <ul><li>eg. 91<sub>hex</sub> = (1001  0001)<sub>bin</sub> = x<sup>7</sup> + x<sup>4&lt;/sup + 1 </sup></li></ul></li><li>加法运算：：a⊕b（XOR）<ul><li>封闭性：a∈F，b∈F =&gt; a⊕b∈F </li><li>交换律：a⊕b=b⊕a</li><li>结合律：a⊕（b⊕c）=（a⊕b）⊕c</li><li>单位元：0，使得a⊕0 = a</li><li>加法逆元：a⊕（-a）= 0（a = -a）</li></ul></li><li>乘法运算：a=f(x), b=g(x), m=m(x), a⊙b=f(x)×g(x) mod m(x)<ul><li>封闭性：a∈F, b∈F  =&gt; a⊙b∈F </li><li>交换律：a⊙b= b⊙a</li><li>结合律：a⊙(b⊙c)= (a⊙b)⊙c</li><li>分配率：a⊙(b⊕c)= (a⊙b)⊕(a⊙c)</li><li>单位元：1 =&gt; a ⊙1=a</li><li>乘法逆元：a⊙a-1= 1 mod m</li></ul></li><li>GF(2<sup>8</sup>)模乘法运算；m(x) = x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1<ul><li>{01} ⊙ { b<sub>7</sub>b<sub>6</sub>b<sub>5</sub>b<sub>4</sub>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub> } = { b<sub>7</sub>b<sub>6</sub>b<sub>5</sub>b<sub>4</sub>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub> }   <strong>被乘数不发生变化</strong></li><li>{02} ⊙ { b<sub>7</sub>b<sub>6</sub>b<sub>5</sub>b<sub>4</sub>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub> } = { b<sub>6</sub>b<sub>5</sub>b<sub>4</sub>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub> } <strong>b7 = 0 的情况</strong></li><li>{02} ⊙ { b<sub>7</sub>b<sub>6</sub>b<sub>5</sub>b<sub>4</sub>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub> } ={ b<sub>6</sub>b<sub>5</sub>b<sub>4</sub>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub> } ⊕ (00011011) <strong>b7 = 1 的情况</strong></li><li>{03} ⊙ {xx } ={xx} ⊕( {02} ⊙ {xx} )</li></ul></li><li>GF(2<sup>8</sup>)模乘法运算 eg. <ul><li>{02} ⊙ {2B} = {02} ⊙ { 0010 1011} = { 0101 0110}</li><li>{02} ⊙ {91}  = {02} ⊙ {1001 0001}  = {0010 0010} ⊕ {00011011}  = 00111001</li><li>{03} ⊙ {6E} = {6E} ⊕( {02}⊙{6E} ) = {0110 1110} ⊕ {10111100} = 10110010</li></ul></li></ul><h5 id="AES的评价标准"><a href="#AES的评价标准" class="headerlink" title="AES的评价标准"></a>AES的评价标准</h5><ul><li>NIST于1997年发出了AES的请求，NIST定义的选择AES的标准氛围三个方面：安全、成本、实施。</li><li>1998年6月接受了15名候选人。</li><li>1999年5个被选入名单：<ul><li>MARS􏰥IBM􏰦(IBM):􏱪􏲨 扩展Feistel密码， 􏰁􏰂􏰏128位分组，􏱉􏰚􏰷􏰏128-1248位密钥。复杂、快速，安全系数高。</li><li>RC6􏰥(USA)：􏰦􏱠128位分组，􏱉􏰚􏰷􏰏128-256位密钥。非常简单、快速，安全系数低。 􏱉􏰁􏰝􏰢􏳹􏰶􏲻􏲇􏰏􏳹􏰶􏳶􏰢􏰆􏰇􏰃􏰻􏳺􏰢 􏱉􏰁􏰝􏰢􏱨􏱩􏲕􏳶􏳷􏰢􏰆􏰇􏰃􏰻􏳸􏰢 􏱉􏰁􏰝􏰢􏱨􏱩􏲕􏳶􏳷􏰢􏰆􏰇􏰃􏰻􏳸􏰢</li><li>Rijndael􏰥(Belgium􏰦)：􏱠128位分组，􏱉􏰚􏰷􏰏128 - 256位密钥。干净、快，安全系数良好。</li><li>Serpent􏰥(Euro)：复杂、干净，安全系数非常高。</li><li>Twofish(􏰥USA􏰦􏱠􏱨􏱩􏲕􏳹􏰶􏳶􏰢􏰆􏰇􏰃􏰻􏳸􏰦􏱠􏳽􏲕􏳻􏳼􏰢􏰆􏰇􏰃􏰻􏳹􏰶􏳸􏰢)：复杂、非常快，安全系数高。</li></ul></li></ul><h5 id="AES算法加密过程"><a href="#AES算法加密过程" class="headerlink" title="AES算法加密过程"></a>AES算法加密过程</h5><ul><li>明文分组长度：128位 / 16字节</li><li>密钥长度：16字节(128位)，24字节(192位)或32字节(256位)。  </li><li>轮数：10 / 12 / 14</li><li>轮密钥长度：128位<ul><li>在<strong>第一轮开始前添加轮密钥</strong></li><li>在<strong>最后一回合没有列混淆</strong><br><img src="/Cryptography/AES.png" width="48%"><img src="/Cryptography/AES2.png" width="52%"><img src="/Cryptography/AES4.png" width="30%"></li></ul></li><li>加密和解密算法的输入是一个128位分组，这个分组被描述为4 * 4 的字节方阵。这个分组被复制到<strong>状态数组</strong>，并在加密或解密的各个阶段被修改。</li><li>四个不同的阶段<ul><li>字节替换：加密S盒，解密S盒<sup>-1</sup>，S盒必须是可逆的。S盒不是自逆的。   <strong>P103 S盒的构造</strong><br><img src="/Cryptography/AESS.png" width="30%"></li><li>行移位(<strong>以字节为单位</strong>)：第1行：不移，第2行：左移1字节，第3行，左移2字节，第4行：左移3字节。</li><li>列混淆：<br><img src="/Cryptography/AESC.png" width="40%"><img src="/Cryptography/AESC2.png" width="50%"></li><li>轮密钥加：加密过程中，每轮的输入与轮密钥异或一次（当前分组和扩展密钥的一部分进行按位异或）；因为二进制数连续异或一个数结果是不变的，所以在解密时再异或上该轮的密钥即可恢复输入。 轮密钥加是自逆的</li></ul></li></ul><h5 id="AES算法解密过程"><a href="#AES算法解密过程" class="headerlink" title="AES算法解密过程"></a>AES算法解密过程</h5><ul><li>是加密过程的逆。</li><li>字节变换：加密S盒，解密S盒<sup>-1</sup></li><li>列混淆：矩阵C进行加密，矩阵C<sup>-1</sup>解密。</li><li>反向轮密钥。</li></ul><h5 id="AES密钥扩展"><a href="#AES密钥扩展" class="headerlink" title="AES密钥扩展"></a>AES密钥扩展</h5><ul><li>AES使用密码扩展算法创建每一轮的轮密钥。如果轮数为Nr，密钥扩展算法会为一个128位(= 16个字节 = 4个字)的加密密钥输出 Nr+1 个轮密钥。</li><li>AES密钥扩展算法的输入值是4个字(16字节)，输出是44个字组成的一维线性数组。<br><img src="/Cryptography/AESkey.png" width="50%"></li></ul><h5 id="AES的实现"><a href="#AES的实现" class="headerlink" title="AES的实现"></a>AES的实现</h5><ul><li>AES可以在软件，硬件和固件中实现。 实现可以使用表查找过程或使用明确定义的代数结构的例程。</li><li>AES中使用的算法非常简单，可以使用廉价的处理器和最少的内存来轻松实现。</li></ul><h5 id="AES的安全性"><a href="#AES的安全性" class="headerlink" title="AES的安全性"></a>AES的安全性</h5><ul><li>AES是在DES之后设计的。 大多数针对DES的已知攻击已经在AES上进行了测试。</li><li>蛮力攻击：由于密钥较大，AES肯定比DES更安全。</li><li>统计攻击：许多测试未能成功对密文进行统计分析。</li><li>差分和线性攻击：目前还没有对AES的差异和线性攻击。</li></ul><h3 id="3-3-分组密码的工作模式"><a href="#3-3-分组密码的工作模式" class="headerlink" title="3.3 分组密码的工作模式"></a>3.3 分组密码的工作模式</h3><h5 id="更先进的对称密码"><a href="#更先进的对称密码" class="headerlink" title="更先进的对称密码"></a>更先进的对称密码</h5><ul><li>IDEA: International Data Encryption Algorithm<ul><li>1992, Lai Xuejia (来学嘉)</li><li>64位分组大小，128位密钥, 8轮<br><img src="/Cryptography/IDEA.png" width="50%"></li></ul></li><li>Blowfish<ul><li>Bruce Schneier, 1993 </li><li>Feistel密码结构</li><li>64位分组大小，32–448位密钥, 16轮</li><li>继承者: Twofish</li><li>Key Generator</li><li>complex<br><img src="/Cryptography/Blowfish.png" width="50%"></li></ul></li><li>RC5<ul><li>可变分组大小（32,64或128位），可变密钥大小（0到2040位）和可变轮次数（0到255）。 </li><li>最初建议的参数选择是块大小为64位，128位密钥和12轮。</li><li>继承者：RC6<br><img src="/Cryptography/RC5.png" width="15%"></li></ul></li><li>高级分组密码的特点<ul><li>可变性：密钥长度，分组大小，轮数，S盒，圆函数</li><li>复杂的轮函数生成</li><li>执行密钥的更多角色：S盒，圆形移位</li></ul></li></ul><h5 id="分组密码的操作模式"><a href="#分组密码的操作模式" class="headerlink" title="分组密码的操作模式"></a>分组密码的操作模式</h5><ul><li>对称加密模式可以使用现代分组密码完成。</li><li>操作模式已经被设计以使用DES或AES加密任何大小的文本。</li><li>实质上，工作模式是一项增强密码算法或者使算法适应具体应用的技术。</li></ul><h5 id="电子密码本-ECB"><a href="#电子密码本-ECB" class="headerlink" title="电子密码本 ECB"></a>电子密码本 ECB</h5><ul><li>一次处理一组明文分块，每次使用相同的密钥加密。<br><img src="/Cryptography/ECB.png" width="55%"></li><li>ECB评价<ul><li>消息中若有几个相同的明文组，那么密文也将出现几个相同的密文分组。</li><li>􏲒􏰍􏳿􏴀􏱺􏱮􏳾􏰅􏴁􏱅􏴂􏴃􏲒􏰍􏳿􏴀􏱺􏱮􏳾􏰅􏴁􏱅􏴂􏴃无法阻止长消息的修改攻击，</li><li>无错误传播：传输中的单个错误可能会在相应块的多个位中产生错误。但该错误对于其他块没有任何影响。（why：因为ECB一次处理一个明文分块，每个明文块使用相同的密钥独立编码。）</li></ul></li><li>ECB适用于：<ul><li>单个数据的安全传输</li><li>eg. 加密 密钥，口令 </li></ul></li></ul><h5 id="密码分组链接模式-CBC"><a href="#密码分组链接模式-CBC" class="headerlink" title="密码分组链接模式 CBC"></a>密码分组链接模式 CBC</h5><ul><li>为了克服ECB的弱点，我们需要将重复的明文文组加密成不同的密文分组。</li><li>CBC的输入是当前明文组的上一个密文组的异或，使用的密钥是相同的。  </li><li>IV 初始向量：为了产生密文的第一个密文块，初始向量IV与第一个明文块进行异或。</li><li>IV必须为收发双方共享，但第三方不能预测。为了最大限度的安全。IV不能不经授权而修改。<br><img src="/Cryptography/CBC.png" width="55%"></li><li>CBC的加密和解密是互逆的。</li><li>CBC方式要求如果最后的分组不是完整的分组，则需要填充至b位的满分组。<ul><li>P<sub>i</sub> = D<sub>K</sub>(C<sub>i</sub>)⊕C<sub>i-1</sub>= D<sub>K</sub>(E<sub>K</sub>(P<sub>i</sub>⊕C<sub>i-1</sub>))⊕C<sub>i-1</sub> = P<sub>i</sub>⊕C<sub>i-1</sub>⊕C<sub>i-1</sub></li></ul></li><li>CBC适用于：<ul><li>面向分组的通用传输</li><li>消息鉴别 / 认证</li></ul></li></ul><h5 id="密码反馈模式-CFB"><a href="#密码反馈模式-CFB" class="headerlink" title="密码反馈模式 CFB"></a>密码反馈模式 CFB</h5><ul><li>实时地传输长消息。</li><li>解密与加密使用相同的办法，只有一点不同：将收到的密文单元与加密函数的输出异或得到明文单元。这里使用的是加密函数而非解密函数。 </li><li>与明文异或的位流是<strong>与明文相关的</strong>。<br><img src="/Cryptography/CFB.png" width="50%">  <img src="/Cryptography/CFB2.png" width="50%"></li><li>CFB：错误传播<ul><li>消息认证</li><li>在<strong>可靠的信道</strong></li></ul></li><li>CFB适用于：<ul><li>面向<strong>数据流</strong>的通用传输  </li><li>认证 </li></ul></li></ul><h5 id="输出反馈模式-OFB"><a href="#输出反馈模式-OFB" class="headerlink" title="输出反馈模式 OFB"></a>输出反馈模式 OFB</h5><ul><li>没有错误传播：传输过程中某位上发生的错误不会影响其他位。OFB作为流密码，可以在<strong>不可靠信道</strong>使用。</li><li>不需要将明文填充到长度是分组长度的整数倍。</li><li>缺点：抗消息流篡改攻击能力不如CFB<br><img src="/Cryptography/OFB.png" width="50%">  <img src="/Cryptography/OFB2.png" width="50%"></li><li>OFB适用于<ul><li>噪声信道上<strong>的数据流传输</strong>，瑞卫星通信</li></ul></li></ul><h5 id="计数器模式-CTR"><a href="#计数器模式-CTR" class="headerlink" title="计数器模式 CTR"></a>计数器模式 CTR</h5><ul><li>没有反馈。</li><li>密钥流的伪随机用计数器来实现。<br><img src="/Cryptography/CTR.png" width="50%">  <img src="/Cryptography/CTR2.png" width="50%"></li><li>CTR适用于<ul><li>面向分组的通用传输，属于数据流的传输</li><li>用于高速需求</li></ul></li></ul><h2 id="4-流密码"><a href="#4-流密码" class="headerlink" title="4. 流密码"></a>4. 流密码</h2><h3 id="4-1-流密码概述"><a href="#4-1-流密码概述" class="headerlink" title="4.1 流密码概述"></a>4.1 流密码概述</h3><ul><li>一个典型的流密码每次加密一个字节的明文，产生伪随机密钥流，与明文流的每个字节进行按位异或运算，得到一个密文字节。</li><li>“一次一密”使用的是真正的随机数流，而流密码使用的是伪随机数流。</li><li>流密码的随机性完全破坏了消息中的统计的性质。</li><li>不能重复使用流密码，否则能够恢复消息。而分组密码可以重复使用密钥。<br><img src="/Cryptography/stream.png" width="60%"></li><li>一些需要考虑的方面：<ul><li>长时间没有重复</li><li>统计学上随机</li><li>取决于足够大的密钥的线形复杂性</li><li>正确设计，可以像具有相同大小密钥的分组密码一样安全，但通常更简单、快速。</li></ul></li><li>流密码：使用分组密码模式——OFB</li></ul><h3 id="RC4算法"><a href="#RC4算法" class="headerlink" title="RC4算法"></a>RC4算法</h3><h5 id="RC4概述"><a href="#RC4概述" class="headerlink" title="RC4概述"></a>RC4概述</h5><ul><li>RC4是流密码，RC5是分组加密算法</li><li>RC4是一个面向字节的流密码，其中明文的一个字节与一个密钥字节进行X-存储，以产生一个密文字节。</li><li>RSA DSI的私有的密码</li><li>另一个是Ron Rivest设计于1987年，简单、有效：<ul><li>可变长度的密钥，面向字节的流密码</li><li>广泛使用（网络SSL / TLS，无线WEP）</li><li>密钥形成所有8位数的随机排列，使用该排列来搅乱一次处理一个字节的输入信息</li></ul></li></ul><h5 id="RC4算法-1"><a href="#RC4算法-1" class="headerlink" title="RC4算法"></a>RC4算法</h5><ul><li>基本描述<ul><li>可变长度密钥K：1-256个字节(8-2048位)。密钥K的长度keylen与明文长度、密钥流长度无关，通常取16字节(128bits)</li><li>状态向量S：256个字节，S的元素记为S[0], S[1], … , S[256]。<strong>从始至终置换后的S包含从0-255的8位数，只不过位置发生了变化</strong></li><li>临时向量T：256个字节，每个单元也是一个字节。如果密钥K的长度是256字节，则直接把密钥的值赋给T，否则轮转地将密钥的每个字节赋给T。</li><li>密钥流：密钥流的长度和明文的长度是对应的(相等)<br><img src="/Cryptography/RC4.png" width="60%"></li></ul></li><li>RC4算法具体描述：<ul><li>初始化S和T</li><li>S的初始置换</li><li>密钥流的生成</li><li><strong>加密</strong>时将k的值与明文的下一字节<strong>异或</strong>；<strong>解密</strong>时将k的值与密文的下一个字节<strong>异或</strong>。</li></ul></li><li>RC4的安全性<ul><li>声称可以抵御已知攻击</li><li>有一些分析，没有实际意义</li><li>结果是非线性</li><li>由于RC4是流密码，因此不能用重复的密钥</li><li>关注WEP，但由于是密钥处理而不是RC4本身</li></ul></li></ul><h5 id="RC4-3bits"><a href="#RC4-3bits" class="headerlink" title="RC4 3bits"></a>RC4 3bits</h5><ul><li>是RC4算法的一个变体。</li><li>可变长度的密钥：3位 - 24位</li><li>24位的状态向量<strong>S</strong>的元素：S[0], S[1], … , S[8]</li><li>eg.<ul><li>明文：(7 2 5 1 5)<sub>oct</sub>     = {111 010 101 001 101}<sub>bin</sub></li><li>密钥：(7 4 3 2)<sub>oct</sub> = {111 100 011 010}<sub>bin</sub>   (密钥长度 = 4*3bit=12) </li><li>初始化：<br><img src="/Cryptography/初始化.png" width="60%"></li><li>初始置换：<br><img src="/Cryptography/初始置换.png" width="60%"><br><img src="/Cryptography/初始置换2.png" width="60%"></li><li>密钥流的生成：<br><img src="/Cryptography/流密钥1.png" width="60%"><br><img src="/Cryptography/流密钥2.png" width="60%"></li></ul></li></ul><h2 id="5-密钥管理和分发"><a href="#5-密钥管理和分发" class="headerlink" title="5. 密钥管理和分发"></a>5. 密钥管理和分发</h2><h5 id="密钥分发历史"><a href="#密钥分发历史" class="headerlink" title="密钥分发历史"></a>密钥分发历史</h5><ul><li>在第二次世界大战期间，德国高级司令部不得不将其每月的日记账分发给其所有谜运营商。而且，U型船往往需要长时间远离开基地，不得不以某种方式获得定期供应的钥匙。</li><li>美国政府的密钥由COMSEC管理和分发。在20世纪70年代，COMSEC负责每天运输大量的钥匙。当携带COMSEC材料的船舶进入码头时，密码管理机构将在船上行进，收集成堆的卡片，纸带，软盘，然后将它们交付给目标收件人。</li></ul><h5 id="密钥分发模型-P319"><a href="#密钥分发模型-P319" class="headerlink" title="密钥分发模型 P319"></a>密钥分发模型 P319</h5><ol><li>A选择一个密钥后以物理的方式(安全)传递给B。</li><li>第三方选择密钥后物理地传递给A和B。</li><li>如果A和B先前或者最近使用过一个密钥，则一方可以将新密钥用旧密钥加密后发送给另一方。</li><li>如果A和B到第三方C有加密连接，C可以在加密连接上传送密钥给A和B。</li><li>第三方加密：<strong>密钥分发中心(KDC)</strong>负责根据用户的需要来分发密钥。</li></ol><h5 id="密钥分发中心-KDC"><a href="#密钥分发中心-KDC" class="headerlink" title="密钥分发中心 KDC"></a>密钥分发中心 KDC</h5><ul><li>密钥分发中心是基于密钥层次体系的，最少需要两个密钥层。<ul><li>会话密钥：用于持续时间的逻辑连接，如帧的转发或传输连接，然后随着连接的断开而丢弃。</li><li>主密钥：用户和KDC共享的唯一的主密钥。用于会话密钥的加密分发。</li><li>主密钥的分发可以通过一些不加密的方式完成，如物理传递</li></ul></li><li>评价：<ul><li>在两个人可以交换秘密之前，他们必须已经分享了一个秘密。</li><li>大量的会话密钥通过互联网进行分发。</li></ul></li></ul><h5 id="密钥分配方案"><a href="#密钥分配方案" class="headerlink" title="密钥分配方案"></a>密钥分配方案</h5><ul><li>Needham/Schreoder 认证协议：KDC <strong>P321</strong><br><img src="/Cryptography/KDC.png" width="55%"></li><li>Denning认证协议 : timestamps<br><img src="/Cryptography/timestamps.png" width="55%"></li><li>Neuman协议：<br><img src="/Cryptography/Neuman.png" width="55%"></li></ul><h5 id="层次密钥控制"><a href="#层次密钥控制" class="headerlink" title="层次密钥控制"></a>层次密钥控制</h5><ul><li>对于大型网络，需要建立KDC的层次体系。<ul><li>同一个本地域的各个实体相互通信，由本地KDC负责密钥分发。</li><li>两个实体在不同域，由两个相对应的本地KDC通过全局KDC协商产生共享密钥。</li></ul></li><li>层次策略使得主密钥分发的开销最小化。</li></ul><h5 id="会话密钥的生命周期"><a href="#会话密钥的生命周期" class="headerlink" title="会话密钥的生命周期"></a>会话密钥的生命周期</h5><ul><li>会话密钥交换得越频繁就越安全。密钥分发会延迟交换的开始时间，增加网络负担。</li><li>对于<strong>面向连接的协议</strong>，在会话的整个生命周期中使用同一个会话密钥。</li><li>对于<strong>无连接的协议</strong>，没有明确的连接初始和终止。最安全的方法是每次都使用新的会话密钥，但开销变大。</li></ul><h5 id="控制密钥的使用"><a href="#控制密钥的使用" class="headerlink" title="控制密钥的使用"></a>控制密钥的使用</h5><ul><li>数据加密密钥，用于网络中通用通信</li><li>PIN加密密钥，用于电子资金过户的销售点应用的个人识别码(PIN)</li><li>文件加密密钥：用于存储可公开访问的加密文件。</li></ul><h2 id="6-密钥交换"><a href="#6-密钥交换" class="headerlink" title="6. 密钥交换"></a>6. 密钥交换</h2><h3 id="6-1-Diffie-Hellman-密钥交换"><a href="#6-1-Diffie-Hellman-密钥交换" class="headerlink" title="6.1 Diffie-Hellman 密钥交换"></a>6.1 Diffie-Hellman 密钥交换</h3><ul><li>加密和解密的密钥不同。(私钥和公钥)</li><li>相比对称加密的密钥分发，不用等待获取会话密钥，然后才能加密和发送消息。</li><li>基于一个单向函数：K = ( Y<sub>B</sub> )<sup>X<sub>A</sub></sup> mod q = ( Y<sub>A</sub> )<sup>X<sub>B</sub></sup> mod q</li><li>Diffie-Hellman算法的有效性建立在<strong>计算离散对数是很困难的</strong>这一基础上。</li><li>算法流程：  <strong>P218 具体计算</strong><br><img src="/Cryptography/Diffie-Hellman.png" width="62%"></li><li>缺点：不能抵抗所谓的中间人攻击。<br><img src="/Cryptography/中间人攻击.png" width="48%"></li></ul><h3 id="6-2-RSA算法"><a href="#6-2-RSA算法" class="headerlink" title="6.2 RSA算法"></a>6.2 RSA算法</h3><h5 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h5><ul><li>数论的核心问题：<strong>质数</strong></li><li><strong>因子分解定律</strong>：任何大于1的整数a都可以被这样分解：a = p<sub>1</sub><sup>a<sub>1</sub></sup> x p<sub>2</sub><sup>a<sub>2</sub></sup> x … x p<sub>k</sub><sup>a<sub>k</sub></sup>，p<sub>1</sub> &gt; p<sub>2</sub> &gt; … &gt; p<sub>k</sub> <ul><li>eg. 11011 = 7 x 11<sup>2</sup> x 13</li></ul></li><li><strong>素数有无限多个 </strong></li><li><strong>同模</strong>：两个整数如果a mod n = b mod n，则称a与b同模<ul><li>eg. 73 mod 23 = 4, 73 = 4 mod 23，则称4与73同模。 </li></ul></li><li>模运算的性质：<ul><li>定义：a mod n = b mod n → a ≡ b mod n</li><li>交换律：a ≡ b mod n → b ≡ a mod n</li><li>传递律：a ≡ b mod n &amp; b ≡ c mod n → a ≡ c mod n</li><li>有前提条件的消除律：如果a与n互质，则a x b  ≡ a x c mod n  → b ≡ c mod n </li></ul></li><li><strong>gcd(a, b)</strong>：表示a和b的最大公约数。</li><li>a与b互质，则gcd(a, b) = 1</li><li><strong>模乘的逆</strong>：<ul><li>定义Z<sub>n</sub>为正整数小于n的集合：Z<sub>n</sub> = {0, 1, …, (n-1)}</li><li>模乘的逆w<sup>-1</sup> ：对于每个w ∈ Z<sub>p</sub>，ョz，w * z  ≡ 1 mod p ，称z为w<sup>-1</sup></li></ul></li><li><strong>费马定理 / 费马小定理</strong>：<ul><li>p是一个质数，a是一个不能被p整除的正整数， 则a<sup>p-1</sup> = 1 mod p</li><li>eg. a = 6, p = 7, 6<sup>7-1</sup> ≡ 1 mod 7</li><li>另一种形式：p是一个质数，a是一个正整数。则a<sup>p</sup> = a mod p</li><li>eg. a = 3, p = 5, 3<sup>5</sup> = 243 ≡ 3 mod 5</li></ul></li><li><strong>欧拉函数</strong><ul><li>定义 φ(n) 为小于n且与n互质的正整数。</li><li>如果p为一个素数，那么φ(p) = p - 1</li><li>如果n = p<sub>1</sub><sup>a<sub>1</sub></sup> p<sub>2</sub><sup>a<sub>2</sub></sup> … p<sub>k</sub><sup>a<sub>k</sub></sup> 是素数分解的n，那么<img src="/Cryptography/oula.png" width="30%"></li></ul></li><li><strong>欧拉定理</strong><ul><li>对于任何互质的a和n，a<sup>φ(n)</sup> ≡ 1 mod n，或者 a<sup>φ(n)+1</sup> ≡ a mod n</li></ul></li><li><strong>欧拉定理的推论</strong><ul><li>给定两个素数p和q，以及整数n = pq，且0 &lt; m &lt; n</li><li>m<sup>φ(n)+1</sup> = m<sup>(p - 1)(q - 1) + 1 </sup> ≡ m mod n</li><li>对任意整数k有：[m<sup>φ(n)</sup>]<sup>k</sup> ≡ 1 mod n 或 m<sup>kφ(n)</sup>  ≡ 1 mod n</li><li>m<sup>kφ(n)+1</sup> = m<sup>k (p - 1)(q - 1) + 1 </sup> ≡ m mod n</li></ul></li></ul><h5 id="RSA算法描述"><a href="#RSA算法描述" class="headerlink" title="RSA算法描述"></a>RSA算法描述</h5><ul><li>对于<code>明文分组M</code>和<code>密文分组C</code>，加密和解密过程如下：<ul><li>C = M<sup>e</sup> mod n <strong>(加密)</strong></li><li>M = C<sup>d</sup> mod n = (M<sup>e</sup>)<sup>d</sup> mod n = M<sup>ed</sup> mod n <strong>(解密)</strong></li><li>其中，收发双方均已知n，发送方已知e，且<strong>只有接收方已知d</strong>，因此公钥加密算法的公钥PU = { e, n }，私钥PR = { d, n }</li></ul></li><li>必须满足以下条件：d 和 e 是模 φ(n) 的乘法逆元。即 d 与 φ(n) 互质（因此 e 也与 φ(n) 互质）<ul><li><strong>ed = kφ(n)+1</strong></li><li>ed ≡ 1 mod φ(n)</li><li>d ≡ e<sup>-1</sup> mod φ(n)</li><li>gcd( φ(n), d) = 1 ），gcd( φ(n), e) = 1 ）</li></ul></li></ul><h5 id="RSA密钥产生"><a href="#RSA密钥产生" class="headerlink" title="RSA密钥产生"></a>RSA密钥产生</h5><ul><li>选择(大)质数p, q（私有）</li><li>计算 n = p * q</li><li>计算 φ(n) = ( p - 1 )( q - 1 )</li><li>选择 e：gcd( φ(n), e) = 1 ）1 &lt; e &lt; φ(n)</li><li>计算 d ≡ e<sup>-1</sup> mod φ(n)（如何计算d -&gt; 扩展欧基里德算法）</li><li>公钥PU = { e, n }，私钥PR = { <strong>d</strong>, n }</li></ul><h5 id="RSA的安全性"><a href="#RSA的安全性" class="headerlink" title="RSA的安全性"></a>RSA的安全性</h5><ul><li>给定n确定p和q是不可行的</li><li>给定e和d确定d是不可行的</li><li>因子分解问题：对于有大素数因子的数字n，因式分解是个难题。</li><li>RSA密钥非常大所以很安全： 1024 / 2048 位</li><li>1994年，彼得肖尔表明，量子计算机可以将多项式时间（多项式时间）考虑在内，从而打破了RSA。如果n是300位或更短，则可以在个人计算机上在几个小时内计算出来 截至2008年，通用分解算法考虑的最大（已知）数量是663位长（参见RSA-200），使用最先进的分布式实现。下一个记录可能是768位模数<ul><li>RSA 秘密研制于上个世纪60年代初，用于控制战略导弹的发射. 70年代被麻省理工学院等高校的教授独立发明，建立在数论，特别是很难对大素数之积进行因式分解的基础之上。</li><li>一旦量子计算机投入实用，将给目前的公共加密技术带来极大威胁。</li></ul></li></ul><h5 id="公钥算法与对称加密"><a href="#公钥算法与对称加密" class="headerlink" title="公钥算法与对称加密"></a>公钥算法与对称加密</h5><ul><li>从最早开始到现代，虚拟（事实上）所有加密系统都基于替代和排列的基本工具。</li><li>公钥算法基于数学函数而不是替换和置换。</li><li>公钥密码可用于<ul><li>加密/解密</li><li>电子签名</li><li>密钥交换/管理</li></ul></li><li>应该提到一些关于PKC的常见误解（误解）：<ul><li>PKC比对称密钥加密更安全(✕)</li><li>PKC是一种通用技术，传统密码已经过时(✕)</li><li>使用PKC时，密钥分发没有意义(✕)</li></ul></li></ul><h2 id="7-消息认证"><a href="#7-消息认证" class="headerlink" title="7. 消息认证"></a>7. 消息认证</h2><h3 id="7-1-安全服务"><a href="#7-1-安全服务" class="headerlink" title="7.1 安全服务"></a>7.1 安全服务</h3><ul><li>对称密钥密码：使用相同的会话密钥K<sub>s</sub>进行/解密。</li><li>使用非对称密钥密码（RSA）来传递会话密钥K<sub>s</sub>。</li><li>已经被提出的5种信息攻击/安全问题<ul><li>泄露</li><li>流量分析</li><li>冒充</li><li>篡改：内容 / 顺序 / 时间 篡改</li><li>拒绝服务 / 推诿</li></ul></li><li>解决方法：<ul><li>信息保密：泄露，流量分析</li><li>数字签名：拒绝服务/推诿</li><li>消息认证： 冒充，篡改</li></ul></li></ul><h3 id="7-2-消息认证"><a href="#7-2-消息认证" class="headerlink" title="7.2 消息认证"></a>7.2 消息认证</h3><h5 id="消息认证"><a href="#消息认证" class="headerlink" title="消息认证"></a>消息认证</h5><ul><li>消息认证：验证所受到的消息确实是来自真正的发送方，且是未被修改的消息，也可以验证消息的顺序和及时性。 <ul><li>数字签名是消息认证机制之一。</li></ul></li><li>不同级别的消息认证：消息身份验证的两个基本级别部署机制</li><li>基础 - 低级别：身份验证<ul><li>消息加密</li><li>消息认证码(MAC)</li><li>Hash函数</li></ul></li><li>应用 - 高级别：身份认证协议<ul><li>PGP ( Pretty Good Privacy)</li><li>Kerberos </li></ul></li><li>对于对称加密，提供：<ul><li>保密</li><li>消息认证(eg. CBC模式)</li></ul></li><li>对于公钥加密，提供：<ul><li>消息认证：发送方用自己的私钥给消息加密，它提供了数字签名。</li><li>保密：发送方用接收方的公钥给已加密的消息再次加密，提供了保密性。</li></ul></li></ul><h5 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h5><ul><li>利用密钥来生成一个固定长度的<strong>短数据块</strong>，并将该数据块附加在消息之后。</li><li>假设A和B共享一个密钥，当A向B发送消息时：<ul><li>A计算MAC，<strong>它是消息和密钥的函数</strong>：MAC = C<sub>K</sub>(M)</li><li>消息和MAC一起发送给接收方B</li><li>当接收到消息后，B用同样的方式计算出MAC，并与接收到的MAC进行比较：MAC’ = C<sub>K</sub>(M)</li><li>如果MAC = MAC’ 则消息得到认证。</li></ul></li><li>MAC函数与加密类似，但是<strong>MAC算法不要求可逆性</strong>，而加密算法必须可逆。</li><li>MAC函数不能提供数字签名机制。MAC使用对称加密，既然一方能够验证你的MAC，就能够伪造你的MAC，因为发送方和接收方的秘钥是一样的。</li><li><strong>消息摘要与MAC的区别</strong><ul><li><strong>消息摘要只能保证消息的完整性</strong>。攻击者可以将原始消息和摘要都篡改成新的消息和摘要。而MAC由于是消息和密钥的函数，攻击者无法生成与篡改后内容匹配的MAC。</li><li>MAC不仅能够保证完整性，还能够保证真实性</li></ul></li></ul><h5 id="Hash函数-P239"><a href="#Hash函数-P239" class="headerlink" title="Hash函数 P239"></a>Hash函数 P239</h5><ul><li>发送者根据待发送的消息使用Hash函数计算一组Hash值，然后将Hash值和消息一起发送过去。</li><li>使用Hash函数的原因：<ul><li>加密软件速度慢</li><li>加密硬件成本不容忽视</li><li>加密硬件的优化通常是针对大数据的</li><li>加密算法可能受专利保护</li><li>加密算法受美国出口管制</li></ul></li><li>哈希函数的要求 <strong>P245</strong><ol><li>H（x）可以应用于任何大小的数据块x</li><li>H（x）产生固定长度的输出</li><li>3.对于任何给定的x，H（x）相对容易计算，使得硬件和软件实现都是现实的。</li><li>单向性：对于任何给定的代码h，它是计算上的不可能找到x使得H（x）= h。</li><li>弱碰撞阻力：对于任何给定的x，找到y≠x -&gt; H(y) = H(x)在计算上是不可行的。</li><li>6.强抗碰撞性：找到任何（x，y）使得H（x）= H（y）在计算上是不可行的。</li></ol></li><li>两个简单的Hash函数：<ul><li>最简单的Hash函数是每个块的逐位异或：C<sub>i</sub> = b<sub>i1</sub> ⊕ b<sub>i2</sub> ⊕ …  ⊕ b<sub>im</sub></li><li>Hash算法包括重复地使用一个压缩函数f：输入为链接变量(上一步的n位输入)和一个b位的块，产生一个n位的输出。<strong>P248</strong></li></ul></li><li>Hash函数的应用<ul><li>消息摘要</li><li>密码/口令保护</li><li>防止重放攻击：用户和Auth Sever秘密共享一个seed，Hash<sup>N-x(seed)，N是一个很大的初始值，x是登录验证的次数。(<strong><code>重放攻击</code></strong>是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，<strong>主要用于身份认证过程</strong>，破坏认证的正确性。)</sup></li></ul></li></ul><h5 id="安全Hash算法-SHA"><a href="#安全Hash算法-SHA" class="headerlink" title="安全Hash算法 SHA"></a>安全Hash算法 SHA</h5><ul><li>SHA-1 来自 MD4</li><li>SHA-2 family：SHA-224, SHA-256, SHA-384和SHA-512<br><img src="/Cryptography/SHA512.png" width="60%"></li></ul><h5 id="消息摘要"><a href="#消息摘要" class="headerlink" title="消息摘要"></a>消息摘要</h5><ul><li>MD5消息摘要算法<ul><li>MD5消息摘要算法由1990年麻省理工学院的Ron Rivest创建</li><li>它将任意长度的消息(但会分成512bits一组)作为输入并产生<strong>128位消息摘要</strong>作为输出。</li></ul></li></ul><h2 id="8-数字签名"><a href="#8-数字签名" class="headerlink" title="8. 数字签名"></a>8. 数字签名</h2><h3 id="8-1-数字签名简介"><a href="#8-1-数字签名简介" class="headerlink" title="8.1 数字签名简介"></a>8.1 数字签名简介</h3><h5 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h5><ul><li>数字签名或数字签名方案是用于证明数字消息或文档的真实性的数学方案。</li><li>有效的数字签名使接收方有理由相信该消息是由已知接收方创建的，并且该邮件在传输过程中未被更改。</li><li>数字签名通常用于软件分发，金融交易，以及其他情况需要检测修改的情况。</li></ul><h5 id="数字签名的特征"><a href="#数字签名的特征" class="headerlink" title="数字签名的特征"></a>数字签名的特征</h5><ul><li>能验证签名者、签名日期和时间</li><li>能认证被签的消息内容</li><li>签名应能由第三方仲裁，以解决争执</li></ul><h5 id="数字签名需求"><a href="#数字签名需求" class="headerlink" title="数字签名需求"></a>数字签名需求</h5><ul><li>签名必须是与消息相关的二进制串</li><li>签名必须使用发送方某些独有的信息，以防伪造和否认</li><li>产生、识别和验证数字签名比较容易</li><li>伪造数字签名在计算上是不可行的</li><li>保存数字签名副本是可行的</li></ul><p><img src="/Cryptography/数字签名.png" width="55%"></p><h5 id="数字签名过程-P300"><a href="#数字签名过程-P300" class="headerlink" title="数字签名过程 P300"></a>数字签名过程 P300</h5><ul><li>数字签名需要<strong>公钥系统</strong>。</li><li>签名者用他的私钥签名，验证者使用签名者的公钥进行验证。<br><img src="/Cryptography/数字签名1.png" width="55%"><br><img src="/Cryptography/数字签名2.png" width="55%"></li></ul><h5 id="数字签名提供的安全服务"><a href="#数字签名提供的安全服务" class="headerlink" title="数字签名提供的安全服务"></a>数字签名提供的安全服务</h5><ul><li>消息验证</li><li>消息完整性</li><li>防止抵赖</li><li>消息完整性</li></ul><h3 id="8-2-数字签名方案"><a href="#8-2-数字签名方案" class="headerlink" title="8.2 数字签名方案"></a>8.2 数字签名方案</h3><h5 id="RSA数字签名方案-P305"><a href="#RSA数字签名方案-P305" class="headerlink" title="RSA数字签名方案 P305"></a>RSA数字签名方案 P305</h5><p><img src="/Cryptography/RSA.png" width="50%"><br><img src="/Cryptography/DSA.png" width="50%"></p><h3 id="8-3-用户认证协议-P348"><a href="#8-3-用户认证协议-P348" class="headerlink" title="8.3 用户认证协议 P348"></a>8.3 用户认证协议 P348</h3><h5 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h5><ul><li>Kerberos概述：<ul><li>Kerberos是一种计算机网络认证协议，它允许通过非安全网络进行通信的节点以安全的方式相互证明其身份。</li><li>它也是麻省理工学院出版的一套免费软件，它实现了这个协议。</li><li>麻省理工学院开发了Kerberos来保护Project Athena提供的网络服务</li><li>存在多种版本的协议; 版本1-3仅在麻省理工学院内部发生。</li><li>版本4发表于20世纪80年代后期</li><li>版本5在1993年作为RFC 1510出现<br><img src="/Cryptography/Ker.png" width="70%"></li></ul></li><li>一个全方位服务的Kerberos环境包括：<ul><li>1个Kerberos服务器</li><li>多个客户端</li><li>多个应用服务器</li></ul></li><li>Kerberos环境要求：<ul><li>Kerberos服务器必须具有该用户ID和密码</li><li>Kerberos服务器必须与每一个服务器共享密钥  </li></ul></li></ul><blockquote><p>这种环境被称为领域</p></blockquote><h5 id="X-509"><a href="#X-509" class="headerlink" title="X.509"></a>X.509</h5><ul><li>X.509是用于单点登录（SSO）和权益管理基础设施（PMI）的公钥基础设施（PKI）的ITU-T（国际电信联盟）标准。</li><li>X.509除其他外指定了公钥证书，证书撤回列表，属性证书和证书路径确认算法的标准格式。<br>有关X.509的详细信息，请参阅第14.2节或维基百科</li></ul><h3 id="8-4-PGP-P445"><a href="#8-4-PGP-P445" class="headerlink" title="8.4 PGP P445"></a>8.4 PGP P445</h3><h5 id="PGP概述"><a href="#PGP概述" class="headerlink" title="PGP概述"></a>PGP概述</h5><ul><li>Pretty Good Privacy（PGP）是一种提供加密隐私和身份验证的计算机程序。</li><li>PGP通常用于签名，加密和解密电子邮件，以提高电子邮件通信的安全性。<br>它由Philip Zimmermann于1991年创建。<br>PGP和其他类似产品遵循OpenPGP标准（RFC 4880）来加密和解密数据。  </li><li>PGP-用户认证：<strong>P448</strong><br><img src="/Cryptography/PGP.png" width="50%"></li><li>PGP-保密：<br><img src="/Cryptography/PGP2.png" width="50%"></li><li>PGP-保密且认证<br><img src="/Cryptography/PGP3.png" width="60%"> </li></ul><h2 id="9-网络安全"><a href="#9-网络安全" class="headerlink" title="9. 网络安全"></a>9. 网络安全</h2><h3 id="9-1-网络安全概述-P396"><a href="#9-1-网络安全概述-P396" class="headerlink" title="9.1 网络安全概述 P396"></a>9.1 网络安全概述 P396</h3><ul><li>Web现在被广泛使用：政府、企业、个人，但互联网和Web容易受到攻击</li><li>TCP/IP 上的HTTP需要增加安全机制。</li><li>有各种各样的威胁：<ul><li>完整性</li><li>保密性</li><li>拒绝服务</li><li>认证 </li></ul></li><li>在哪里添加安全机制？<br><img src="/Cryptography/网络安全.png" width="40%"> </li></ul><h3 id="9-2-SSL-TLS"><a href="#9-2-SSL-TLS" class="headerlink" title="9.2 SSL / TLS"></a>9.2 SSL / TLS</h3><h5 id="SSL-TLS-P-397"><a href="#SSL-TLS-P-397" class="headerlink" title="SSL / TLS P 397"></a>SSL / TLS P 397</h5><ul><li>SSL：安全套接字层<ul><li>版本：1-3</li><li>最初由Netscape开发</li><li>使用TCP提供可靠和安全的端到端服务</li><li>SSL位于<strong>应用层和传输层之下</strong></li><li>SSL有两层四个协议</li></ul></li><li>TLS：传输层安全协议<ul><li>版本：1.1-1.2</li><li>TLS是SSL的继承者</li><li>成为互联网标准（RFC 2246）</li></ul></li></ul><h5 id="SSL-TLS提供服务："><a href="#SSL-TLS提供服务：" class="headerlink" title="SSL / TLS提供服务："></a>SSL / TLS提供服务：</h5><ul><li>Fragmentation(碎片?分段?)</li><li>压缩</li><li>消息完整性：MAC/HMA, 数字签名(公钥加密)</li><li>保密性：密钥交换(公钥加密)，对称密钥加密</li><li>Framing(取景? 框架？)</li></ul><h5 id="SSL-TLS-安全机制"><a href="#SSL-TLS-安全机制" class="headerlink" title="SSL/TLS 安全机制"></a>SSL/TLS 安全机制</h5><ul><li><p>密钥交换算法  - 保密性<br><img src="/Cryptography/Keyex.png" width="55%"> </p><ul><li>RSA<br><img src="/Cryptography/key1.png" width="55%"> </li><li>Anonymous(匿名的) Diffie-Hellman<br><img src="/Cryptography/key2.png" width="55%"> </li><li>Ephemeral(短暂的) Diffie-Hellman<br><img src="/Cryptography/key3.png" width="55%"></li></ul></li><li><p>对称加密/解密算法 - 保密性<br><img src="/Cryptography/ssl1.png" width="60%"></p></li><li>Hash函数 - 消息完整性<br><img src="/Cryptography/ssl2.png" width="55%"></li></ul><h5 id="SSL-TLS-结构"><a href="#SSL-TLS-结构" class="headerlink" title="SSL/TLS 结构"></a>SSL/TLS 结构</h5><ul><li>2层</li><li>4 个协议<br><img src="/Cryptography/sll3.png" width="40%"></li><li><strong>SSL / TLS 记录协议</strong>(Record Protocol)<ul><li>提供的安全服务：保密性，完整性</li><li>如何利用HMAC算法和会话密钥同意：握手 </li><li><img src="/Cryptography/sslrecord.png" width="55%"></li></ul></li><li><strong>SSL / TLS 握手协议</strong><ul><li>允许服务器和客户端：1. 相互认证 2. 协商加密和MAC算法 3. 协商要使用的加密密钥 </li><li>包括一系列分阶段的消息： 建立安全功能  -&gt; 服务器验证和密钥交换 -&gt; 客户端验证和密钥交换 -&gt; 结束<br><img src="/Cryptography/hs.png" width="50%"> <img src="/Cryptography/hs12.png" width="35%"><br><img src="/Cryptography/hs1.png" width="50%">  <img src="/Cryptography/hs13.png" width="40%">  <img src="/Cryptography/hs2.png" width="50%"><img src="/Cryptography/hs22.png" width="50%"><br><img src="/Cryptography/hs3.png" width="50%">  <img src="/Cryptography/hs32.png" width="50%"></li></ul></li></ul><h3 id="9-3-Wireshark-实验-TLS1-2"><a href="#9-3-Wireshark-实验-TLS1-2" class="headerlink" title="9.3 Wireshark 实验 - TLS1.2"></a>9.3 Wireshark 实验 - TLS1.2</h3><ul><li>POP3 and SMTP <strong>over TCP</strong><br><img src="/Cryptography/tcp1.png" width="30%"><img src="/Cryptography/tcp2.png" width="30%"></li><li>POP3 and SMTP <strong>over TLS</strong><br><img src="/Cryptography/pop31.png" width="30%"><img src="/Cryptography/pop32.png" width="30%"></li><li>Mail Agent(邮件代理): Foxmail 7.x</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;h3 id=&quot;1-1-计算机安全概念&quot;&gt;&lt;a href=&quot;#1-1-计算机安全概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 计算机安全概念&quot;&gt;&lt;/a&gt;1.1 计算机安全概念&lt;/h3&gt;&lt;p&gt;网络和Internet安全领域涉及阻止、防止、检测和纠正信息传输中出现的安全违规欣慰的措施。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>软件需求笔记</title>
    <link href="http://daisine.me/require/"/>
    <id>http://daisine.me/require/</id>
    <published>2019-05-10T03:47:27.000Z</published>
    <updated>2019-05-10T03:48:19.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-基本的软件需求"><a href="#1-基本的软件需求" class="headerlink" title="1. 基本的软件需求"></a>1. 基本的软件需求</h2><h3 id="1-1-软件需求"><a href="#1-1-软件需求" class="headerlink" title="1.1 软件需求"></a>1.1 软件需求</h3><ul><li>要解决的问题是：<ul><li>什么是软件需求？</li><li>为什么要实现软件需求？</li><li>哪些人应参与软件需求<a id="more"></a></li></ul></li><li><strong>需求分析模型：</strong><br><img src="/require/需求分析模型.png" width="40%"><img src="/require/需求分析模型2.png" width="40%"></li><li>软件需求活动 <ul><li>需求诱导 → 需求分析 → 需求传递 → 需求确认 → 需求演化  </li></ul></li><li>IEEE软件工程标准词汇表中定义<strong>软件需求</strong>为：<br>（1）<strong>用户</strong>为解决某个问题或达到目标而需具备的条件或能力。<br>（2）<strong>系统</strong>或系统部件为满足合同、标准、规范或其它正式文档而必须满足的条件或能力。<br>（3）上述（1）或（2）中定义的条件或能力的<strong>文档表达</strong>。 </li><li>需求分析：<ul><li>分析软件用户的需求，细致的进行、调查，把用户“做什么”的要求，最终转换为一个完全的、精细的软件逻辑模型。</li><li>并写出软件的需求规格说明。</li><li>准确地表达用户的要求。</li></ul></li><li><strong>需求的层次</strong><ul><li><strong>业务需求</strong>：表示组织或客户高层次的目标。描述了组织为什么要开发一个系统，即目标。可以用前景和范围文档表述。</li><li><strong>用户需求</strong>：描述的是用户的目标，或用户要求系统必须能完成的任务，即用户能使用系统来做些什么。可以用用例、场景描述和时间-响应表表述。</li><li><strong>功能需求</strong>：规定开发人员必须在产品中实现的软件功能，用户利用这些功能来完成任务，满足业务需求，即开发人员需要实现什么。<br><img src="/require/产物.png" width="50%"></li></ul></li><li>需求不应该包括：<ul><li>设计和实现的细节</li><li>项目计划信息</li><li>测试信息</li></ul></li></ul><h3 id="1-2-需求工程"><a href="#1-2-需求工程" class="headerlink" title="1.2 需求工程"></a>1.2 需求工程</h3><h5 id="1-需求开发"><a href="#1-需求开发" class="headerlink" title="1. 需求开发"></a>1. 需求开发</h5><ul><li>需求开发的过程：<ul><li><strong>诱导 → 分析 → 规范化 → 确认</strong></li></ul></li></ul><h5 id="2-需求管理"><a href="#2-需求管理" class="headerlink" title="2. 需求管理"></a>2. 需求管理</h5><ul><li><strong>需求管理的4个主要内容</strong>：<ol><li><strong>变更控制</strong>：建议变更；分析影响；作出决策；交流；合并；测量需求的稳定性。</li><li><strong>版本控制</strong>：确定需求文档版本；确定单个需求文档版本。</li><li><strong>需求跟踪</strong>：定义对其它需求的连接链；定义对其它系统元素的连接。</li><li><strong>需求跟踪状态</strong>：定义需求状态；跟踪需求每一个状态。</li></ol></li><li>需求开发与需求管理的分界<br><img src="/require/界限.png" width="30%"></li></ul><h5 id="需求的好坏"><a href="#需求的好坏" class="headerlink" title="需求的好坏"></a>需求的好坏</h5><ul><li><strong>糟糕的需求</strong><ul><li>用户参与不足</li><li>用户需求扩展</li><li>有歧义的需求</li><li>镀金问题</li><li>过于抽象的需求</li><li>忽略了某类用户</li><li>不准确的计划</li></ul></li><li><strong>理想情况下需求的性质</strong><ul><li>完整的</li><li>正确的</li><li>可行的</li><li>必须的</li><li>优先化的 / 有优先次序的</li><li>清楚的 / 无歧义的</li><li>可检验的 / 可验证性</li></ul></li><li><strong>需求规格说明的特点</strong><ul><li>完整性</li><li>一致性</li><li>可修改性</li><li>可跟踪性</li></ul></li></ul><h2 id="2-客户眼中的需求"><a href="#2-客户眼中的需求" class="headerlink" title="2. 客户眼中的需求"></a>2. 客户眼中的需求</h2><h5 id="用户：是一种泛称"><a href="#用户：是一种泛称" class="headerlink" title="用户：是一种泛称"></a>用户：是一种泛称</h5><ul><li>掏钱买软件的用户称为<strong>客户</strong></li><li>真正操作软件的用户叫<strong>最终用户</strong></li><li><strong>间接用户</strong>既不掏钱买该软件产品，也不使用该软件，但是它可能对软件产品有很大的影响。<ul><li>eg. 财务软件 -&gt; <strong>国家财政局</strong>审核</li><li>客户与最终用户可能是同一个人也可能不是同一个人</li></ul></li></ul><h5 id="涉众"><a href="#涉众" class="headerlink" title="涉众"></a>涉众</h5><ul><li><strong>涉众</strong>：在软件开发项目中主要是<strong>指和这个项目有密切相关利益的人</strong>，他们共同感兴趣的就是需求分析阶段。</li><li>这些涉众包括客户、用户、业务或需求分析员、开发人员、测试人员、用户文档编写者、项目管理者和客户管理者。 <ul><li>需求分析员：负责收集客户需求并编写文档，以及负责客户与开发机构之间联系沟通的人</li></ul></li></ul><h5 id="软件客户的权利"><a href="#软件客户的权利" class="headerlink" title="软件客户的权利(!!!)"></a>软件客户的权利(!!!)</h5><ol><li>要求需求分析员<strong>使用客户的语言</strong></li><li>要求需求分析员<strong>熟悉客户的业务，了解客户对系统的目标</strong></li><li>要求需求分析员<strong>把需求收集过程中客户提供的信息组织成书面的<code>软件需求规格说明</code></strong></li><li>要求需求分析员<strong>解释需求过程生成的所有工作结果</strong></li><li>要求需求分析员和开发人员尊重客户，始终以合作和专业的态度与客户进行互动</li><li>要求需求分析员和开发人员为需求和产品实现提供思路和备用方案</li><li>要求开发人员实现能让产品使用起来更容易、更有趣的特性</li><li><strong>调整需求</strong>，便于重用已有的软件组件</li><li>在提<strong>出需求变更时，获得对变更的成本</strong>、影响及二者权衡关系的真实评估</li><li>获得满足功能和质量要求的系统，这些要求必须事先告知开发人员征得其同意</li></ol><h5 id="软件客户的义务"><a href="#软件客户的义务" class="headerlink" title="软件客户的义务"></a>软件客户的义务</h5><ol><li>为需求分析员和开发人员<strong>讲解业务</strong>并<strong>定义业务术语</strong></li><li>提供需求，阐明需求，通过与开发人员的交互将<strong>需求充实完善</strong></li><li>对系统需求的<strong>描述</strong>必须<strong>详细、准确</strong></li><li>需要时，及时对需求做出决断</li><li><strong>尊重</strong>开发人员对需求<strong>成本和可行性的评估</strong></li><li>与开发人员<strong>协作</strong>，为功能需求、系统特性和用例<strong>设置优先级</strong></li><li><strong>审阅</strong>需求文档，评估原型</li><li>发现需要变更需求时，<strong>及时</strong>与开发人员<strong>沟通</strong></li><li>按照开发组织的变更控制过程<strong>提出需求变更</strong></li><li>尊重需求分析员在需求工程中使用的过程</li></ol><h2 id="3-需求工程的推荐方法"><a href="#3-需求工程的推荐方法" class="headerlink" title="3. 需求工程的推荐方法"></a>3. 需求工程的推荐方法</h2><ul><li><strong>需求工程的推荐方法：</strong><ul><li>知识技能</li><li>需求管理 </li><li>项目管理 </li></ul></li><li><strong>需求开发：</strong><ul><li>获取 </li><li>分析 </li><li>编写规格说明书 </li><li>验证  </li></ul></li></ul><h2 id="4-需求分析员"><a href="#4-需求分析员" class="headerlink" title="4. 需求分析员"></a>4. 需求分析员</h2><ul><li><strong>需求分析员</strong>：<ul><li>是<strong>对软件项目设计的需求进行收集、分析、记录和验证等工作的主要承担者。</strong></li><li>是用户群体和软件开发团队之间进行需求沟通的桥梁。</li><li>是收集和传播的中心角色。</li><li>需求分析员是一种项目角色，而不是职务头衔。</li><li>需求分析员称职与否关系到项目的成败。</li></ul></li><li><strong>需求分析员的任务</strong> <strong>深刻了解</strong><ul><li>定义业务需求</li><li>确定项目涉众和用户类别</li><li>获取需求</li><li>分析需求</li><li>编写需求规格说明</li><li>为需求建模</li><li>主持对需求的验证</li><li>引导对需求的优先级划分</li><li>管理需求</li></ul></li><li><strong>需求分析员的来源</strong>：<ul><li>从<strong>用户</strong>转为分析员</li><li>从<strong>开发人员</strong>转为分析员</li><li>应用领域专家 / 主题专家</li></ul></li></ul><h2 id="5-确定产品前景与项目范围"><a href="#5-确定产品前景与项目范围" class="headerlink" title="5. 确定产品前景与项目范围"></a>5. 确定产品前景与项目范围</h2><ul><li>项目视图：描述了产品所涉及的各个方面和最终所具有的功能。 </li><li>项目范围：<ul><li>描述了产品应包括的部分和不应包括的部分。</li><li>说明了在包括的部分与不包括的部分之间的界线。</li></ul></li></ul><h5 id="前景与范围文档"><a href="#前景与范围文档" class="headerlink" title="前景与范围文档"></a>前景与范围文档</h5><ul><li><strong>业务需求</strong><ul><li>包括<strong>背景、业务机遇、业务目标与成功标准、客户与市场需求、业务风险</strong></li></ul></li><li>解决方案的前景<ul><li>包括前景声明、主要特征、假设与依赖</li></ul></li><li>范围与限制<ul><li>包括第一个版本的范围、各后续版本的范围、限制与排除</li></ul></li><li>业务背景<ul><li>包括涉及简介、项目优先级、操作环境</li></ul></li></ul><h5 id="DFD图"><a href="#DFD图" class="headerlink" title="DFD图"></a>DFD图</h5><ul><li>关联图（0层DFD） ：<ul><li>确定了通过某一接口与系统相连的<strong>外部实体</strong>。有时，称为“端点”。</li><li>以及，外部实体和系统之间的数据流和物流</li><li>我们把<strong>关联图</strong>，作为结构化分析方法，形成<strong>数据流图</strong>的<strong>最高抽象层</strong>。 </li></ul></li></ul><h2 id="6-获取客户的需求"><a href="#6-获取客户的需求" class="headerlink" title="6. 获取客户的需求"></a>6. 获取客户的需求</h2><ul><li><strong>需求的来源</strong><ol><li>与潜在的用户进行交谈和讨论</li></ol><ul><li>描述现有产品或竞争产品的文档</li><li>系统需求规格说明</li><li>现有系统的问题报告和改进要求</li><li>市场调查和用户问卷调查</li><li>观察用户如何工作</li><li>用户工作的情景分析</li><li>时间和响应</li></ul></li><li><strong>用户代言人</strong><ul><li>用户代言人本身就是实际用户</li><li><strong>外部的用户代言人</strong></li><li>对用户代言人的要求：计划、需求、确认和验证、用户辅助、变更控制</li><li>设置多位用户代言人</li><li>设置用户代言人会出现和应避免的问题 P72</li></ul></li><li><strong>步骤</strong><ul><li><strong>准备调查</strong>：首先，需求分析员应当起草需求调查问题表，将调查重点锁定在该问题表内，否则调查工作将变得漫无边际。其次，需求分析员应当确定需求调查的方式。最后需求分析员与被调查者建立联系，确定调查的时间、地点、人员等。</li><li><strong>执行调查</strong>：按照计划执行调查。在调查过程中随时记录（或存储）需求信息。需求分析员与用户面谈时应守时，先去了解用户的身份、背景。</li></ul></li><li>为了征求客户的意见，必须采取以下几步：<ul><li>明确项目用户需求的来源。</li><li>明确使用该产品的不同类型的用户。</li><li>与产品不同用户类的代表进行沟通。</li><li>遵从项目的最终决策者的意见。</li></ul></li></ul><h2 id="7-聆听客户的需求"><a href="#7-聆听客户的需求" class="headerlink" title="7. 聆听客户的需求"></a>7. 聆听客户的需求</h2><h5 id="需求获取"><a href="#需求获取" class="headerlink" title="需求获取"></a>需求获取</h5><ul><li>需求获取是最困难、最关键、最容易出错和最需要沟通的环节</li><li>需求获取的方式：面谈、小组讨论、解决冲突等</li><li>多问“为什么”</li><li>获得业务问题或总体特性</li><li>设身处地</li><li>对现有系统最感到烦恼的事情是什么？</li><li>工作流程—流程图和判定树</li><li>编写文档及评审</li></ul><h5 id="需求获取讨论会"><a href="#需求获取讨论会" class="headerlink" title="需求获取讨论会"></a>需求获取讨论会</h5><ul><li>建立基本规则</li><li>不超出范围（项目范围）</li><li>使用活动挂图来捕获以后再考虑的一些条目</li><li>时间盒讨论</li><li>保持较小的团队规模并找到合适的参与者（人多误事）</li><li>确保每个人都积极地参与讨论</li></ul><h5 id="将客户的意见归类"><a href="#将客户的意见归类" class="headerlink" title="将客户的意见归类"></a>将客户的意见归类</h5><ul><li>业务需求</li><li>用例或场景</li><li>业务规则</li><li>功能性需求</li><li>质量属性</li><li>外部接口需求</li><li>约束</li><li>数据定义</li><li>解决思路</li></ul><h2 id="8-理解用户需求"><a href="#8-理解用户需求" class="headerlink" title="8. 理解用户需求"></a>8. 理解用户需求</h2><ul><li>需要了解 使用用例获取方法  </li><li><strong>使用用例产生的成果：数据字典</strong><br><img src="/require/使用用例.png" width="50%"></li></ul><h5 id="使用用例的好处"><a href="#使用用例的好处" class="headerlink" title="使用用例的好处"></a>使用用例的好处</h5><ul><li>使用户更清楚地认识到新系统允许他们做什么</li><li>防止“孤立”的功能</li><li>揭示对象以及它们之间的责任</li></ul><h5 id="使用用例时应避免的问题"><a href="#使用用例时应避免的问题" class="headerlink" title="使用用例时应避免的问题"></a>使用用例时应避免的问题</h5><ol><li><strong>太多</strong>的使用用例 </li><li>使用用例的<strong>冗余</strong> </li><li>使用用例中的<strong>用户界面的设计</strong> </li><li>使用用例中<strong>包括数据定义</strong> </li><li>试图把每一个需求与一个使用实例相联系</li></ol><h5 id="需求整理和分析的过程"><a href="#需求整理和分析的过程" class="headerlink" title="需求整理和分析的过程"></a>需求整理和分析的过程</h5><ul><li>需求收集 -&gt; 解释原始数据 -&gt; 整理需求 -&gt; 设置权重 -&gt; 概念选择</li><li>整理单项需求：黄纸贴</li><li>头脑风暴</li></ul><h5 id="单项需求重要性定义（BSA）"><a href="#单项需求重要性定义（BSA）" class="headerlink" title="单项需求重要性定义（BSA）"></a>单项需求重要性定义（BSA）</h5><ul><li>B（Basic）：基本需求</li><li>S（Satisfied）：让客户更满意的需求 </li><li>A（Attractive）：更有吸引力的需求</li></ul><h2 id="9-遵守规则"><a href="#9-遵守规则" class="headerlink" title="9. 遵守规则"></a>9. 遵守规则</h2><ul><li>遵守业务规则（从讨论会来）</li><li>业务规则：是对业务的某个方面进行定义或约束的语句<ul><li>eg. 政策性法规</li></ul></li><li>业务规则的<strong>分类</strong>：<ul><li>事件</li><li>约束</li><li>动作触发规则</li><li>计算</li><li>推论</li></ul></li></ul><h2 id="10-编写需求文档"><a href="#10-编写需求文档" class="headerlink" title="10. 编写需求文档"></a>10. 编写需求文档</h2><ul><li><strong>软件需求规格说明</strong><ul><li>精确地阐述了一个软件系统必须提供的功能和性能，以及所要考虑的限制条件。</li><li>是一个软件系统成功的基础</li></ul></li><li>编写软件需求规格说明的<strong>三种方法</strong>：<ul><li><strong>用好的结构化和自然语言编写文本型文档</strong></li><li><strong>建立图形化模型方法：</strong>模型可以描绘转换过程、系统状态和它们之间的变化、数据关系、逻辑流或对象类和它们的关系。</li><li><strong>编写形式化规格说明：</strong>这可以通过使用数学上精确的形式化逻辑语言来定义需求。</li></ul></li><li>高质量需求文档，所具有的特征：<ul><li>完整性</li><li>一致性</li><li>必要性</li><li>明确性</li><li>可验证性</li><li>可更改性</li><li>可跟踪性</li></ul></li><li>注意事项：(最后的分析题可以用到)<ul><li>对节、小节和单个需求的号码编排，必须一致。</li><li>正确使用各种可视化强调标志 —— 例如，黑体、下划线、斜体等</li><li>创建目录表和索引表，有助于读者寻找所需的信息。</li><li>对所有图和表，指定号码和标识号，并且可按号码进行查阅。</li><li>使用字处理程序中，交叉引用的功能，来查阅文档中其它项或位置。</li></ul></li><li>优秀的需求文档应该考虑： <ul><li>保持语句和段落的简短。</li><li>采用主动语态的表达方式。</li><li>编写具有正确的语法、拼写和标点的完整句子。</li><li>使用的术语与词汇表中所定义的应该一致。</li><li>需求陈述应该具有一致的样式。</li><li>为了减少不确定性，避免模糊的、主观的术语。</li><li>避免使用比较性的词汇</li></ul></li><li>编号：<ol><li>序列号   如：UR-9、SRS-43</li><li>层次化编码 如：3.2.1</li><li>层次化文本标签  </li></ol></li><li>数据字典<ul><li>数据字典是一个共享存储库，用于定义应用程序中使用的所有数据元素或属性的含义、数据类型、长度、格式、需要的精度以及数据允许的取值范围或数据值的列表。</li><li>数据字典与数据流图配合，能清楚地表达数据处理的要求</li></ul></li></ul><h2 id="11-需求的图形化分析"><a href="#11-需求的图形化分析" class="headerlink" title="11. 需求的图形化分析"></a>11. 需求的图形化分析</h2><ul><li><strong>软件系统从三个方面来表达</strong><ul><li><strong>过程</strong>：数据流图 </li><li><strong>数据</strong>：实体-关系图 </li><li><strong>状态</strong>：状态转换图，对话图，判定表和树。</li></ul></li><li><strong>数据流图</strong>：一个数据流图可以标识系统的转换过程、系统所操纵的数据或物质集合（存储），以及过程、存储和外部世界之间的数据流或物质流。<ul><li><strong>过程</strong>：用<strong>圆圈</strong>表示</li><li><strong>端点</strong>：用<strong>矩形框</strong>表示</li><li><strong>数据流</strong>：用<strong>箭头</strong>表示</li><li><strong>数据存储区</strong>：用<strong>一对平行线</strong>表示</li></ul></li><li><strong>实体-关系图</strong>：描绘了系统的数据关系<ul><li><strong>实体</strong>用单名词来命名。用<strong>矩形</strong>框表示。</li><li>每个实体要用几个<strong>属性</strong>来描述，每个实体的单个实例具有不同的属性值。</li><li><strong>关系</strong>用能描述关系的本质来命名，它确定了一对实体之间在逻辑上和数量上的连接。用<strong>菱形框</strong>表示。</li></ul></li><li><strong>状态转换图</strong>：表示处理结果可能的状态转换。<ul><li><strong>系统状态</strong>，用<strong>矩形框</strong>表示。</li><li><strong>状态改变</strong>，用<strong>箭头连接一对矩形框</strong>表示。</li><li><strong>事件或条件</strong>，在每个迁移箭头上用<strong>文本标签</strong>来表示。</li></ul></li><li>对话图：在<strong>较高的抽象层次上</strong>表示用户界面的设计，它展示了系统的对话元素及这些元素之间的导航连接，但<strong>没有展示</strong>详细的屏幕设计。一种状态转换图<ul><li>每个<strong>对话元素</strong>表示为一个状态，用<strong>矩形框</strong>表示</li><li>将每个允许的<strong>导航选项</strong>表示为一个<strong>转换</strong>，用<strong>箭头</strong>表示。</li><li>触发用户界面导航的<strong>条件</strong>表示为<strong>转换箭头上的文本标签</strong>。</li></ul></li><li>决策表：应用表格的形式进行需求表达。<ul><li>可列出影响系统行为的所有因素的各种取值，并表明对这些因素的每一种组合所期望的系统响应动作。</li></ul></li><li>决策树：采用一种树形结构表达需求。用树形结构表示动作的各种分支。</li></ul><h2 id="12-软件质量属性"><a href="#12-软件质量属性" class="headerlink" title="12. 软件质量属性"></a>12. 软件质量属性</h2><ul><li>质量属性难以挖掘</li><li><strong>软件质量属性</strong>是系统非功能性需求的一部分。<ul><li>非功能需求：描述系统<strong>展现给用户的行为和执行的操作</strong>等。</li></ul></li><li><strong>主要对用户重要的属性</strong> <strong>一定了解</strong> <ul><li><strong>可用性</strong>：系统能够正常运行的时间比例。</li><li><strong>有效性</strong>：系统如何优化处理器、磁盘空间或通信带宽的。</li><li><strong>灵活性</strong>：在产品中，增加新功能时，所需工作量的大小。</li><li><strong>完整性</strong></li><li><strong>互操作性</strong>：表明了产品与其它系统交换数据和服务的难易程度。</li><li><strong>可靠性</strong>：软件无故障执行一段时间的概率。</li><li><strong>健壮性</strong>：是指当系统或其组成部分遇到非法输入数据、相关软件或硬件组成部分的缺陷或异常的操作情况时，能继续正确运行功能的程度。</li><li><strong>易用性</strong>：对于新用户或不常使用产品的用户在学习使用产品时的难易程度。</li></ul></li><li><strong>主要对开发人员重要的属性：</strong> <strong><code>一定了解</code></strong> <ul><li><strong>可维护性</strong>：在软件中纠正一个缺陷或做一次更改的难易程度。</li><li><strong>可移植性</strong>：把一个软件从一种运行环境转移到另一种运行环境中所花费的工作量。对于工程的成功是不重要的。</li><li><strong>可重用性</strong>：除了在最初开发的系统中使用之外，还可以在其它应用程序中使用的程度。</li><li><strong>可测试性</strong>：测试软件组件或集成产品时查找缺陷的难易程度。</li></ul></li></ul><h2 id="13-通过原型法减少项目风险"><a href="#13-通过原型法减少项目风险" class="headerlink" title="13. 通过原型法减少项目风险"></a>13. 通过原型法减少项目风险</h2><ul><li>一个软件原型：<strong>是所提出的新产品的部分实现</strong></li><li><strong>使用软件原型的3个目的：</strong><ul><li>明确并完善需求</li><li>研究设计选择方案</li><li>发展为最终产品</li></ul></li></ul><h5 id="原型的分类"><a href="#原型的分类" class="headerlink" title="原型的分类"></a>原型的分类</h5><ul><li><strong>水平原型</strong>（行为原型或演示性模型）主要描绘用户界面的一部分，<strong>不深入</strong>到体系结构的所有层次。</li><li><strong>垂直原型</strong>（结构化原型或概念模型）主要在技术服务层次上实现应用程序用户界面的一部分功能，它触及到了系统实现的<strong>所有层次。</strong></li><li><strong>进化型原型</strong>是螺旋式软件开发生命周期模型和某些面向对象软件开发过程的一个组成部分。</li><li><strong>废弃型原型</strong>是指达到预期目的后，原型本身被抛弃。<ul><li>用途：解决需求不确定性、二义性、不完整性、含糊性等。</li></ul></li><li><strong>书面原型</strong>和电子原型：用<strong>平面工具</strong>把系统是如何实现的呈现在用户面前。<ul><li>是一种廉价、快速，并且不涉及高技术的方法</li><li>它可以把一个系统某部分，是如何实现的呈现在用户面前。  </li></ul></li><li><strong>使用原型法的若干可能的方法</strong><br><img src="/require/原型.png" width="40%"></li><li><strong>原型法的好处</strong><ol><li>提供了一套强有力的技术</li></ol><ul><li>可以缩短开发进度</li><li>增加用户的满意程度</li><li>生产出高质量的产品</li><li>可以减少需求错误和用户界面的缺陷。 </li></ul></li></ul><h2 id="14-设定需求优先级"><a href="#14-设定需求优先级" class="headerlink" title="14. 设定需求优先级"></a>14. 设定需求优先级</h2><h5 id="为什么要划分优先级"><a href="#为什么要划分优先级" class="headerlink" title="为什么要划分优先级"></a>为什么要划分优先级</h5><ul><li><strong>设定优先级的好处</strong>:<ul><li>有助于项目经理解决冲突、安排阶段性交付，并且，做出必要的取舍。</li><li>尽早确定出所交付的产品应具备的最重要的功能</li><li>权衡合理的项目范围和进度安排、预算以及质量目标的约束</li></ul></li><li>设定优先级的一般方法是<ul><li>把需求分成三类：高、中、低</li></ul></li><li>每一个需求的优先级，必须写入软件需求规格说明或使用实例的说明中。</li></ul><h5 id="基于价值、费用和风险的优先级设定"><a href="#基于价值、费用和风险的优先级设定" class="headerlink" title="基于价值、费用和风险的优先级设定"></a>基于价值、费用和风险的优先级设定</h5><ol><li>列出要设定优先级的所有需求、特性或使用实例；</li></ol><ul><li>估计每一个特性提供给客户或业务的相关利益。</li><li>估计出如果没有把应该实现的特性包括到产品中，将会给客户或业务上带来的损失。</li><li>总价值栏是相对利润和相对损失的总和。<ul><li>总价值 = 相对利益 <em> 利益权值 + 相对损失 </em> 损失权值</li></ul></li><li>估计实现每个特性的相对费用。</li><li>估计出与每个特性相关的技术或风险相对程度。</li><li>一旦把所有的估算写入平面表，就可以利用如下公式计算出每一特性的优先级：<ul><li>优先级 =  价值% / (费用% <em> 费用权值+ 风险% </em> 风险权值)</li></ul></li><li>按计算出的优先级的降序排列表中的特性。   </li></ul><h2 id="15-需求确认"><a href="#15-需求确认" class="headerlink" title="15. 需求确认"></a>15. 需求确认</h2><ul><li>需求确认：是指开发方和客户方共同对《产品需求规格说明书》进行<strong>评审</strong>，双方对需求达成共识后作出<strong>承诺</strong>。</li><li>需求确认包含两个重要工作：<ol><li><strong>需求评审</strong></li><li><strong>需求承诺</strong></li></ol></li><li>评审过程要干些什么 看每一个步骤大概要点<br><img src="/require/审查.png" width="40%"></li><li>需求评审的参与者(5-9人)<ol><li>产品的开发者及其可能的同组成员</li></ol><ul><li>先前产品的开发者或正在评审的项目的SRS编写者</li><li>要根据正在审查的文档来开展工作的人</li></ul></li></ul><h2 id="18-需求管理的原则与实现"><a href="#18-需求管理的原则与实现" class="headerlink" title="18. 需求管理的原则与实现"></a>18. 需求管理的原则与实现</h2><ul><li><strong>需求管理</strong>的4个部分，每部分大概需要做什么。<br><img src="/require/管理.png" width="40%"></li><li><strong>需求基线</strong>-是团队成员已经承诺将在某一特定产品版本中实现的功能性和配功能性需求的一组集合。</li></ul><h2 id="19-变更管理"><a href="#19-变更管理" class="headerlink" title="19. 变更管理"></a>19. 变更管理</h2><ul><li>注意事项：<ol><li>应仔细评估已建议的变更</li><li>挑选合适的人选对变更做出决定</li><li>变更应及时通知所有涉及的人员</li><li>项目要按一定的程序来采纳需求变更</li></ol></li><li>变更控制策略<ol><li>所有需求变更必须遵循一个过程，按照此过程，如果一个变更需求未被采纳，则其后过程不再予以考虑。</li><li>对于未获批准的的变更，除可行性论证之外，不应再做其他设计和实现工作。</li><li>简单请求一个变更不能保证能实现变更，要由项目CCB决定实现哪些变更。</li><li>项目风险承担者应该能够了解变更数据库的内容。</li><li>绝不能从数据库中删除或修改变更请求的原始文档。</li><li>每一个集成的需求变更必须能跟踪到一个经核准的变更请求。</li></ol></li></ul><h4 id="考点：对整个需求过程比较关键的环节的概念比较重要。"><a href="#考点：对整个需求过程比较关键的环节的概念比较重要。" class="headerlink" title="考点：对整个需求过程比较关键的环节的概念比较重要。"></a>考点：对整个需求过程比较关键的环节的概念比较重要。</h4><ul><li>做需求需要哪几个典型阶段</li><li>每个阶段需要哪些参与者</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-基本的软件需求&quot;&gt;&lt;a href=&quot;#1-基本的软件需求&quot; class=&quot;headerlink&quot; title=&quot;1. 基本的软件需求&quot;&gt;&lt;/a&gt;1. 基本的软件需求&lt;/h2&gt;&lt;h3 id=&quot;1-1-软件需求&quot;&gt;&lt;a href=&quot;#1-1-软件需求&quot; class=&quot;headerlink&quot; title=&quot;1.1 软件需求&quot;&gt;&lt;/a&gt;1.1 软件需求&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;要解决的问题是：&lt;ul&gt;
&lt;li&gt;什么是软件需求？&lt;/li&gt;
&lt;li&gt;为什么要实现软件需求？&lt;/li&gt;
&lt;li&gt;哪些人应参与软件需求&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多媒体技术笔记</title>
    <link href="http://daisine.me/media/"/>
    <id>http://daisine.me/media/</id>
    <published>2019-05-10T03:45:47.000Z</published>
    <updated>2019-05-10T03:46:38.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-引论"><a href="#1-引论" class="headerlink" title="1. 引论"></a>1. 引论</h2><h5 id="媒体的分类"><a href="#媒体的分类" class="headerlink" title="媒体的分类"></a>媒体的分类</h5><ul><li><code>感觉媒体</code>: 能直接作用于人的感官，使人直接产生感觉的一类媒体<strong>（作用于人）</strong>。如人类的语言、音乐、自然界的各种声音、图形、图像。</li><li><code>表示媒体</code>: 计算机对信息的表示方法的描述。是<strong>为了加工、处理和传输感觉媒体</strong>而人为研究、构造出来的一种媒体<strong>（作用于计算机)</strong>。具体体现为：编码<a id="more"></a></li><li><code>表现媒体</code>: <strong>感觉媒体和用于通信的电信号之间转换</strong>用的一类媒体，分为输入表现媒体和输出表现媒体。如打印机、音箱、MIDI键盘，扫描仪、键盘、鼠标。除此之外，还有耳麦、轨迹球、绘图仪等<strong>（用于人与计算机交互）</strong></li><li><code>存储媒体</code>: 用于计算机存放<strong>表示媒体</strong>，以便计算机随时处理、加工和调用信息编码。常用的有光盘、硬盘、磁带、活动硬盘、优盘等</li><li><code>传输媒体</code>: 用于传输<strong>表示媒体</strong>，将表示媒体从一处传送到另一处的物理载体。如双绞线、同轴电缆、光纤等</li></ul><h5 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h5><ul><li><strong><code>多媒体</code></strong>是指信息<strong>表示媒体</strong>的多样化，包括文本、图形、图像、声音、音乐、动画、视频等，即多媒体<strong>主要研究表示媒体</strong>。</li><li>性质：<ul><li>多媒体是多种信息载体的<strong>表现</strong>形式、<strong>存储</strong>和<strong>传输</strong>方式的有机集合</li><li>多媒体系统具有<strong>多样性</strong>、<strong>集成性</strong>、<strong>实时性</strong>和<strong>交互性</strong></li></ul></li></ul><h5 id="多媒体系统的体系结构"><a href="#多媒体系统的体系结构" class="headerlink" title="多媒体系统的体系结构"></a>多媒体系统的体系结构</h5><p><img src="/media/体系结构.png" width="30%"></p><ul><li><strong>多媒体应用系统</strong> / 多媒体应用软件：利用多媒体工具软件，针对某一主题<strong>设计开发的具体多媒体应用系统</strong>。</li><li><strong>多媒体创作系统</strong> / 多媒体应用系统开发软件：集成文本、图形、声音、图像、视频和动画等多种媒体信息的编辑和著作工具，是开发多媒体应用系统的平台或环境，可以用于<strong>生成各种多媒体应用系统</strong>。</li><li><strong>媒体制作平台与工具</strong> / 多媒体素材创作软件：利用本层提供的工具及接口可以完成多媒体数据的采集、制作及编辑。</li><li><strong>多媒体核心系统</strong> / 多媒体系统软件：提供硬件层上的基础服务，拥有一系列的服务软件，包括对多种硬件设备的连接、控制，对用户使用的语言环境的支持和解释。其核心是<strong>多媒体操作系统</strong>，还包括<strong>设备驱动程序</strong></li><li><strong>多媒体计算机硬件系统</strong>：包括多媒体计算机<strong>主机系统</strong>（MPC）及各种外围设备的<strong>接口部件</strong>。</li><li><strong>多媒体外围设备</strong>：包括音频、视频等多种媒体的<strong>输入/输出设备和装置</strong>，通信（网络）<strong>传输设备及装置</strong></li></ul><h2 id="2-图形图像技术"><a href="#2-图形图像技术" class="headerlink" title="2. 图形图像技术"></a>2. 图形图像技术</h2><h5 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h5><ul><li>图形（矢量图）是用一系列计算机指令来表示一幅图，如画点、画线、画曲线、画圆、画矩形等。例如，一条直线可以用Line (1,1 5,5)表示（计算机中描述方式？）</li><li>优点<ul><li>存储和传输时数据量较小</li><li>缩放、旋转、移动图形不会失真，能保证质量（可无级缩放）</li><li>适合管理图形的每一部分</li><li>编辑方便</li><li>图块可重用</li></ul></li><li>缺点<ul><li>图形重生成花费时间较长 </li><li>不适合描述彩色图像</li></ul></li></ul><h5 id="图像-位图"><a href="#图像-位图" class="headerlink" title="图像 / 位图"></a>图像 / 位图</h5><ul><li>将一幅图像在<strong>空间</strong>上<strong>离散化</strong>为多个<strong>像素</strong>，每个像素用若干个二进制位来描述其<strong>颜色、亮度和属性</strong></li><li>位图的获取通常使用扫描仪、数码相机、数码摄像机</li><li>优点<ul><li>显示速度快</li><li>表现力强，可适于任何自然图像，细腻、层次多、细节丰富</li></ul></li><li>缺点<ul><li>存储和传输时数据量比较大</li><li>缩放、旋转时算法复杂且容易失真</li><li>矢量图和位图之间可以进行转换</li><li>由矢量图转换成位图采用光栅化技术，转换也相对容易</li><li>由位图转换成矢量图用跟踪技术</li></ul></li></ul><h5 id="采样与量化"><a href="#采样与量化" class="headerlink" title="采样与量化"></a>采样与量化</h5><ul><li>在用计算机进行处理时，需要<strong>对连续信号离散化</strong>。包括空间、时间、幅值上的离散化</li><li>其中<strong>空间/时间</strong>离散称为<strong>采样</strong>，<strong>幅值离散</strong>称为<strong>量化</strong></li><li><p>离散化后的连续信号还需要进行<strong>编码</strong>，以便计算机存储、处理和传输</p></li><li><p>对量化后的数据编码、压缩，生成不同多媒体信息的表示媒体，可以采用多种方案。思考：什么是编码？编码是否等同于压缩？</p><ul><li>对于数据编码不一定压缩数据，但压缩数据的结果一定是一种编码，即编码可以分为非压缩编码和压缩编码</li><li>压缩可以在编码前进行，也可以在编码后针对编码结果进行压缩得到另一种编码</li></ul></li><li><p>输入矢量图时是否需要采样、量化和编码？为什么？</p><ul><li>矢量图在表示方式上采用数学描述，因此在输入时不需要采样和量化，但在计算机内部有其自身的编码方式</li></ul></li></ul><h5 id="颜色模型"><a href="#颜色模型" class="headerlink" title="颜色模型"></a>颜色模型</h5><ul><li><strong><code>RGB</code></strong>：R，G，B分别代表红、绿、蓝三色，<strong>相加混色模型</strong>。用于显示设备。(从黑色开始加)</li><li><strong><code>CMYK</code></strong>：印刷四分色模式，<strong>相减混色模型</strong>。用于打印设备。（从白色开始减）</li><li><strong><code>HSL</code></strong>：H(色调)、S(饱和度)、I(光强度)这3个分量来表示一种颜色。用于人眼。</li><li><strong><code>Lab</code></strong>：颜色-对立空间，带有维度L表示亮度，a和b表示颜色对立维度，<strong>所生成的颜色与所使用的设备无关</strong>。用途：Lab模式可以用作为在不同颜色模式之间转换时使用的中间颜色模式。</li><li><strong><code>Index</code></strong>：索引色彩模式用<strong>8bit</strong>描述，最多可以使用<strong>256种颜色</strong>，采用调色板方式实现。用于减小图片文件的大小，同时基本上不影响视觉效果。(不是真的彩色)</li><li><strong><code>Grayscale</code></strong>：灰度模式用<strong>8bit</strong>描述，最多使用<strong>256级灰度</strong>来表现图像，图像中的每个像素有一个0（黑色）到255（白色）之间的亮度值。主要用于医学、图像识别领域。</li><li><strong><code>Binary</code></strong>：二值图像是每个像素只有两个可能值的数字图像(黑、白)。主要用于数字图像处理研究。</li></ul><blockquote><p>索引色彩模式和灰度模式中，每个像素值都占用一个字节，为什么一种为彩色？一种不为彩色？<br>索引彩色有调色板，灰度模式没有，且灰度模式的索引8bit就是灰度值本身灰度模式和索引色彩模式归为同一类。</p></blockquote><h5 id="位图图像基本属性"><a href="#位图图像基本属性" class="headerlink" title="位图图像基本属性"></a>位图图像基本属性</h5><ul><li><strong>分辨率</strong><ul><li>图像分辨率：构成图像的像素总数，以水平和垂直的像素表示。</li><li>显示分辨率：在某种显示方式下，在屏幕上最大的显示区域中，可显示的像素总数。</li></ul></li><li><strong>颜色深度：</strong>图像每个像素所占用的存储位数。它决定了彩色图像中最多能使用的颜色数，或者灰度图像中最多能有的灰度级数</li><li><strong>调色板：</strong><ul><li>一个彩色图像假如只包含24位真彩色空间中的16个离散的点（16色图），则可以建立一个颜色查找表，表中的每一行记录一组RGB值。</li><li>实际像素的值用来指定该点颜色在查找表中的索引值，这样就可以大大缩小存储量。这个颜色查找表就叫做调色板</li></ul></li><li><strong>真彩色、伪彩色与直接色</strong> (不考)<ul><li>真彩色：在组成一幅彩色图像的每个像素值中，有R，G，B三个基色分量，每个基色分量直接决定显示设备的基色强度。</li><li>伪彩色：把像素值当作彩色查找表(调色板)的表项入口地址，去查找一个显示图像时使用的R，G，B强度值，用查找出的R，G，B强度值产生的彩色。</li><li>直接色：每个像素值分成R，G，B分量，每个分量作为单独的索引值对它做变换。也就是通过相应的彩色变换表找出基色强度，用变换后得到的R，G，B强度值产生的彩色称为直接色</li></ul></li><li><strong>位图图像数据量</strong><ul><li>位图图像数据量计算公式B = (h <em> w </em> c ) / 8 (Byte)</li><li>其中，h:垂直分辨率，w:水平分辨率，c:颜色深度</li><li>例：一副大小为640X480，256色彩色图像，其数据量为：B =（ 640 × 480 × 8 ) / 8 = 307, 200字节</li></ul></li></ul><h5 id="BMP图像文件格式"><a href="#BMP图像文件格式" class="headerlink" title="BMP图像文件格式"></a>BMP图像文件格式</h5><ul><li>BMP图像文件格式：<ul><li>采用位映射存储格式</li><li>图像颜色深度可选lbit、4bit、8bit及24bit</li><li>不采用其他任何压缩（？）</li><li>包含的图像信息较丰富</li><li>占用磁盘空间过大，不利于网络传输</li><li>存储数据时，图像的扫描方式是按<strong>从左到右、从下到上</strong>的顺序</li></ul></li><li><p>BMP文件由4个部分组成：</p><ol><li>位图文件头</li><li>位图信息头</li><li>颜色表</li><li>图像数据阵列字节</li></ol></li><li><p>有哪些不同类型的图形/图像文件？为什么有这些不同的类型？各自有何特点？</p></li></ul><h2 id="3-音频技术"><a href="#3-音频技术" class="headerlink" title="3. 音频技术"></a>3. 音频技术</h2><ul><li>声音、语音、音乐的区别和联系？<ul><li>声音是统称，或专指除语音、音乐之外的其它声音。</li><li>语音是声音的一种特殊类型，因为人类语音的频率范围小于声音的频率范围，且具有独特的发音特点。</li><li>音乐也是声音的一种特殊类型，主要是指MIDI音乐。</li></ul></li></ul><h5 id="声音的听觉心理特性"><a href="#声音的听觉心理特性" class="headerlink" title="声音的听觉心理特性"></a>声音的听觉心理特性</h5><ul><li>音调：声音的高低。由声音的(基)频率决定</li><li>音强（响度）：表示人们所感觉到的声音能量的强弱，主要取决于声波振幅的大小。可听声音的强度范围是0-120dB</li><li>响度的特性：响度与人耳的可闻程度有关<ul><li>人耳的可听频率范围外，声音的响度再大，人耳也无法察觉</li><li>人耳的可听频域范围内，当声音弱或强到一定程度，人耳都无法听到</li></ul></li><li>等响曲线：人类感受不同频率声音时，其所感知的相同响度对应的声音能量是不同的，由此构成了等响曲线。</li><li>听阈：人能听到的最低声压级</li><li>痛阈：当声压级增大到一定强度时，人耳会感到不适或疼痛。</li></ul><h5 id="掩蔽效应："><a href="#掩蔽效应：" class="headerlink" title="掩蔽效应："></a>掩蔽效应：</h5><ul><li>一种频率的声音阻碍听觉系统感受另一种频率的声音的现象。人的耳朵只对最明显的声音反应敏感，而对于不明显的声音，反应则较不敏感</li><li>前者称为掩蔽声音，后者称为被掩蔽声音</li><li>应用此原理，人们发明了mp3等<strong>压缩的数字音乐格式</strong>，在这些格式的文件里，只突出记录了人耳朵较为敏感的中频段声音，而对于较高和较低的频率的声音则简略记录，从而大大压缩了所需的存储空间<ul><li>频域掩蔽：指一个<strong>强纯音</strong>会掩蔽在其附近同时发声的弱纯音。</li><li>时域掩蔽：指在<strong>时间上相邻的声音之间</strong>也有掩蔽现象。</li></ul></li></ul><h5 id="声音信号数字化"><a href="#声音信号数字化" class="headerlink" title="声音信号数字化"></a>声音信号数字化</h5><ul><li>声音如何数字化？  <ul><li>与模拟图像数字化相似，声音数字化包括<strong>采样、量化和编码</strong></li></ul></li><li><strong>采样</strong>：将声音信号<strong>在时间上离散化</strong>，即每隔相等的一段时间抽取一个信号样本</li><li><strong>量化</strong>：将连续的信号<strong>幅度离散化</strong>。<ul><li>如果幅度的划分是等间隔的，称为线性量化/均匀量化。</li><li>否则为非线性量化/非均匀量化。</li></ul></li><li><strong>编码</strong>：按<strong>一定的格式</strong>将离散的数字信号记录下来，并在数据的前、后加上同步、纠错等控制信号</li></ul><h5 id="影响数字音频质量的技术参数"><a href="#影响数字音频质量的技术参数" class="headerlink" title="影响数字音频质量的技术参数"></a>影响数字音频质量的技术参数</h5><ul><li>数字音频的质量取决于：<strong>采样频率、采样精度/量化位数和声道数</strong></li></ul><h5 id="采样数据量-考试不用计算，考算式"><a href="#采样数据量-考试不用计算，考算式" class="headerlink" title="采样数据量(考试不用计算，考算式)"></a>采样数据量(考试不用计算，考算式)</h5><ul><li><strong>声音采样数据量 (字节) = 采样频率 × 采样精度 / 8 × 声道数 × 采样时间</strong></li><li>为了减少数据量，采样且量化后的数据常要进行压缩编码（将在第5章介绍）</li><li>eg. <strong>1分钟</strong>的<strong>双声道声音</strong>，采用不同采样频率和精度所需的存储容量例如，采用<strong>44.1kHz采样频率</strong>和<strong>16位采样精度</strong>时，数字化后需要的存贮容量为：<strong>44.1 × 16 / 8 × 2 × 60 = 10584(字节)</strong></li></ul><h5 id="语音"><a href="#语音" class="headerlink" title="语音"></a>语音</h5><ul><li>以语音的基本特性为基础，主要针对语音的成分进行相应处理，包括语音<strong>采样、识别、模拟、合成</strong>等技术</li><li><strong>语音识别和语音合成</strong>技术是实现人机语音通信的两项关键技术</li></ul><h5 id="MIDI音乐"><a href="#MIDI音乐" class="headerlink" title="MIDI音乐"></a>MIDI音乐</h5><ul><li>数字音乐是一种音乐语言；数字音乐编码。</li><li>MIDI：电子乐器数字接口</li><li><strong>MIDI音乐是一种数字音乐</strong>，MIDI音乐通常被称为<strong>电子音乐或合成音</strong>乐，它也是声音的一种，但是这种声音与流行的乐器有关，例如，钢琴、提琴、长号、鼓等乐器。</li><li>优点：<ul><li>生成的文件比较小，一个六分多钟、有16个乐器的文件只有80多KB（为什么？）</li><li>容易编辑</li><li>可以作背景音乐</li></ul></li></ul><ul><li>缺点：<ul><li>播放效果因软、硬件而异。好的播放效果必须支持波表功能</li><li>录制较复杂，需要学习一些使用MIDI创作并改编作品的专业知识，还须有专门工具，如键盘合成器</li></ul></li></ul><h5 id="音频文件的格式"><a href="#音频文件的格式" class="headerlink" title="音频文件的格式"></a>音频文件的格式</h5><ul><li>WAV</li><li>MIDI：MIDI文件储存着MIDI资料和命令。</li><li>MP3：利用了<strong>知觉音频编码技术</strong>，削减了音乐中人耳所听不到的成分，尽可能保持原有的音质。</li><li>MP3PRO：降低压缩比</li><li>ra(RealAudio) &amp; rm(RealMedia)：网络流媒体文件格式</li><li>Windows Media</li></ul><h2 id="4-动画视频技术"><a href="#4-动画视频技术" class="headerlink" title="4. 动画视频技术"></a>4. 动画视频技术</h2><ul><li>动态图像：由多幅连续的图像构成的序列称为动态图像</li><li>原理：它利用了人眼的视觉暂留性</li></ul><h5 id="动态图像的特点"><a href="#动态图像的特点" class="headerlink" title="动态图像的特点"></a>动态图像的特点</h5><ul><li><strong>时间连续性</strong>：动态图像具有时间连续性</li><li><strong>数据量大</strong>：数据量更大</li><li><strong>相关性强</strong>：动态图像的帧与帧之间具有很强的相关性。据研究，相邻帧之间有10%以下的像素有亮度变化，1%以下的像素有色度变化(注：该性质在动态图像压缩中具有重要作用。为什么？)@<strong>“为什么”考试</strong></li><li><strong>实时性高</strong>：动态图像对实时性要求高，必须在规定的时间内完成更换画面播放的过程</li></ul><h5 id="动画文件的格式"><a href="#动画文件的格式" class="headerlink" title="动画文件的格式"></a>动画文件的格式</h5><ul><li>GIF</li><li>SWF</li><li>FLI/FLC</li></ul><h5 id="视频文件格式"><a href="#视频文件格式" class="headerlink" title="视频文件格式"></a>视频文件格式</h5><ul><li>微软的AVI </li><li>苹果公司的MOV</li><li>MPEG</li><li>RealNetwork公司的RM</li><li>ASF、 WMV</li></ul><h2 id="5-多媒体数据压缩技术"><a href="#5-多媒体数据压缩技术" class="headerlink" title="5. 多媒体数据压缩技术"></a>5. 多媒体数据压缩技术</h2><h3 id="5-1-数据压缩的基本原理和方法"><a href="#5-1-数据压缩的基本原理和方法" class="headerlink" title="5.1 数据压缩的基本原理和方法"></a>5.1 数据压缩的基本原理和方法</h3><h5 id="多媒体数据压缩的必要性和可能性"><a href="#多媒体数据压缩的必要性和可能性" class="headerlink" title="多媒体数据压缩的必要性和可能性"></a>多媒体数据压缩的必要性和可能性</h5><ul><li>必要性<ul><li>数字化后的图像、视频和音频等媒体信息的海量性</li><li>计算机存储资源和网络带宽难以满足需要</li><li>导致多媒体数据存储和传输的困难</li><li>结论：多媒体数据需要压缩</li></ul></li><li>可能性<ul><li>多媒体数据冗余：统计冗余（空间冗余、时间冗余）、结构冗余、知识冗余、感知冗余（视觉冗余、听觉冗余）</li><li>信息表达冗余：信息熵冗余</li></ul></li></ul><h5 id="数据冗余"><a href="#数据冗余" class="headerlink" title="数据冗余"></a>数据冗余</h5><ul><li><strong>统计冗余</strong> <ul><li>时间冗余: 一段视频的前后相邻的2帧中会有大量的区域有相同或相近的数据，形成帧间的数据冗余。</li><li>空间冗余: 在同一个静态图像或画面中，有部分区域数据值一样或相差不大，形成空间冗余。</li></ul></li><li>结构冗余：有些图像存在着明显的分布模式</li><li>知识冗余：许多图像的理解与某些基础知识有相当大的相关性。如人脸的图像有固定的结构。 </li><li><strong>感知冗余</strong><ul><li>视觉冗余</li><li>听觉冗余</li></ul></li><li><strong>信息熵冗余</strong>：信息的表达存在冗余。<ul><li>信息熵：一组数据所携带的<strong>平均信息量</strong>（不确定性的度量）</li><li>平均信息量乘以数据的个数，就是整个一组数据的信息量</li></ul></li></ul><blockquote><ul><li>存在数据冗余，才可能进行数据压缩</li><li>某些数据冗余是多媒体数据所特有的</li><li>针对不同数据冗余，设计不同数据压缩方法</li></ul></blockquote><h5 id="信源符号，码元，码字"><a href="#信源符号，码元，码字" class="headerlink" title="信源符号，码元，码字"></a>信源符号，码元，码字</h5><ul><li>对于<strong>消息集</strong>中的<strong>信源符号</strong>使用<strong>符号集</strong>中的<strong>码元</strong>进行编码，得到<strong>输出集（码书）</strong>中的与信源符号<strong>一一对应</strong>的<strong>码字</strong></li><li>信源符号，码元，码字（要求信源符号和码字一一对应）<ul><li>英文字母，0和1，ASCII码</li><li>数字，0和1，ASCII码</li><li>汉字，0和1，GB2312码</li></ul></li><li><strong>压缩目标：</strong>用尽量短的码字表达信源符号，且一一对应</li><li>按照单个英文字母或单个汉字，与按照单词或词组，<strong>信源符号的个数不同</strong></li><li>不同环境下的信源符号、码元、码字，<strong>同一符号可能分别为信源符号或码元</strong></li></ul><h5 id="感知冗余"><a href="#感知冗余" class="headerlink" title="感知冗余"></a>感知冗余</h5><ul><li>视觉冗余（是否知道有哪些？）<ul><li><strong>亮度和色度的差别</strong>：人眼<strong>对亮度的敏感性比色度要强</strong>，所以在色度成分上，可以不要保留太多细节，这样可以使色度成分中出现更多的冗余。</li><li><strong>高亮度区和非高亮度区差别</strong>：在高亮度区，人眼的敏感度会下降。灰度值的量化可以更粗糙些，<strong>人类视觉系统一般分辨能力约为2<sup>6</sup>灰度等级，而一般图像量化采用2<sup>8</sup>灰度等级</strong>。</li><li><strong>边缘和非边缘区别</strong>:人眼对急剧色彩和亮度变化的<strong>物体边缘</strong>的敏感度比非边缘区域强<br>听觉冗余（在“音频数据压缩技术”中介绍）</li></ul></li></ul><h5 id="数据压缩方法分类"><a href="#数据压缩方法分类" class="headerlink" title="数据压缩方法分类"></a>数据压缩方法分类</h5><ul><li>根据解码（解压缩）后数据与原始数据是否完全一致，数据压缩方法分为两类<ul><li><strong>可逆编码</strong>(无失真编码，无损编码）：解码数据与原始数据（数字而非模拟）严格相同  </li><li><strong>不可逆编码(</strong>有失真编码，有损编码）： 解码数据与原始数据存在一定的误差，但感知效果一般可以接受。常用的有<strong>变换编码和预测编码</strong>等。</li></ul></li><li>根据数据压缩的原理可以分为<ul><li><strong>统计编码</strong>（<strong>针对信息熵冗余</strong>，即信息表达冗余）</li><li><strong>预测编码</strong>（<strong>针对统计冗余</strong>，即多媒体信号的相关性）</li><li><strong>变换编码</strong>（<strong>针对感知冗余</strong>，即多媒体信号的人类感知冗余）</li><li><strong>其他编码</strong></li></ul></li><li><strong>通用无损数据压缩</strong><ul><li>研究中发现，大多数信息表达都存在着一定的冗余度，通过采用一定的模型和编码方法，可以降低这种冗余度。</li><li><strong>eg.</strong> Huffman编码，算术编码，词典式编码，LZ78，LZW，ZIP格式。</li></ul></li><li><strong>(专用)多媒体数据压缩</strong><ul><li>采用成熟的通用数据压缩技术进行压缩</li><li>根据<strong>媒体信息的特性</strong>设计新的压缩方法</li><li><strong>eg.</strong> RLE编码(游程编码，适合压缩具有面积重复的颜色块的图像)，预测编码，变换编码</li></ul></li><li>数据压缩方法评价<ul><li><strong>压缩比</strong>（压缩效果：要求压缩比高</li><li><strong>算法复杂性和运算速度</strong>（压缩效率）：要求算法简单，压缩和解压缩速度快，最好能实时解压</li><li><strong>失真度</strong>（压缩质量）：要求恢复效果好</li><li>三个指标相互制约</li></ul></li></ul><h3 id="5-2-统计编码"><a href="#5-2-统计编码" class="headerlink" title="5.2 统计编码"></a>5.2 统计编码</h3><h5 id="统计编码的基本原理"><a href="#统计编码的基本原理" class="headerlink" title="统计编码的基本原理"></a>统计编码的基本原理</h5><ul><li>数据压缩技术的理论基础是<strong>信息论</strong>，根据信息论的原理，<strong>数据压缩的理论极限是信息熵</strong></li></ul><ul><li>如果要求编码过程中不<strong>丢失信息量（无损编码）</strong>，即要求保存信息熵，这种信息保持编码叫<strong>熵编码（统计编码）</strong></li><li>信息论认为信源中存在的冗余度来自于<strong>信源本身的相关性</strong>和<strong>信源概率分布的不均匀性</strong></li><li>熵编码（统计编码）要解决的问题是，如何利用信息熵理论<strong>减少数据在存储和传输中的冗余度</strong>。也就是要找到<strong>去除信源的相关性和概率分布的不均匀性</strong>的方法</li><li>无损压缩编码</li><li>根据信源符号出现概率的分布特性进行编码<ul><li><strong>概率大</strong>的信源符号用<strong>短码字</strong>表示</li><li><strong>概率小</strong>的信源符号用<strong>长码字</strong>表示</li><li>从而去除数据之间的冗余而达到压缩的目的</li></ul></li><li>统计编码需要在信源符号和码字之间确定严格的一一对应关系，以便准确无误地再现原来信源，同时使平均码长尽量小</li><li>如果所有的信源符号出现的概率相同，则说明平均信息量最大，也就不存在信源的冗余<ul><li>游程（RLE）编码</li><li>Huffman编码</li><li>算术编码</li></ul></li></ul><h5 id="游程（RLE）编码"><a href="#游程（RLE）编码" class="headerlink" title="游程（RLE）编码"></a>游程（RLE）编码</h5><ul><li>不需要存储每一个像素的颜色值，而仅仅存储一个像素的颜色值，以及具有相同颜色的连续像素数目</li><li>即，将颜色值相同的相邻像素用一个计数值和那些像素的颜色值来代替<ul><li>例如:aaabccccccddeee，则可用3a1b6c2d3e来代替</li></ul></li></ul><ul><li><strong>游程长度</strong>：具有相同颜色并且是连续的像素数目</li><li>对于拥有大面积，相同颜色区域的图像，用RLE压缩方法非常有效</li><li>无损压缩编码</li></ul><ul><li><strong>RLE压缩编码特点</strong><ul><li>直观，经济</li><li><strong>压缩比的大小，主要取决于图像本身的特点。</strong>如果图像中具有相同颜色的图像块越大，图像块数目越少，获得的压缩比就越高。反之，压缩比就越小</li><li><strong>适用于计算机生成的图像</strong>，但对颜色丰富的自然图像不仅不能压缩图像数据，反而可能使原来的图像数据变得更大。</li></ul></li></ul><h5 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h5><ul><li>统计编码，针对信息熵冗余，无损压缩编码</li><li>1952年为文本文件建立</li><li>编码方法简单且有效，得到广泛应用，现在已经派生出很多变体。</li><li><strong>基本原理</strong>：<ul><li>使用<strong>变长编码</strong>，对出现概率大的<strong>信源符号</strong>赋于短码字，而对于出现概率小的<strong>信源符号</strong>赋于长码字</li><li>如果码字长度严格按照所对应符号出现概率大小逆序排列，则编码结果平均码字长度一定小于任何其它排列方式。</li></ul></li><li><strong>步骤</strong>：<ol><li>将信源符号按概率递减顺序排列；</li><li>把二个最小概率相加作为新符号的概率, 并按(1)重排；</li><li>重复 (1)、(2)，直到概率为1；</li><li>在每次合并信源时,将合并的信源分别赋“0”和“1”(例如概率大的赋“0”,概率小的赋“1”)；</li><li>寻找从每一信源符号到概率为1处的路径，记录下路径上的“1”和“0”；</li><li>写出每一符号的“1”、“0”序列(从树根到信源符号节点)。<br><img src="/media/huf.png" width="50%"></li></ol></li><li>特点<ul><li>Huffman编码是最佳变长码，其优点是<strong>编码效率高</strong></li><li>Huffman编码<strong>依赖于信源的统计特性</strong></li></ul></li><li>Huffman编码是否只能得到唯一编码结果？<ul><li>由于“0”和“1”的指定可以是任意的，所以Huffman编码所得到的编码不是唯一的。</li><li>各次累加时对于信源符号可以任意指定0或1，并非一定要所有大概率信源符号使用相同编码，所有小概率信源符号使用相同编码。因为最终是以查表的方式查找信源符号的码字。</li></ul></li><li>Huffman编码结果是否需要考虑如何区分不同字符的编码？<ul><li>Huffman编码不需要附加同步代码，任何一个字符的编码，都不是另一个字符编码的前缀</li></ul></li><li>Huffman编码如何解码？特别是对于自适应概率模型解码？<ul><li>查表。因此在<strong>解码时需要有编码时采用的Huffman表</strong>，才能正确解码、</li><li>如果信源符号数（例如，汉字？）很大，需要存储的码表（码书）也需很大，从而会影响存储量、编码以及解码速度等各个方面的性能。</li></ul></li><li>根据Huffman编码得到的消息编码序列，是否可以从中间开始解码？<ul><li>Huffman编码是可变长度码，很难随意查找或调用压缩文件中间的内容</li></ul></li><li>Huffman编码没有错误保护功能，会出现错误传播</li><li>总结<ul><li>信源符号的概率统计模型 → Huffman表</li><li>编码：消息（由信源符号组成） → 根据Huffman表对于消息中的信源符号逐个编码  →  消息编码</li><li>解码：消息编码 → 根据Huffman表对于消息编码逐个解码 → 信源符号 → 消息</li></ul></li></ul><h5 id="算术编码"><a href="#算术编码" class="headerlink" title="算术编码"></a>算术编码</h5><ul><li>统计编码，针对信息熵冗余，无损压缩编码。</li><li>常用于图像数据压缩标准(如JPEG，JBIG)中</li><li><strong>基本原理</strong>：将出现概率较多的<strong>“消息”</strong>(可以是字符或字符串) (Huffman编码针对信源符号) ，用尽可能少的位或字节来表示。</li><li>算术编码是一种变长码，主要针对出现概率高的消息序列标识的信息进行压缩。<ul><li>信源符号是表达消息的符号</li></ul></li><li>算术编码用到的两个基本的参数是<strong>符号的概率</strong>和它的<strong>编码间隔</strong>。<ul><li>信源符号的概率决定压缩编码的效率，也决定编码过程中信源符号的间隔。</li><li>间隔则决定了符号压缩后的输出</li></ul></li><li>算术编码区别于Huffman编码的是，它是<strong>根据信源符号估计出各个元素的概率</strong>，然后进行<strong>迭代计算</strong>。而不像Huffman编码必须预先得知信源的出现概率。</li><li>将编码的消息表示成实数0和1之间的一个间隔，<strong>消息越长，编码表示它的间隔就越小，表示这一间隔所需的二进制位就越多</strong>。</li><li><strong>步骤</strong><ul><li>两个基本的参数：符号的概率和编码间隔(在0到1之间)。令概率为p<sub>1</sub>,p<sub>2</sub>,…p<sub>n</sub>（其和为1），则编码间隔为［0,p<sub>1</sub>) 、[p<sub>1</sub>，p<sub>1</sub>+p<sub>2</sub>）…[p<sub>1</sub>+p<sub>2</sub>+…p<sub>n-1</sub>，1）</li><li>令high为间隔的高端，low为低端，range为间隔的长度，rangelow为编码字符分配的间隔低端，rangehigh为编码字符分配的间隔高端。</li><li>初始<strong>high=1，low=0，range = high-low</strong></li><li>计算一个字符编码后新的low和high：<br><strong>low = low + range×rangelow</strong><br><strong>high = low + range×rangehigh</strong><br><img src="/media/算数编码.jpg" width="100%"></li></ul></li><li><strong>特点：</strong><ul><li>算术编码的精度在64位以内，对于运算中的溢出问题，可使用比例缩放方法解决</li><li>在解码器中<strong>需要添加一个专门的终止符</strong>，当解码器看到终止符时就停止解码，否则可以无穷尽地解码。</li><li>算术编码器对整个消息只产生一个码字，这个码字是在间隔[0，1）中的<strong>一个实数</strong>，解码器在接受到表示这个实数的所有位之前不能进行解码</li><li>算术编码也是一种<strong>对错误很敏感的编码方法</strong></li><li>算术编码可以<strong>是静态的或者自适应</strong>的。在静态算术编码中，信源符号的概率是固定的。但事先很难知道精确的信源概率。最有效的方法是在编码过程中估算概率，这就是自适应算术编码，信源符号的概率根据编码时符号出现的频繁程度动态地进行修改，也就是在编码期间估算信源符号概率建模。</li><li><strong>信源符号概率接近时，建议使用算术编码</strong>，这种情况下其效率高于Huffman编码(约5%) 。</li></ul></li></ul><h3 id="5-3-词典编码"><a href="#5-3-词典编码" class="headerlink" title="5.3 词典编码"></a>5.3 词典编码</h3><ul><li>词典编码：在不知数据统计特性的前提下的通用编码算法<ol><li>用已经出现过的字符串替代重复的部分，输出仅仅是指向早期出现过的字符串的“指针”。eg. <strong>LZ77算法</strong></li><li>创建一个“短语词典”。编码中遇到已在词典中出现的“短语”时，输出词典中的短语的“索引号” 。eg. <strong>LZ78算法</strong>，改进后为LZW压缩编码。</li></ol></li></ul><h5 id="LZW压缩编码算法"><a href="#LZW压缩编码算法" class="headerlink" title="LZW压缩编码算法"></a>LZW压缩编码算法</h5><ul><li>查找冗余字符和用较短的符号标记替代冗余字符</li><li>压缩效率较高（思考：为什么？）</li><li>无损压缩编码<ul><li>LZ77  →  LZ78  →  LZW</li></ul></li><li><strong>特点：</strong><ul><li>处理过程比其他压缩过程复杂，但过程完全可逆</li><li>对于简单图像和平滑且噪音小的信号源具有较高的压缩比，并且有<strong>较高的压缩和解压缩速度</strong>。对机器硬件条件要求不高</li><li>可压缩<strong>任何类型和格式的数据</strong>。</li><li>有错误传播（虽然是定长编码，但在解码过程中需要生成词典。如果存在错误，可能导致生成词典出错，甚至无法生成词典）</li></ul></li></ul><h5 id="各种编码方式的比较"><a href="#各种编码方式的比较" class="headerlink" title="各种编码方式的比较"></a>各种编码方式的比较</h5><p><img src="/media/编码.png" width="80%"></p><h3 id="预测编码-amp-变换编码"><a href="#预测编码-amp-变换编码" class="headerlink" title="预测编码 &amp; 变换编码"></a>预测编码 &amp; 变换编码</h3><ul><li>预测编码：根据离散信号之间存在一定的<strong>相关性</strong>的特点，利用前面的一个或多个信号对下一个信号进行<strong>预测</strong>，然后对实际值和预测值的<strong>差值</strong>进行<strong>编码</strong>。<ul><li>针对<strong>统计冗余</strong></li><li>有损压缩编码</li><li>适合于声音和图像数据的压缩</li></ul></li><li>变换编码：对欲编码的原始数据所在的时间或空间域<strong>进行某种数学变</strong>换，从一种信号空间变换到另一种信号空间，产生一批<strong>变换系数</strong>，使得通过变换后<strong>能够突出原始数据中的重要部分</strong>，以便重点处理。然后再对这些系数进行编码处理。<ul><li>数据变换的方式有：傅立叶变换、沃尔什变换、正弦变换、余弦变换、斜变换、哈尔变换、K-L变换等</li><li>针对<strong>感知冗余</strong></li><li>有损压缩编码</li><li>常用于音频信号压缩编码和图像/视频信号压缩编码</li></ul></li></ul><h3 id="5-4-音频信号压缩技术"><a href="#5-4-音频信号压缩技术" class="headerlink" title="5.4 音频信号压缩技术"></a>5.4 音频信号压缩技术</h3><ul><li>音频编译码器的分类<ul><li><strong>波形编译码器</strong>：不利用生成话音的信号的任何知识，将话音视为一种普通的声音，直接对波形信号进行采样和量化。 <strong>eg.PCM、DPCM、ADPCM等</strong></li><li>音源编译码器 / 参数编译码器 / 声码器：它从话音波形信号中提取话音生成模型的参数，使用这些参数通过话音生成模型重构出话音。</li><li><strong>混合编译码器</strong>：综合使用上述两种技术。使用的激励信号波形尽可能接近于原始话音信号的波形。<strong>eg. CELP， MPEGⅠ中的音频部分是一种混合编码</strong></li></ul></li></ul><h5 id="两类压缩"><a href="#两类压缩" class="headerlink" title="两类压缩"></a>两类压缩</h5><ul><li><strong>模拟信号转换为数字信号</strong><ul><li>降低采样频率，减少量化位数</li><li>音频信号编码，PCM、DM、DPCM</li></ul></li><li><strong>针对数字信号</strong><ul><li>统计编码，词典编码。无损。通用压缩编码</li><li>预测编码，变换编码。有损。多媒体数据专用压缩编码</li></ul></li></ul><h2 id="6-多媒体数据压缩标准"><a href="#6-多媒体数据压缩标准" class="headerlink" title="6. 多媒体数据压缩标准"></a>6. 多媒体数据压缩标准</h2><h3 id="6-1-图像数据压缩标准"><a href="#6-1-图像数据压缩标准" class="headerlink" title="6.1 图像数据压缩标准"></a>6.1 图像数据压缩标准</h3><h5 id="JPEG算法特点"><a href="#JPEG算法特点" class="headerlink" title="JPEG算法特点"></a>JPEG算法特点</h5><ul><li>JPEG是一个适用范围很广的静态图像数据压缩标准，既可用于<strong>灰度图像</strong>又可用于<strong>彩色图像</strong>（为什么？） <ul><li><strong>JPEG算法与色彩空间无关</strong>，因此“RGB到YUV变换”和“YUV到RGB变换”不包含在JPEG算法中。JPEG算法处理的彩色图像是单独的彩色分量图像，因此<strong>它可以压缩来自不同彩色空间的数据</strong>，如RGB, YCbCr和CMYK</li></ul></li><li>通常使用YUV模式（为什么？）<ul><li>JPEG不仅适于<strong>静止图像</strong>的压缩，<strong>电视图像的帧内图像的压缩编码</strong>，也常采用此算法（作为动态图像压缩的一个组成部分）</li></ul></li><li>JPEG标准还可以大范围地<strong>调节</strong>图像压缩比及其保真度（如何调节？）<ul><li>JPEG中的有损压缩利用了人的视觉系统的特性，使用<strong>变换编码+量化</strong>和<strong>无损压缩编码</strong>相结合来去掉<strong>视觉的冗余信息和数据本身的冗余信息</strong></li></ul></li></ul><h5 id="JPEG压缩编码算法的主要步骤"><a href="#JPEG压缩编码算法的主要步骤" class="headerlink" title="JPEG压缩编码算法的主要步骤"></a>JPEG压缩编码算法的主要步骤</h5><ol><li>图像分块<ul><li>分为8x8图像块；相关性强，标准化，计算量的考虑。</li></ul></li><li><strong>正向离散余弦变换(FDCT)</strong><ul><li>区分重要信息和次要信息 </li></ul></li></ol><ul><li>量化<ul><li>减小非“0”系数的幅度以及<strong>增加“0”值系数的数目</strong>。</li><li>重要系数和次要系数采用不同的量化步长。分别处理，量化表可以不同，可调节压缩比和压缩质量。</li><li>不能使用一个值作为所有系数的量化系数，需要体现相对于感知冗余的不同系数的不同重要性。</li></ul></li><li>Z字形编排<ul><li>增加0值系数的长度</li></ul></li><li>使用差<strong>分脉冲编码调制(DPCM)</strong>对直流系数(DC)进行编码<ul><li>直流DC系数特点：相关性预测编码</li><li>进一步压缩：预测编码，DPCM</li></ul></li><li>使用<strong>游程长度编码(RLE)</strong>对交流系数(AC)进行编码<ul><li>交流AC系数特点：0值系数较多</li><li>进一步压缩：RLE游程编码 </li></ul></li><li><strong>熵编码</strong></li><li>组成位数据流</li><li><strong>各种压缩技术的组合</strong></li></ul><h5 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h5><ol start="2"><li>为什么不使用整个图像而使用分块图像？<ul><li>局部图像的相关性比整体图像的相关性更强</li><li>算法标准化</li><li>计算量的考虑</li></ul></li></ol><ul><li>采样精度为P位(二进制)，把[0，2<sup>P-1</sup>]范围的无符号数变换成[-2<sup>P-1</sup>，2<sup>P-1</sup>-1]范围的有符号数（为什么？），作为正向离散余弦变换的输入，通过DCT变换，把能量集中在少数几个系数上。<ul><li>使得变换后的系数分布于[-2<sup>P-1</sup>，2<sup>P-1</sup>-1]</li></ul></li><li>对经过FDCT变换后的系数进行量化（为什么？）<ul><li>目的是减小非“0”系数的幅度以及增加“0”值系数的数目</li><li>量化是图像质量下降的最主要原因 </li></ul></li><li>对经过FDCT变换后的系数进行量化（为什么？）<ul><li>目的是减小非“0”系数的幅度以及增加“0”值系数的数目</li><li>量化是图像质量下降的最主要原因 </li></ul></li><li>量化后的系数按Z字形编排（为什么？）<ul><li>目的是为了增加连续的“0”系数的个数，就是“0”的游程长度</li></ul></li><li>变换编码提到通过正交变换减少相关性，为什么这里还有相关性存在并可以加以利用？<ul><li>DCT变换减少的是8×8块内部各像素之间的相关性，但各8×8块之间的相关性依然存在</li></ul></li><li>DC、AC系数表达的特点？如何进一步压缩？<ul><li>信息表达的冗余</li><li>熵编码，先转化为中间符号</li></ul></li></ul><h5 id="JPEG图像文件格式-amp-JPEG2000"><a href="#JPEG图像文件格式-amp-JPEG2000" class="headerlink" title="JPEG图像文件格式 &amp;  JPEG2000"></a>JPEG图像文件格式 &amp;  JPEG2000</h5><ul><li>JEPG文件大体上可以分成两个部分：<strong>标记码</strong>（tag）和<strong>压缩数据</strong><ul><li><strong>标记码部分给出了JPEG图像的所有信息</strong>，如图像的宽、高、Huffman表、量化表等等</li></ul></li><li>JPEG2000主要特点<ul><li><strong>高压缩率</strong>。在具有和传统JPEG类似质量的前提下，JPEG2000的<strong>压缩率比JPEG高30%左右</strong>。</li><li><strong>同时支持有损和无损压缩</strong></li><li><strong>渐进传输。</strong>即先传输图像的轮廓，然后逐步传输数据，不断提高图像质量，让图像由朦胧到清晰显示，以满足用户的需要。从而节约、充分利用有限的带宽。</li><li><strong>感兴趣区域压缩</strong>。即可以指定感兴趣区域，在这些区域，可以在压缩时指定特定的压缩质量，或在恢复时指定特定的解压缩要求。</li></ul></li></ul><h3 id="6-2-动态图像压缩标准MPEG"><a href="#6-2-动态图像压缩标准MPEG" class="headerlink" title="6.2 动态图像压缩标准MPEG"></a>6.2 动态图像压缩标准MPEG</h3><h5 id="MPEG-Video压缩技术基本方法"><a href="#MPEG-Video压缩技术基本方法" class="headerlink" title="MPEG-Video压缩技术基本方法"></a>MPEG-Video压缩技术基本方法</h5><ul><li>如何分别实现图像空间方向压缩和运动图像时间方向压缩？<ul><li>在<strong>空间方向</strong>上，图像数据压缩采用<strong>JPEG压缩算法</strong>来去掉冗余信息</li><li>在<strong>时间方向</strong>上，图像数据压缩采用<strong>运动补偿算法</strong>来去掉冗余信息</li></ul></li></ul><h5 id="MPEG定义的三种图"><a href="#MPEG定义的三种图" class="headerlink" title="MPEG定义的三种图"></a>MPEG定义的三种图</h5><ul><li><strong>I图像（帧内图）</strong><ul><li>采用帧内编码方式，即只利用了单帧图像内的空间相关性，而没有利用时间相关性</li><li>与JPEG压缩算法大致相同</li><li>压缩后每个像素为1～2bit</li><li><strong>一个内帧是一个随机访问点</strong></li><li><strong>可作为其它图像的参考帧</strong></li></ul></li><li><strong>P图像（预测图）</strong><ul><li>用最近的前一个I图像(或P图像)预测编码得到</li><li>只采用前向时间预测</li></ul><ul><li>可以提高<strong>压缩比和图像质量</strong></li><li><strong>可作为其它图像的参考帧</strong></li></ul></li><li><strong>B图像（插补图，即双向预测图）</strong><ul><li>B图像在预测时, 既可使用前一个图像作参照, 也可使用后一个图像做参照或同时使用前后两个图像作为参照图像(双向预测)</li><li>采用双向时间预测可以大大提高压缩比</li><li><strong>不可作为其它图像的参考帧</strong></li></ul></li><li>P图像和B图像采用帧间编码方式，即同时利用了空间和时间上的相关性</li></ul><h2 id="7-多媒体应用系统创作技术"><a href="#7-多媒体应用系统创作技术" class="headerlink" title="7. 多媒体应用系统创作技术"></a>7. 多媒体应用系统创作技术</h2><h5 id="多媒体应用系统设计基本过程"><a href="#多媒体应用系统设计基本过程" class="headerlink" title="多媒体应用系统设计基本过程"></a>多媒体应用系统设计基本过程</h5><ul><li>多媒体应用系统适用于各个领域，多媒体软件融图、文、声、像于一体，它的创作是一项系统工程，涉及到多种因素。</li><li>主要涉及到制作人员、制作环境和制作步骤三个方面</li><li>包含<strong>系统目标确定、编写系统脚本、进行脚本分析、脚本制作、脚本测试、系统评价</strong>等</li></ul><h5 id="多媒体系统创作工具"><a href="#多媒体系统创作工具" class="headerlink" title="多媒体系统创作工具"></a>多媒体系统创作工具</h5><ul><li>基于<strong>多媒体著作工具的多媒体系统创作</strong></li><li>包括：<ul><li>Hypercard</li><li>ToolBook</li><li>Authorware Professional</li><li>IconAuthor</li><li>Action</li><li>Director</li><li>PowerPoint</li><li>Animation Works Interactive</li><li>Storyboard</li><li>方正奥思多媒体创作工具</li><li>洪图多媒体编著系统</li></ul></li></ul><h5 id="多媒体程序设计基础"><a href="#多媒体程序设计基础" class="headerlink" title="多媒体程序设计基础"></a>多媒体程序设计基础</h5><ul><li>在Windows系统中，对多媒体设备进行控制主要有<strong>三种方法</strong>：<ul><li><strong>使用Microsoft提供的多媒体控制接口MCI</strong>，MCI是多媒体设备和多媒体应用软件之间进行设备无关的沟通的桥梁</li><li><strong>通过调用Windows的应用程序接口API多媒体相关函数</strong>实现媒体控制</li><li><strong>使用对象链接与嵌入OLE</strong>为不同软件之间共享数据和资源提供了有效的手段</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-引论&quot;&gt;&lt;a href=&quot;#1-引论&quot; class=&quot;headerlink&quot; title=&quot;1. 引论&quot;&gt;&lt;/a&gt;1. 引论&lt;/h2&gt;&lt;h5 id=&quot;媒体的分类&quot;&gt;&lt;a href=&quot;#媒体的分类&quot; class=&quot;headerlink&quot; title=&quot;媒体的分类&quot;&gt;&lt;/a&gt;媒体的分类&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;感觉媒体&lt;/code&gt;: 能直接作用于人的感官，使人直接产生感觉的一类媒体&lt;strong&gt;（作用于人）&lt;/strong&gt;。如人类的语言、音乐、自然界的各种声音、图形、图像。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;表示媒体&lt;/code&gt;: 计算机对信息的表示方法的描述。是&lt;strong&gt;为了加工、处理和传输感觉媒体&lt;/strong&gt;而人为研究、构造出来的一种媒体&lt;strong&gt;（作用于计算机)&lt;/strong&gt;。具体体现为：编码&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>机器学习笔记</title>
    <link href="http://daisine.me/ml/"/>
    <id>http://daisine.me/ml/</id>
    <published>2019-05-10T03:41:54.000Z</published>
    <updated>2019-05-10T03:43:48.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-机器学习概述"><a href="#0-机器学习概述" class="headerlink" title="0. 机器学习概述"></a>0. 机器学习概述</h2><h5 id="机器学习基本任务"><a href="#机器学习基本任务" class="headerlink" title="机器学习基本任务:"></a>机器学习基本任务:</h5><ul><li><strong>回归</strong>：<ul><li>能解决分类、预测问题。</li><li>eg. 年龄估计、表情分析<a id="more"></a></li></ul></li><li><strong>分类</strong>：<ul><li>分类、识别、检测</li></ul></li><li><strong>聚类</strong>：<ul><li>分割(图像、视频)、背景建模</li><li>数据挖掘、数据恢复</li><li>字典学习(视觉信息，文本)</li></ul></li><li><strong>表征</strong>：<ul><li>特征提取(便于前三个任务解决)</li><li>数据重构</li><li>信息检索</li></ul></li></ul><h5 id="方法分类-根据学习形式"><a href="#方法分类-根据学习形式" class="headerlink" title="方法分类(根据学习形式)"></a>方法分类(根据学习形式)</h5><ul><li><strong>有监督学习</strong><ul><li>数据都有明确的标签，根据机器学习产生的模型可以将新数据分到一个明确的类或得到一个预测值。</li><li>eg. 支持向量机、贝叶斯分类器、决策树、线性判别分析…….</li></ul></li><li><strong>无监督学习</strong><ul><li>数据没有标签，机器学习出的模型是从数据中提取出来的模式(提取决定性特征或者聚类等)</li><li>eg. K均值、Meanshift、主成分分析、典型相关分析</li></ul></li><li><strong>半监督学习</strong><ul><li>部分数据有明确的标签，根据机器学习产生的模型可以将新数据分到一个明确的类或得到一个预测值。</li><li>eg. 图直推学习、超图直推学习……</li></ul></li></ul><h5 id="数据划分"><a href="#数据划分" class="headerlink" title="数据划分"></a>数据划分</h5><ul><li>训练集：用来训练模型或确定模型参数。</li><li>测试集：测试已经训练好的模型的推广能力。</li><li>验证集(可选)：用来做模型选择，即做模型的最终优化及确定的。</li></ul><h5 id="误差与精度"><a href="#误差与精度" class="headerlink" title="误差与精度"></a>误差与精度</h5><ul><li>误差：学习器的实际预测输出与 样本的真实输出之间的差异。</li><li>错误率：被错误分类的样本在总样本中的比例。</li><li>精度：被正确分类的样本在总样本中的比例，即1 – error rate。</li><li>训练误差：学习器在训练集上的误差。</li><li>经验误差：即训练误差</li><li>泛化误差：在新样本的误差，实际误差!</li><li>测试误差：学习器在测试集上的误差，用来近似泛化误差。</li></ul><h5 id="过拟合与欠拟合"><a href="#过拟合与欠拟合" class="headerlink" title="过拟合与欠拟合"></a>过拟合与欠拟合</h5><ul><li>过拟合(Overfitting): 为了得到一致假设而使假设变得<strong>过度严格</strong>。</li><li>欠拟合(Underfitting): 模型没有很好地捕捉到数据特征，<strong>不能够很好地</strong>拟合数据</li></ul><h5 id="数据集划分策略"><a href="#数据集划分策略" class="headerlink" title="数据集划分策略"></a>数据集划分策略</h5><ul><li>数据集划分策略：利用测试集或验证集评估学习器的泛化 误差，进而进行模型优化与选择，避免 过拟合。</li><li>常见划分策略:<ul><li>留出法</li><li>交叉验证法</li><li>自助法</li></ul></li><li>数据集划分各子集之间<strong>不能有重合</strong>。</li><li><strong><code>留出法</code></strong><ul><li>直接将数据集D划分为两个互斥的集合，分别为训练集S与测试集T，即 D = S T， S T =  。</li><li>训练/测试集划分尽量保持数据一致性。</li><li>采用合理的采样，合理控制训练集与测试集比例。</li><li>多次使用留出法，重复进行试验评估，求均值，减少数据分布差异造成的偏差。</li></ul></li><li><strong><code>交叉验证法</code></strong><ul><li>n-折交叉验证法：数据集等 分为n份相互不重叠的子集，每次以其中1份子集作为 测试集，其余n-1份子集作为训练集，重复n次，<strong>直至所有子集都作为测试集进行过一次实验评估</strong>，最后返 回n次实验评估的平均结果。常见n取值2、5、10、20。</li><li>交叉验证是最常见数据集划分方法。</li></ul></li><li><strong><code>留一法</code></strong><ul><li>特殊的交叉验证法，每个被划分的子集只有一个样本。</li><li>优点：训练集比例高，训练出来模型与用所有数据进行训练的模型<strong>相似度高</strong>。</li><li>缺点：评估开销大；测试集比例太低，模型调参不便。 </li></ul></li><li><strong><code>自助法</code></strong><ul><li>假设一个由m个样本组成数据集D，对其进行m次<strong>随机采样</strong>构造一个由m个样本组成新数据集D’, 由于m次随机采样可能会对D中部分样本重复采样，所以D’中有部分样本是完全相同，而D中 有部分样本是没有被采样到数据集D’中。因此我们可以把D中这部分<strong>没有被采样到样本D\D’构造测试集， 而D’作为训练集。</strong></li><li>这种没被采样到样本在数据集D中比例一般占 25%~36.8%之间。</li><li>自助法通常用于<strong>数据集较小或难以有效划分训练/测试集情况。</strong></li></ul></li></ul><h5 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h5><ul><li>真正例TP 真反例TN 假正例FP 假反例FN<ul><li>(TP+FN)+(TN+FP) = P + N = 样本总数</li></ul></li><li><strong>均方误差</strong>：多用于度量学习器解决<strong>回归任务</strong>的性能。</li><li><strong>错误率与精度</strong>：多用于评估分类任务的性能。</li><li><strong>查准率、查全率与F1</strong> ：<ul><li>查准率：被正确分类的正例样本在被学习器分类为正例样本中所占的比例。</li><li>查全率：被正确分类的正例样本在正例样本中的比例。</li><li>查全率与查准率是一对相互矛盾的度量。</li></ul></li><li><strong>ROC与AUC</strong><ul><li>二分类问题的性能度量：根据置信度对样本进行降序排序… </li><li>受试者工作特征(ROC)曲线</li><li>AUC：ROC曲线下的面积</li></ul></li></ul><h2 id="1-线性回归"><a href="#1-线性回归" class="headerlink" title="1. 线性回归"></a>1. 线性回归</h2><ul><li>损失函数<ul><li>平方损失函数</li><li>绝对损失函数</li><li>平均损失函数</li></ul></li><li><strong><code>单变量回归模型</code></strong><br><img src="/ml/线性1.png" width="50%"><img src="/ml/线性3.png" width="50%"></li><li><strong><code>多元线性回归</code></strong><br><img src="/ml/线性2.png" width="50%"><br><img src="/ml/线性4.png" width="50%"><img src="/ml/线性5.png" width="50%"></li><li>概率解释<ul><li>似然函数</li><li><strong>极大似然法</strong>：令每个样本x<sub>i</sub>输出为y<sub>i</sub>的概率越大越好。</li></ul></li><li>回归任务的思想：分析变量之间的关系</li><li>定义了损失函数来评估线性回归模型的好坏：平方损失函数、极大似然函数。</li><li>线性回归函数中两个参数的显示表达：最小二乘法(向量与矩阵形式)</li><li>线性回归算法可以对数据进行分析、预测。</li><li>线性回归的概率解释：极大似然法</li></ul><h2 id="2-逻辑回归"><a href="#2-逻辑回归" class="headerlink" title="2. 逻辑回归"></a>2. 逻辑回归</h2><ul><li>逻辑回归与线性回归的区别与联系：<ul><li>逻辑回归是用于解决二分类问题的机器学习方法。</li><li>线性回归要求因变量是连续性数值变量，逻辑回归要求因变量是分类型变量。</li></ul></li><li>逻辑回归的损失函数：<strong>分类损失函数</strong> </li><li><strong>求解无约束优化问题</strong>：<ul><li>数值方法I：<strong>牛顿法</strong> -&gt; 方程求根问题 / 最小化问题</li><li>数值方法II：<strong>梯度下降法</strong> y<sub>n</sub>是第n步下降时选取的步长，也称学习旅率。</li></ul></li><li>掌握梯度下降法、牛顿法的基本原理与迭代公式：<br><img src="/ml/牛顿.png" width="50%">  </li></ul><h2 id="3-决策树"><a href="#3-决策树" class="headerlink" title="3. 决策树"></a>3. 决策树</h2><ul><li>决策树：构建一个基于属性的<strong>树形分类器</strong>。<ul><li>每个非叶节点表示一个特征属性上的测试(分割)。</li><li>每个分支代表这个特征属性在某个值域上的输出。</li><li>每个叶节点存放一个类别。</li></ul></li><li>使用决策树进行决策的过程：<ul><li>从根节点开始，测试待分类项中相应的特征属性，并按照其值选择输出分支，直到到达叶子节点，将叶子节点存放的类别作为决策结果。</li></ul></li><li>决策树构建：<strong>分治法思想(递归)</strong></li><li>对于当前结点<strong>返回递归条件</strong> / <strong>递归结束条件</strong>:<ul><li>当前结点样本均属于同一类别，无需划分。</li><li>当前属性集为空。</li><li>所有样本在当前属性集上取值相同，无法划分。 </li><li>当前结点包含的样本集合为空，不能划分。</li></ul></li></ul><h5 id="决策树的核心"><a href="#决策树的核心" class="headerlink" title="决策树的核心"></a>决策树的核心</h5><ul><li>定义最佳划分属性:<ul><li>经过属性划分后，不同类样本被更好的分离。</li><li>理想情况:划分后样本被完美分类。即每个分支的样本都属于同一类。</li><li>实际情况:不可能完美划分。尽量使得每个分支某一类样本比例尽量高，即尽量提高划分后子集的纯度(purity)。</li></ul></li><li>最佳划分属性目标: <ul><li>提升划分后子集的纯度</li><li>降低划分后子集的不纯度</li></ul></li></ul><h5 id="ID3决策树算法"><a href="#ID3决策树算法" class="headerlink" title="ID3决策树算法"></a>ID3决策树算法</h5><ul><li>我们希望决策树的分支节点所包含的样本尽可能属于同一类别，即结点的“纯度”越来越高。</li><li>纯度 ↑ = 确定性 ↑ = 信息量 ↓ </li><li><strong><code>信息熵</code></strong>：<strong>度量样本集合纯度</strong>最常用的一种指标。<ul><li>假定当前样本集合D中第k类样本所占的比例为p<sub>k</sub>(k = 1, 2, …, |y|)，则D的信息熵为：<br><img src="/ml/信息熵.png" width="30%"></li><li>信息熵用来度量信息量，<strong>信息熵值越小，说明样本集的纯度越高。</strong></li></ul></li><li><strong><code>信息增益</code></strong>：<br><img src="/ml/信息增益.png" width="50%"></li><li>ID3决策树算法：<strong>利用</strong>划分后的<strong>信息增量来判断</strong>属性划分的优劣性。<ul><li><strong>信息增益越大，说明当前划分效果越好。</strong></li><li>信息增量准则对可取值数目较多的属性有所偏好。 eg. 每个学号因为只有一个样本，纯度都很高。</li></ul></li></ul><h5 id="C4-5决策树算法"><a href="#C4-5决策树算法" class="headerlink" title="C4.5决策树算法"></a>C4.5决策树算法</h5><ul><li><strong><code>增益率</code></strong>：越大越好<br><img src="/ml/增益率.png" width="50%"></li><li>采用此新准则的方法称为C4.5决策树算法。</li></ul><h5 id="CART决策树算法"><a href="#CART决策树算法" class="headerlink" title="CART决策树算法"></a>CART决策树算法</h5><ul><li><strong><code>基尼指数</code></strong>：越小 -&gt; 纯度越高 -&gt; 越好<br><img src="/ml/gini.png" width="40%"></li></ul><h5 id="决策树的裁剪"><a href="#决策树的裁剪" class="headerlink" title="决策树的裁剪"></a>决策树的裁剪</h5><ul><li>剪枝处理：避免训练<strong>过拟合</strong>。 </li><li><strong><code>预剪枝</code></strong>：指<strong>在决策树生成过程中</strong>，对每个结点在划分前后进行估计，若当前结点划分不能提升决策树泛化性能，则进行裁剪，把结点标记为叶结点。<ul><li>优点: 减少属性划分与测试时间开销。 </li><li>缺点: 可能造成欠拟合。</li></ul></li><li><strong><code>后剪枝</code></strong>：在<strong>生成一颗完整的决策树后</strong>，<strong>自底向上</strong>地对非叶结点进行考察，若将该结点对应的子树被替换为叶节点能提升决策树泛化能力，则进行裁剪。<ul><li>优点: 减少欠拟合风险。 </li><li>缺点: 时间开销大。</li></ul></li></ul><h5 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h5><ul><li>决策树ID3算法能不能进一步优化? <ul><li>𝐺𝑎𝑖𝑛𝐷,𝑎 = 𝑬𝒏𝒕𝑫 − 𝐸𝑛𝑡𝐷,𝑎 减少开销</li></ul></li><li>如何设计自己决策树算法?<ul><li>设计自己的划分属性优劣性目标函数。</li></ul></li><li>现有决策树框架的分类是否是全局最优? <ul><li>决策树采用<strong>贪心法则</strong>，只得<strong>局部最优</strong>。</li></ul></li><li>如何提升决策树算法框架的性能?<ul><li>融入随机性，提升泛化能力，Eg.<strong>随机森林</strong>。</li></ul></li><li>划分属性优劣度量(重点) <ul><li>ID3算法：信息增益</li><li>C4.5算法：增益率 </li><li>CART算法：基尼指数</li></ul></li></ul><h2 id="4-感知机"><a href="#4-感知机" class="headerlink" title="4. 感知机"></a>4. 感知机</h2><h5 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h5><ul><li>感知机由两层神经元组成，输入层接受外界输入信号后传递给输出层，输出层是M-<br>本质上, M-P神经元 = <strong>线性二分类</strong>器</li><li>感知机能容易地实现逻辑与、或、非运算。 <strong>P99</strong>(感知机<strong>不能解决异或</strong>这样的非线性可分问题)</li><li>感知机只有输出神经元进行激活函数处理，即只拥有一层功能神经元。<ul><li>只能解决线性可分问题：存在一个线性超平面将他们分开，感知机的学习过程收敛。</li><li>否则感知机学习过程会发生振荡。</li></ul></li></ul><h5 id="多层神经网络"><a href="#多层神经网络" class="headerlink" title="多层神经网络"></a>多层神经网络</h5><ul><li>非线性可分问题：多层功能神经元。</li><li>多层网络的<strong>权重优化法则</strong>：<strong>误差逆传播(简称BP)算法</strong>。</li></ul><h5 id="BP算法-P101"><a href="#BP算法-P101" class="headerlink" title="BP算法 P101"></a>BP算法 P101</h5><ul><li>基于梯度下降策略，是一个迭代学习算法。</li><li>核心思想：利用前向传播，计算第 𝑛 层输出值。</li><li>优化目标：输出值和实际值的残差。(最小化训练集D上的累积误差)</li><li>计算方法：将残差按影响逐步传递回第 𝑛 −1, 𝑛 − 2, ⋯ , 2层，以修正各层参数。(即所谓的误差逆传播)</li><li>主要工具：链式法则(复合函数求偏导)。</li><li>BP算法局限性<ul><li>容易过拟合 -&gt; 早停、正则化</li><li>容易陷入局部最优 -&gt; 选取多次初值、随机梯度下降法</li><li>难以设置隐层个数 -&gt; 试错法</li></ul></li></ul><h2 id="5-神经网络"><a href="#5-神经网络" class="headerlink" title="5. 神经网络"></a>5. 神经网络</h2><ul><li>神经网络: 神经网络是由具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实世界物体所做的交互反应。<br><img src="/ml/神经元.png" width="60%"><ul><li>Sigmoid函数 ≠ Logistic函数</li><li>Logistic函数 ⊂ Sigmoid函数</li></ul></li></ul><h2 id="6-支持向量机-SVM模型"><a href="#6-支持向量机-SVM模型" class="headerlink" title="6. 支持向量机(SVM模型)"></a>6. 支持向量机(SVM模型)</h2><h5 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h5><ul><li>离分类边界远的样本的置信度高，而离分类边界近的样本置信度低。</li><li>SVM是一个凸的带不等式约束的凸二次规划问题</li><li><strong>基本思想：</strong>寻找两类样本之间最中间的直线。</li><li><strong>目的：</strong>使划分平面对于样本的扰动容忍性好。</li><li>对比：<ul><li>逻辑回归算法是基于全部样本的二分类器：考虑<strong>全部样本的平均似然性</strong>。</li><li>支持向量机算法是基于部分样本的二分类器：考虑<strong>部分靠近边界</strong>的支持向量。</li></ul></li></ul><h5 id="拉格朗日乘子法"><a href="#拉格朗日乘子法" class="headerlink" title="拉格朗日乘子法"></a>拉格朗日乘子法</h5><ul><li>拉格朗日乘子法：求解约束优化问题常用的方法之一。</li><li>基本思想：<strong>求解与之等价的无约束对偶问题</strong>。</li><li>较之原问题来说，对偶问题可能更方便求解。</li><li>较之原问题来说，对偶问题也可能更有意义。</li><li>原问题和对偶问题等价的充分必要条件被称作KKT条件</li></ul><h5 id="SVM对偶模型"><a href="#SVM对偶模型" class="headerlink" title="SVM对偶模型"></a>SVM对偶模型</h5><ul><li>可以利用拉格朗日乘子法得到SVM的对偶模型。</li><li>对偶模型更能反映该问题的特点，只有支持向量才对优化问题起作用。</li><li>求解对偶模型的比求解原问题简单，计算复杂度更低。</li></ul><h5 id="软间隔SVM"><a href="#软间隔SVM" class="headerlink" title="软间隔SVM"></a>软间隔SVM</h5><ul><li>前面的讨论一直假定训练样本在样本空间或者特征空间中是线性可分的，即存在一个超平面能将不同的类的样本完全划分开。</li><li>在现实任务重很难确定合适的核函数使得训练集在特征空间中线性可分。<ul><li>缓解该问题的一个办法是允许支持向量机在一些样本上出错。</li><li>硬间隔：要求所有样本均满足约束。</li><li>软间隔：允许某些样本不满足约束。在最大化间隔的同时，不满足约束的样本应该尽可能少。</li></ul></li><li>软间隔SVM三种常见的替代损失函数：<ul><li>hinge损失</li><li>指数损失</li><li>对率损失</li></ul></li><li>软间隔SVM可以对有outlier的数据分类。<ul><li>软间隔SVM对偶模型与SVM对偶模型非常相似，可以用相同算法求解。</li><li>软间隔SVM模型可以看作是最小化hinge损失函数的正则化模型。</li><li>当参数C趋向无穷大时，软间隔SVM退化成普通的SVM。</li></ul></li></ul><h5 id="SMO算法"><a href="#SMO算法" class="headerlink" title="SMO算法"></a>SMO算法</h5><ul><li>SMO的两个部分:<ul><li>解析地求解两个变量二次规化问题。</li><li>启发式地选择变量。</li></ul></li><li>SMO小结<ul><li>序列极小化优化算法(SMO)是求解SVM模型最高效的算法。</li><li>SMO每次迭代解两个变量的二次优化问题，其最优解可以显式表达。</li><li>SMO利用了启发式算法根据数据点违反KKT条件的大小选取需要迭代的变量。</li></ul></li></ul><h5 id="非线性SVM-核化SVM-P126"><a href="#非线性SVM-核化SVM-P126" class="headerlink" title="非线性SVM / 核化SVM P126"></a>非线性SVM / 核化SVM P126</h5><ul><li>核技巧是处理非线性分布数据处理问题最常见的方法之一。</li><li>核技巧最早出线在SVM模型中，随后在许多机器学习领域都有应用。。</li><li>核化SVM的效果主要取决于核函数的选取。</li></ul><h5 id="支持向量回归SVR-P133"><a href="#支持向量回归SVR-P133" class="headerlink" title="支持向量回归SVR P133"></a>支持向量回归SVR P133</h5><ul><li>线性回归问题<ul><li>寻找最佳直线(超平面)，使得预测值𝒇(𝒙𝒊 )和真实标签的均方误差尽量小。</li></ul></li><li>支持向量机思想<ul><li>寻找最佳直线(超平面)，使得数据点到直线的间隔尽可能的大。</li></ul></li></ul><h2 id="7-K-均值-聚类"><a href="#7-K-均值-聚类" class="headerlink" title="7. K-均值(聚类)"></a>7. K-均值(聚类)</h2><h5 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h5><ul><li>聚类：根据某种<strong>相似性</strong>，把一组数据<strong>划分</strong>成<strong>若干个簇</strong>的过程。<ul><li>难点一:相似性很难精准定义! <strong>各种距离，度量学习</strong>。 </li><li>难点二:可能存在的划分太多! <strong>避免穷举，优化算法</strong>。 </li><li>难点三: 若干个簇 = ? <strong>预先给定，算法自适应</strong>。</li></ul></li></ul><h5 id="K-means-K均值算法"><a href="#K-means-K均值算法" class="headerlink" title="K-means / K均值算法"></a>K-means / K均值算法</h5><ul><li>聚类问题可以通过为每个簇簇的中心寻找合适的中心来实现。</li><li>假设每个簇的中心已经找到， 可以把所有数据点分配到距离它最近的中心所在的簇。</li><li>K-means模型可能的划分数：<strong>非凸组合优化问题</strong>，NP-难</li><li>求解非凸组合优化问题的两种常见方法:<ul><li><strong>启发式方法</strong>: 一个基于直 观或经验构造的算法，在可接受的时间内下 给出待解决组合优化问题每一个实例的一个 可行解，该可行解与最优解的偏离程度一般不能被预计。</li><li><strong>松弛方法</strong>: 对组合优化问题进行适当的松弛，将其转化为多项式时间内可解的优化问题，松弛后问题的解不是原组合优化问题的解，需要适当的后处理。</li></ul></li></ul><h5 id="K-means模型的矩阵形式"><a href="#K-means模型的矩阵形式" class="headerlink" title="K-means模型的矩阵形式"></a>K-means模型的矩阵形式</h5><ul><li>对于任意一种划分都对应一个<strong>标准化示性矩阵 H</strong>(或<strong>均一化邻接矩阵 W</strong> )。</li><li>反之，任意一个标准化示性矩阵 H (或均一化邻接矩阵 W )都对应着<strong>一种划分</strong>。</li><li>本质上说，标准化示性矩阵 H(或均一化邻接矩阵 W ) 的引入并没有简化聚类问题的难度，但是<strong>为求解方法提供了更多的参考和选择</strong>。</li></ul><h5 id="Lloyd算法"><a href="#Lloyd算法" class="headerlink" title="Lloyd算法"></a>Lloyd算法</h5><p> <img src="/ml/lloyd.png" width="50%"><img src="/ml/lloyd2.png" width="50%"></p><ul><li>优势：<ul><li>Lloyd 算法属于EM算法(期望最大化)，可以保证收敛到K-means问题的局部最优解。</li><li>Lloyd 算法的速度快，计算复杂度为O(nk)。</li><li>Lloyd 算法思想简单，容易实现，可拓展性强。</li></ul></li><li>劣势:<ul><li>簇的个数k需要预先给定。</li><li>聚类结果依赖于初值的选取。</li></ul></li></ul><h2 id="8-谱聚类-聚类"><a href="#8-谱聚类-聚类" class="headerlink" title="8. 谱聚类(聚类)"></a>8. 谱聚类(聚类)</h2><h5 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h5><ul><li>输入: 数据矩阵 X，簇个数 k。<ul><li>构建邻接矩阵W。</li><li>计算<strong>拉普拉斯矩阵L</strong>。 </li><li>计算L最小k个特征值对应的特征向量U。</li><li>对U进行<strong>K-means</strong>聚类。</li></ul></li><li>输出: k 个簇。</li></ul><h5 id="谱聚类和K-means的关系"><a href="#谱聚类和K-means的关系" class="headerlink" title="谱聚类和K-means的关系"></a>谱聚类和K-means的关系</h5><ol><li>相比直接进行K-means聚类，谱聚类有什么不同?<ul><li>相当于<strong>先做了一次特征提取</strong>，再聚类。</li></ul></li><li>谱聚类背后的机理是什么? <ul><li>图论中的<strong>切割图问题。</strong></li></ul></li></ol><h2 id="9-降维"><a href="#9-降维" class="headerlink" title="9. 降维"></a>9. 降维</h2><h5 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h5><ul><li>为什么要降维?<ul><li>去除不相关的特征(去噪、特征提取) </li><li>储存与计算</li><li>可视化</li><li>数据本身具有低维特点</li></ul></li><li>线性降维方法:<ul><li>PCA </li><li>LDA </li><li>SVD </li><li>NMF</li></ul></li><li>非线性降维方法:<ul><li>Kernel PCA </li><li>Isomap</li><li>MDS</li></ul></li></ul><h5 id="主成分分析-PCA"><a href="#主成分分析-PCA" class="headerlink" title="主成分分析 PCA"></a>主成分分析 PCA</h5><blockquote><p><strong>思想</strong>: 假设降维的目的是解决维度灾难，在低维空间进行分类。那么我们希望降维后的样本保持<br>一定的可分性，即经过投影之后，同类样本的投 影点尽可能接近，异类样本的投影点尽可能远离。</p><blockquote><p><strong>解决方案</strong>: 让投影后的<strong>类中心之间的距离尽可能大</strong>，从而增强样本的可分性。</p></blockquote></blockquote><ul><li>PCA: 最大可分性<br><img src="/ml/pca.png" width="50%"><img src="/ml/pca2.png" width="36%"></li><li>PCA在考虑数据降维时候希望在新空间的信息越多 越好，即低维嵌入的方差(协方差矩阵的迹)越大。</li><li>PCA是一个<strong>无监督降维方法</strong>，并没有运用任何有监督信息，这也是PCA算法一个弊端。</li><li>对于一个分类问题，保留信息越多分类效果一定 会更好么?<ul><li>不一定，分类效果完全取决样本在新的子空间下的<strong>可区分度</strong>。</li></ul></li></ul><h5 id="线性判别分析-LDA"><a href="#线性判别分析-LDA" class="headerlink" title="线性判别分析 LDA"></a>线性判别分析 LDA</h5><ul><li>对于二维数据来说，线性判别分析(Linear Discriminant Analysis)同时最大化类间散度矩阵，最小化类内散度矩阵。</li><li><strong>目标函数</strong>通常被成为<strong>广义瑞利商</strong>，最优解为广义特征值问题。<ul><li>可以构建拉格朗日函数 -&gt; 𝓛对变量𝒘求偏导 -&gt; 对偶问题</li></ul></li><li>此模型的<strong>最优解有无穷多个</strong>(对最优解w进行任意缩放)。<ul><li>如何<strong>定义聚合程度和扩散程度</strong>?   方差<strong>(协方差矩阵)</strong></li><li>如何保证样本点尽量聚合？  所有点接近<strong>中心点</strong>。</li><li>如何便于分类? <strong>同类样本应具有较好的聚合度，而类别之间应该具有较好的扩散度。</strong></li></ul></li><li>LDA算法流程：<br><img src="/ml/lda.png" width="36%"> </li></ul><h5 id="LDA-vs-PCA"><a href="#LDA-vs-PCA" class="headerlink" title="LDA vs PCA"></a>LDA vs PCA</h5><ul><li>相同点:<ul><li>都属于降维方法。</li><li>都转化为求解特征值问题。 </li><li>都可以使用核化技巧。</li></ul></li><li>不同点:<ul><li>PCA是非监督降维，LDA是监督降维。</li><li>PCA效率比LDA更高</li><li>PCA旨在寻找一组子坐标系(定义一个子空间)<strong>使得样本点的方差最大</strong>，即信息量保留越多。LDA旨在寻找一组子坐标系(定义一个子空间)<strong>使得样本点类内散度越小</strong>，类间散度越大。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-机器学习概述&quot;&gt;&lt;a href=&quot;#0-机器学习概述&quot; class=&quot;headerlink&quot; title=&quot;0. 机器学习概述&quot;&gt;&lt;/a&gt;0. 机器学习概述&lt;/h2&gt;&lt;h5 id=&quot;机器学习基本任务&quot;&gt;&lt;a href=&quot;#机器学习基本任务&quot; class=&quot;headerlink&quot; title=&quot;机器学习基本任务:&quot;&gt;&lt;/a&gt;机器学习基本任务:&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;回归&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;能解决分类、预测问题。&lt;/li&gt;
&lt;li&gt;eg. 年龄估计、表情分析&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机图形学笔记及练习</title>
    <link href="http://daisine.me/CG/"/>
    <id>http://daisine.me/CG/</id>
    <published>2019-05-10T03:01:18.000Z</published>
    <updated>2019-05-10T03:41:25.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-计算机图形学概述"><a href="#1-计算机图形学概述" class="headerlink" title="1. 计算机图形学概述"></a>1. 计算机图形学概述</h2><h3 id="1-1-研究内容"><a href="#1-1-研究内容" class="headerlink" title="1.1 研究内容"></a>1.1 研究内容</h3><ul><li><code>图形</code>含有几何属性，或者说更强调场景的集合表示，是由场景的几何模型和警务的物理属性共同组成。（矢量/参数）</li><li><code>图像</code>是指计算机内以位图形式存在的灰度信息。（位图）</li><li><code>计算机图形学</code>：利用计算机研究一系列原理、方法与技术的学科。<a id="more"></a> <ul><li>图形的表示和生成：如何对数据建模，并将数据转换为图像？</li><li>图形的处理和显示：如何在专门的显示设备上显示图形？</li></ul></li><li>一个完整的图形处理过程包括：<ul><li>图形的输入</li><li>图形的处理</li><li>图形的输出</li></ul></li></ul><h3 id="1-2-计算机图形学的发展历史"><a href="#1-2-计算机图形学的发展历史" class="headerlink" title="1.2 计算机图形学的发展历史"></a>1.2 计算机图形学的发展历史</h3><ul><li>50年代，CTR的出现为计算机生成和显示图形提供了可能。</li><li>50年代末期，MIT的林肯实验室在“旋风”计算机上开发SAGE空中防御体系，通过光笔在屏幕上指点与系统交互，<strong>标志着交互式图形技术的诞生。</strong></li><li>60年代<ul><li>MIT林肯实验室的<strong>I. E. Sutherland</strong>发表了一片题为“<strong>Sketchpad：一个人机交互通信的图形系统</strong>”的博士论文，确定了交互图形学作为一个学科分支。</li><li>法国雷诺汽车公司的工程师Pierre Bezier提出 Bezier曲线、曲面的理论，而称为计算机辅助几何设计(CAGD)的先驱。</li><li>MIT的教书 Steven A. Coons提出了超限插值的新思想，通过插值四条任意便捷的曲线来构造曲面，</li></ul></li><li>70年代<ul><li>光栅图形学迅速发展</li><li>图形软件标准化：ISO发布CGI、CGM、GKS、PHIGS</li><li>真实感图形学和实体造型技术：(1970)Bouknight提出第一个光反射模型；(1971)Gourand提出“漫反射模型 + 插值”的思想，被称为Gourand明暗处理；(1975)Phong提出著名的简单光照模型-Phong模型。</li></ul></li></ul><h3 id="1-3-图形软件发展及软件标准的形成"><a href="#1-3-图形软件发展及软件标准的形成" class="headerlink" title="1.3 图形软件发展及软件标准的形成"></a>1.3 图形软件发展及软件标准的形成</h3><ul><li>近二十年，国际标准化组织ISO已经批准和正在讨论的与计算机图形有关的标准有：<ul><li>GKS、GKS-3D、PHIGS、CGM、CGI、IGES、STEP</li></ul></li><li>事实标准<ul><li>SGI的OpenGL，微软的Direct X，Adobe的Postscript等。  </li></ul></li></ul><h3 id="1-4-当前研究热点"><a href="#1-4-当前研究热点" class="headerlink" title="1.4 当前研究热点"></a>1.4 当前研究热点</h3><ul><li>造型技术</li><li>真实感图形绘制技术</li><li>人机交互技术</li><li>与计算机网络技术的紧密结合<ul><li>远程导航与维修</li><li>远程教育</li></ul></li><li>图像生成技术与图像处理的结合</li><li>虚拟现实技术</li></ul><h3 id="1-5-图形系统"><a href="#1-5-图形系统" class="headerlink" title="1.5 图形系统"></a>1.5 图形系统</h3><p>一个图形系统通常由：图形处理器、图形输入设备和图形输出设备构成。</p><h5 id="图形输入设备"><a href="#图形输入设备" class="headerlink" title="图形输入设备"></a>图形输入设备</h5><ul><li>鼠标</li><li>键盘：输入控制命令，利用光标指示对象与位置。</li><li>光笔：一种检测光的装置。P13 <strong>考核原理，判断正误</strong></li><li>数字化仪：数控板/手写板</li><li>扫描仪：直接把图形和图像扫描到计算机中以像素信息进行存储的设备。 <ul><li>光学信号 -&gt; 模拟信号 -&gt; 数字信号</li></ul></li><li>触摸屏，3D图形输入设备</li></ul><h5 id="图形处理器-显卡"><a href="#图形处理器-显卡" class="headerlink" title="图形处理器(显卡)"></a>图形处理器(显卡)</h5><ul><li>显示主芯片是显卡的核心，俗称GPU</li><li>显存用于存储将要现实的图形信息及保存图形运算的中间数据。</li></ul><h5 id="图形显示设备"><a href="#图形显示设备" class="headerlink" title="图形显示设备"></a>图形显示设备</h5><ul><li>图形输出包括图形的显示和图形的绘制<ul><li><code>图形显示</code>指的是在屏幕上输出图形。</li><li><code>图形绘制</code>通常指把图形画在纸上(硬拷贝)，如打印机和绘图仪</li></ul></li><li>显示器分类：<ul><li>CRT显示器</li><li>平板显示器</li></ul></li></ul><h5 id="阴极射线管-CRT-P9"><a href="#阴极射线管-CRT-P9" class="headerlink" title="阴极射线管(CRT) P9"></a>阴极射线管(CRT) P9</h5><ul><li>CRT显示器分类<ul><li>视觉属性：单色CRT，彩色CRT</li><li>偏转系统：偏转电场式，偏转磁场式</li><li>扫描方式：随机扫描，光栅扫描  </li></ul></li><li>组成：<ul><li>电子枪</li><li>聚焦系统</li><li>加速电极</li><li>偏转系统</li><li>荧光屏</li></ul></li><li>工作原理<ul><li>电子枪发射电子束</li><li>经过聚焦系统、加速电极、偏转系统，轰击到荧光屏的不同部位，被其表面的荧光物质吸收，发光产生可见的图形。</li><li>为要保持一幅稳定的画面，必须不断地发射电子束(<strong>不断刷新</strong>)，以抵消亮度的衰减。 </li></ul></li><li>电子枪 <ul><li>阴极：电流通过，灯丝加热，发出电子束。</li><li>控制栅：通过调节负电压来控制电子数量，即控制荧光屏上相应点的亮度。</li></ul></li><li>聚焦系统：通过电场和磁场控制电子束变细，保证亮点足够小，提高分辨率。</li><li>加速电极：加正的高电压(几万伏)，使电子达到轰击激发荧光屏应有的速度</li><li>偏转系统<ul><li>控制静电场或磁场，使电子束偏转。</li><li>最大的偏转角是系统性能的最重要的指标，显示器长短与此有关。</li><li>CRT显示器屏幕越大，整个显像管就越长。</li></ul></li><li>荧光屏<ul><li>荧光物质：吸收电子束而发光</li><li>余辉时间：持续发光时间。电子束离开某点后，该点的亮度值衰减到初始值。</li><li>刷新：为了让荧光物质保持在一个稳定的亮度值。</li><li>刷新频率：每秒重绘屏幕次数，显示器更新图像的速率。  </li><li>光点：电子束打在荧光屏上，显示器能显示的最小的发光点。</li><li>像素：构成屏幕的最小元素。</li><li>图形显示在屏幕上时，按当前的图形显示分辨率所能提供的最小元素点。像素点可看做光点的集合，其最小尺寸等于光点。</li><li>屏幕分辨率/光栅分辨率：是物理分辨率，CRT在水平或者竖直方向单位长度上能识别的最大像素个数，单位通常为dip。</li><li>显示分辨率：计算机显示控制器所提供的显示模式分辨率。</li></ul></li></ul><blockquote><p>P9 <strong>考点</strong> 假设荧光物质的持续发光时间为40ms 则，CRT产生稳定图像所需要的<strong>最小刷新频率 = 1秒/荧光物质的持续发光时间= 1000/40ms = 25 Hz</strong><br>只有刷新频率高达一定值后，图像才能稳定显示，约为每秒60帧(60Hz)。一般必须要有85Hz以上的刷新频率。</p></blockquote><h5 id="彩色阴极射线管"><a href="#彩色阴极射线管" class="headerlink" title="彩色阴极射线管"></a>彩色阴极射线管</h5><ul><li>彩色CRT：通过将能发不同颜色的光的荧光物质进行组合而产生彩色。<ul><li><strong>渗透性 - 射线穿透法</strong>：常用于随机扫描显示器。</li><li><strong>多枪型 - 影孔板法</strong>：常用于光栅扫描显示器。</li></ul></li></ul><h5 id="射线穿透法"><a href="#射线穿透法" class="headerlink" title="射线穿透法"></a>射线穿透法</h5><ul><li>屏幕内表面涂有两层荧光涂层。红色光和绿色光两种发光物质，不同速度电子束穿透荧光层的深浅，决定所产生的颜色。</li><li>应用：主要用于画线显示器</li><li>优点：成本低</li><li>缺点：只能产生有限几种颜色</li></ul><h5 id="影孔板法-P10"><a href="#影孔板法-P10" class="headerlink" title="影孔板法 P10"></a>影孔板法 P10</h5><ul><li>影孔板被安装在荧光屏的内表面，用于精确定位像素的位置。</li><li>分类： <ul><li><strong>点阵式</strong>：球面显像管。</li><li><strong>栅线式</strong>：柱面显像管，如日本索尼公司的特丽珑管，三菱公司的钻石龙管。</li><li><strong>栅格式/沟槽式</strong>：LG的未来窗显像管。</li></ul></li><li>工作原理：<ul><li>三基色(红绿蓝)，三色荧光点，三只电子枪。</li><li>电子枪、影孔板中的一个小孔和对应的荧光点呈一直线。</li><li>每个小孔与一个像素（即三个荧光点）对应。</li><li>调节各电子枪发生的电子束中所含电子的数目，即可控制各色光点亮度。<br><img src="/CG/影孔板.png" width="30%"></li></ul></li><li>显示器能同时显示的颜色个数：如果每支电子枪发出的电子束的强度有256个等级，则显示 器能同时显示<code>256*256*256=16M</code>种颜色，称为真彩系统。</li></ul><h5 id="栅线式-vs-点阵式"><a href="#栅线式-vs-点阵式" class="headerlink" title="栅线式 vs 点阵式"></a>栅线式 vs 点阵式</h5><ul><li>原理的区别：光线的选择方式和荧光点的排列不同</li><li>点阵式的缺点：<ul><li>用于球面荧光屏，几何失真大。</li><li>三角形的荧光点排列，即使很密很细也不会特别清晰。</li></ul></li><li>栅线式的优点：<ul><li>亮度更高，色彩也更鲜艳。</li><li>用于高分辨率的柱面和平面显示器。</li><li>电子束通过率有很大的提高。 </li></ul></li></ul><h5 id="荫罩式显示器的固有缺陷"><a href="#荫罩式显示器的固有缺陷" class="headerlink" title="荫罩式显示器的固有缺陷"></a>荫罩式显示器的固有缺陷</h5><ul><li>由合金钢板制成的荫罩<strong>易磁化</strong></li><li>受热受冲击时<strong>易变形</strong><ul><li>显像管内射向荧光屏的电子束中有75% 以上被荫罩阻挡，转变成热量浪费了</li></ul></li><li>屏幕尺寸越大或清晰度越高，就越难制造， <strong>生产成本高</strong>，成品率偏低，价格过高</li><li>制约彩色显像管<strong>清晰度</strong>提高的技术<strong>瓶颈</strong>是彩色显像管中的荫罩</li></ul><h5 id="随机扫描显示系统特点"><a href="#随机扫描显示系统特点" class="headerlink" title="随机扫描显示系统特点"></a>随机扫描显示系统特点</h5><ul><li>数据表示：矢量表示，只有端点信息，无线段中间点</li><li>扫描方式：电子束像一支快速移动的画笔，在任意方向上自由移动，<br>按照显示命令用画线的方式绘出图形</li><li>显示图形：几何属性为主，线框图形</li><li>别称：矢量扫描显示器，画线显示器</li><li>优点：扫描速度快，分辨率高，线条质量好，易修改，交互性好，<br>动态性能好</li><li>缺点：价格贵，只能显示线框图形，应用于军事、CAD领域</li></ul><h5 id="光栅扫描的显示系统特点"><a href="#光栅扫描的显示系统特点" class="headerlink" title="光栅扫描的显示系统特点"></a>光栅扫描的显示系统特点</h5><ul><li>数据表示：像素矩阵，像素数组</li><li>扫描方式：从上到下，从左到右，与电视工作原理类似</li><li>显示图形：几何属性＋视觉属性(Visual attribute) , 真实<br>感图形</li></ul><h5 id="光栅图形显示系统"><a href="#光栅图形显示系统" class="headerlink" title="光栅图形显示系统"></a>光栅图形显示系统</h5><ul><li>显示处理器：主要任务是将应用程序定义为一组像素强度值，存放在帧缓冲存储器中。</li><li>帧缓冲存储器：俗称<strong>显存</strong>，保存了对应屏幕所有亮点的亮度值。</li><li>视频控制器：建立帧缓存与屏幕像素之间一一对应，负责刷新。</li><li>CRT显示器</li></ul><p><img src="/CG/光栅图形.png" width="50%"></p><h5 id="帧缓存与显示器分辨率的关系"><a href="#帧缓存与显示器分辨率的关系" class="headerlink" title="帧缓存与显示器分辨率的关系"></a>帧缓存与显示器分辨率的关系</h5><ul><li>帧缓存的大小 =  显示器分辨率的大小 * 帧缓存的位平面数 / 8</li><li>eg. 分辨率为640x480、1280x1024、1024x1024的显示器各需要多少字节位平面数为24的帧缓存？ans: 分辨率*24/8</li></ul><h5 id="显存问题"><a href="#显存问题" class="headerlink" title="显存问题"></a>显存问题</h5><ul><li>高分辨率和真彩要求有大的显存：1024x1024真彩模式需要3M字节显存。</li><li>解决办法：<ul><li>采用<strong>查色表</strong>或者称彩色表机制。</li><li>采用<strong>隔行扫描</strong>的方法。</li></ul></li></ul><h5 id="带宽问题"><a href="#带宽问题" class="headerlink" title="带宽问题"></a>带宽问题</h5><ul><li>带宽T与分辨率(M<em>N)、帧频(刷新频率)F的关系：`T &gt;= M </em> N * F`</li><li>高分辨率和高刷新频率要求高带宽</li><li>解决办法：<ul><li>隔行扫描(现在一般用逐行扫描)</li><li>对Z缓冲期内容进行压缩和快速清除。</li></ul></li></ul><h5 id="光栅显示系统的特点"><a href="#光栅显示系统的特点" class="headerlink" title="光栅显示系统的特点"></a>光栅显示系统的特点</h5><ul><li>优点<ul><li>成本低</li><li>易于绘制填充图形</li><li>色彩丰富</li><li>刷新频率一定，与图形的复杂度无关</li><li>易于修改图形</li></ul></li><li>缺点<ul><li>需要扫描转换</li><li>扫描转换速度偏低，交互操作响应慢</li><li>分辨率偏低，有阶梯效应，会产生走样  </li></ul></li></ul><h5 id="LCD显示器"><a href="#LCD显示器" class="headerlink" title="LCD显示器"></a>LCD显示器</h5><ul><li>优点<ul><li>外观小巧精致，厚度只有6.5-Bcm左右</li><li>响应速度快、无闪烁、无干扰</li><li>工作电压低，功耗小，省电</li><li>没有电磁辐射，对人体健康没有任何影响</li></ul></li><li>缺点<ul><li>成品率偏低导致成本偏高，冷阴极荧光灯的使用寿命井不算太长，可<br>视角度有限</li></ul></li></ul><h3 id="1-6-计算机图形学的应用及研究前沿"><a href="#1-6-计算机图形学的应用及研究前沿" class="headerlink" title="1.6 计算机图形学的应用及研究前沿"></a>1.6 计算机图形学的应用及研究前沿</h3><ul><li>计算机辅助设计与制造</li><li>可视化</li><li>真实感图形实时绘制与自然景物仿真 </li><li>计算机动画</li><li>用户接口</li><li>计算机艺术</li></ul><h2 id="2-基本图形的生成算法"><a href="#2-基本图形的生成算法" class="headerlink" title="2.基本图形的生成算法"></a>2.基本图形的生成算法</h2><p><img src="/CG/基本图形.png" width="60%"></p><h3 id="2-1-直线绘制算法"><a href="#2-1-直线绘制算法" class="headerlink" title="2.1 直线绘制算法"></a>2.1 直线绘制算法</h3><ul><li>光栅平面的显示图形<ul><li>在光栅显示平面上，我们只能用二维光栅网格上<strong>尽可能靠近</strong>这条直线的象素集合来表示它。</li><li>每个象素具有一定的尺寸，是显示平面上可被访问的最小单位，</li><li>它的<strong>坐标x和y只能是整数</strong>，也就是说相邻象素的坐标值是阶跃的而不是连续的。</li></ul></li></ul><h5 id="直线段的扫描转换"><a href="#直线段的扫描转换" class="headerlink" title="直线段的扫描转换"></a>直线段的扫描转换</h5><ul><li>两点确定一条直线</li><li>通过直线的两个点的坐标计算出斜率和截距，确定直线方程。</li><li>通过x值确定每一个y的值，并舍入y的值。</li></ul><h5 id="数值微分-DDA-算法"><a href="#数值微分-DDA-算法" class="headerlink" title="数值微分(DDA)算法"></a>数值微分(DDA)算法</h5><ul><li>基本思想： <ul><li>假设直线段的宽度为1,直线段的斜率: |k| ≤ 1</li><li>已知过端点P<sub>0</sub>(x<sub>0</sub>, y<sub>0</sub>), P<sub>1</sub>(x<sub>1</sub>, y<sub>1</sub>)的直线L：y = kx + b。</li><li>直线斜率 k = (y<sub>1</sub> - y<sub>0</sub>) / (x<sub>0</sub> - x<sub>0</sub>)</li><li>当x的增量D<sub>x</sub> = 1， y<sub>i+1</sub> = y<sub>i</sub> + k</li></ul></li><li>当x每递增1，y递增k(即直线斜率)；取象素点(x, round(y))作为当前点的坐标。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DDALine(x0,y0,x1,y1,color) </span><br><span class="line"><span class="keyword">int</span> x0,y0,x1,y1,color;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x</span><br><span class="line"><span class="keyword">float</span> dx,dy,k,y</span><br><span class="line">dx=x1-x0; dy=y1-y0; </span><br><span class="line">k=dy/dx;</span><br><span class="line">y=y0;</span><br><span class="line"><span class="keyword">for</span>(x=x0;x&lt;=x1;x++)</span><br><span class="line">&#123;</span><br><span class="line">drawpixel(x,<span class="keyword">int</span>(y+<span class="number">0.5</span>),color); </span><br><span class="line">y=y+k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：<ul><li>当|k| ≤ 1时，x每增加1，y最多变化1。</li><li>当|k| &gt; 1时，必须把x与y的地位互换。</li></ul></li><li><strong>DDA算法的特点</strong> 以|k| ≤ 1为例<ul><li>y与k必须用浮点数表示</li><li>每一步都要对y进行四舍五入后取整</li><li>不利于硬件实现</li></ul></li></ul><h5 id="中点算法"><a href="#中点算法" class="headerlink" title="中点算法"></a>中点算法</h5><ul><li>基本原理<ul><li>通过在每列(行)象素中确定与理想直线最接近的象素来进行扫描转换</li><li>考虑直线斜率k在0~1之间</li><li>当前象素点为P（x<sub>p</sub>,y<sub>p</sub>），则下一个象素点有两种可选择点<br>P<sub>1</sub>（x<sub>p</sub>+1,y<sub>p</sub>）, P<sub>2</sub>（x<sub>p</sub>+1,y<sub>p+1</sub>）</li><li>P1与P2的中点（x<sub>p</sub>+1,y<sub>p</sub>+0.5）称为M</li><li>Q为理想直线与x = x<sub>p</sub>+1垂线的交点<br>当M在Q的下方时，则取P<sub>2</sub>应为下一个象素点<br>当M在Q的上方时，则取P<sub>1</sub>为下一个象素点<br><img src="/CG/中点算法.png" width="40%"> </li></ul></li><li>算法实现<ul><li>过点(x<sub>0</sub>,y<sub>0</sub>)、(x<sub>1</sub>, y<sub>1</sub>)的直线段L的方程式为：F(x, y)=ax+by+c=0</li><li><strong>其中，a = y<sub>0</sub> - y<sub>1</sub>, b = x<sub>1</sub> - x<sub>0</sub>, c = x<sub>0</sub>y<sub>1</sub> - x<sub>1</sub>y<sub>0</sub></strong></li><li>欲判断中点M在交点Q点的上方还是下方，只要把M代入F（x，y），并判断它的符号即可</li><li>构造判别式：d=F(M)=F(x<sub>p</sub>+1, yp+0.5)=a(x<sub>p</sub>+1)+b(y<sub>p</sub>+0.5)+c    </li><li>当d&lt;0时，M在L(Q点)下方，取P2为下一个象素        </li><li>当d&gt;0时，M在L(Q点)上方，取P1为下一个象素      </li><li>当d=0时，选P1或P2均可，约定取P1为下一个象素  </li></ul></li></ul><h5 id="增量法改进："><a href="#增量法改进：" class="headerlink" title="增量法改进："></a>增量法改进：</h5><ul><li>注意到d是x<sub>p</sub>, y<sub>p</sub>的线性函数，可采用增量计算，提高运算效率 <ul><li>d = F(M)=F(x<sub>p</sub>+1, y<sub>p</sub>+0.5) = a(x<sub>p</sub>+1)+b(y<sub>p</sub>+0.5)+c </li></ul></li><li>若当前象素（P的下一个像素）处于d≥0情况，则取P的正右方象素P1(x<sub>p</sub>+1, y<sub>p</sub>)，再下一个象素位置的判别式：<ul><li>d<sub>1</sub> = F(x<sub>p</sub>+2, y<sub>p</sub>+0.5) = a(x<sub>p</sub>+2)+b(y<sub>p</sub>+0.5)+c = d+a</li><li><strong>增量为a</strong></li></ul></li><li>若当前象素（P的下一个像素） d&lt;0时，则取右上方象素P2(x<sub>p</sub>+1, y<sub>p</sub>+1)，再下一个像素位置的判别式：<ul><li>d<sub>2</sub> = F(x<sub>p</sub>+2, y<sub>p</sub>+1.5) = a(x<sub>p</sub>+2)+b(y<sub>p</sub>+1.5)+c = d+a+b</li><li><strong>增量为a＋b</strong></li></ul></li><li><strong>初值计算</strong><ul><li>画线从(x<sub>0</sub>, y<sub>0</sub>)开始， F(x<sub>0</sub>, y<sub>0</sub>) = 0</li><li>d的初值：起始点(x0, y0) 下一个像素的判别式：</li><li>d<sub>0</sub> = F(x<sub>0</sub>+1, y<sub>0</sub>+0.5)+c = F(x<sub>0</sub>, y<sub>0</sub>)+a+0.5b = 0 + a+0.5b = a+0.5b</li></ul></li><li><strong>摆脱小数计算</strong><ul><li>我们使用的只是d的符号</li><li>d的增量都是整数，只是初始值包含小数</li><li>可以用2d代替d来摆脱小数</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> Midpoint <span class="title">Line</span> <span class="params">(<span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> x1, <span class="keyword">int</span> y1,<span class="keyword">int</span> color)</span></span>&#123; </span><br><span class="line"><span class="keyword">int</span> a, b, d1, d2, d, x, y;a=y0-y1； b=x1-x0；d=<span class="number">2</span>*a+b; <span class="comment">//初值</span>d1=<span class="number">2</span>*a； d2=<span class="number">2</span>* (a+b);x=x0；y=y0;drawpixel(x, y, color);<span class="keyword">while</span> (x&lt;x1)&#123; </span><br><span class="line"><span class="keyword">if</span> (d&lt;<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">x++;</span><br><span class="line">y++；;</span><br><span class="line">d+=d2; </span><br><span class="line">&#125;<span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">x++;</span><br><span class="line">d+=d1;</span><br><span class="line">&#125;drawpixel (x, y, color);&#125; &#125;</span><br></pre></td></tr></table></figure><h5 id="Bresenham算法"><a href="#Bresenham算法" class="headerlink" title="Bresenham算法"></a>Bresenham算法</h5><ul><li>基本思想：<ul><li>过各行各列象素中心构造一组虚拟网格线</li><li>按直线从起点到终点的顺序计算直线与各垂直网格线的<strong>交点</strong></li><li>然后根据<strong>误差项的符号</strong>确定该列象素中与此交点最近的象素</li><li>采用<strong>增量计算</strong>，使得对于每一列，只要检查一个误差项的<strong>符号</strong>，就<br>可以确定该列的所求象素<br><img src="/CG/Bresenham.png" width="30%"></li></ul></li><li>算法实现<ul><li>先考虑斜率k=dy/dx≤1的直线，直线方程可以表示为</li><li>假设当前像素的x坐标已经确定为x<sub>i</sub>，其y坐标为y<sub>i</sub></li><li>由于坐标(x<sub>i</sub>, y<sub>i</sub>)只能取整数，下一个像素的x坐标为</li><li>而y<sub>i</sub>＋1的坐标有两种可能：保持不变，即y<sub>i</sub>＋1＝y<sub>i</sub>；y坐标递增1，即y<sub>i</sub>＋1＝y<sub>i</sub>＋1<br><img src="/CG/Bresenham1.png" width="20%"></li><li>设A为CD边的中点，若B点在A点上方，选择D点； 否则，选C点。</li></ul></li><li>具体实现<ul><li>如果直线的<strong>起始点在象素中心</strong>，所以误差项d的初值<strong>d<sub>0</sub>＝0</strong>。</li><li>x下标每增加1，d的值相应递增直线的斜率值k，<strong>即d＝d＋k</strong>。</li><li>一旦d≥1，就把它减去1，这样<strong>保证d在0与1之间</strong>。<br>①当d≥0.5时，最接近于当前象素的右上方象素（x<sub>i</sub>+1, y<sub>i</sub>+1）<br>②当d&lt;0.5时，更接近于右下方象素（x<sub>i</sub>+1, y<sub>i</sub>）</li><li>为方便计算，<strong>令e＝d-0.5</strong></li><li>e的初值为-0.5 (d0 = 0)，增量为k<br>①当e≥0时，最接近于当前象素的右上方象素（x<sub>i</sub>+1, y<sub>i</sub>+1）<br>②当e&lt;0时，更接近于右方象素（x<sub>i</sub>+1, y<sub>i</sub>）</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bresenhamline</span> <span class="params">(<span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> x1, <span class="keyword">int</span> y1,<span class="keyword">int</span> color)</span></span>&#123;<span class="keyword">int</span> x, y, dx, dy;<span class="keyword">float</span> k, e;dx = x1-x0, dy = y1- y0, k=dy/dx;e=<span class="number">-0.5</span>, x=x0, y=y0;<span class="keyword">for</span> (i=<span class="number">0</span>; i≤dx; i++)&#123;drawpixel (x, y, color);x=x+<span class="number">1</span>, e=e+k;<span class="keyword">if</span> (e≥<span class="number">0</span>)&#123; </span><br><span class="line">y++, e=e<span class="number">-1</span>;</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Bresenham画线算法优点</strong>：<ul><li>快速增量算法</li><li>仅使用整数计算</li><li>效率高，易于用硬件实现</li></ul></li><li>与DDA算法相比，DDA算法的问题：<ul><li>误差的累积会使直线远离真实的结果</li><li>四舍五入运算和浮点运算耗时</li></ul></li></ul><h5 id="改进的Bresenham算法"><a href="#改进的Bresenham算法" class="headerlink" title="改进的Bresenham算法"></a>改进的Bresenham算法</h5><ul><li>可以改用整数以避免除法。由于算法中只用到误差项的符号，因此可作如下替换：<ul><li>e’ = 2 <em> e </em> dx 即用2 <em> dx </em> e代替原有的e。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InterBresenhamline</span> <span class="params">(<span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> x1, <span class="keyword">int</span> y1,<span class="keyword">int</span> color)</span></span>&#123;dx = x1-x0, dy = y1- y0；e=-dx; x=x0; y=y0;<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;dx; i++)&#123;drawpixel (x, y, color）x++； e=e+<span class="number">2</span>*dy;<span class="keyword">if</span> (e&gt;=<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"> y++; </span><br><span class="line"> e=e<span class="number">-2</span>*dx;</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-圆的生成"><a href="#2-2-圆的生成" class="headerlink" title="2.2 圆的生成"></a>2.2 圆的生成</h3><ul><li>八等分圆：可以同时绘制八分对称的点。<br><img src="/CG/八等分.png" width="30%"> <ul><li>八分对称性同时解决了“绘制点稀疏”的问题。</li><li>只需绘制右上八分之一的圆弧。</li><li>①切线斜率|dy/dx| ≤ 1 ②y的变化慢于x ③x每递增1，y最多最多改变一个像素单位 ④不会产生像素空隙 ⑤会有更多的像素拟合圆弧 ⑥使圆弧拟合更精确。</li></ul></li></ul><h5 id="中点画圆法"><a href="#中点画圆法" class="headerlink" title="中点画圆法"></a>中点画圆法</h5><ul><li>构造判别式(圆方程)：F(x, y) = x<sup>2</sup> + y<sup>2</sup> - R<sup>2</sup></li><li>判断点在圆内(F &lt; 0)、圆上(F = 0)、圆外(F &gt; 0)</li><li>M(x<sub>p</sub> + 1,y<sub>p</sub> - 0.5)是P1和P2的中点</li><li>d = F(M) = F(x<sub>p</sub> + 1,y<sub>p</sub> - 0.5) = (x<sub>p</sub> + 1)<sup>2</sup> + (y<sub>p</sub> - 0.5)<sup>2</sup> - R<sup>2</sup><br><img src="/CG/中点画圆.png" width="30%"> <ul><li>八分之一圆弧（如半径R=20），初始象素坐标(0, R)</li><li>下一个像素的绘制位置(1, R) 或(1, R-1)</li><li>得到中点坐标(1, R-0.5)</li><li>构造判别式d<sub>0</sub> = F(M) -&gt; d<sub>1</sub>, d<sub>2</sub>…</li></ul></li></ul><h5 id="增量算法避免重复计算"><a href="#增量算法避免重复计算" class="headerlink" title="增量算法避免重复计算"></a>增量算法避免重复计算</h5><p><img src="/CG/中点画圆增量.png" width="60%"> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MidPointCircle(<span class="keyword">int</span> R <span class="keyword">int</span> color)&#123;<span class="keyword">int</span> x,y;<span class="keyword">float</span> d;x=<span class="number">0</span>; y=R; d=<span class="number">1.25</span>-R;CirclePoints (x,y,color); <span class="comment">//显示圆弧上的八个对称点</span><span class="keyword">while</span>(x&lt;=y)&#123;<span class="keyword">if</span>(d&lt;<span class="number">0</span>) </span><br><span class="line">d+=<span class="number">2</span>*x+<span class="number">3</span>;<span class="keyword">else</span> </span><br><span class="line">&#123; </span><br><span class="line">d+=<span class="number">2</span>*(x-y)+<span class="number">5</span>; </span><br><span class="line">y--; </span><br><span class="line">&#125;x++;CirclePoints(x,y,color); <span class="comment">//显示圆弧上的八个对称点</span>&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>为了进一步提高算法的效率，可以将上面的算法中的浮点数改写成整数，将乘法运算改成加法运算，即仅用整数实现中点画<br>圆法。</li><li>初始化运算使用 Q:为什么可以去掉0.25？<ul><li>d’= d - 0.25 = 1.25 – R – 0.25 = 1 – R 代替 d = 1.25 - R</li></ul></li></ul><h5 id="中点算法小结"><a href="#中点算法小结" class="headerlink" title="中点算法小结"></a>中点算法小结</h5><ul><li>圆弧各点切线斜率绝对值<1 -=""> 从x扫描至x+1，y的备选绘制点为y, y-1</1></li><li>适当利用对称性提高效率<ul><li>利用圆的八分对称性 -&gt; 只需绘制圆右上八分之一圆弧</li></ul></li><li>利用中点判别法选择绘制点<ul><li>联合圆方程 + 每一步的两个备选绘图点的中点 -&gt; 构造判别式</li></ul></li><li>设计增量算法 -&gt; 避免重复计算</li><li>符号判别 -&gt; 简化浮点运算为整数运算</li></ul><h5 id="生成圆弧的Bresenham法"><a href="#生成圆弧的Bresenham法" class="headerlink" title="生成圆弧的Bresenham法"></a>生成圆弧的Bresenham法</h5><ul><li>以点(0, R) 为起点按顺时针方向生成圆，则在第一象限内（四分之一圆弧）y是x的单调递减函的单调递减函。</li><li>假设圆心和起点均精确地落在像素中心上。如果已经知道圆弧上的一点 (x<sub>i</sub>,y<sub>i</sub> )，下一像素的选取有三种可能：<br>①正右方像素H ②右下角像素D ③正下方像素V<br><img src="/CG/圆弧.png" width="20%"></li><li>构造函数：F(x<sub>p</sub> + 1,y<sub>p</sub> - 0.5) = (x<sub>p</sub> + 1)<sup>2</sup> + (y<sub>p</sub> - 0.5)<sup>2</sup> - R<sup>2</sup>  </li><li>这三个像素的偏差的平方为：<br><img src="/CG/偏差.png" width="20%"><br><img src="/CG/偏差2.png" width="50%"><img src="/CG/偏差3.png" width="50%"><br><img src="/CG/偏差4.png" width="55%"></li></ul><h3 id="2-3-椭圆的生成"><a href="#2-3-椭圆的生成" class="headerlink" title="2.3 椭圆的生成"></a>2.3 椭圆的生成</h3><ul><li>F(x,y) = b<sup>2</sup>x<sup>2</sup>+a<sup>2</sup>y<sup>2</sup>-a<sup>2</sup>b<sup>2</sup>=0</li><li>椭圆的对称性：<ul><li>只考虑第一象限椭圆弧生成 只考虑第一象限椭圆弧生成 ，分上下两部分</li><li><strong>以切线斜率为-1的点作为分界的点。</strong></li></ul></li><li>椭圆上一点处的法向量：N(x,y) = (F)’ x i+(F)’ y j = 2b<sup>2</sup>x i+2a<sup>2</sup>y j<ul><li>在上部分，法向量的y向分量较大，斜率K满足 |k|&lt; 1,|△x| ＞|△y| ，所以 x方向为主位移方向。</li><li>在下部分，法向量的x向分量较大，斜率K满足 |k|&gt; 1,|△y| ＞|△x| ，所以 y方向为主位移方向。</li></ul></li><li>与圆弧中点算法类似：确定一个象素后，接着在两个候选象素的中点计算一个判别式的值，由判别式的符号确定更近的点。</li><li>先讨论椭圆弧的上部分：<ul><li>(x<sub>p</sub>, y<sub>p</sub>)的中点(x<sub>p</sub> + 1, y<sub>p</sub> - 0.5)</li><li>d<sub>1</sub> = F(x<sub>p</sub> + 1, y<sub>p</sub> - 0.5)<br><img src="/CG/椭圆.png" width="75%"><br><img src="/CG/椭圆2.png" width="60%"><br><img src="/CG/椭圆3.png" width="50%"><br><img src="/CG/椭圆4.png" width="50%"> <img src="/CG/椭圆5.png" width="50%"> </li></ul></li><li>算法步骤：<ol><li>输入椭圆的长半轴 a 和短半轴 b。</li><li>计算初始值 d=b<sup>2</sup>+a<sup>2</sup>(-b+ 0.25 )，x= 0，y=b 。</li><li>绘制点 (x, y )及其在四分象限上的另外三个对称点。</li><li>判断 d 的符号。若d≤ 0，则先将d更新为d+b<sup>2</sup>(2x + 3)，再将 ( x, y)更新为 (x+ 1,y)；否则先将d更新为 d+b<sup>2</sup>(2x + 3) + a<sup>2</sup>(-2y + 2)，再将 ( x, y )更新为 (x + 1, y - 1)。</li><li>当b<sup>2</sup>(x+1) &lt; a<sup>2</sup>(y - 0.5)时，重复步骤 3 和 4 。否则转到步骤 6 。</li><li>用上半部分计算的最后点 ( x, y )来计算下半部分中d的初值：d = b<sup>2</sup>(x + 0.5)<sup>2</sup> + a<sup>2</sup> (y - 1)<sup>2</sup> - a<sup>2</sup> b<sup>2</sup></li></ol></li></ul><h3 id="2-4-多边形的扫描转换"><a href="#2-4-多边形的扫描转换" class="headerlink" title="2.4 多边形的扫描转换"></a>2.4 多边形的扫描转换</h3><h5 id="1-实区域填充算法"><a href="#1-实区域填充算法" class="headerlink" title="1. 实区域填充算法"></a>1. 实区域填充算法</h5><ul><li>点在多边形内的包含性检验<ul><li><strong>检验夹角之和</strong>：若夹角和为0，则点p在多边形外；若夹角和为360°，则点p在多边形内。</li><li><strong>射线法检验交点数</strong>：交点数 = 偶数(包括0) -&gt; 点在多边形之外；交点数 = 奇数 -&gt; 点在多边形之内</li></ul></li><li>逐点测试：效率低不实用。 <ul><li>解决办法：<strong>包围盒法</strong>。</li></ul></li><li>分类<ul><li>扫描线填充算法：按扫描线顺序，测试点的连贯性</li><li>种子填充算法：从内部一个种子点出发，测试点的连贯性。</li></ul></li></ul><h5 id="2-多边形种类"><a href="#2-多边形种类" class="headerlink" title="2. 多边形种类"></a>2. 多边形种类</h5><ul><li>多边形 :由一系列首尾相连的直线段构成的图形称为多边形。 <ul><li><strong>凸多边形</strong>是指任意两顶点间的连线均在多边形内;</li><li><strong>凹多边形</strong>是指任意两顶点间的连线有不在多边形内的部分;</li><li><strong>含内环的多边形</strong>则是指多边形内再套有多边形，多边形内的多边形也叫内环，内环之间不能相交。</li></ul></li></ul><h5 id="3-如何表示多边形"><a href="#3-如何表示多边形" class="headerlink" title="3. 如何表示多边形"></a>3. 如何表示多边形</h5><ul><li><strong>顶点表示</strong>是用多边形的顶点序列来表示多边形。<ul><li>表示直观、几何意义强、占内存少，易于进行几何变换，被广泛用于各种几何造型系统中;</li></ul></li><li><strong>点阵表示</strong>是用位于多边形内的象素集合来刻画多边形。<ul><li>丢失了许多几何信息(如边界、顶点)，但它是光栅显示图形所需要的表示形式。</li></ul></li><li><strong>多边形的扫描转换处理对象</strong>：非自交多边形 (边与边之间除了顶点外无其它交点)</li></ul><h5 id="4-多边形的扫描转换-扫描线算法-多边形的有序边表法"><a href="#4-多边形的扫描转换-扫描线算法-多边形的有序边表法" class="headerlink" title="4. 多边形的扫描转换 / 扫描线算法 / 多边形的有序边表法"></a>4. 多边形的扫描转换 / 扫描线算法 / 多边形的有序边表法</h5><ul><li>4个基本步骤：<ul><li><strong>求交</strong>：计算扫描线与多边形各边的交点</li><li><strong>排序</strong>：把所有交点按x值递增顺序排序</li><li><strong>配对</strong>：将第一个与第二个、第三个与第四个等交点配对，每对交点代表扫描线与多边形的一个相交区间。</li><li><strong>填色</strong>：把相交区间内的像素置成多边形的颜色，相交区间外的颜色置成背景色。</li></ul></li><li><strong>顶点交点的计数问题：</strong><ul><li>思路1: 局部最高点和局部最低点：计偶数次交点</li><li>思路2: 检查交于该顶点的两条边的另外两个端点的y坐标值：大于该顶点y坐标值的个数</li></ul></li><li><strong>填充扩大化问题</strong> <ul><li>取中心扫描线 y+0.5<br>– 检查交点右方像素的中心是否落在区间内：x<sub>l</sub> ≤ x + 0.5 ≤ x<sub>r</sub></li></ul></li><li><strong>效率问题：</strong><ul><li>影响算法效率的因素：<strong>求交和交点排序</strong></li><li>把多边形所有边放在一个表中，按顺序取出，分别计算与当前扫描线求交点。</li><li>为了减少和简化求交点计算，对每条扫描线，建立一个<strong>活性边表</strong>：把所有与当前扫描线有交点的边放到一个表中存储。(活性边：仅与当前扫描线有交点的边)</li></ul></li><li><strong>活性边表 AET</strong>：<ul><li>结点信息：<br>① x:当前扫描线与边的交点<br>②△x:从当前扫描线到下一条扫描线之间的x增量<br>③ymax:边所交的最高扫描线号</li><li>活性边表的更新：<br>①结点信息的更新  <strong>x’ = x + △ x</strong><br>②旧边的删除<br>③新边的插入 </li></ul></li><li><strong>新边表 NET</strong><ul><li>为解决新边插入的问题，对每条扫描线建立一个新边表。</li><li>扫描线与边的交点应为扫描线与边的初始交点</li><li>结点信息<br>①x<sub>0</sub>:扫描线与边的初始交点。（若采用中心扫描线，则需将活性边的较低端点的x坐标值加上0.5△x作为x0）<br>②△x:从当前扫描线到下一条扫描线之间的x增量<br>③ymax:边所交的最高扫描线号<br><img src="/CG/扫描线.png" width="70%"></li></ul></li><li>优点: <ul><li>对每个像素只访问一次 </li><li>与设备无关</li></ul></li><li>缺点:<ul><li>数据结构复杂，表的维护、排序开销大</li><li>只适合软件实现</li></ul></li></ul><h5 id="扫描线算法步骤"><a href="#扫描线算法步骤" class="headerlink" title="扫描线算法步骤"></a>扫描线算法步骤</h5><ol><li>根据给出的多边形顶点坐标，建立NET表;<br>求出顶点坐标中最大y值ymax和最小y值ymin。</li><li>初始化AET表指针，使它为空。</li><li>执行下列步骤直至NET和AET都为空.<ol><li>如NET中的第y类非空，则将其中的所有边取出并插入AET中;</li><li>如果有新边插入AET，则对AET中各边排序;</li><li>对AET中的边两两配对，(1和2为一对，3和4为一对，…)，将每对边中x坐标按规则取整，获得有效的填充区段，再填充.</li><li>当前扫描线纵坐标y值递值1;</li><li>如果AET表中某记录的ymax=yj，则删除该记录(因为每条边被看作下闭上开的);</li><li>对AET中剩下的每一条边的x递增1/k，即x = x+ 1/k .</li></ol></li></ol><h5 id="边填充算法"><a href="#边填充算法" class="headerlink" title="边填充算法"></a>边填充算法</h5><ul><li>无需复杂的链表结构</li><li>涉及到屏幕像素的异或写操作<ul><li>第一次异或写操作，像素被置为前景色</li><li>第二次异或写操作，像素被置为背景色</li></ul></li><li>边填充算法的基本思想<ul><li>对每一条与多边形相交的中心扫描线</li><li>将像素中心位于交点右方的全部像素取补 (异或写)</li></ul></li><li>分类：<ul><li>算法1：<strong>以扫描线为中心</strong>的边缘填充算法</li><li>算法2：<strong>以边为中心</strong>的边缘填充算法</li></ul></li><li>边填充算法的优点:<ul><li>最适合于有帧缓存的显示器</li><li>可按任意顺序处理多边形的边</li><li>仅访问与该边有交点的扫描线上右方的像素，算法简单</li></ul></li><li>缺点: <ul><li>对复杂图形，每一像素可能被访问多次，输入/输出量大</li><li><strong>图形输出不能与扫描同步进行</strong>，只有全部画完才能打印</li></ul></li></ul><h5 id="边界标志法-P27"><a href="#边界标志法-P27" class="headerlink" title="边界标志法 P27"></a>边界标志法 P27</h5><ul><li>在帧缓冲器中对多边形的每条边进行<strong>直线扫描转换</strong>，亦即对多边形边界所经过的象素打上标志。</li><li>对每条与多边形相交的扫描线依从左到右的顺序，逐个访问该扫描线上的象素。</li><li>使用一个<strong>布尔量inside</strong>来指示当前点是否在多边形内的状态。<ul><li>Inside的初值为假，每当当前访问的象素为被打上边标志的点，就把inside取反。 </li><li>对未打标志的象素，inside不变。</li><li>若访问当前象素时，inside为真，说明该象素在多边形内，则把该象素置为填充颜色。</li></ul></li><li>用软件实现时，有序边表算法(扫描线算法)与边界标志算法的执行速度几乎相同。</li><li>但由于边界标志算法<strong>不必建立维护边表以及对它进行排序，所以边界标志算法更适合硬件实现</strong>，这时它的执行速度比有序边表算法快一至两个数量级。</li></ul><h3 id="2-5-区域-种子-填充算法"><a href="#2-5-区域-种子-填充算法" class="headerlink" title="2.5  区域(种子)填充算法"></a>2.5  区域(种子)填充算法</h3><h5 id="区域填充"><a href="#区域填充" class="headerlink" title="区域填充"></a>区域填充</h5><ul><li><strong>区域</strong>：指已经表示成<strong>点阵形式</strong>的填充图形，它是象素的集合。</li><li>表示方法: 内点表示、边界表示</li><li><strong>内点表示</strong><ul><li>枚举处区域内部的所有像素</li><li>内部的所有像素着同一个颜色</li><li>边界像素着与内部像素不同的颜色</li></ul></li><li><strong>边界表示</strong><ul><li>枚举出边界上所有的像素</li><li>边界上的所有像素着同一颜色</li><li>内部像素着与边界像素不同的颜色</li></ul></li><li>种子填充算法的另外一种思路: <ul><li>假设多边形区域内至少有一个像素已知 </li><li>由该像素出发找出区域内部的所有像素</li></ul></li><li><strong>区域连通方式</strong><ul><li>4连通区域(4个方向运动：上下左右)</li><li>8连通区域(8个方向运动)</li></ul></li></ul><h5 id="种子填充的一种非递归-栈-算法"><a href="#种子填充的一种非递归-栈-算法" class="headerlink" title="种子填充的一种非递归(栈)算法"></a>种子填充的一种非递归(栈)算法</h5><ul><li>以4连通边界为例</li><li>种子像素入栈</li><li>当栈非空时，重复以下步骤: <ul><li>栈顶像素出栈</li><li>将出栈象素置成填充色</li><li>按左、上、右、下顺序检查与出栈象素相邻的四象素，若其中某象素不在边界上且未被置成填充色，则将其入栈</li></ul></li><li>特点: 每个像素都需要压栈，耗内存，费时间<br><img src="/CG/种子.png" width="40%"></li></ul><h5 id="种子填充的扫描线算法"><a href="#种子填充的扫描线算法" class="headerlink" title="种子填充的扫描线算法"></a>种子填充的扫描线算法</h5><ul><li>基本思想:<ul><li>利用扫描线的连贯性，每次<strong>填充一行像素</strong></li><li>减少压入堆栈的像素数目</li></ul></li><li>种子像素入栈</li><li>当栈非空时，重复以下步骤:<ul><li>栈顶像素出栈</li><li>沿扫描线对出栈像素的左右像素进行填充，直到遇到边界像素为止</li><li>将上述区间内最左、最右像素记为x<sub>l</sub>,和x<sub>r</sub></li><li>在区间[x<sub>l</sub>,x<sub>r</sub>]中检查与当前扫描线相邻的上下两条扫描线是否全为边界像素、或已填充的像素，若为非边界、未填充的像素，则<strong>把每一区间的最右像素取为种子像素入栈</strong>。(后进先出)</li></ul></li><li><strong>扫描线种子填充算法的特点</strong><ul><li>适用于边界定义的区域</li><li>四连通边界定义的区域既可以是凸的，也可以是凹的，还可以是有孔的。</li><li>算法减少了每个像素的访问次数</li><li>所需堆栈深度较浅</li><li>每次递归填充一行像素，因而速度较快</li></ul></li></ul><h5 id="多边形扫描转换-A-与区域填充方法-B-比较"><a href="#多边形扫描转换-A-与区域填充方法-B-比较" class="headerlink" title="多边形扫描转换(A)与区域填充方法(B)比较"></a>多边形扫描转换(A)与区域填充方法(B)比较</h5><ul><li>都是光栅图形面着色， 用千真实感图形显示。</li><li>可相互转换。</li><li>不同点：</li></ul><ol><li>基本思想不同；<ul><li>A用于将顶点表示转换成点阵表示；</li><li>B只改变区域内填充颜色，没有改变表示方法。</li></ul></li><li>对边界的要求不同<ul><li>A：只要求扫描线与多边形边界交点个数为偶数。</li><li>B：区域封闭，防止递归填充跨界。</li></ul></li><li>基本的条件不同<ul><li>A：从边界顶点信息出发。</li><li>B：区域内种子点。</li></ul></li></ol><h3 id="2-6-字符"><a href="#2-6-字符" class="headerlink" title="2.6 字符"></a>2.6 字符</h3><h5 id="字符的表示和输出"><a href="#字符的表示和输出" class="headerlink" title="字符的表示和输出"></a>字符的表示和输出</h5><ul><li><strong>字符</strong>：数字、字母、汉字， 计算机中字符由一个数字编码唯一标识。</li><li><strong>字符集</strong>：<ul><li>ASCII码：美国信息交换标准代码。</li><li>ISO 8859：是国际标准化组织(ISO)及国际电工委员会(IEC)联合制定的一系列8位字符集的标准， 现时定义了15个字符集。增加、加192个字母及符号， 附加符号的拉丁字母语言</li><li>GB2312/GBK, 这就是汉字的国标码， 专门用来表示汉字， 是双字节编码，</li><li>Unicode可以用来表示所有语言的字符， 而且是定长双字节（也有四字节的）编码， 包括英文字母在内。</li><li>UTF可以用来表示所有语言的字符， utf编码是不定长编码， 每一个字符的长度从1-6个字节不等。另外， utf编码自带简单的校验功能。一般来讲， 英文字母都是用一个字节<br>表示， 而汉字使用三个字节。</li></ul></li><li><strong>字库</strong>：字库中存储了每个字符的形状信息，字库分为<strong>矢量和点阵型</strong>两种。</li><li><strong>点阵字符</strong>：<ul><li>在点阵表示中，每一个字符由一个点阵位图来表示。点阵字符的存储是<strong>按行或者按列进行编码</strong>。</li><li>显示时，形成字符的像素图案。</li></ul></li><li>矢量字符<ul><li>采用直线和曲线段来描述字符形状，矢量字符库中记录的是笔划信息(存的是<strong>顶点的位置信息</strong>)。</li><li>显示时，解释字符的每个笔划信息</li></ul></li></ul><h3 id="2-7-反走样"><a href="#2-7-反走样" class="headerlink" title="2.7 反走样"></a>2.7 反走样</h3><ul><li>什么是反走样?<ul><li>把<strong>由离散量表示连续量引起的失真</strong>称为走样;</li><li>把减少或克服走样效果的技术称为反走样技术，简称反走样。 </li></ul></li><li>光栅图形的走样有如下几种:<ul><li>产生阶梯或锯齿形;</li><li>狭小图形遗失;细节失真</li><li>实时动画忽隐忽现、闪烁跳跃。 </li></ul></li><li><strong>常用的反走样的主要方法</strong> <strong>P41</strong><ul><li>提高分辨率方法(硬件技术)</li><li>非加权区域采样：改变直线段的模型，由此产生算法。将直线段看作具有一定宽度的狭长矩形。<strong>缺点</strong>是直线离像素中心点越近，贡献越大。</li><li>加权区域采样：使相交区域对象亮度的贡献依赖于该区域与像素中心的距离。</li></ul></li></ul><h2 id="3-三维图形的剪裁"><a href="#3-三维图形的剪裁" class="headerlink" title="3. 三维图形的剪裁"></a>3. 三维图形的剪裁</h2><ul><li>场景由世界坐标中指定的对象集合组成</li><li>当我们显示场景时，仅显示特定窗口中的那些对象</li><li>因为将内容绘制到显示器需要时间，我们会剪切窗口外的所有内容</li><li>设窗口的边界为wx<sub>min</sub>, wy<sub>min</sub>, wx<sub>max</sub>, wy<sub>max</sub><ul><li>当一个点(x, y)满足：wx<sub>min</sub> &lt; x &lt; wx<sub>max</sub> &amp;&amp; wy<sub>min</sub> &lt; y &lt; wy<sub>max</sub> 则不需要被剪裁</li><li>否则被剪裁。</li></ul></li></ul><h3 id="3-1-直线段裁剪"><a href="#3-1-直线段裁剪" class="headerlink" title="3.1 直线段裁剪"></a>3.1 直线段裁剪</h3><h5 id="Cohen-Sutherland算法"><a href="#Cohen-Sutherland算法" class="headerlink" title="Cohen-Sutherland算法"></a>Cohen-Sutherland算法</h5><ul><li>优点：减少了必须计算的线与窗口的交点的数量。</li><li>世界空间根据窗口边界划分为区域：<ul><li>每个区域具有唯一的四位区域码。</li><li>区域码表<strong>示区域相对于窗口的位置</strong>。<br>&lt;img src = “区域码.png” width =50%”&gt;</li></ul></li><li>判别方法：设线段的两个端点为P1(x1，y1)和P2(x2，y2)， 根据上述规则，可以求出P1和P2所在区域的分区代码C1和C2。<ul><li>C1 = C2 = 0，表明两端点全在窗口内，因而整个线段也在窗内，应予保留。</li><li>C1 And C2 ≠ 0(两端点代码<strong>按位作逻辑乘</strong>不为0)，即C1和C2至少有某一位同时为1，表明两端点必定处于某一边界的同一外侧，因而整个线段全在窗外，应予舍弃。</li><li>不属于上面两种情况，均需要求交点。</li></ul></li><li>注意：求的交点可能是<strong>延长线上的交点</strong>。</li><li>求交点：<ul><li>使用直线的方程计算与窗口边界的交点</li><li>假设一条直线具有端点(x1, y1), (x2, y2)</li><li>与垂直窗口边界的交点坐标为 y = y<sub>1</sub> + m(x<sub>边界</sub> - x<sub>1</sub>), x<sub>边界</sub>可以为x<sub>min</sub>或者x<sub>max</sub></li><li>与水平窗口边界的交点坐标 x = x<sub>1</sub> + (y<sub>边界</sub> - x<sub>1</sub>) / m</li><li>m = (y<sub>2</sub> - y<sub>1</sub>) / (x<sub>2</sub> - x<sub>1</sub>)</li></ul></li></ul><h5 id="中点分割剪裁算法"><a href="#中点分割剪裁算法" class="headerlink" title="中点分割剪裁算法"></a>中点分割剪裁算法</h5><ul><li>注意：求的交点是<strong>真实的交点</strong>。</li><li><strong>基本思想</strong>：<ul><li>P( (x<sub>1</sub> + x<sub>2</sub>) / 2 , (y<sub>1</sub> + y<sub>2</sub>) / 2 )</li><li>如果P1与P同侧，移动P1点。即可能的交点只能出现在PP2段 <code>if((C1&amp;C)!=0) P1=P</code>;</li><li>如果P1与P不同侧，移动P2点。即可能的交点只能出现在P1P段 <code>if((C1&amp;C)= =0) P2=P</code>;<br>&lt;img src = “中点分割.png” width =22%”&gt;</li></ul></li><li><strong>算法步骤</strong>：<ul><li><strong>将直线的两端点P1、P2编码得：C1、C2。</strong></li><li><strong>根据C1和C2的具体值，可以有三种情况：</strong><br>①C1=C2=0，表明两端点全在窗口内，因而整个线段也在窗内，应予保留。<br>②C1&amp;C2≠0，表明两端点必定处于某一边界的同一外侧，因而整个线段全在窗外，应予舍弃。<br>③不属于上面两种情况，均需要求交点。</li><li><strong>求交点</strong><br>①令窗外端点为P1，如果窗外点不是P1，则P1和P2交换端点。保留窗内端点P2到暂存器里。<br>②对P1编码为C1，用中点公式求出中点 ，并编码得C。按照中点算法的求交规则：<br>若P1和P同侧，移动P1点<code>if((C1&amp;C)!=0) P1=P</code>; 否则，移动P2点 <code>else P2=P</code><br>③流程转②，直到P1和P2相差一个单位时:令交点为P2，取出暂存器的端点赋给P1，然后转向流程①</li></ul></li><li><strong>算法特点</strong>：<ul><li>求交点的次数(n)与线段长度(L)有关，其关系为: <strong>L = 2<sup>n</sup></strong> 例如：线段长度为256，则求交点的次数为8。</li><li>中点分割法求出的交点是<strong>边界上的有效交点</strong>，而不是边界及其延长线上的交点。而Cohen-Sutherland直线裁剪算法求出的则是<strong>边界上或者边界的延长线上的交点</strong>。</li></ul></li></ul><h3 id="3-2-多边形裁剪"><a href="#3-2-多边形裁剪" class="headerlink" title="3.2 多边形裁剪"></a>3.2 多边形裁剪</h3><h5 id="Sutlerland-Hodgman算法-逐边裁剪算法"><a href="#Sutlerland-Hodgman算法-逐边裁剪算法" class="headerlink" title="Sutlerland-Hodgman算法 / 逐边裁剪算法"></a>Sutlerland-Hodgman算法 / 逐边裁剪算法</h5><ul><li>窗口的一条边以及延长线构成的裁剪线该线把平面分成两个部分：可见一侧；不可见一侧。</li><li>简单地通过依次将多边形与每个边界进行比较来修剪多边形。</li><li>多边形的各条边的两端点S、P。它们与裁剪线的位置关系只有四种：<ul><li>S，P均在可见一侧 → 输出P</li><li>S，P均在不可见一侧 → 无输出</li><li>S可见，P不可见 → 输出SP与裁剪线的交点I</li><li>S不可见，P可见  → 输出SP与裁剪的交点I和P<br><img src="/CG/裁剪.jpeg" width="45%"></li></ul></li><li><strong>特点：</strong><ul><li>裁剪算法采用流水线方式， <strong>适合硬件实现。</strong></li><li>可推广到<strong>任意凸多边形裁剪窗口</strong></li></ul></li></ul><h5 id="Weiler-Atherton算法"><a href="#Weiler-Atherton算法" class="headerlink" title="Weiler-Atherton算法"></a>Weiler-Atherton算法</h5><ul><li><strong>特点：</strong><ul><li>裁剪窗口为<strong>任意多边形(凸、凹、带内环)</strong>的情况:</li></ul></li><li>内裁减与外裁剪：<ul><li>内裁剪: 即通常意义上的裁剪，取图元位于窗口之内的部分</li><li>外裁剪: 取图元位于窗口之外的部分。</li></ul></li><li>如果主多边形与裁剪多边形有交点，则<strong>交点成对出现</strong>。它们被分为如下两类:<ul><li>一类称“入”点。即被裁剪多边形由此点进入裁剪窗口，如图中a、c、e。</li><li>一类称“出”点。即被裁剪多边形由此点离开裁剪窗口，如图中b、d、f。</li></ul></li><li>Weiler-Atherton算法步骤<ol><li>建顶点表 </li><li>求交点</li><li>裁剪<br><img src="/CG/wa.png" width="75%"></li></ol></li><li><strong>详细步骤</strong><ol><li><strong>顺时针</strong>输入被裁剪多边形顶点序列 I 放入数组1中。</li><li><strong>顺时针</strong>输入裁剪窗口顶点序列II放入数组2中。</li><li>求出被裁剪多边形和裁剪窗口相交的所有交点，并给每个交点打上 “入”、“出”标记。 然后将交点按顺序插入序列I得到新的顶点序列 III ，并放入数组3中;同样也将交点按顺序插入序列II得到新的顶点序列 IV ，放入数组4中; </li><li>初始化输出数组Q，令数组Q为空。接着从数组3中寻找“入”点。如果“入”点没找到，程序结束。 </li><li>如果找到“入”点，则将“入”点放入S中暂存。</li><li>将“入”点录入到输出数组Q中。并从数组 3 中将该“入”点的“入” 点标记删去。 </li><li>沿数组 3 顺序取顶点: 如果顶点是“出点”，则将顶点录入到输出数组Q中，流程转第7步。否则，流程转第8步。</li><li>沿数组4顺序取顶点:如果顶点是“入点”，则将顶点录入到输出数组Q中，流程转第8步。 否则，流程转第9步。</li><li><strong>如果顶点不等于起始点S，流程转第6步，继续跟踪数组3</strong>。 否则，将数组Q输出。</li><li>流程转第4步，寻找可能存在的分裂多边形。 算法在第4步：满足“入”点没找到的条件时，算法结束。</li></ol></li><li><strong>交点的奇异情况处理</strong><ul><li>与裁剪多边形边重合的主多边形的边不参与求交点;</li><li>对于顶点落在裁剪多边形的边上的主多边形的边，如果落在该裁<br>剪边的内侧，将该顶点算作交点;而如果这条边落在该裁剪边<br>的外侧，将该顶点不看作交点。<br><img src="/CG/奇异.png" width="60%"></li></ul></li></ul><h3 id="3-3-字符裁剪"><a href="#3-3-字符裁剪" class="headerlink" title="3.3 字符裁剪"></a>3.3 字符裁剪</h3><ul><li><strong>基于字符串</strong>：将包围字符串的外接矩形对窗口作裁剪。当字符串外接矩形整个在 窗口内时予以显示，否则不显示。</li><li><strong>基于字符</strong>：将包围字符的外接矩形对窗口作<br>裁剪，如某个字符外接矩形整个落<br>在窗口内予以显示，否则不显示。</li><li><strong>基于构成字符的最小元素 / 像素</strong>：点阵字符：点裁剪 ；矢量字符：线裁剪<br><img src="/CG/字符.png" width="80%"></li></ul><h2 id="4-图形的变换"><a href="#4-图形的变换" class="headerlink" title="4. 图形的变换"></a>4. 图形的变换</h2><h3 id="4-1-图形变换的数学基础"><a href="#4-1-图形变换的数学基础" class="headerlink" title="4.1 图形变换的数学基础"></a>4.1 图形变换的数学基础</h3><ul><li><strong>图形几何变换</strong>：几何图形按照某种法则或规律变换成另一种几何图形的过程。</li><li>矩阵及其运算 P203</li></ul><h3 id="4-2-二维几何变换"><a href="#4-2-二维几何变换" class="headerlink" title="4.2 二维几何变换"></a>4.2 二维几何变换</h3><h5 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h5><ul><li>齐次坐标：所谓齐次坐标, 就是将一个原本是n维的向量用一个n+1 维向量来表示。<ul><li>例如, 向量(x<sub>1</sub>, x<sub>2</sub>, …, x<sub>n</sub>)的齐次坐标表示为<br>(H<sub>x<sub>1</sub></sub>, H<sub>x<sub>2</sub></sub>, …, H<sub>x<sub>n</sub></sub>, H), 其中H是一个不为0的实数。</li></ul></li><li>由点或向量的齐次坐标(H<sub>x<sub>1</sub></sub>, H<sub>x<sub>2</sub></sub>, …, H<sub>x<sub>n</sub></sub>, H)求它的<strong>规范化齐次坐标</strong>, 可根据如下公式求得：<ul><li>x<sub>1</sub> = H<sub>x<sub>1</sub></sub> / H, x<sub>2</sub> = H<sub>x<sub>2</sub></sub> / H, …, x<sub>n</sub> = H<sub>x<sub>n</sub></sub> / H</li></ul></li><li>齐次坐标表示不是唯一的，通常<strong>当h=1时</strong>，称为<strong>规格化齐次坐标</strong>， 在计算机图形学里面，我们常用的是规格化齐次坐标。</li><li>为什么需要引入齐次坐标？<ul><li>多个变换作用于多个目标</li><li>引入齐次坐标，变换的表示法统一</li></ul></li><li>图形变换具有统一表示形式的优点：<ul><li>便于变换合成 </li><li>便于硬件实现  </li></ul></li></ul><h5 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h5><ul><li><strong>平移、旋转、缩放变换</strong><br><img src="/CG/几何变换.jpg" width="100%"></li><li><strong>对称变换</strong>：<br><img src="/CG/对称.jpg" width="100%"></li><li><p><strong>错切变换</strong>： </p><ul><li>也称为剪切、错位变换，用于产生弹性物体的变形处理。</li><li>错切的变换矩阵<br><img src="/CG/错切.jpg" width="100%"></li><li>(a) 错切角 (b) 沿x方向错切 (c) 沿y方向错切<br><img src="/CG/错切3.png" width="50%"></li></ul></li><li><p><strong>仿射变换</strong></p><ul><li>变换的坐标x’和y’都是原始坐标x和y的线性函数。</li><li>仿射变换具有平行线转换成平行线和有限点映射到有限点的一般特性。</li><li><strong>平移、比例、旋转、对称和错切变换是二维仿射变换的特例</strong>，任何常用的二维仿射变换总可表示为这五种变换的组合。 </li></ul></li></ul><h5 id="复杂变换"><a href="#复杂变换" class="headerlink" title="复杂变换"></a>复杂变换</h5><ul><li>复合变换是指对图形进行一次以上的变换，变换的结果是 每次的变换矩阵相乘。</li><li>任何一组变换都可以表示成一个复合变换矩阵，只需要计算每一个单独<strong>变换矩阵</strong>，并求解出乘积。</li><li>从另一个方面讲，任何一个复杂的几何变换都可以看作基本几何变换的组合形式，也叫复合变换。</li></ul><h3 id="4-3-窗口到视区的变换"><a href="#4-3-窗口到视区的变换" class="headerlink" title="4.3 窗口到视区的变换"></a>4.3 窗口到视区的变换</h3><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ul><li><strong>坐标系</strong>：建立了图形与数之间的对应联系<ul><li><strong>世界坐标系</strong>：用户需要在图形独享所在的控件定义一个坐标系</li><li><strong>用户坐标系</strong>：用户按照自己习惯建立世界坐标系，所以世界坐标系有时也称用户坐标系。</li><li><strong>局部坐标系</strong>：简化图形对象的描述，相对于图形定义</li><li><strong>屏幕坐标系</strong>：屏幕上或绘图纸上定义一个二维直角坐标系，也称为设备坐标系。</li></ul></li><li><strong>窗口</strong>：在计算机图形学中，将在用户坐标系中需要进行观察和处理的一个坐标区域。</li><li><strong>视区</strong>：将窗口映射到显示设备上的坐标区域。 <ul><li>改变视区的位置，可以在输出设备的不同位置显示图形对象。</li><li>改变视区的大小和比例可以改变显示对象的大小和比例。 </li></ul></li><li><strong>裁剪在扫描转换之前</strong><br><img src="/CG/显示.png" width="60%"></li></ul><h5 id="窗口到视区变换"><a href="#窗口到视区变换" class="headerlink" title="窗口到视区变换"></a>窗口到视区变换</h5><ul><li>变换步骤：<ul><li>将窗口左下角点<strong>移至用户系统系的坐标原点</strong></li><li>针对原点进行<strong>比例变换</strong></li><li>进行<strong>反平移</strong></li></ul></li><li>两种情况：<ol><li>窗口区的边与坐标轴平行</li><li>窗口区的边与坐标轴不平行：将窗口左下角点<strong>移至用户系统系的坐标原点</strong>后需要旋转到与坐标轴平行。</li></ol></li></ul><h3 id="4-4-三维几何变换"><a href="#4-4-三维几何变换" class="headerlink" title="4.4 三维几何变换"></a>4.4 三维几何变换</h3><h5 id="三维齐次坐标"><a href="#三维齐次坐标" class="headerlink" title="三维齐次坐标"></a>三维齐次坐标</h5><ul><li>(x, y, z)对应的齐次坐标为(x<sub>h</sub>, y<sub>h</sub>, z<sub>h</sub>, h)<ul><li>标准齐次坐标(x,y,z,1) ==〉用来表示三维空间点(x, y, z)。</li></ul></li><li>使用<strong>右手坐标系</strong>(z轴正方向向外) </li></ul><h5 id="三维几何变换"><a href="#三维几何变换" class="headerlink" title="三维几何变换"></a>三维几何变换</h5><ul><li>三维平移变换、放缩变换</li><li>三维旋转变换<ul><li>是指给定的三维立体绕三维空间某个指定的坐标轴旋转θ角度。 </li><li>旋转后, 立体的空间位置将发生变化, 但形状不变。 </li><li><strong>θ角的正负按右手规则确定</strong>, 右手大姆指指向旋转轴的正向, 其余四个手指指向旋转角的正向。</li></ul></li></ul><p><img src="/CG/3d.jpg" width="100%"></p><ul><li>三维错切变换：是指三维立体在空间沿x、 y、 z三个方向实现错切变形, 三维错切是二维错切变换的一个扩充。</li><li>三维对称变换<br><img src="/CG/3d2.jpg" width="60%"></li></ul><h2 id="5-投影"><a href="#5-投影" class="headerlink" title="5. 投影"></a>5. 投影</h2><h3 id="5-1-三维图形显示的基本问题"><a href="#5-1-三维图形显示的基本问题" class="headerlink" title="5.1 三维图形显示的基本问题"></a>5.1 三维图形显示的基本问题</h3><ol><li><strong>在二维屏幕上如何显示三维物体?</strong><ul><li>显示器屏幕、绘图纸等是二维的，显示对象是三维的</li><li>解决方法：投影</li></ul></li><li><strong>如何表示三维物体?</strong><ul><li>二维形体的表示：直线段, 折线, 曲线段, 多边形区域</li><li>二维形体的输入：<strong>简单</strong>(图形显示设备与形体的维数一致)</li><li>三维形体的表示：空间直线段、折线、曲线段、多边形、曲面片 </li><li>三维形体的输入、运算、有效性保证<strong>(困难)</strong></li><li>解决方法：<strong>各种用于形体表示的理论、模型、方法</strong></li></ul></li><li><strong>如何反映遮挡关系?</strong><ul><li>物体之间或物体的不同部分之间存在相互遮挡关系</li><li>遮挡关系是空间位置关系的重要组成部分</li><li>解决方法：<strong>消除隐藏面与隐藏线</strong></li></ul></li><li><strong>如何产生真实感图形?</strong><ul><li>人们观察现实世界产生的真实感来源于<br>• 空间位置关系：近大远小的透视关系和遮挡关系<br>• 光线传播引起的物体表面颜色的自然分布</li><li>解决方法：<strong>建立光照明模型、开发真实感图形绘制方法</strong></li></ul></li></ol><h5 id="三维图形显示的基本研究内容"><a href="#三维图形显示的基本研究内容" class="headerlink" title="三维图形显示的基本研究内容"></a>三维图形显示的基本研究内容</h5><ul><li>投影</li><li>三维形体的表示</li><li>消除隐藏面与隐藏线</li><li>建立光照明模型、开发真实感图形绘制方法</li></ul><h3 id="5-2-平面几何投影"><a href="#5-2-平面几何投影" class="headerlink" title="5.2 平面几何投影"></a>5.2 平面几何投影</h3><ul><li>投影 — 照相机模型<ul><li>选定投影类型 → <strong>透视投影</strong>与<strong>平行投影</strong></li><li>设置投影参数 → 拍摄方向、距离等</li><li>三维裁剪 → 取景</li><li>投影和显示 → 成像</li></ul></li><li><strong>简单的三维图形显示流程图</strong><br><img src="/CG/3d流程.png" width="40%"> </li><li><strong>投影</strong>：将n维的点变换成小于n维的点。比如将3维的点变换成小于3维的点</li><li><strong>投影中心</strong>(COP: Center of Projection)<ul><li>eg. 视觉系统—观察点、视点; 电影放映机—光源</li></ul></li><li><strong>投影面</strong>：不经过投影中心的面<ul><li>eg. 平面–照相机底片; 曲面—球幕电影,视网膜</li></ul></li><li><strong>投影线：</strong>从投影中心向物体上各点发出的射线<ul><li>eg. 直线—光线; 曲线—喷绘</li></ul></li><li><strong>平面几何投影</strong>：投影面是平面，投影线为直线</li><li><strong>投影变换</strong>：投影过程，投影的数学表示</li><li>平面几何投影的分类<br><img src="/CG/投影.png" width="40%"> </li></ul><h5 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h5><ul><li>投影中心与投影平面之间的距离为有限</li><li>参数：投影中心、投影方向</li><li>eg. 室内白炽灯的投影，视觉系统</li><li><strong>灭点</strong>：不平行于投影平面的平行线，经过透视投影之后收敛于一点，称为灭点。</li><li><strong>主灭点</strong>：坐标轴方向的平行线在投影面上 形成的灭点称作主灭点。<ul><li>一点透视：表现范围广，纵深感强，适合表现庄重、严肃的室内空间或建筑物。比较呆板，与真实效果有一定的距离</li><li>两点透视为：构图画面增加动感，使画面结构丰富。</li><li>三点透视：一般用于超高层建筑俯瞰图或仰视图。<br><img src="/CG/透视.png" width="40%"> </li></ul></li><li><strong>特点</strong>：产生近大远小的视觉效果，由它产生的图形深度强，看起来更加真实。</li></ul><h5 id="平行投影"><a href="#平行投影" class="headerlink" title="平行投影"></a>平行投影</h5><ul><li>投影中心与投影平面之间的距离为无限</li><li>是透视投影的极限状态</li><li>分类:<ul><li>根据投影射线与投影平面的关系，平行投影可分为<strong>正投影和斜投影</strong>。<br><img src="/CG/平行投影.png" width="40%"> </li></ul></li><li>正投影：<ul><li>根据投影面和坐标轴的夹角可分为两类:三视图和正轴测图</li><li>当<strong>投影面与某一坐标轴垂直</strong>时，得到的投影为三视图，这时投影方向和这个坐标轴的方向一致。否则，得到的投影为正轴测图。<br><img src="/CG/正投影.png" width="40%"> </li></ul></li><li><strong>三视图</strong>: 包括<strong>主视图、侧视图和俯视图</strong>三种，投影面分别与X轴、Y轴和Z轴垂直</li><li>正轴侧：当投影平面与三个坐标轴都不垂直时。<ul><li>正轴侧又分为等轴侧、正二侧和正三侧。</li><li>当投影面与<strong>三个</strong>坐标轴之间的<strong>夹角都相等</strong>时为等轴测。</li><li>当投影面与<strong>两个</strong>坐标轴之间的<strong>夹角相等</strong>时为正二测。</li><li>当投影面与<strong>三个</strong>坐标轴之间的<strong>夹角都不相等</strong>时为正三测。</li></ul></li></ul><h5 id="斜投影"><a href="#斜投影" class="headerlink" title="斜投影"></a>斜投影</h5><ul><li><strong>投影方向不垂直于投影面</strong></li><li>分类：<ul><li>斜等侧投影:投影方向和投影面夹角α成45° </li><li>斜二侧投影:投影方向和投影面夹角α=arctan(2)</li></ul></li></ul><h5 id="投影总结"><a href="#投影总结" class="headerlink" title="投影总结"></a>投影总结</h5><ul><li>平行投影:投影中心与投影面间距离为无穷远。</li><li>正平行投影:投影方向和投影面垂直。</li><li>三视图:三个投影面和坐标轴相互垂直。</li><li>正轴侧:投影面和坐标轴呈一定的关系。 </li><li>斜平行投影:投影方向和投影面不垂直。</li><li>透视投影:投影中心与投影面间距离为有限。</li></ul><h3 id="5-3-投影变换-amp-投影举例"><a href="#5-3-投影变换-amp-投影举例" class="headerlink" title="5.3 投影变换 &amp; 投影举例"></a>5.3 投影变换 &amp; 投影举例</h3><ul><li><strong>三维观察变换</strong>所起的作用是完成从用户空间选取的一部分物体描述变换到 显示屏上指定的视窗中的图形描述。<ul><li>简单的三维观察流水线：<br><img src="/CG/流水线.png" width="40%"> </li></ul></li><li><strong>取景变换</strong>:完成从用户坐标系中的描述 -&gt; 观察坐标系中的描述的坐标变换。</li><li><strong>观察坐标系(VRC)</strong>:照相机所在的坐标系</li></ul><h5 id="建立观察坐标系"><a href="#建立观察坐标系" class="headerlink" title="建立观察坐标系"></a>建立观察坐标系</h5><ul><li>挑选一个用户坐标点称为观察参考点VRP(View Reference Point)， 即该点为观察坐标系的原点;</li><li>通过给定观察平面法向量来选择观察坐标系的 Zv轴和观察平面方向;</li><li>指定一观察向上向量，通过该向量来建立 观察坐标系的Yv轴;</li><li>确定观察点又称为投影中心(若为透视投影时) 或确定投影方向(若为平行投影时)</li></ul><h5 id="用户坐标到观察坐标的变换"><a href="#用户坐标到观察坐标的变换" class="headerlink" title="用户坐标到观察坐标的变换"></a>用户坐标到观察坐标的变换</h5><ul><li>在物体描述投影到观察平面之前，必须将其转换成观察坐标。该变换顺序是:    <ul><li>平移观察参考点VRP(x0,y0,z0)到用户坐标系原点; </li><li>进行旋转分别让Xv,Yv和Zv轴对应到用户坐标系的x、y、和z轴。 一旦景物中物体的用户坐标描述转换到观察坐标后，我们就可以将三维<br>物体投影到二维观察平面上。<br><img src="/CG/观察坐标.png" width="50%"> </li></ul></li><li>为使剪取处理简单和规范化(即单位化)，需要利用坐标变换将<strong>视见体规范化</strong>。</li></ul><h5 id="视见体-View-Port"><a href="#视见体-View-Port" class="headerlink" title="视见体(View Port)"></a>视见体(View Port)</h5><ul><li>视见体是三维裁剪窗口。</li><li>建立步骤：<ul><li>定义窗口 → 发出射线 → 形成观察空间 → 前后剪裁面 → 形成视见体</li></ul></li><li>需注意，对于透视投影，<strong>前截面必须在投影中心和后截面之间。</strong></li><li>投影参考点(PRP: Projection Reference Point)<br><img src="/CG/视见体.png" width="50%"> <ul><li>透视投影: COP==PRP;</li><li>平行投影: 投影方向DOP= CW-PRP</li><li>透视投影: 观察空间为四棱锥</li><li>平行投影: 观察空间为四棱柱</li></ul></li></ul><h5 id="透视投影变换"><a href="#透视投影变换" class="headerlink" title="透视投影变换"></a>透视投影变换</h5><ul><li>问题：在uvn中，投影平面为n=0，投影中心为(0，0，d)， 待投影点为P(u<sub>p</sub>，v<sub>p</sub>，n<sub>p</sub>)，求投影点Q (u<sub>Q</sub>，v<sub>Q</sub>，n<sub>Q</sub>)<br><img src="/CG/透视投影变换.png" width="25%"><br><img src="/CG/透视投影变换2.png" width="25%"></li><li>透视投影变换矩阵:作用就是将三维物体变换成二维透视投影。</li></ul><h5 id="斜平行投影"><a href="#斜平行投影" class="headerlink" title="斜平行投影"></a>斜平行投影</h5><ul><li>投影方向不垂直于投影平面的平行投影被称为斜平行投影。</li></ul><h5 id="从世界坐标系到观察坐标系的变换"><a href="#从世界坐标系到观察坐标系的变换" class="headerlink" title="从世界坐标系到观察坐标系的变换"></a>从世界坐标系到观察坐标系的变换</h5><p><img src="/CG/变换.png" width="25%"></p><h3 id="5-4-规范视见体变换-规范裁剪空间"><a href="#5-4-规范视见体变换-规范裁剪空间" class="headerlink" title="5.4 规范视见体变换 / 规范裁剪空间"></a>5.4 规范视见体变换 / 规范裁剪空间</h3><ul><li>为什么引入规范视见体?<ul><li>使裁剪算法非常容易、直观</li><li>有助于隐藏线和隐藏面的消除。</li></ul></li><li>规范化变换：将任意视见体变换成规范视见体的变换</li><li>三维图形的显示流程图<br><img src="/CG/2.png" width="45%"></li><li>采用视见体变换的三维图形显示流程图<br><img src="/CG/1.png" width="45%"><ul><li>观察变换：从世界坐标系到观察坐标系的变换</li></ul></li></ul><h5 id="何时裁剪"><a href="#何时裁剪" class="headerlink" title="何时裁剪"></a>何时裁剪</h5><ul><li><strong>投影之前裁剪 三维裁剪</strong><ul><li>优点：只对可见的物体进行投影变换</li><li>缺点：三维裁剪相对复杂</li></ul></li><li><strong>投影之后裁剪 二维裁剪</strong><ul><li>优点：二维裁剪相对容易</li><li>缺点：需要对所有的物体进行投影变换</li></ul></li><li>采用投影后裁剪的三维图形显示流程图<br><img src="/CG/3.png" width="45%"></li><li>在投影之前裁剪的理由<ul><li>三维物体的表面通常被离散表示成多边形或折线，而对这类简单图元，三维裁剪同样比较简单。</li><li>三维图形<strong>在显示过程中需要被消隐</strong>，做这个工作要有图形的深度信息，所以必须在投影之前完成。 消隐很费时，如果在此之前裁剪 (或部分裁剪)掉不可见的图形，可使需要消隐的图形减至最小。</li></ul></li></ul><h2 id="6-隐藏面的消除"><a href="#6-隐藏面的消除" class="headerlink" title="6. 隐藏面的消除"></a>6. 隐藏面的消除</h2><h3 id="6-1-基本概念"><a href="#6-1-基本概念" class="headerlink" title="6.1 基本概念"></a>6.1 基本概念</h3><ul><li>要画出确定的、立体感很强的三维图形，就必须将那些被不透明的面<br>(或物体)所遮挡的线段(或面)移去，这就是隐藏线或隐藏面的消隐处理。</li><li><strong>按消隐对象</strong>将三维物体消隐分为两类: <ul><li><strong><code>线消隐</code></strong>：其消隐对象是物体上的边, 消除的是<strong>物体上不可见的边</strong>，用于线框图。</li><li><strong><code>面消隐</code></strong>：其消隐对象是物体上的面, 消除的是<strong>物体上不可见的面</strong>，用于填色图。</li></ul></li><li><strong>根据消隐空间</strong>的不同，将消隐算法分为3类：<ul><li>物体空间的消隐算法：将场景中每一个面与其它每个面比较, 求出所有点、边、面的遮挡关系。算法精度较高。如<strong>光线投射</strong>等。</li><li>图像空间的消隐算法：对屏幕上每个像素进行判断, 决定哪个多边形在该像素可见。 如：<strong>Z-buffer、扫描线</strong>等。</li><li>物体空间和图像控件的消隐算法：在物体空间中预先计算面的可见性优先级, 再在图像空间中生成 消隐图。如：<strong>画家算法</strong>等。</li></ul></li></ul><h3 id="6-2-提高消隐算法效率的常见方法"><a href="#6-2-提高消隐算法效率的常见方法" class="headerlink" title="6.2 提高消隐算法效率的常见方法"></a>6.2 提高消隐算法效率的常见方法</h3><ol><li>利用连贯性<ul><li>物体的连贯性</li><li>面的连贯性</li><li>区域的连贯性 </li><li>扫描线的连贯性</li></ul></li><li>将透视投影转换成平行投影 <ul><li>消隐与投影方式有关 (消隐必须在投影之前完成)</li></ul></li></ol><ul><li>包围盒技术：包围目标的简单形体</li><li>背面剔除</li><li>空间分割技术</li><li>物体分层表示  </li></ul><h5 id="包含消隐的三维图形显示流程图："><a href="#包含消隐的三维图形显示流程图：" class="headerlink" title="包含消隐的三维图形显示流程图："></a>包含消隐的三维图形显示流程图：</h5><p><img src="/CG/4.png" width="45%"></p><h5 id="消隐的基本-核心-问题-排序"><a href="#消隐的基本-核心-问题-排序" class="headerlink" title="消隐的基本(核心)问题:排序"></a>消隐的基本(核心)问题:排序</h5><ul><li>整体排序: 画家算法</li><li>点排序: Z-Buffer算法、光线投射算法 </li><li>区间排序: 扫描线算法</li><li>区域排序: 区域子分算法</li></ul><h3 id="6-3-画家算法"><a href="#6-3-画家算法" class="headerlink" title="6.3 画家算法"></a>6.3 画家算法</h3><ul><li>基本思想 <ul><li>先将场景中的物体按其距观察点的远近进行排序，结果放在一张线性表中;</li><li>线性表构造:距观察点远的称优先级低，放在表头;距观察点近的称优先级高， 放在表尾。该表称为深度优先级表</li><li>然后按照从表头到表尾的顺序逐个绘制物体。</li></ul></li><li>基本步骤<ul><li>对场景中的多边形按深度进行排序，</li><li>形成深度优先级表;</li><li>按从远到近的顺序显示多边形;</li></ul></li><li>画家算法不能处理的情况<ul><li>多边形循环遮挡</li><li>多边形相互穿透</li></ul></li><li>解决办法: 沿多边形所在平面之间的交线循环地分割这些多边形，直至最终可建立确定的优先级表。</li></ul><h3 id="6-4-Z缓冲器算法"><a href="#6-4-Z缓冲器算法" class="headerlink" title="6.4 Z缓冲器算法"></a>6.4 Z缓冲器算法</h3><ul><li>基本思想<ul><li>先将Z缓冲器中个单元的初始值置为-1 (规范视见体的最小n值)。</li><li>当要改变某个像素的颜色值时，首先检查当前<strong>多边形的深度值</strong>是否大于该像素<br>原来的深度值(保存在该像素所对应的Z缓冲器的单元中);</li><li><strong>如果大于，说明当前多边形更靠近观察点</strong>，用它的颜色替换像素原来的颜色;</li><li>否则说明在当前像素处，当前多边形被前面所绘制的多边形遮挡了，是不可见的，像素的颜色值不改变。</li></ul></li><li><strong>优点</strong><ul><li>算法简单、稳定</li><li>便于硬件加速</li><li>不需要整个场景的几何数据</li></ul></li><li><strong>缺点</strong><ul><li>需要Z缓冲器 <strong>改进: 扫描线Z缓冲器算法</strong> </li><li>计算复杂度大 <strong>改进:区域子分算法</strong></li></ul></li></ul><blockquote><p> 需要计算的像素深度值次数 = 多边形个数 * 多边形平均占据的像素个数</p></blockquote><h3 id="6-5-扫描线Z缓冲器算法"><a href="#6-5-扫描线Z缓冲器算法" class="headerlink" title="6.5 扫描线Z缓冲器算法"></a>6.5 扫描线Z缓冲器算法</h3><ul><li>改进一: 将窗口分割成扫描线<ul><li>缺点：在每一个被多边形覆盖像素处需要计算深度值；被多个多边形覆盖的像素需要多次计算深度值</li></ul></li><li>改进二：利用扫描线的连贯性计算深度 (增量法)</li><li>改进三：采用多边形分类表(PT)、活化多边形表 (APT)<strong>避免多边形与扫描线的盲目求交</strong></li><li>改进四：利用边、边的分类表(ET)、边对、活化边对表(AEPT)<strong>避免边与扫描线的盲目求交</strong></li></ul><h3 id="6-6-区间扫描线算法"><a href="#6-6-区间扫描线算法" class="headerlink" title="6.6 区间扫描线算法"></a>6.6 区间扫描线算法</h3><ul><li><strong>要求多边形不能相互贯穿</strong></li><li>该算法可以看作是边相关扫描线填充算法的延伸。</li><li>不同的是在消隐算法中处理的是多个面片，而多边形填充中是对单个多边形面进行填充。</li><li>它是把当前扫描线与各多边形在投影平面的投影的交点进行排序后，使扫描线分为若干子区间。因此，只要在区间任一点处找出在该 处z值最大的一个面，这个区间上的每一个象素就用这个面的颜色来显示。</li><li>改进：<ul><li>在一条扫描线上，以区间为单位确定多边形的可见性</li><li>不需要Z-Buffer</li></ul></li></ul><h3 id="6-7-区域子分割算法"><a href="#6-7-区域子分割算法" class="headerlink" title="6.7 区域子分割算法"></a>6.7 区域子分割算法</h3><ul><li>首先将场景中的多边形投影到绘图窗口内(假设它为边长为k的正方形)</li><li>判断窗口是否足够简单，若是则算法结束;</li><li>否则将窗口进一步分为四块(左上，右上，左下，右下)。</li><li>对此四个小窗口重复上述过程，直到窗口仅为一个像素大小。</li><li>此时可能有多个多边形覆盖了该像素，计算它们的深度值，以最近的颜色 显示该像素即可。</li></ul><h3 id="6-8-光线投射算法"><a href="#6-8-光线投射算法" class="headerlink" title="6.8 光线投射算法"></a>6.8 光线投射算法</h3><ul><li>考察<strong>由视点出发穿过观察屏幕</strong>的一像素而射入场景的一条射线,则可确定出场景中与该射线相交的物体。 </li><li>在计算出光线与物体表面的交点之后, 离像素最近的交点的所在面片的颜色为该像素的颜色; 如果没有交点, 说明没有多边形的投影覆盖此像素, 用背景色显示它即可。</li></ul><h2 id="7-真实感图形的生成"><a href="#7-真实感图形的生成" class="headerlink" title="7. 真实感图形的生成"></a>7. 真实感图形的生成</h2><ul><li>当光照射到物体表面时，光线可能被<strong>吸收</strong>、<strong>反射</strong>和<strong>透射</strong>。被物体吸收的部分转化为热，反射、透射的光进入 人的视觉系统，使我们能看见物体。</li><li>为模拟这一现象，我们建立一些数学模型来替代复杂的物理模型，这些模型就称为明暗效应模型或者光照明模型。三维形体的图形经过消隐后，再进行明暗效应的处 理，可以进一步提高图形的真实感。</li></ul><h3 id="7-1-简单光照明模型"><a href="#7-1-简单光照明模型" class="headerlink" title="7.1 简单光照明模型"></a>7.1 简单光照明模型</h3><ul><li>光照射到物体表面，主要发生:<ul><li>反射 </li><li>透射(对透明物体) </li><li>部分被吸收成热能 </li></ul></li><li>反射光和透射光的<strong>光谱分布</strong>——决定景物表面的<strong>颜色</strong></li><li>反射光和透射光的<strong>强弱</strong>——决定景物表面的<strong>明暗程度</strong></li><li><strong>环境光</strong>：在空间中近似均匀分布，即在任何位置、任何方向<br>上强度一样</li><li><strong>点光源</strong>:几何形状为一个点，位于空间中的某个位置，向周围所有的方向上辐射等强度的光。<ul><li>在物体的不同部分其亮度也不同，亮度的大小依赖于物体的朝向及它与点光源之间的距离。</li></ul></li><li><strong>漫反射</strong>：粗糙、无光泽物体(如粉笔，墙面)表面对光的反射<ul><li>各点反射光的强度只与①点光源强度、入射角 ②物体表面的反射系数  ③物体各表面的朝向 有关</li><li><strong>与观察者的观察方向无关</strong></li></ul></li><li><strong>镜面反射</strong>: 光滑物体(如金属或塑料)表面对光的反射<ul><li>n为镜面反射(高光)指数，n越大，则Is(镜面反射光强)随α的增大衰减的越快  </li><li><strong>n的取值与表面粗糙程度有关</strong><br>①n越大，表面越平滑(散射现象少，稍一偏离，明暗亮度急剧下降)<br>②n越小，表面越毛糙(散射现象严重)</li></ul></li><li>高光: 入射光在光滑物体表面形成的特别亮的区域</li></ul><h5 id="Phong光照明模型"><a href="#Phong光照明模型" class="headerlink" title="Phong光照明模型"></a>Phong光照明模型</h5><ul><li>由物体表面上一点P反射到视点的光强 I 为<strong>环境光的反射光强</strong> I<sub>e</sub>， <strong>理想漫反射光强</strong> I<sub>d</sub>，和<strong>镜面反射光</strong>I<sub>s</sub>的总和。</li><li>Phong光照明模型是真实感图形学中提出的第一个有影响的光照明模型</li><li>经验模型，Phong模型存在不足:<ul><li>显示出的物体象塑料，<strong>无质感变化</strong></li><li><strong>没有考虑物体间相互反射光</strong></li><li>镜面反射颜色与材质无关</li><li>镜面反射大入射角失真现象</li></ul></li></ul><h3 id="7-2-多边形表示的明暗处理"><a href="#7-2-多边形表示的明暗处理" class="headerlink" title="7.2 多边形表示的明暗处理"></a>7.2 多边形表示的明暗处理</h3><h5 id="Gouraud明暗处理-双线性光强插值"><a href="#Gouraud明暗处理-双线性光强插值" class="headerlink" title="Gouraud明暗处理(双线性光强插值)"></a>Gouraud明暗处理(双线性光强插值)</h5><ul><li>先计算物体表面多边形各顶点的光强, 然后用双线性插值, 求出多边形内部区域中各点的光强。</li><li><strong>基本算法描述</strong>:<ol><li>计算多边形顶点的平均法向;</li><li>计算顶点的平均光强;</li><li>插值计算离散边上的各点光强;</li><li>插值计算多边形内域中各点的光强。</li></ol></li><li><strong>优点</strong><ul><li>简单易行，计算量小</li><li>只需已知顶点的法向量 </li></ul></li><li><strong>缺点</strong><ul><li>只适用于简单的漫反射光照模型，不能正确模 拟镜面反射高光形状</li><li>用于动态显示物体时，物体表面明暗以不规则方式进行变化，高光显示问题</li><li>光亮度变化不连续的边界处出现过亮或过暗的条纹</li><li>公共顶点处颜色不连续，顶点方向不具代表性</li></ul></li><li><strong>在Gouraud提出明暗处理方法时，Phong模型还没有出现</strong></li></ul><h5 id="Phong明暗处理-双线性法向插值"><a href="#Phong明暗处理-双线性法向插值" class="headerlink" title="Phong明暗处理 (双线性法向插值)"></a>Phong明暗处理 (双线性法向插值)</h5><ul><li>与双线性光强插值相比, 该方法有如下特点:<ul><li>保留双线性插值, 对多边形边上的点和内域各点, 采用增量法。</li><li>对顶点的法向量进行插值, 而顶点的法向量, 用相邻的多边形的法向作平均。</li><li>由插值得到的法向, 计算每个像素的光亮度。</li><li>假定光源与视点均在无穷远处, 光强只是法向量的函数。</li></ul></li><li>优点<ul><li>Phong方法绘制的图形比Gouraud方法更真实</li></ul></li><li>缺点<ul><li>计算量远大于Gouraud方法</li></ul></li></ul><h5 id="阴影的生成"><a href="#阴影的生成" class="headerlink" title="阴影的生成"></a>阴影的生成</h5><ul><li>阴影<ul><li>光源不能直接照射的区域</li><li>对光源来说，不可见的面(隐藏面)</li></ul></li></ul><h3 id="7-3-透明"><a href="#7-3-透明" class="headerlink" title="7.3 透明"></a>7.3 透明</h3><ul><li>现实世界中有许多透明物体，如玻璃等。透过透明物体，可以观察到其后面的景物。</li><li>产生简单透明效果的方法<ul><li>插值透明方法</li><li>过滤透明方法</li></ul></li></ul><h5 id="Whitted光透射模型"><a href="#Whitted光透射模型" class="headerlink" title="Whitted光透射模型"></a>Whitted光透射模型</h5><ul><li>基于经验、理论，不是严格的物理模型。</li></ul><h5 id="Hall光透射模型"><a href="#Hall光透射模型" class="headerlink" title="Hall光透射模型"></a>Hall光透射模型</h5><ul><li>在Whitted光透射模型的基础上推广而来。<ul><li>加入光源引起的规则透射分量。</li><li>可以处理理想的漫透射。</li></ul></li></ul><h3 id="7-4-整体光照明模型"><a href="#7-4-整体光照明模型" class="headerlink" title="7.4 整体光照明模型"></a>7.4 整体光照明模型</h3><ul><li><strong>五个组成部分：</strong><ul><li></li></ul></li><li>简单光照模型是一种局部光照模型，不考虑周围环境对当前 景物表面的光照明影响，<strong>忽略了光在环境景物之间的传递</strong>，很难表现自然界复杂场景的高质量真实感图形。</li><li>基于简单光照明模型的<strong>光透射模型</strong>，虽然可以模拟光的折射，但是这种折射的计算范围很小，不能很好的模拟多个透明 体之间的复杂光照明现象。</li><li>对于上述的这些问题，就必须要有一个更精确的光照明模型。<strong>整体光照明模型</strong>就是这样的一种模型，它是相对于局部光照明模型而言的。</li></ul><h3 id="7-5-光线跟踪算法-P149"><a href="#7-5-光线跟踪算法-P149" class="headerlink" title="7.5 光线跟踪算法 P149"></a>7.5 光线跟踪算法 P149</h3><ul><li><strong>四种光线</strong><ul><li>视线：由视点与象素(x，y)发出的射线</li><li>阴影测试线：物体表面上点与光源的连线</li><li>反射光线 </li><li>折射光线</li></ul></li><li>无论是Gouraud还是Phong明暗绘制算法，都只能模拟局部光照明效果。</li><li>如果场景中存在<strong>光亮的镜面物体和透明物体，则光线会在物体之间反射和折射</strong>，这些都是上述算法所无法模拟的。还不能产生阴影效果。如果必须模拟这些效果，则我们可以采用光线跟踪算法或辐射度算法。</li><li><strong>自然界中光线的传播过程</strong>：光源 -&gt; 物体表面 -&gt; 物体表面 -&gt; 人眼</li><li><p>光线跟踪过程：<strong>光线传播的逆过程(视线跟踪)</strong></p><ul><li>光源发出光线，经反射与折射，只有很少部分可以进入人的眼睛。因此直接从光源出发，沿光的传播方向进行光 线跟踪是不现实的，也是不必要的。</li><li>实际上，<strong>光线跟踪算法的跟踪方向与光传播的方向是相反的，是视线跟踪</strong>。<br><img src="/CG/光线.png" width="45%"></li></ul></li><li><p><strong>优点</strong>: 能够方便的产生阴影，模拟镜面反射与折射现象。 </p></li><li><strong>缺点</strong>: 计算量大，每一条光线都要与场景中的物体进行求交、计算光照模型等。</li></ul><h5 id="递归终止条件"><a href="#递归终止条件" class="headerlink" title="递归终止条件"></a>递归终止条件</h5><ol><li>该光线未碰到任何物体。</li><li>该光线碰到了背景。</li><li>光线在经过许多次反射和折射以后，就会产生衰减，光线对于视点的光强贡献很小(小于某个设定值)。</li><li>光线反射或折射次数即跟踪深度大于一定值。</li></ol><h3 id="7-6-纹理"><a href="#7-6-纹理" class="headerlink" title="7.6 纹理"></a>7.6 纹理</h3><ul><li><strong>颜色纹理</strong>：光滑表面的花纹、图案。</li><li><strong>几何纹理</strong>：粗糙的表面(如桔子表面的皱纹), 是基于物体表面的微观几何形状的表面纹理。</li><li>两种方法来定义纹理:<ul><li>图像纹理</li><li>函数纹理</li></ul></li></ul><ol><li>分辨率为1024x1024的显示器各需要多少字节位平面<br>数为24的帧缓存？<br>A) 512KB ; B) 1 MB ; C) 2MB ; D) 3MB  </li><li>哪一个不是国际标准化组织(ISO)批准的图形标准？<br>A) GKS ; B) PHIGS ; C) CGM ; D) DXF</li><li>在计算机图形学的发展历史上，是谁确立了计算机图形学作为一门新学科的地位，他的哪些技术直到今天还在使用？</li><li>计算机图形系统的硬件设备有哪些？</li><li>光栅扫描显示器中，屏幕图形是依靠帧缓存进行刷新的，帧缓存里存放的是什么？</li><li>简述随机扫描显示器和光栅扫描显示器的简单工作原理和各自的特点。</li><li>用中点画线方法扫描转换连接两点P0（0,0）和P1（5,2）的直线段。<br>a = y0 - y1 = -2<br>b = x1 - x0 = 5<br>d0 = 2 <em> a + b = 1<br>d1 = 2 </em> a = -4<br>d2 = 2 * (a+b) = 6<br><img src="/CG/中点.png" width="45%"></li></ol><h2 id="图形学题目"><a href="#图形学题目" class="headerlink" title="图形学题目"></a>图形学题目</h2><ol><li>Breenham算法：<br><img src="/CG/bre.png" width="20%">  <img src="/CG/bre1.png" width="20%"></li><li>中点画圆算法<br><img src="/CG/中点画圆1.png" width="70%"></li><li><p>用边相关扫描线填充算法将顶点为P1 (2，2)，P2 (5，1)， P3(10，3)， P4(8，8)，P5(5，5)，P6(2，7)的多边形填充。请说明如何建立新边表NET和活动边表AET并写出该多边形填充的新边表NET和活动边表AET。<br><img src="/CG/扫描.png" width="60%"> </p></li><li><p>用数值微分DDA算法、中点算法和Bresenham算法扫描转换直线段(1,1)–(5,3)，<br>写出扫描转换的结果:写出每一步递推过程的x，y坐标及判别式d的值，图示计<br>算结果。</p></li><li>图中有两条圆弧A和B，假定当前取点为(xi，yi)，那么下一点只能是正<br>右方的 E(xi+1，yi)或右下方的SE(xi+1，yi-1)两者之一。 假设M是E和SE的中点，即，利用中点画圆算法，回答下列问题:<ul><li>当F(M) &lt; 0时，下一点应取哪个点? <strong>E点</strong> </li><li>当F(M) &gt; 0时，下一点应取哪个点? <strong>SE点</strong></li><li>当F(M) = 0时，下一点应取哪个点?  <strong>在E与SE之中随便取一个 即可，我们约定取SE点。</strong><br><img src="/CG/选点.png" width="30%"> </li></ul></li><li>裁剪的实质是什么?<ul><li>ans：裁剪的实质就是决定图形中哪些点、线段、文字、以及多边形在窗口之内。 </li></ul></li><li>已知窗口左下角坐标(50，50)，右上角坐标(400，400) 直线的端点坐标P1(40，100)和P2(500，420)， 试用Cohen-Sutherland直线编码裁剪算法，结合编码图示， 求出P1和P2所在区域的分区代码C1和C2。<ul><li>C1为0001; C2为1010 。 </li></ul></li><li>当线段与窗口边界有交点时，如果线段的长度为1024， 用中点分割算法求交点的次数是多少?<ul><li>10次。</li></ul></li><li>用Weiler-Atherton算法完成内裁剪和外裁剪。DCBA为裁剪窗口，dcba为要裁剪的多边形。<br><img src="/CG/wa题.png" width="50%"> </li><li>一个由顶点(10，20)，(20，20)和(15，30)所定义的三角形，让它相对于点Q(5，25)正向旋转30°，求其变换后的三角形。<br><img src="/CG/几何1.png" width="60%"> </li><li>推导以直线ax+by+c=0为对称轴的二维对称变换矩阵。<br><img src="/CG/几何2.png" width="70%"> </li><li>在坐标系oxyz中，求一个变换将P(1,1,1)Q(2,2,2)变换到z 轴上:P在坐标原点，Q在z轴正半轴。<br><img src="/CG/3dt.png" width="70%"> </li><li>如图所示三角形ABC，将其关于A点逆时针旋转90度，写 出其变换矩阵和变换后图形各点的规范化齐次坐标。<br><img src="/CG/3dti.png" width="40%"> </li><li>下列有关平面几何投影的叙述，错误的是( )<br>A)透视投影又可分为一点透视、二点透视、三点透视;<br>B)斜投影又可分为斜等测、斜二测;<br>C)正轴测又可分为正一测、正二测、正三测;<br>D)三视图又可分为正视图、侧视图、俯视图。</li><li>下列有关平面几何投影的叙述语句中，正确的论述为( )<br>A)在平面几何投影中，若投影中心移到距离投影面无穷远 处，则成为平行投影;<br>B)透视投影与平行投影相比，视觉效果更有真实感，而且 能真实地反映物体的精确的尺寸和形状;<br>C)透视投影变换中，一组平行线投影在与之平行的投影面 上，可以产生灭点;<br>D)在三维空间中的物体进行透视投影变换，可能产生三个 或者更多的主灭点。  </li><li>用下列二维图形变换矩阵:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;0&nbsp;1&nbsp;<br>T&nbsp;=&nbsp;0&nbsp;1&nbsp;1&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    0&nbsp;0&nbsp;1  &nbsp;<br>将产生变换的结果为( )<br>A) 图形放大2倍;<br>B) 图形放大2倍，同时沿X、Y坐标轴方向各移动1个绘图单位;<br>C) 沿X坐标轴方向各移动2个绘图单位;<br>D) 沿X坐标轴方向放大2倍，同时沿X、Y坐标轴方向各平移1个 绘图单位。</li><li>下列有关透视投影的叙述，错误的是( )<br>A)投影线从视点出发;<br>B)投影线不平行;<br>C)任何一束不平行于投影面的平行线的透视投影将汇成一点;<br>D)主灭点有无数个。  </li><li>请解释平面几何投影的含义。</li><li>何为“透视投影”?并说明“灭点”和“主灭点”是如何产生的?</li><li>什么是观察坐标系?为什么要建立观察坐标系?</li><li>已知投影面为xoy坐标平面，投影中心在z轴的正向、z=d的 位置上，求透视投影变换矩阵。</li><li>描述Z缓存器消隐算法的基本原理和算法实现;</li><li>光线跟踪算法的跟踪方向与光传播的方向是相同的，是视线 跟踪。( )</li><li>双线性法向插值算法先计算出曲面在各多边形顶点处的光强 ，然后再采用双线性插值方法确定在扫描线上每个像素处的 光强值，得到多边形的光滑颜色分布。( )</li><li>非理想镜面反射中，镜面反射指数n模拟镜面反射光在空间 中的汇聚程度，n越大，表面越粗糙( )。</li><li>粗糙的物体表面能够将反射光向各个方向散射， 称为( )。</li><li>比较Gouraud明暗处理算法和Phong明暗处理算法的优缺点。</li><li>何谓“光线跟踪算法”?请简要叙述光线跟踪算法的基本思想。</li></ol><ul><li>CRT的原理简单了解</li><li>光栅图形显示系统：4部分 每一部分具体是做什么用的 </li><li>中点算法增量法的改进 为什么可以摆脱小数计算</li><li>扫面线算法 四个步骤，交点的计数问题</li><li>字符的两种类型 和存储的信息分别是什么</li><li>Cyrus Beck Line Clipping 梁八子算法不作要求</li><li>消隐算法的分类 要能判断。画家算法 Z-Buffer及它的改进 要能描述清楚，其余的了解基本思想和优缺点</li><li>物体对光产生<strong>反射、投射</strong>和部分<strong>吸收</strong>成热能，填空</li><li>两种投影类型 正轴测投影的分类，透视投影变换要会推导</li><li>三维图像的显示流程（剪裁和投影的前后关系）</li><li>光线跟踪算法的递归终止条件 简答题</li><li>为什么引入齐次坐标 ？把加法变成乘法；统一的表达方式；无穷？？</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-计算机图形学概述&quot;&gt;&lt;a href=&quot;#1-计算机图形学概述&quot; class=&quot;headerlink&quot; title=&quot;1. 计算机图形学概述&quot;&gt;&lt;/a&gt;1. 计算机图形学概述&lt;/h2&gt;&lt;h3 id=&quot;1-1-研究内容&quot;&gt;&lt;a href=&quot;#1-1-研究内容&quot; class=&quot;headerlink&quot; title=&quot;1.1 研究内容&quot;&gt;&lt;/a&gt;1.1 研究内容&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;图形&lt;/code&gt;含有几何属性，或者说更强调场景的集合表示，是由场景的几何模型和警务的物理属性共同组成。（矢量/参数）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;图像&lt;/code&gt;是指计算机内以位图形式存在的灰度信息。（位图）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;计算机图形学&lt;/code&gt;：利用计算机研究一系列原理、方法与技术的学科。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mac OS X下连接校园网VPN [L2TP方式]</title>
    <link href="http://daisine.me/macvpn/"/>
    <id>http://daisine.me/macvpn/</id>
    <published>2018-09-20T00:32:10.000Z</published>
    <updated>2018-09-23T07:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>以重庆大学校园网VPN为例，操作系统OS X 10.11.6。</p><ul><li>首先查看<a href="http://net.cqu.edu.cn/info/1025/1255.htm" target="_blank" rel="noopener">重庆大学校园网VPN说明</a>：</li></ul><blockquote><p>重庆大学VPN支持<strong>标准的PPTP和L2TP两种方式</strong>。用户在网络连接的设置中，新增虚拟专网VPN连接。VPN的地址请填写域名vpn.cqu.edu.cn，系统会自动解析相应地址。</p></blockquote> <a id="more"></a> <ul><li>打开<code>系统偏好设置</code> - &gt; <code>网络</code> - &gt; <code>右下角＋号</code>新建VPN服务<ul><li>接口：VPN</li><li>VPN类型：IPSec上的L2TP</li><li>服务名称：CQU VPN</li></ul></li><li>新建VPN完成后，<code>服务器地址</code>填写为<code>vpn.cqu.edu.cn</code>，账户名称为学号。</li><li><p>现在点击<code>链接</code>，输入密码(默认为身份证后六位)会提示，IPSec 共享密钥丢失。需要在终端进行进一步设置：</p><ul><li>在/etc/ppp/下创建options文件：<br><code>sudo vim /etc/ppp/options</code></li><li>在options文件中输入(键入A - &gt; INSERT)并保存(ESC - &gt; wq)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plugin L2TP.ppp</span><br><span class="line">l2tpnoipsec</span><br></pre></td></tr></table></figure></li><li><p>回到VPN设置，选择<code>高级</code>- &gt; <code>选项</code> - &gt; <code>通过VPN连接发送所有流量</code></p></li><li>再次点击连接VPN，连接成功。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以重庆大学校园网VPN为例，操作系统OS X 10.11.6。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先查看&lt;a href=&quot;http://net.cqu.edu.cn/info/1025/1255.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;重庆大学校园网VPN说明&lt;/a&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;重庆大学VPN支持&lt;strong&gt;标准的PPTP和L2TP两种方式&lt;/strong&gt;。用户在网络连接的设置中，新增虚拟专网VPN连接。VPN的地址请填写域名vpn.cqu.edu.cn，系统会自动解析相应地址。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记11 文件系统</title>
    <link href="http://daisine.me/os11/"/>
    <id>http://daisine.me/os11/</id>
    <published>2018-07-03T06:19:18.000Z</published>
    <updated>2018-10-29T03:16:09.247Z</updated>
    
    <content type="html"><![CDATA[<h4 id="文件系统接口-用户角度"><a href="#文件系统接口-用户角度" class="headerlink" title="文件系统接口(用户角度)"></a>文件系统接口(用户角度)</h4><h5 id="文件概念"><a href="#文件概念" class="headerlink" title="文件概念"></a>文件概念</h5><ul><li><strong><code>文件</code></strong>是逻辑外存单元的最小分配单元。</li><li><strong>类型</strong><ul><li>数据：数字字符，二进制…</li><li>程序</li></ul></li><li><p><strong>文件结构</strong></p><ul><li>无： 一个字节序列</li><li>简单的记录结构：①行 ②固定长度 ③可变长度</li><li>复杂结构：①格式化文档 ②对象文件 ③可执行文件</li></ul><a id="more"></a></li><li><strong>谁决定文件结构？</strong><ul><li>操作系统：可执行文件和共享库文件的结构</li><li>程序</li></ul></li><li><strong>文件属性</strong>：所有文件的信息都保存在目录结构中。<ul><li>名称：文件符号名称是唯一的、按照人们易读取的形式保存。</li><li>标识符：标示文件系统内文件的唯一标签，通常为人不可读。</li><li>类型：被支持不同类型的文件系统所使用。</li><li>位置：该信息指向设备和设备上文件位置的指针。</li><li>大小：文件当前大小，也可包括文件允许的最大容量值。</li><li>保护：决定谁能读、写、执行等的访问控制信息。</li><li>时间，日期和用户标识：文件创建、上次修改和赏赐访问的相关信息。这些数据用于保护、安全和使用跟踪。</li></ul></li><li><strong>文件操作</strong><ul><li>创建，打开，关闭，读，写，在文件内重定位(搜索目录相应条目)，删除，截短(删除内容保留属性，长度设置为0并释放)。</li><li>打开文件：当一个文件被打开时，除了存储在设备上的信息之外，还会执行几条数据来管理打开的文件<br>①<strong>文件指针</strong>：指向上次读取/写入位置的指针，这种指针对于打开文件的每个进程唯一。<br>②<strong>文件打开计数器</strong>：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间会不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件。该计数器跟踪打开和关闭的数量，当该计数为0 时，系统关闭文件，删除该条目。<br>③<strong>文件磁盘位置</strong>：绝大多数文件操作都要求系统修改文件数据。该信息保存在内存中以免为每个操作都从磁盘中读取。<br>④<strong>访问权限</strong>：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等)。该信息保存在进程的打开文件表中以便操作系统能允许或拒绝之后的 I/O 请求。</li></ul></li><li><strong>文件类型</strong><br><img src="https://i.loli.net/2018/06/19/5b2914df7a5d7.png" width="65%" height="80%"></li><li><strong>文件访问</strong>：文件访问<ul><li>顺序访问：从头开始读取所有字节/记录。不能跳转，但当存储设备是磁带时可以倒带或备份。</li><li>随机访问/直接访问：读/写顺序无限制。字节/记录以任何顺序读取，这种访问对数据库很重要。</li></ul></li></ul><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><ul><li><strong>目录操作</strong>：<ul><li>搜索文件</li><li>创建文件</li><li>删除文件</li><li>遍历目录</li><li>重命名文件</li><li>跟踪文件系统</li></ul></li><li><strong><code>单层目录结构</code></strong><ul><li>限制：①文件必须具有唯一名称(命名问题) ②(文件过多)分组问题<br><img src="https://i.loli.net/2018/06/19/5b28ff48b0896.png" width="55%" height="80%"></li></ul></li><li><strong><code>双层目录结构</code></strong><ul><li>为每个用户创建<strong>独立目录</strong></li><li>特点：①文件或目录可以按其路径定位 ②不同的用户可以使用相同文件名<br><img src="https://i.loli.net/2018/06/19/5b28ff4703f01.png" width="55%" height="80%"></li></ul></li><li><strong><code>树状目录结构</code></strong><ul><li>分组能力</li><li>禁止共享文件或目录</li><li>路径名有两种形式：①绝对路径名 ②相对路径名</li><li>每个进程都有一个当前目录，在启动时分配给它。<br><img src="https://i.loli.net/2018/06/19/5b28ff481348c.png" width="55%" height="80%"></li></ul></li><li><strong><code>无环图目录</code></strong>：树状结构目录的扩展<ul><li>允许目录含有共享子目录和文件。同一文件或子目录可出现在两个不同目录中。</li><li>某些操作系统不支持无环图目录，例如MS-DOS</li><li>UNIX/LINUX和Windows（7+）通过<strong>符号链接</strong>支持它<br><img src="https://i.loli.net/2018/06/19/5b29157df0de1.png" width="55%" height="80%"></li></ul></li></ul><h5 id="文件系统挂载"><a href="#文件系统挂载" class="headerlink" title="文件系统挂载"></a>文件系统挂载</h5><ul><li>文件系统在被系统上的进程使用之前必须安装/挂载。</li><li>目录结构可以建立在多个卷上。这些卷必须安装以使它们在文件系统命名空间可用。(U盘)</li><li>文件系统的安装位置称为<strong>安装点</strong>，为一个空目录。<ul><li>Windows操作系统在引导过程中安装包含FAT（-12，-16，-32）或NTFS文件系统的所有分区，分别是“C：”，“D：”等。</li><li>在UNIX / Linux中，系统管理员必须发出命令来在设备中安装文件系统。<code>mount -t iso9660 / mnt / cdrom / dev / cdrom</code></li></ul></li></ul><h5 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h5><ul><li>在多用户系统上共享文件是可取的。</li><li>大多数系统通过其唯一的用户标识或UID来识别用户。除了UID，一些系统还实现了组功能</li><li>每个组都分配一个唯一的组标识或GID。每个用户可以在一个或多个组中</li><li>当文件或目录最初创建时，它与用户的UID和GID相关联。拥有文件的用户是该文件的所有者。</li></ul><h5 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h5><ul><li>文件所有者应该能够控制可以完成什么以及由谁来完成</li><li>访问类型：读取（R），写入（W），执行（X），添加，删除，列表</li><li>访问控制列表（ACL）指定用户名和每个用户允许的访问类型。<ul><li>它用于执行细粒度的文件和目录保护。 ACL的主要问题是它们的长度。</li><li>因此，最常见的方法是将UNIX样式保护与ACL结合使用。</li><li>例如，Windows NT或更高版本以及Solaris 2.6或更高版本使用此组合方法。</li></ul></li></ul><h4 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h4><h5 id="文件系统结构"><a href="#文件系统结构" class="headerlink" title="文件系统结构"></a>文件系统结构</h5><ul><li>文件<ul><li>逻辑存储单元</li><li>相关信息的集合</li><li><strong>文件控制块(FCB)</strong>：包含文件的所有信息。在UNIX中，FCB通常称为inode</li></ul></li><li>文件系统：提供对磁盘的高效且便捷的访问，用以轻松地存储、定位和提取数据。<ul><li>在二级存储器中，采用分层结构实现文件系统能够最大限度地减少重复的代码。<br><img src="https://i.loli.net/2018/06/19/5b29075ab4052.png" width="20%" height="80%"></li></ul></li><li>一个典型的文件控制块FCB：<br><img src="https://i.loli.net/2018/06/19/5b29078f88bfe.png" width="35%" height="80%"></li></ul><h5 id="虚拟文件系统-VFS"><a href="#虚拟文件系统-VFS" class="headerlink" title="虚拟文件系统(VFS)"></a>虚拟文件系统(VFS)</h5><ul><li>问题：<ul><li>操作系统如何把多个文件系统整合成一个目录？</li><li>用户如何在访问文件系统空间时，可以无缝地在文件系统之间移动？</li></ul></li><li>虚拟文件系统(VFS)：</li><li>大多数操作系统包括UNIX使用面向对象的技术来简化，组织和模块化实现过程。  <ul><li>一个通用的文件系统接口与文件系统实现分离，文件系统接口包含“打开”，“关闭”，“读取”，“写入”和“查找”等系统调用。<br><img src="https://i.loli.net/2018/06/19/5b2909f0cae33.png" width="50%" height="80%"></li></ul></li><li><strong><code>VFS接口</code></strong>有两个重要功能：<ul><li>VFS层通过定义一个清晰的VFS接口，以将文件系统的通用操作和具体实现分开。</li><li>VFS提供了在网络上唯一标识一个文件的机制。VFS基于名为<strong>vnode</strong>的文件表示结构，该结构包含一个数值标识符以表示位于整个网络范围的唯一文件。</li></ul></li></ul><h5 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h5><ul><li>一些操作系统（包括UNIX）将目录完全视为文件<ul><li>它为每个文件或其子目录保存两条信息：文件/子目录名称和指向文件/子目录的FCB的指针（它们通常被组织成一个C“struct dirent”）</li></ul></li><li>一个目录可能包含很多文件或子目录，如何组织这些“dirent”？(Unix的一个结构体)</li><li><strong>线性列表</strong>：使用存储文件名和数据快指针的线性列表。<ul><li>√ 实现简单</li><li>× 搜索耗时</li></ul></li><li><strong>哈希表</strong>：线性列表存储结构 + 哈希数据结构<ul><li>√ 减少目录搜索时间，插入和删除也很简单。</li><li>× 其通常固定的大小和哈希函数对大小的依赖性。<strong>增长困难。</strong></li></ul></li><li>大多数操作系统使用“线性列表”来组织目录。</li></ul><h5 id="分配方法"><a href="#分配方法" class="headerlink" title="分配方法"></a>分配方法</h5><ul><li>如何为文件分配空间以便利用磁盘空间并快速访问文件？</li><li>三种主要分配方法<ol><li>连续分配</li><li>链接分配</li><li>索引分配</li></ol></li></ul><h5 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h5><ul><li>要求每个文件在磁盘上占用一组连续块。</li><li>优缺点：<ul><li>√ 简单：只有起始位置（块号）和长度（块数）保存在FCB中</li><li>√ 支持随机访问</li><li>√ 对缓存友好</li><li>× 产生外部碎片：动态存储分配问题</li><li>× 难以扩展文件<br><img src="https://i.loli.net/2018/06/19/5b290e7e8879c.png" width="50%" height="80%"></li></ul></li></ul><h5 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h5><ul><li>每个文件都是磁盘块的链接列表。<ul><li>FCB包含文件<strong>第一块的指针</strong>和<strong>最后一块的指针</strong>。</li><li>每个块包含一个指向下一个块的指针。</li><li>这些指针对用户不可见，因此，如果每个块是512字节,磁盘地址（指针）为4个字节，则用户看到508个字节的块。</li></ul></li><li>优缺点：<ul><li>√ 简单：只需要起始地址</li><li>√ 不浪费空间</li><li>√ 指针需要额外的空间</li><li>√ 没有随机存取，(用单项链表)只能顺序访问</li><li>× 可靠性：分散在整个磁盘上的指针</li></ul></li><li>指针的开销可以通过将几个块收集到一个称为群集的较大块中来降低</li><li>为了解决简单链接分配的问题，每个分区开始处的一段磁盘被放置在一旁，以包含一个包含文件系统所有指针的表。</li><li>文件分配表(FAT)：一个简单但有效的磁盘空间分配方法，<strong>用于MS-DOS和OS/2</strong>。<ul><li>每一个卷的开始部分用于存储该FAT。</li><li>每块都在该表中有一项。</li><li>该表可以通过块号码来索引。<br><img src="https://i.loli.net/2018/06/19/5b29116fb0aca.png" width="60%" height="80%"></li></ul></li></ul><h5 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h5><ul><li>将所有指向文件磁盘块的指针合并到一个位置：索引块。索引块包含一系列磁盘块地址。</li><li>解决了连续分配的外部碎片和大小声明问题。<br><img src="https://i.loli.net/2018/06/19/5b2912b622534.png" width="45%" height="80%"></li><li>优缺点<ul><li>√ 支持直接/随机访问</li><li>√ 没有外部碎片(但有索引块的开销)。</li><li>× 需要索引表。  </li></ul></li><li>索引块的大小：<ol><li>链接方案</li><li>多级索引</li><li>(以上两种)组合方案 (这是大多数UNIX文件系统使用的方案)<br><img src="  https://i.loli.net/2018/06/19/5b2913335d5d3.png" width="55%" height="80%"></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;文件系统接口-用户角度&quot;&gt;&lt;a href=&quot;#文件系统接口-用户角度&quot; class=&quot;headerlink&quot; title=&quot;文件系统接口(用户角度)&quot;&gt;&lt;/a&gt;文件系统接口(用户角度)&lt;/h4&gt;&lt;h5 id=&quot;文件概念&quot;&gt;&lt;a href=&quot;#文件概念&quot; class=&quot;headerlink&quot; title=&quot;文件概念&quot;&gt;&lt;/a&gt;文件概念&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;文件&lt;/code&gt;&lt;/strong&gt;是逻辑外存单元的最小分配单元。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;数据：数字字符，二进制…&lt;/li&gt;
&lt;li&gt;程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;文件结构&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无： 一个字节序列&lt;/li&gt;
&lt;li&gt;简单的记录结构：①行 ②固定长度 ③可变长度&lt;/li&gt;
&lt;li&gt;复杂结构：①格式化文档 ②对象文件 ③可执行文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记10 虚拟内存</title>
    <link href="http://daisine.me/os10/"/>
    <id>http://daisine.me/os10/</id>
    <published>2018-07-03T06:19:15.000Z</published>
    <updated>2018-10-29T03:16:41.459Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul><li>自从有了计算机以来，我们就希望能够方便、高效地使用(今天仍然)十分有限的内存：<ol><li>用户总是可以认为自己计算机的<strong>内存大到足够运行任何程序</strong>。</li><li>程序员可以认为自己的程序将运行<strong>在巨大、连续的内存</strong>中。不需要用overlay或swap等技术来自己管理内存。</li><li>进程在运行过程中<strong>不能访问(包括读写)其他进程的数据</strong>，更<strong>不能访问属于操作系统的数据</strong>。而且某一个进程引起的问题不会波及到操作系统或其他进程。</li><li>由于内存有限，应该尽可能地<strong>共享一些公用的代码和数据</strong>。</li></ol></li><li><p>前面介绍的各种技术解决了上述问题的某一些方面，但没有提出一个整体的解决方案。</p><ul><li>虚拟内存技术基于已有的各种技术给出了一个完整的解决方案, 是20世纪计算机技术最重要的发明之一。</li></ul><a id="more"></a></li></ul><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><ul><li><strong><code>虚拟内存</code></strong>：将用户逻辑内存与物理内存的分离。<ul><li>为每个进程提供一个巨大的，连续的和私有的逻辑内存，可能比物理内存大得多。只有部分程序需要在内存中执行。</li><li>允许地址空间被多个进程共享，更有效的进程创建。<br><img src="https://i.loli.net/2018/06/19/5b28aed7c426e.png" width="40%" height="80%"></li></ul></li><li>虚拟内存可通过以下方式实现：<ul><li><strong>按需调页</strong></li><li>按需分段  </li></ul></li></ul><h4 id="按需调页"><a href="#按需调页" class="headerlink" title="按需调页"></a>按需调页</h4><ul><li><strong><code>按需调页</code></strong>：仅在需要时才调入相应的页，即<strong><code>懒惰交换</code></strong>。<ul><li>需要更少的 I/O 。</li><li>需要更少的内存。</li><li>响应更快。</li><li>更多的进程。</li></ul></li><li><strong>交换程序</strong>是对<strong>整个进程</strong>进行操作，而<strong>调页程序</strong>只对<strong>单个页</strong>进行操作。 因此按需调页需要使用调页程序。<br><img src="https://i.loli.net/2018/06/19/5b28b017d35a8.png" width="45%" height="80%"></li><li><strong><code>有效-无效位</code></strong>：当操作系统调度某个进程运行时，判断该进程的页面是否已经调入内存中。<ul><li>！每个页表项(PTE)都有一个有效无效位关联。</li><li>设置为“有效”：关联页面合法且在内存中。</li><li>设置为“有效”：该页面不合法(不在该进程的逻辑地址空间中)，或者是合法的，但是在磁盘上。<br><img src="https://i.loli.net/2018/06/19/5b28b144e932a.png" width="45%" height="80%"></li></ul></li><li>在MMU中的地址转换期间，如果PTE中的有效-无效位是“无效”<ol><li>CPU触发一个<strong><code>页面错误陷阱</code></strong>(<strong>page-fault</strong> trap)陷入操作系统。这种陷阱是由于操作系统未能将所需的页调入内存中引起的。</li><li>操作系统检查内部页表（通常与PCB一起保存）来确定该引用是合法还是非法的地址访问。<br>①引用非法，OS终止进程；②引用有效但尚未调入页面，OS将调入该页面。</li><li>找到一个空闲帧。</li><li>调度一个磁盘操作，以便将所需的页面调入刚分配的帧。</li><li>当磁盘操作完成后，修改进程的内部表和页表，以表示该页已在内存中</li><li>(CPU自动执行)重新开始因陷阱而中断的指令。进程现在能访问所需的页，就好像它似乎总在内存中。<br><img src="https://i.loli.net/2018/06/19/5b28b58f5e1f1.png" width="58%" height="80%"></li></ol></li><li>架构要求(硬件)<ol><li><strong>页表</strong>：该表能够通过<code>有效-无效位</code>或保护位，将条目设定为无效。</li><li><strong>次级存储器</strong>：该次级存储器用来保护不在内存中的页。次级存储器通常为快速硬盘。它通常称为交换设备，用于交换的这部分磁盘称为<strong><code>交换空间</code></strong>。</li><li>能在发生页面错误后<strong>准确重新执行指令</strong>。在出现页错误时，保持中断进程的状态(寄存器、条件代码、指令计数器)，必须能够按完全相同的位置和地址重新开始执行进程)。对于绝大多数情况，这种要求容易满足。</li></ol></li></ul><h4 id="页面置换"><a href="#页面置换" class="headerlink" title="页面置换"></a>页面置换</h4><ul><li>如果增加了多道程序的程度。那么会<strong><code>过度分配</code></strong>内存。</li><li>发生页面错误时，没有可用的空闲帧。如何进行？<ul><li>在内存中找到一个没有被充分使用的帧，将其分页。</li></ul></li><li><strong><code>页面替换</code></strong>：修改页<code>错误处理程序</code>以包括页置换。<strong>页面置换可以在较小的物理内存上提供大的虚拟内存</strong><br><img src="https://i.loli.net/2018/06/19/5b28ba339487d.png" width="58%" height="80%"><ol><li>查找所需页在磁盘上的位置。</li><li>查找一个空闲帧：<br>①如果有空闲帧，那么就使用它。<br>②如果没有空闲帧，那么就使用<strong>页面置换算法</strong>以选择一个<strong>牺牲“帧”</strong>。<br>③将“牺牲”帧的内容写到磁盘上，改变页表和帧表。</li><li>将所需页读入(新)空闲帧，改变页表和帧表。</li><li>重启用户进程。<br><img src="https://i.loli.net/2018/06/19/5b28bb1c5ee42.png" width="58%" height="80%"></li></ol></li><li>注意：<ul><li>如果没有帧空闲，则需要两次页传输：一次换入和一次换出。页面处理时间加倍。</li><li>可以通过将每页或帧与<strong>修改位</strong>（或<strong>脏位</strong>）通过硬件关联，来降低额外开销。<br>①每当页面被修改时，硬件就会设置该页的修改位以表示该页已修改。<br>②<strong>当修改位被设置时，才需要进行页换出操作。</strong></li></ul></li><li>页面置换是按需调页的基础。</li></ul><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><ul><li>算法目标：得到最低的页面错误率。</li><li>为了方便研究各种页面置换算法，计算各个算法所产生的页面错误，引入如下概念：<ul><li>引用串：内存引用的字符串。 通常以页面为单位。</li></ul></li><li>通过在引用串上运行页面置换算法，并计算该引用串上的<code>页面错误</code>数来评估算法。</li><li>页错误和帧数量图：<br><img src="https://i.loli.net/2018/06/19/5b28bde285b5f.png" width="40%" height="80%"></li><li>类型<ul><li>FIFO页置换</li><li>最优置换</li><li>LRU页置换</li><li>近似LRU页置换（二次机会算法）</li></ul></li></ul><h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><ul><li>页面错误率：0 ≤ p ≤ 1.0。<ul><li>如果p = 0，则不存在页面错误;</li><li>如果p = 1，则每个引用都会出现页面错误</li></ul></li><li>有效访问时间(EAT)<br>EAT = (1 - p) × (内存访问时间)+p × (页面错误时间)</li><li>一般来说，内存访问时间远小于处理页面错误的时间。因此，我们可以假设EAT与p成正比，即页面错误率。</li></ul><h5 id="FIFO页置换"><a href="#FIFO页置换" class="headerlink" title="FIFO页置换"></a>FIFO页置换</h5><ul><li>FIFO页置换：置换最旧的页。<br><img src="https://i.loli.net/2018/06/19/5b28c00a3454e.png" width="60%" height="80%"></li><li><strong><code>Belady</code>异常</strong>：一般情况下，page-fault会随着frame的数量增加而减少。但如果采用FIFO算法，<strong>情况有时并非如此</strong>。<br><img src="https://i.loli.net/2018/06/19/5b28c00a2b78c.png" width="40%" height="80%"></li></ul><h5 id="最优置换-OPT-MIN"><a href="#最优置换-OPT-MIN" class="headerlink" title="最优置换(OPT / MIN)"></a>最优置换(OPT / MIN)</h5><ul><li>最优置换：置换最长时间不会使用的页。</li><li>最优页面置换算法是所有算法中产生页错误率最低的。</li><li>最优置换难以实现，因为需要参考串的未来的知识。最优算法主要用于研究。<br><img src="https://i.loli.net/2018/06/19/5b28c1260fab8.png" width="60%" height="80%"></li></ul><h5 id="LRU页置换-最近最少使用算法"><a href="#LRU页置换-最近最少使用算法" class="headerlink" title="LRU页置换/最近最少使用算法"></a>LRU页置换/最近最少使用算法</h5><ul><li>FIFO算法使用的是页面调入的时间。OPT算法使用的是页将来使用的时间。</li><li>LRU页置换：置换最近最少使用的页面。近似的最佳页面替换。<br><img src="https://i.loli.net/2018/06/19/5b28c20f69818.png" width="60%" height="80%"></li><li>LRU置换可能需要一定的硬件支持来为页帧确定一个排序序列。有两种可行实现：①计数器 ②栈</li></ul><h5 id="近似LRU页置换"><a href="#近似LRU页置换" class="headerlink" title="近似LRU页置换"></a>近似LRU页置换</h5><ul><li>二次机会页置换算法/时钟置换算法：基本算法是FIFO置换算法。<ul><li>当要选择一个页时，检查其引用位。</li><li>如果值为0，则直接置换。如果访问位是1，就给它第二次机会。并选择下一个FIFO页面。</li><li>当一个页面得到第二次机会时，它的访问位就清为0，它的到达时间就置为当前时间。如果该页在此期间被访问过，则访问位置为1。  </li></ul></li><li>可以采用循环队列实现。<br><img src="https://i.loli.net/2018/06/19/5b28c30cbe814.png" width="45%" height="80%"><br><img src="https://i.loli.net/2018/06/19/5b28c30cbf0e9.png" width="50%" height="80%"></li></ul><h4 id="为什么虚拟内存运行良好？"><a href="#为什么虚拟内存运行良好？" class="headerlink" title="为什么虚拟内存运行良好？"></a>为什么虚拟内存运行良好？</h4><ul><li><strong><code>局部模型</code></strong>：<ul><li>局部：经常使用的页的集合。当进程执行时，它从一个局部移向另一个局部。</li><li>一个程序通常由多个不同局部组成。它们可能<strong>重叠</strong>(共享页面)。</li></ul></li><li>局部模型也是缓存工作正常的原因。</li><li>内存引用模式中的局部性：<br><img src="https://i.loli.net/2018/06/19/5b28c77b89a47.png" width="30%" height="80%"></li></ul><h4 id="颠簸"><a href="#颠簸" class="headerlink" title="颠簸"></a>颠簸</h4><ul><li>如果系统没有“足够”的帧，页面错误率非常高。 这导致：<ul><li>CPU利用率低。</li><li>长期调度员认为需要提高多程序的程度。</li><li>系统中增加了更多进程。</li></ul></li><li>颠簸：是一个系统忙于将页面导入和导出并且没有任何用处的情况。<ul><li>原因：所有局部大小的总和 &gt; 总内存大小<br><img src="https://i.loli.net/2018/06/19/5b28c84c5483c.png" width="40%" height="80%"></li></ul></li></ul><h4 id="工作集合模型"><a href="#工作集合模型" class="headerlink" title="工作集合模型"></a>工作集合模型</h4><ul><li><strong><code>工作集合模型</code></strong>是基于局部性假设的。<ul><li>该模型使用参数 &Delta; 定义<strong>工作集合窗口</strong></li><li>这最近 &Delta; 个引用的页面集合称为<strong>工作集合</strong>。因此，工作集是进程的局部性的近似值。</li></ul></li><li><p>将WSS<sub>i</sub>表示为最近进程P<sub>i</sub>的工作集。D为总的帧需求量。</p><ul><li>D = &Sigma; WSS<sub>i</sub></li><li>如果D &gt; 可用帧的数量，有的进程就会得不到足够的帧，从而会出现颠簸。<br><img src="https://i.loli.net/2018/06/19/5b28c9f434159.png" width="70%" height="80%"></li></ul></li><li><p>使用工作集合模型</p><ul><li>操作系统监视每个进程的工作集合，并为其分配大于其工作集合的帧数。</li><li>如果还有空闲帧，那么可以启动另一进程。</li><li>如果所有工作集合大小之后 &gt; 可用帧的总数，那么操作系统会选择暂停一个进程。</li><li>工作集合策略可以防止颠簸，并尽可能保持多道程序的程度。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;自从有了计算机以来，我们就希望能够方便、高效地使用(今天仍然)十分有限的内存：&lt;ol&gt;
&lt;li&gt;用户总是可以认为自己计算机的&lt;strong&gt;内存大到足够运行任何程序&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;程序员可以认为自己的程序将运行&lt;strong&gt;在巨大、连续的内存&lt;/strong&gt;中。不需要用overlay或swap等技术来自己管理内存。&lt;/li&gt;
&lt;li&gt;进程在运行过程中&lt;strong&gt;不能访问(包括读写)其他进程的数据&lt;/strong&gt;，更&lt;strong&gt;不能访问属于操作系统的数据&lt;/strong&gt;。而且某一个进程引起的问题不会波及到操作系统或其他进程。&lt;/li&gt;
&lt;li&gt;由于内存有限，应该尽可能地&lt;strong&gt;共享一些公用的代码和数据&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前面介绍的各种技术解决了上述问题的某一些方面，但没有提出一个整体的解决方案。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟内存技术基于已有的各种技术给出了一个完整的解决方案, 是20世纪计算机技术最重要的发明之一。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记09 内存管理</title>
    <link href="http://daisine.me/os9/"/>
    <id>http://daisine.me/os9/</id>
    <published>2018-07-03T06:17:35.000Z</published>
    <updated>2018-10-29T03:17:43.457Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内存管理介绍"><a href="#内存管理介绍" class="headerlink" title="内存管理介绍"></a>内存管理介绍</h4><ul><li>进程管理回顾 <ul><li>进程管理提供了一个虚拟的机器接口，让每一个进程都以为是自己在独占CPU，如下图所示:<br><img src="https://i.loli.net/2018/06/18/5b27ad8cd9ef4.png" width="50%" height="80%"></li></ul></li><li><p>内存管理的任务：提供一个虚拟的机器接口，让每一个进程都以为是自己在独占RAM。</p><a id="more"></a></li></ul><h4 id="基本方法-以MS-DOS为例"><a href="#基本方法-以MS-DOS为例" class="headerlink" title="基本方法 - 以MS-DOS为例"></a>基本方法 - 以MS-DOS为例</h4><ul><li>MS-DOS (Microsoft Disk Operating System)<ul><li>单用户、单任务 只能访问1MB内存：INTEL 8086/80286只有20根地址线</li><li>没有任何保护机制：INTEL 8086/80286没有提供硬件保护机制支持</li></ul></li><li>在MS-DOS中, MS-DOS自己要占用1/3左右; 剩余部分留给系统唯一的进程使用。</li><li>问题1：如果某个MS-DOS下的应用程序<strong>需要超过640K的内存才能运行</strong>,怎么办?</li><li><strong><code>覆盖</code></strong>：一种允许内存能分配的小于一个进程中所需空间的技术。<ul><li><strong>基本原理</strong>：只保留在任何给定时间需要的指令和数据。程序运行时<strong>并非任何时候都要访问程序及数据的各个部分</strong>，因此可以把用户空间分成一个固定区和若干个覆盖区。经常活跃的部分放在固定区，其余部分按调用关系分段。在覆盖区和外存(即磁盘)中屡次<strong>调入调出</strong>。除了程序本身外，程序员还要提供一个所谓的“overlay driver”来负责模块的调入调出。</li><li>无论进程在运行时占有多大的内存,在某一段时间内，它<strong>只会访问其中的一部分</strong>。</li><li><strong>打破</strong>了必须将一个进程的全部信息装入主存后才能运行的<strong>限制</strong>。</li></ul></li><li>目前覆盖技术已经<strong>很少被使用</strong>，除了在一些内存资源相当紧张的<code>嵌入式系统</code>中。</li><li><p>假设MS-DOS支持多任务,即系统中有多个进程。</p><ul><li>进程必须在内存中才能运行。</li><li>运行中的进程可能会申请额外的内存。</li></ul></li><li><p>问题2：假设系统目前有两个进程：P<sub>1</sub>和P<sub>2</sub>，而且系统已经没有内存可以使用。此时，正在运行的P<sub>1</sub>又要申请更多的内存才能继续运行，怎么办?</p></li><li><strong><code>交换</code></strong>：一个进程可以<strong>暂时</strong>从内存交换到backing-store，然后再加载到内存中<strong>继续执行</strong>。<ul><li>OS可以将(不在运行的)P<sub>2</sub>交换到backing-store中，同时释放P<sub>2</sub>所占用的内存，并分配给P<sub>1</sub>让其继续运行。</li><li>当调度器重新调度P<sub>2</sub>运行时，OS从backing-store中加载P2到内存继续运行。</li><li>此时可能要把P<sub>1</sub>交换到backing-store中以释放足够的内存空间供P<sub>2</sub>运行。<br><img src="https://i.loli.net/2018/06/18/5b27b3384a591.png" width="50%" height="80%"></li></ul></li><li><strong>Swap方法存在的限制</strong>：<ul><li>要求计算机必须有<strong>足够大的备份存储</strong>。备份存储一般是快速、大容量的硬盘。</li><li><strong>上下文切换要花费大量的时间</strong>：主要用于磁盘数据传输。调度算法的设计尤其重要，应尽量减少上下文切换。</li><li>被swap-out的进程必须被重新swap-in到<strong>相同的内存地址</strong>才能继续运行。</li></ul></li><li>这种原始的swap-in/out已经<strong>很少被使用</strong>。但是，swap的思想非常重要：当系统内存不足时，可以向备份存储“借”一部分来使用。</li></ul><h4 id="多任务系统的内存管理"><a href="#多任务系统的内存管理" class="headerlink" title="多任务系统的内存管理"></a>多任务系统的内存管理</h4><ul><li>多任务环境下会带来许多内存管理问题：<ul><li>重定位(relocation)问题</li><li>内存保护(protection)问题</li><li>内存分配(allocation)问题</li></ul></li></ul><h5 id="源程序变成进程的过程："><a href="#源程序变成进程的过程：" class="headerlink" title="源程序变成进程的过程："></a>源程序变成进程的过程：</h5><ul><li>程序员编写的<strong>源代码</strong>必须先被编译成<strong>目标文件</strong>。</li><li>然后通过<strong>链接器</strong>链接成<strong>可执行文件</strong>。</li><li>最后由操作系统<strong>加载</strong>可执行文件到内存从而<strong>形成进程</strong>。</li></ul><h5 id="重定位-amp-地址绑定概念"><a href="#重定位-amp-地址绑定概念" class="headerlink" title="重定位 &amp; 地址绑定概念"></a>重定位 &amp; 地址绑定概念</h5><ul><li>在多任务的环境中，可执行文件可能会被加载到内存中的任何位置运行。</li><li>链接器在生成可执行文件时必须确定程序中各个符号(如函数、全局变量)的地址。<ul><li>把程序中的符号映射为地址的过程叫做<strong><code>地址绑定</code></strong>。</li></ul></li><li>事实上，由于链接器无法预知程序将被加载到哪个内存位置，因此无法完成绝对的地址绑定。</li><li>因此，链接器只能假定程序中第一条指令的地址是0，从而用相对于它的<strong>偏移量</strong>来进行相对的<strong>地址绑定</strong>。</li><li>这样的程序只能被加载到0地址的内存运行。如果该程序被加载到其他非0的地址，必须对程序中所引用的地址进行修改才能运行，这个修改过程就称为<strong><code>重定位</code></strong>。</li><li>几个概念：<ul><li>逻辑地址：指<strong>程序中引用的地址</strong>，亦即CPU产生的地址。</li><li>物理地址：指系统中内存单元所看到的地址。</li><li>内存管理单元：指专门完成逻辑地址到物理地址<strong>转换</strong>的硬件单元，一般是CPU的一部分。<br><img src="https://i.loli.net/2018/06/18/5b27b73f52d0f.png" width="50%" height="80%"></li></ul></li><li>这里介绍的是最简单的重定位技术，只是冰山一角。</li><li>今天使用的操作系统(如Windows, Linux)所采用的重定位技术相当复杂，涉及到编译器、链接器、可执行文件、函数库、操作 系统内核和硬件等多个组件之间的协作才能完成。</li></ul><h5 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h5><ul><li>在多任务的环境中，必须要保护各个进程的内存不被其他进程访问或破坏。<ul><li>其实，即使在单任务的环境中也存在着操作系统如何保护自己不被应用程序访问或破坏的问题。 在MS-DOS中，应用程序可以合法地把MS-DOS的内核所占的内存全部破坏。</li></ul></li><li>对应用程序访问的每一个内存地址进行检查，看是否超出了内存范围。为了获得最好的性能，一般用<strong><code>内存管理单元</code></strong>(MMU)通过硬件来实现这种检查的功能。</li><li>内存保护是现代操作系统必备的功能之一，它需要硬件的支持才能实施保护。</li><li>后面讲解的各种内存管理方法都包含有内存保护的方法。<br><img src="https://i.loli.net/2018/06/18/5b27b98f2c33e.png" width="60%" height="80%"></li></ul><h5 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h5><ul><li>在多任务的环境中，操作系统需要为每个新创建的进程分配一定数量的内存才能运行。当进程退出时，操作系统要回收它所占用的内存。</li><li>操作系统如何有效地管理内存的分配和回收，以尽量满足进程的需求？这个问题也称为<strong><code>动态内存分配问题</code></strong>。</li><li>操作系统有一张表格，用于指出哪些内存可用和哪些内存已被占用。可用内存块称为<strong>孔</strong>。<ul><li>最初，所有内存都可用于用户进程。</li><li>当有新进程需要内存时，为该内存查找足够大的孔。</li><li>当一个进程终止时，它将释放内存，如果新的孔与其他孔相邻，这些相邻的孔合并形成一个更大的孔。<br><img src="https://i.loli.net/2018/06/18/5b27beab9738f.png" width="50%" height="80%"></li></ul></li><li>分配算法<ul><li><strong>首次适应</strong>：分配第一个足够大的孔。</li><li><strong>最佳适应</strong>：分配最小的足够大的孔。</li><li><strong>最差适应</strong>：分配最大的孔。 </li></ul></li><li>另一种方法：把系统内存分成固定大小的内存块，操作系统以块为单位进行内存的分配和释放。最终分配给进程的内存可能会比所请求要多一点，称多出来的这部分为<strong><code>内部碎片</code></strong>。</li><li>分配主要解决在多任务的环境中，操作系统采用什么算法进行内存的分配和回收，减少<strong><code>外部碎片</code></strong>或<strong>内部碎片</strong>，提高内存利用率。相对于外部碎片，内部碎片的情况不是很严重。</li><li>事实上，内存的分配和回收问题不仅出现在OS中，应用程序面临着同样的问题。<ul><li>当进程被创建时,操作系统会采用某种算法分配一块足够大的内存给进程,由进程自己管理(其中的一部分)。</li><li>eg. heap由进程自己管理。库函数new/delete(或malloc/free)就是操纵heap中的内存。它们所采用的分配与回收算法非常通用，相应的空间和时间利用率也很一般。在一个大型的项目中，已有的库函数可能不会满足应用的要求，需要自己开发更好的来替换它们以负责heap中内存的分配与回收。</li></ul></li></ul><h4 id="分页内存管理"><a href="#分页内存管理" class="headerlink" title="分页内存管理"></a>分页内存管理</h4><ul><li>基本内存管理方法存在着很大的限制：<ul><li>每个进程所占用的物理内存<strong>必须连续</strong>。</li><li>系统可能会<strong>产生大量外部碎片</strong>，最后不可避免地要进行compaction。</li><li>对<strong>整个进程</strong>进行(<strong>交换</strong>)swap-in/swap-out非常地<strong>耗时</strong>。</li></ul></li><li>分页很好地解决了上面的问题：<ul><li>进程所占用的物理内存<strong>不必连续</strong>。</li><li>没有外部碎片，但是会<strong>产生</strong>一定的<strong>内部碎片</strong>。</li><li>对进程所占用的<strong>部分内存</strong>进行swap-in/swapout。</li></ul></li><li>在早期，分页系统主要由<strong>硬件</strong>来实现。如今分页由<strong>硬件和操作系统</strong>共同完成。</li><li>基本概念：<ul><li>将物理内存分为固定大小的块，称为<strong><code>帧</code></strong>。</li><li>将逻辑内存也分为同样大小的块，称为<strong><code>页</code></strong>。</li><li><strong><code>页表</code></strong>包含每页所在物理内存的基地址，用于页到帧的映射。</li><li>页表的一个条目称为<strong><code>页表项（PTE）</code></strong>。</li></ul></li><li>把逻辑地址分成两部分: <ul><li>第一部分称为<strong><code>页号(p)</code></strong>，页号作为页表的索引。 </li><li>第二部分称为<strong><code>页偏移(d)</code></strong>。</li></ul></li><li>地址转换：在页表的帮助下，MMU把CPU产生的逻辑地址转换成物理地址。</li><li>过程如图：<br><img src="https://i.loli.net/2018/06/18/5b27c49f4dbb7.png" width="50%" height="80%"></li><li>两个例子：<br><img src="https://i.loli.net/2018/06/18/5b27c48c6758f.png" width="37%" height="80%"><br><img src="https://i.loli.net/2018/06/18/5b27c486e7c06.png" width="37%" height="80%"></li><li>页 &amp; 帧:<ul><li>它们的大小必须相同，都是2的幂次方。</li><li>具体由CPU体系结构决定，常见的有1K、4K、8K、4M等。</li></ul></li><li>地址划分<ul><li>如果逻辑地址空间的大小为2<sup>m</sup>，而page或frame的大小为2<sup>n</sup>(n &lt; m)，那么逻辑地址的划分如图所示：<br><img src="https://i.loli.net/2018/06/18/5b27c4e64d7b4.png" width="37%" height="80%"></li></ul></li></ul><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><ul><li>分页的一个重要方面是用户的内存视图和实际物理内存之间的明确分离。地址翻译硬件使这些差异得到调和。该<strong>映射对用户是隐藏的</strong>，由操作系统控制。</li><li>由于是操作系统在控制地址映射，它必须记录系统物理内存的使用状况。<ul><li>通常使用一个称为<strong><code>帧表</code></strong>的数据结构来保存系统中每一个帧的状态，如果占用，被哪个(些)进程的哪个页所占用。</li><li>为每一个进程保存一个页表，只包括进程所拥有的那些页。</li></ul></li></ul><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ul><li>页表必须被保存在内存中。CPU中的两个寄存器记录了它的信息:<ul><li>页表基寄存器(PTBR)：保存了页表的地址。</li><li>页表长度寄存器(PTLR)：保存了页表的大小。</li></ul></li><li>因此在分页中,每一个内存访问都需要两次内存操作：一次访问页表，一次访问内存数据。考虑到CPU访问内存的频率，这种<strong>地址转换成了系统性能的颈瓶</strong>。</li><li>为了提高地址转换效率，MMU中包含了一个高速缓存称为<strong><code>转换表缓冲区(TLBs)</code></strong>。</li><li>TLB条目由<strong>键和值</strong>组成，当关联内存根据定值查找时，会同时与所有键进行比较，如果找到条目，那么就得到相应的值域。<ul><li>TLB这种查找方式比较快。但由于硬件昂贵，通常TLB的条目数并不多，在64-1024之间。</li><li>A的地址转换：如果A在TLB（<strong>TLB命中</strong>）中，则将帧取出。否则，从<strong>内存中的页表获取帧。</strong><br><img src="https://i.loli.net/2018/06/18/5b27c9366d11f.png" width="47%" height="80%"></li></ul></li><li><strong>性能</strong>：假设<ul><li>TLB查找时间 = x</li><li>存储器周期时间为1微秒（10<sup>-6</sup>秒)</li><li>TLB命中率 = y，在TLB中找到页码的次数的概率百分比。</li></ul></li><li>有效访问时间 EAT = (1 + x) y + (2 + x) (1 - y) = 2 + x - y</li></ul><h5 id="内存保护-1"><a href="#内存保护-1" class="headerlink" title="内存保护"></a>内存保护</h5><ul><li>在<strong>分页系统</strong>中，<strong>内存保护是以页为单位</strong>。 <ul><li>保护信息通常都保存在PTE中， 可以提供只读、读写和执行(RWX - Read, Write, eXecute)保护。</li></ul></li><li>此外，不是所有的PTE都可以使用。因此，PTE中的一位表示该PTE是否可以使用(valid/invalid)。<ul><li>仅当该位有效时，MMU才能用它进行地址转换。 否则，MMU将通过异常向OS报告错误。<br><img src="https://i.loli.net/2018/06/20/5b29bf28312c1.png" width="50%" height="80%"></li></ul></li></ul><h5 id="页表问题"><a href="#页表问题" class="headerlink" title="页表问题"></a>页表问题</h5><ul><li>假设：<ul><li>逻辑地址空间大小：2<sup>32</sup>，即4GB。</li><li>page和frame的大小：2<sup>12</sup>，即4KB。</li><li>sizeof(PTE) = 4B。</li></ul></li><li>一个页表要消耗多少内存?<ul><li>(2<sup>32</sup> / 2 <sup>12</sup>) × 4 = 4MB</li></ul></li><li>记住：每一个进程都需要一个页表。</li><li>一个只有256MB内存的系统如何能同时运行几十个进程呢?</li></ul><h5 id="页表结构"><a href="#页表结构" class="headerlink" title="页表结构"></a>页表结构</h5><ul><li>事实上，很少的进程会使用整个地址空间(如32位机器上的4GB和64位机器上的2<sup>64</sup>B );<ul><li>页表中大部分的PTE都是处于invalid状态。 </li><li>OS无法预测一个进程的页表大小，因此只能根据进程使用内存的情况动态地伸缩。 </li><li>显然线性的页表结构太简单，不能满足这个要求，需要新的页表结构。</li></ul></li><li>现有的页表结构:<ul><li>层次型页表 Hierarchical Page Tables</li><li>哈希页表 Hashed Page Tables</li><li>反向页表 Inverted Page Tables</li></ul></li></ul><h5 id="层次型页表"><a href="#层次型页表" class="headerlink" title="层次型页表"></a>层次型页表</h5><ul><li>这种方法采用“树”结构来组织页表,形成一个层次结构的页表。<ul><li>根据这颗树的深度可以分为:一、二、三级页表等。其中，一级页表(也称为单级页表)就退化成了线性页表。</li><li>这里以32位逻辑地址、页面大小为4KB为例来讲解二级页表。</li></ul></li><li>二级页表设计：<ul><li>把一个巨大的线性页表分割成很多小的页表。</li><li>然后通过一个称为<strong><code>外页表</code></strong>(outer page table)的表把这些小页表组织起来。<br><img src="https://i.loli.net/2018/06/19/5b2895ea7742b.png" width="40%" height="80%"></li><li>采用二级页表的逻辑地址与地址转换<br><img src="https://i.loli.net/2018/06/19/5b2896f44e766.png" width="46%" height="80%"><br><img src="https://i.loli.net/2018/06/19/5b28982d23bff.png" width="35%" height="80%"></li></ul></li></ul><h4 id="帧管理"><a href="#帧管理" class="headerlink" title="帧管理"></a>帧管理</h4><ul><li>前面介绍了页面的管理，以及页面到帧的映射。但是，<strong>最终保存数据的地方是帧</strong>，而不是页面。 </li><li>操作系统需要管理系统中所有帧的分配和回收,<ul><li>当进程被创建时，操作系统要分配足够多的帧给它，并在该进程的页表中做相应的映射。</li><li>当进程退出时，操作系统回收它所占用的帧。</li></ul></li><li>最简单的方法是维护一个空闲帧链表。如图所示:<br><img src="https://i.loli.net/2018/06/19/5b2897f562b1d.png " width="47%" height="80%"></li></ul><h4 id="页面共享"><a href="#页面共享" class="headerlink" title="页面共享"></a>页面共享</h4><ul><li>在<strong>分页系统</strong>中,显然应该<strong>以页面为单位进行内存共享</strong>。<ul><li>eg. 假设系统中有三个用户同时运行某个编辑器在编辑各自的文件，显然编辑器的代码可以被共享，而各自的文件数据则是私有的。<br><img src="https://i.loli.net/2018/06/19/5b28990756fee.png" width="47%" height="80%"></li></ul></li></ul><h4 id="分段内存管理"><a href="#分段内存管理" class="headerlink" title="分段内存管理"></a>分段内存管理</h4><ul><li>为什么分段？<ul><li>通常用户<strong>不会</strong>将内存视为一个<strong>线性字节数组</strong>，有的包含指令而其它的包含数据。</li><li>用户通常愿意将内存视为一组<strong>长度不同的段的集合</strong>。分段就是支持这种</li></ul></li><li><strong><code>分段</code></strong>把进程的<strong>逻辑地址空间</strong>分成一个个<strong>大小不等</strong>的段，每一段集中了一种类型的数据，如代码，数据，栈等等。<ul><li>与分页系统一样，这些段在物理内存中也不一定是连续的</li></ul></li></ul><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><ul><li><p>逻辑地址由有序对组成：&lt;segment-number, offset&gt; (&lt;段号，段内偏移&gt;)。(为了简单，段是编号的段号而不是通过段名来引用)<br><img src="https://i.loli.net/2018/06/19/5b28ab03eefee.png" width="20%" height="80%">&lt;img src=”<a href="https://i.loli.net/2018/06/19/5b28ab0404f03.png&quot;" target="_blank" rel="noopener">https://i.loli.net/2018/06/19/5b28ab0404f03.png&quot;</a> width=40%” height=”80%” /&gt;</p></li><li><p><strong><code>段表</code></strong>用于将逻辑地址映射到物理地址。 每个表项都有</p><ul><li>段基地址：含该段在内存中开始的物理地址。</li><li>界限：指定该段的长度。<strong>段表长度不固定，页表固定。</strong></li><li>保护位(RWX)。</li></ul></li><li>段基地址寄存器(STBR)：指向段表在存储器中的位置。</li><li>段界限寄存器(STLR)：表示进程使用的段的个数。  </li><li>地址转换：<br><img src="https://i.loli.net/2018/06/19/5b28ab040db5c.png" width="45%" height="80%"></li><li>在<strong>分段系统</strong>中，<strong>内存的保护与共享以段为单位</strong></li><li>由于段的长度是根据需要变化的,因此分段会产生<strong>外部碎片</strong>。<ul><li>这个问题的严重程度与<strong>操作系统的内存分配算法</strong>和<strong>进程各个段的平均大小</strong>有关。</li></ul></li><li>由于系统无法预测各个进程使用内存的状况，<strong>外部碎片很难控制</strong>。因此，单纯的分段系统目前很少使用。</li><li>各个硬件产商也不再支持单纯的分段系统。<ul><li>INTEL 80386以前的CPU只支持分段,而80386以后(包括80386) 的CPU则增加了分页支持。</li></ul></li></ul><h4 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h4><ul><li>分页和分段系统有各自的优缺点，因此人们就考虑结合分页和分段，这就形成了段页式内存管理。</li><li>段页式内存管理的地址转换包括两个步骤：<strong>先分段，再分页。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;内存管理介绍&quot;&gt;&lt;a href=&quot;#内存管理介绍&quot; class=&quot;headerlink&quot; title=&quot;内存管理介绍&quot;&gt;&lt;/a&gt;内存管理介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;进程管理回顾 &lt;ul&gt;
&lt;li&gt;进程管理提供了一个虚拟的机器接口，让每一个进程都以为是自己在独占CPU，如下图所示:&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2018/06/18/5b27ad8cd9ef4.png&quot; width=&quot;50%&quot; height=&quot;80%&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内存管理的任务：提供一个虚拟的机器接口，让每一个进程都以为是自己在独占RAM。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记08 死锁</title>
    <link href="http://daisine.me/os8/"/>
    <id>http://daisine.me/os8/</id>
    <published>2018-07-03T06:17:31.000Z</published>
    <updated>2018-07-03T06:21:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h4><ul><li><p>如果集合中的每个进程正在等待只有集合中的另一个进程可能导致的事件，则会导致一组进程死锁。    </p><ul><li>Kansas立法机构通过的一个法律：当两列列车在十字路口逼近时，它们要完全停下来，且在一列列车开走之前，另一列列车不能启动。</li><li>只有一个方向的交通：桥的每个部分都可以被视为一个资源。如果发生死锁，则可以解决一辆车是否备份（抢占资源并回滚），可能需要“备份几辆汽车。 饥饿是可能的。</li></ul><a id="more"></a></li></ul><p>#####系统模型</p><ul><li>一个系统由有限数量的资源组成，分配给多个竞争过程。</li><li>资源被分成几种类型：资源类型R<sub>1</sub>，R<sub>2</sub>，…，R<sub>m</sub>，例如CPU周期，内存空间和 I/O 设备。</li><li>每个资源类型R<sub>i</sub>都有W<sub>i</sub>实例操作来使用资源<ol><li><strong>申请</strong>：如果不能立即授予请求，则请求进程必须等待直到它获得该资源为止。</li><li><strong>使用</strong>：进程正在使用该资源。</li><li><strong>释放</strong>：进程释放资源。</li></ol></li></ul><h4 id="死锁特征"><a href="#死锁特征" class="headerlink" title="死锁特征"></a>死锁特征</h4><ul><li>如果以下4个条件同时满足，则会出现死锁：<ol><li>互斥：至少有一个资源必须处于非共享模式，即一次只有一个进程可以使用该资源。 </li><li>占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其它资源所占有。</li><li>非抢占：资源不能抢占，即资源只能在进程完成任务后自动释放。</li><li>循环等待：有一组等待进程{P<sub>0</sub>，P<sub>1</sub>，… ，P<sub>n</sub>}，P<sub>0</sub>等待的资源由P<sub>1</sub>占有，P<sub>1</sub>等待的资源由P<sub>2</sub>占有，… ，P<sub>n-1</sub>等待的资源由P<sub>n</sub>占有，并且P<sub>n</sub>等待的资源由P<sub>0</sub>占有。</li></ol></li></ul><blockquote><p>所有4个条件必须同时满足才会出现死锁。循环等待条件意味着占有并等待条件，这样的4个条件并不完全独立。</p></blockquote><h4 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h4><ul><li>死锁问题可用称为<strong>系统资源分配图</strong>的有向图进行更精确地描述。</li><li>该图由一组顶点集合V和一组边集合E组成。</li><li>V被分成两种类型：<ul><li>P = {P<sub>0</sub>，P<sub>1</sub>，…，P<sub>n</sub>}，系统中的所有进程的集合。</li><li>R = {R<sub>0</sub>，R<sub>1</sub>，…，R<sub>m</sub>}，系统中所有资源类型的集合。</li></ul></li><li>申请边：P<sub>i</sub> → R<sub>j</sub></li><li>分配边：R<sub>j</sub> → P<sub>i</sub><br><img src="https://i.loli.net/2018/06/18/5b27ab5721290.png" width="25%" height="80%"><br><img src="https://i.loli.net/2018/06/18/5b27ab5ac25d8.png" width="33%" height="80%"></li><li>如果资源分配图不包含环，则系统中的<strong>任何进程都不会</strong>死锁;</li><li>如果资源分配图包含环，则<strong>可能存在</strong>死锁。</li></ul><h4 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h4><ul><li>可以设计一个协议来预防或避免死锁，确保系统永远不会进入死锁状态。</li><li>可以允许系统进入死锁状态，检测并从中恢复。</li><li>可以完全忽略这个问题，并假设系统中永远不会发生死锁。(鸵鸟算法)<ul><li>大多数操作系统都使用该解决方案，包括Windows和Unix。</li><li>由于死锁<strong>很少发生</strong>，并且死锁预防、死锁避免或死锁检测和恢复<strong>算法成本很高</strong>。</li><li>这是便利性和正确性之间的权衡。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;死锁问题&quot;&gt;&lt;a href=&quot;#死锁问题&quot; class=&quot;headerlink&quot; title=&quot;死锁问题&quot;&gt;&lt;/a&gt;死锁问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果集合中的每个进程正在等待只有集合中的另一个进程可能导致的事件，则会导致一组进程死锁。    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kansas立法机构通过的一个法律：当两列列车在十字路口逼近时，它们要完全停下来，且在一列列车开走之前，另一列列车不能启动。&lt;/li&gt;
&lt;li&gt;只有一个方向的交通：桥的每个部分都可以被视为一个资源。如果发生死锁，则可以解决一辆车是否备份（抢占资源并回滚），可能需要“备份几辆汽车。 饥饿是可能的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记07 进程同步</title>
    <link href="http://daisine.me/os7/"/>
    <id>http://daisine.me/os7/</id>
    <published>2018-07-03T06:17:28.000Z</published>
    <updated>2018-07-03T06:21:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul><li>协作进程可以通过内核提供的IPC工具共享一块内存。一个进程中的多个线程可以通过使用全局变量来共享一段内存。</li><li>共享数据的并发访问可能会导致数据不一致。 保持数据一致性需要机制来确保协作进程的有序执行。</li><li><p>对生产者和消费者问题的解决方案：允许同时在缓冲区内最多只有（BSIZE - 1）项。</p><a id="more"></a></li><li><p>假设我们通过添加一个变量计数器来修改代码。<br><img src="https://i.loli.net/2018/06/18/5b275da7bfa0f.png" width="40%" height="80%"><img src="https://i.loli.net/2018/06/18/5b275daa58ac3.png" width="45%" height="80%"></p></li><li>需要注意的是，可能由于这两个进程并发操作变量counter，而得到不正确的运行结果。</li><li><strong><code>竞争条件</code></strong>：多个进程并发地访问和操作同一数据且执行结果与访问发生的特定顺序有关。<ul><li>为避免竞争条件，需要保证一段时间内只有一个进程能够操作变量。</li><li>为了实现这种保证，要求进行一定形式的<strong><code>进程同步</code></strong>。</li></ul></li></ul><h4 id="临界区问题"><a href="#临界区问题" class="headerlink" title="临界区问题"></a>临界区问题</h4><ul><li><strong><code>临界区</code></strong>：一段访问共享资源的代码。</li><li>竞态条件的解决方案必须满足以下4个要求：<ol><li>相互排斥：任何两个进程不能同时处于临界区。</li><li>前进：临界区外运行的进程不能阻塞其他进程尝试进入其临界区，以确定谁能下一个进入临界区。且这种选择不能无限推迟。</li><li>有限等待：没有任何一个进程需要无限期等待进入其临界区。</li><li>速度：不应该对CPU的速度和数量做任何假设。 </li></ol></li><li>临界区问题：设计一个以便进程协作的协议。<ul><li>每个进程必须请求允许进入其临界区。实现这一请求的代码段称为<strong>进入区</strong>。</li><li>临界区之后可有<strong>退出区</strong>。其余代码为<strong>剩余区</strong>。 </li></ul></li></ul><h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p><img src="https://i.loli.net/2018/06/18/5b2765a247934.png" width="45%" height="80%"></p><blockquote><p>First &amp; Second try都不满足“前进”这个要求。Third try即为Peterson算法，满足四个要求。</p></blockquote><h4 id="硬件同步"><a href="#硬件同步" class="headerlink" title="硬件同步"></a>硬件同步</h4><ul><li>可以使用简单的硬件指令来解决竞争条件。</li></ul><ol><li>单处理器环境(通常为非抢占内核所用)：<strong>禁用中断</strong></li><li>多处理器环境：<strong>特殊指令</strong> ①TSL（Test and Set Lock）②SWAP</li></ol><h5 id="禁用中断"><a href="#禁用中断" class="headerlink" title="禁用中断"></a>禁用中断</h5><ul><li>禁止中断，就能确保当前指令序列的执行不会被中断。由于其它指令不可能执行，共享变量不会被意外修改。</li><li>进程就可以访问共享内存而不用担心受到任何其他进程干预。</li><li>缺点<ol><li>用户进程不应该禁用中断。</li><li>在多处理器系统中不可行。</li></ol></li></ul><h5 id="TSL-and-SWAP"><a href="#TSL-and-SWAP" class="headerlink" title="TSL and SWAP"></a>TSL and SWAP</h5><ul><li>TSL和SWAP指令分别具有以下功能：<br><img src="https://i.loli.net/2018/06/18/5b276be04718e.png" width="75%" height="80%"></li><li>TSL和SWAP是以<strong>原子方式</strong>执行的，即作为一个<strong>不间断单元</strong>执行。</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>上述解决方案有一个共同缺点：<strong>繁忙等待</strong>。 <ul><li>当进程处于临界区时，其他进程尝试进入临界区必须在进入区代码中循环。 </li><li>繁忙等待浪费了一些其他进程可能可以有效使用的CPU周期。</li></ul></li><li>这种类型的解决方案也被称为<strong>自旋锁</strong>。<ul><li>因为该过程在等待锁的过程时定时“旋转”，一直在循环抢锁。 </li><li>自旋锁<strong>仅在多处理器系统中</strong>有用。可以避免一次上下文切换。</li></ul></li></ul><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul><li>上一节描述的基于硬件的临界区问题的解决方案并不容易推广到更复杂的问题。为了克服这个困难，我们可以使用一个名为semaphore的同步工具。它由Edsger Dijkstra发明并首次在THE操作系统中使用。</li><li><strong><code>信号量S</code></strong>是个整数变量，<strong>除初始化之外</strong>，只能通过两个标准的<strong>原子操作</strong>来访问：P(down) 和V(up）。<br><img src="https://i.loli.net/2018/06/18/5b276ff356715.png" width="65%" height="80%"></li><li>“value”的大小是<strong>可用资源(&gt;0)的数量</strong>或<strong>等待信号量(&lt;0)的进程的数量</strong>。</li><li>P 和 V 必须以原子方式执行。<ul><li>有两种方法：①禁用单处理器系统或中断 ②多处理器系统中的自旋锁。</li></ul></li></ul><h5 id="二进制信号量"><a href="#二进制信号量" class="headerlink" title="二进制信号量"></a>二进制信号量</h5><ul><li>上述的信号量构造通常被称为计数信号量。因为它的值可以覆盖不受限制的域。</li><li>二进制信号量是一个整数值范围只在0和1之间的信号量。<ul><li>在某些硬件体系结构上实现比计数信号量更简单。计数信号可以使用二进制信号量来实现。<br><img src="https://i.loli.net/2018/06/18/5b277a3576f4b.png" width="80%" height="80%"><br><img src="https://i.loli.net/2018/06/18/5b277a3524a9e.png" width="80%" height="80%"></li></ul></li></ul><h5 id="死锁与饥饿"><a href="#死锁与饥饿" class="headerlink" title="死锁与饥饿"></a>死锁与饥饿</h5><ul><li>虽然信号量为进程同步提供了一种方便有效的机制，但它们的不正确使用仍然会导致难以检测到的错误。<ul><li>eg. 假设生产者循环中的两个P操作按顺序颠倒过来。</li></ul></li><li>集合中的每个进程正在等待只有集合中的另一个进程可能导致的事件，则会导致一组进程<strong>死锁</strong>。</li><li>与死锁有关的另一个问题：饥饿/不确定阻塞，即进程在信号量内无限期地等待。<ul><li>例如，解决<code>读者-作者问题</code>的方法可能会导致饥饿。</li><li>通过使用FCFS调度策略可以避免饥饿。</li></ul></li></ul><h4 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h4><ul><li>生产者-消费者问题</li><li>读者-作者的问题<ul><li>一个数据库可以为多个并发进程所共享。</li><li>读者可能只需要读取数据库，写者可能需要更新数据库(即读和写)。</li><li>多个读者可以同时访问共享数据，写者对共享数据有<strong>排他的访问</strong>。</li></ul></li><li>哲学家进餐问题</li></ul><h5 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h5><ul><li>访问缓冲区时使用信号量互斥锁来保护临界区，初始化为值1。</li><li>empty被初始化为值BSIZE(缓冲项个数)，full被初始化为0。生产者为消费者生产满缓冲项，消费者为生产者生产空缓冲项。<br><img src="https://i.loli.net/2018/06/18/5b2774f9a0ad0.png" width="65%" height="80%"></li></ul><h5 id="读者-作者的问题"><a href="#读者-作者的问题" class="headerlink" title="读者-作者的问题"></a>读者-作者的问题</h5><ul><li>信号量<code>wrt</code>用于保护共享数据对象，初始化为值1。</li><li>变量readcount用来跟踪多少进程正在读对象，初始化为0。</li><li>另一个信号量mutex用于确保在更新变量readcount时的互斥，初始化为1。<br><img src="https://i.loli.net/2018/06/18/5b2774a70cbcf.png" width="65%" height="80%"></li></ul><h5 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h5><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><ul><li>管程：是一组方法、变量、函数..的集合。</li><li>管程结构确保了<strong>只有一个进程可以在管程中处于活动状态</strong>。在实现互斥方面很有用。<br><img src="https://i.loli.net/2018/06/18/5b278148f0f3e.png" width="40%" height="80%"><img src="https://i.loli.net/2018/06/18/5b278156992a9.png" width="48%" height="80%"><br><img src="https://i.loli.net/2018/06/18/5b2784cd6bc52.png" width="35%" height="80%"></li></ul><h5 id="带条件变量的管程"><a href="#带条件变量的管程" class="headerlink" title="带条件变量的管程"></a>带条件变量的管程</h5><ul><li>管程内部可定义condition类型的变量以提供同步机制，称其为<strong><code>条件变量</code></strong>。条件型变量c实际上是一个指针，它指向一个等待该条件的PCB队列。</li><li>它只与两个操作相关联：<ul><li>c.wait()：意味着调用它的进程会被挂起，直到另一个进程调用</li><li>c.signal()：重新启动一个悬挂的进程。</li><li>请注意，如果没有进程挂起，那么signal()没有任何影响。</li></ul></li><li>管程模式下的 x.signal() 和信号量的 signal() 区别在于： <ul><li>信号量操作 signal() 会影响信号量的状态</li><li>管程下的 c.signal() 在 c 不存在挂起进程的情况下没有任何影响。</li></ul></li></ul><h5 id="c-signal（）之后会发生什么？"><a href="#c-signal（）之后会发生什么？" class="headerlink" title="c.signal（）之后会发生什么？"></a>c.signal（）之后会发生什么？</h5><ul><li>假设一个进程P调用c.signal（），另一个进程Q被条件变量c阻塞。</li><li>P完成c.signal（）后，可能P和Q在监视器内同时处于活动状态。</li><li>这将打破显示器的属性！ 存在三种可能性：<ul><li>Hoare风格：暂停P并让Q运行。 </li><li>Brinch-Hansen风格：P必须立即离开显示器。 </li><li>Mesa风格（Mesa是一种编程语言）：让P运行并暂停Q.</li></ul></li></ul><h5 id="语言支持"><a href="#语言支持" class="headerlink" title="语言支持"></a>语言支持</h5><ul><li>管程结构需要编程语言支持才有用。也就是说，编译器必须识别管程结构并生成代码以支持其功能。</li><li>示例：Java（仅包含一个条件变量的Mesa样式监视器）<ul><li>通过将关键字synchronized添加到方法声明中，Java保证一旦任何线程开始执行该方法，就不允许其他线程开始执行该类中的任何其他同步方法。</li><li>Java提供了两种操作：等待并通知阻塞线程，唤醒线程。</li></ul></li></ul><h4 id="信号量与管程的关系"><a href="#信号量与管程的关系" class="headerlink" title="信号量与管程的关系"></a>信号量与管程的关系</h4><ul><li>信号量和管程在功能上是等效的。</li><li>但是它们的使用和实现是非常不同的。<br><img src="https://i.loli.net/2018/06/18/5b2785f39478e.png" width="35%" height="80%"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;协作进程可以通过内核提供的IPC工具共享一块内存。一个进程中的多个线程可以通过使用全局变量来共享一段内存。&lt;/li&gt;
&lt;li&gt;共享数据的并发访问可能会导致数据不一致。 保持数据一致性需要机制来确保协作进程的有序执行。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对生产者和消费者问题的解决方案：允许同时在缓冲区内最多只有（BSIZE - 1）项。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记06 CPU调度</title>
    <link href="http://daisine.me/os6/"/>
    <id>http://daisine.me/os6/</id>
    <published>2018-07-03T06:16:50.000Z</published>
    <updated>2018-07-03T06:21:33.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>CPU调度是多道程序操作系统的基础。通过在进程之间切换CPU，操作系统可以提高计算机的<strong>吞吐率</strong>。</li><li>在内核级支持线程的操作系统中，是线程被操作系统调度，而不是进程。</li><li><p>调度是操作系统的基本功能。 几乎所有的计算机资源在使用前都要调度。 CPU调度对操作系统设计来说很重要。</p><a id="more"></a></li></ul><h5 id="CPU-I-O-区间周期"><a href="#CPU-I-O-区间周期" class="headerlink" title="CPU- I/O 区间周期"></a>CPU- I/O 区间周期</h5><ul><li>CPU的成功调度依赖于进程的如下属性：<ul><li>进程执行由<strong>CPU执行</strong>和 <strong>I/O 等待周期</strong>组成</li><li>进程在这两个状态之间切换。</li><li>由CPU区间开始- I/O 区间 -..-最后的CPU区间通过系统请求终止执行。</li></ul></li><li>CPU区间时间曲线图：通常为指数/超指数形式，具有大量短CPU区间和少量长CPU区间。<br><img src="https://i.loli.net/2018/06/18/5b274fd5857b6.png" width="35%" height="80%"><br><img src="https://i.loli.net/2018/06/18/5b2750265b65e.png" width="55%" height="80%"> </li></ul><h5 id="CPU调度程序"><a href="#CPU调度程序" class="headerlink" title="CPU调度程序"></a>CPU调度程序</h5><ul><li>每当CPU空闲时，操作系统就必须从就绪队列中选择一个进程来执行。晋城选择由<strong>短期调度程序</strong>或CPU调度程序来执行。</li><li>CPU调度决策可在如下4种情况下发生：<ol><li>当一个进程从运行切换到等待状态。</li><li>当一个进程从运行状态切换到就绪状态。</li><li>当一个进程从等待切换到就绪状态。</li><li>当一个进程终止。</li></ol></li><li>当调度只能发生1和4两种情况下，称调度方案是<strong>非抢占的/协作</strong>的，否则，称调度方案是<strong>抢占的</strong>。</li><li>抢占调度：对访问共享数据是有代价的，对操作系统内核的设计也有影响。</li></ul><h4 id="调度标准"><a href="#调度标准" class="headerlink" title="调度标准"></a>调度标准</h4><ul><li>CPU使用率：使CPU尽可能忙。</li><li>吞吐量：一个时间单元内所完成的进程的数量。</li><li>周转时间：从进程提交到进程完成的时间段。</li><li>等待时间：进程在就绪队列中等待的时间量。</li><li>响应时间：从提交请求到产生第一个响应所花费的时间量。</li></ul><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><h5 id="先到先服调度-FCFS"><a href="#先到先服调度-FCFS" class="headerlink" title="先到先服调度(FCFS)"></a>先到先服调度(FCFS)</h5><ul><li>先请求CPU的进程先分配CPU</li><li>非抢占：一旦CPU被分配给了一个进程，该进程就会保持CPU直到释放CPU位置。  </li><li>1 - 2 - 3进程等待时间: P1 = 0; P2 = 24; P3 = 27; 平均等待时间: (0 + 24 + 27) / 3 = 17 </li><li>2 - 3 - 1进程等待时间: P1 = 6; P2 = 0; P3 = 3; 平均等待时间: (6 + 0 + 3) / 3 = 3<br><img src="https://i.loli.net/2018/06/18/5b27443f91882.png" width="35%" height="80%"><br><img src="https://i.loli.net/2018/06/18/5b274417bceb8.png" width="49%" height="80%"><br><img src="https://i.loli.net/2018/06/18/5b274425dba0b.png" width="49%" height="80%"></li></ul><h5 id="最短作业优先调度-SJF"><a href="#最短作业优先调度-SJF" class="headerlink" title="最短作业优先调度(SJF)"></a>最短作业优先调度(SJF)</h5><ul><li>将每个进程与其下一个CPU区间段相关联。当CPU为空闲时，它会赋给具有最短CPU区间的进程。</li><li>SJF调度算法可证明为最佳，对给定的一组进程，平均等待时间最短。</li><li>具有理论价值，无法实现，因为没有办法知道下一个CPU区间的长度。</li><li>两种方案：<ul><li>非抢占：一旦CPU给予该进程，它就不可能被抢占。eg. 平均等待时间: (0 + 6 + 3 + 7)/4 = 4.</li><li>抢占：如果一个到达的新的进程CPU区间长度小于当前执行进程的剩余时间，则抢占。也被称为最短剩余时间优先（SRTF）调度。eg. 平均等待时间: (9 + 1 + 0 + 2)/4 = 3.   </li></ul></li></ul><p><img src="https://i.loli.net/2018/06/18/5b2750dbb6036.png" width="25%" height="80%">   <img src="https://i.loli.net/2018/06/18/5b2750cd7f5a5.png" width="35%" height="80%"><img src="https://i.loli.net/2018/06/18/5b2750d34e6ca.png" width="35%" height="80%"></p><h5 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h5><ul><li>每一个进程都有一个优先级与其关联。具有最高优先级的进程会分配到CPU。</li><li>优先级通常为固定区间的数字。此处用小数字表示高优先级。</li><li>SJF算法是优先级调度的一个特例，其优先级为下一个CPU区间的倒数。CPU区间越大，优先级越小。</li><li>优先级调度可以是抢占或非抢占的<br><img src="https://i.loli.net/2018/06/18/5b2754621eca0.png" width="35%" height="80%"><img src="https://i.loli.net/2018/06/18/5b27545d3e4a1.png" width="50%" height="80%"></li><li>存在的问题<ol><li>饥饿/无穷阻塞：低优先级进程可能永远不会执行。</li><li>优先级反转：高优先级进程需要访问资源，被另一个优先级较低的进程持有，该低优先级进程不运行则不释放资源。</li></ol></li><li>解决办法<ul><li>老化：逐渐增加在系统中等待很长时间的进程的优先级。</li></ul></li></ul><h5 id="轮转法调度-RR"><a href="#轮转法调度-RR" class="headerlink" title="轮转法调度(RR)"></a>轮转法调度(RR)</h5><ul><li>轮转法调度算法专门为分时系统设计。类似FCFS调度，但增加了抢占以切换进程。</li><li>定义一个较小时间单元，称为<strong>时间片</strong>，通常为10-100ms。</li><li>将就绪队列作为循环队列。CPU调度程序循环就绪队列，为每个进程分配不超过一个时间片的CPU。<ol><li>进程只需要小于时间片的CPU区间，释放CPU，继续就绪队列的下一个进程。</li><li>进程的CPU区间比时间片长，经过这段时间片的CPU区间，进程被抢占并加入到就绪队列的末尾。</li></ol></li><li>如果在就绪队列中有n个进程并且时间量为q，那么每个进程会得到 1 / n 的CPU时间，其长度不超过q时间单元。每个进程必须等到的CPU时间不超过 ( n - 1 ) q 个时间单元，直到它的下一个时间片为止。</li><li>性能很大程度上依赖于时间片的大小<ul><li>时间片非常大 ➡ FCFS</li><li>时间片很小 ➡ 时间片要比上下文切换时间长，否则开销太高。</li></ul></li></ul><h5 id="多级队列调度"><a href="#多级队列调度" class="headerlink" title="多级队列调度"></a>多级队列调度</h5><ul><li>就绪队列被分成多个独立队列。</li><li>根据进程的属性，如内存大小、进程优先级、进程类型etc，一个进程被永久地分配到一个队列。</li><li>每个队列有自己的调度算法<ul><li>eg. 前台队列（用于交互式进程）使用RR算法调度，后台队列（用于批处理）使用FCFS算法调度。<br><img src="https://i.loli.net/2018/06/18/5b275848a05ce.png" width="40%" height="80%"></li></ul></li></ul><h5 id="多级反馈队列调度"><a href="#多级反馈队列调度" class="headerlink" title="多级反馈队列调度"></a>多级反馈队列调度</h5><ul><li>一个进程可以在各个队列之间移动。<ul><li>eg. 如果进程使用过多CPU时间，那么它就被转移到更低优先级队列。<br><img src="https://i.loli.net/2018/06/18/5b2758db6dfa5.png" width="40%" height="80%"></li></ul></li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>在实践中正确实施比在原则上正确实施要困难得多。因此，调度程序很少做出最佳选择。</li><li>解决方案：<strong>调度策略和调度机制的分离</strong>。也就是说，调度算法以某种方式被参数化，但参数可以由用户填写。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;CPU调度是多道程序操作系统的基础。通过在进程之间切换CPU，操作系统可以提高计算机的&lt;strong&gt;吞吐率&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在内核级支持线程的操作系统中，是线程被操作系统调度，而不是进程。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调度是操作系统的基本功能。 几乎所有的计算机资源在使用前都要调度。 CPU调度对操作系统设计来说很重要。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记05 线程管理</title>
    <link href="http://daisine.me/os5/"/>
    <id>http://daisine.me/os5/</id>
    <published>2018-07-03T06:16:07.000Z</published>
    <updated>2018-07-03T06:21:43.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><ul><li>传统意义上，一个进程只有一个控制线程。<strong>在这种情况下</strong>进程是<strong>①资源分配单位和②调度单位</strong>。</li><li>将上述两个概念分开并允许单个进程包括多个控制线程，得到线程。也就是说，进程用于将资源组合在一起，线程是派发（调度）在CPU上执行的实体。</li><li><p>线程是现代操作系统中CPU使用的基本单位。也称为轻量级过程（LWP）。</p><a id="more"></a></li><li><p>多线程</p><ul><li>在同一个进程中允许多个线程。</li><li>进程是<strong>资源分配的单位</strong>，线程是<strong>调度的单位</strong>。</li><li><strong>共享</strong>属于同一进程的资源，例如是<strong>代码段，数据段，打开的文件</strong>和信号等。</li><li>一个进程中的每个线程都有一个<strong>私有线程上下文</strong>（包括<strong>CPU寄存器集</strong>和<strong>其他状态信息：?函数参数，变量，返回地址etc</strong>）和一个<strong>私有堆栈</strong>。<br><img src="https://i.loli.net/2018/06/18/5b2736316b722.png" width="75%" height="80%"></li></ul></li><li>进程：①地址空间 ②全局变量 ③打开的文件 ④子进程 ⑤未决(pending)警报 ⑥信号和信号处理程序 ⑦计数信息</li><li>线程：①程序计数器 ②寄存器 ③堆 ④状态</li></ul><h4 id="多线程编程优点"><a href="#多线程编程优点" class="headerlink" title="多线程编程优点"></a>多线程编程优点</h4><ul><li><strong>响应度高</strong>：即使一个或多个线程被阻塞或正在执行冗长的操作，允许其他线程继续响应用户。</li><li><strong>资源共享</strong>：由于同一进程内的线程共享内存和资源，它们可以在不调用内核的情况下相互通信。它能允许一个应用进程在同一地址空间有多个不同的活动进程。</li><li><strong>经济</strong>：创建一个新线程比一个进程花费的时间和资源要少得多。在同一个进程中，线程比上下文切换花费的时间更少。</li><li><strong>多处理器体系结构的利用</strong>：通过为每个CPU分配一个线程可以实现并行，在多CPU上使用多线程加强了并发功能。</li></ul><h4 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h4><ul><li>多线程实现的地方：<strong>不一定在内核实现</strong><ul><li>用户线程：在用户空间实现。</li><li>内核线程：在内核实现。</li><li>通过组合用户线程和内核线程的混合方案。</li></ul></li></ul><h5 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h5><ul><li>它在内核之外用户空间的<strong>线程库</strong>实现。<ul><li>线程库是为线程创建，调度和管理提供支持的库。</li><li>就内核而言，它正在管理普通的单线程进程。</li></ul></li><li>eg. ①Mach C-threads ②Solaris 2 UI-threads</li><li>优点<ul><li>线程管理和上下文切换不需要陷入内核。这将节省大量的CPU周期。</li><li>允许每个进程拥有自己的自定义调度算法。</li></ul></li><li>缺点<ul><li>执行阻塞系统调用的任何用户级线程都将导致整个进程阻塞。即使其他线程已准备好在进程中运行。</li><li>在多处理器的系统上，不能调度用户级线程并行执行。</li></ul></li></ul><h5 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h5><ul><li>由操作系统直接支持。内核在内核空间执行线程创建，调度和管理。</li><li>eg. ①Windows NT / XP ②Solaris</li><li>优点和缺点：和用户线程的相反。</li></ul><h4 id="多线程应用程序编程接口"><a href="#多线程应用程序编程接口" class="headerlink" title="多线程应用程序编程接口"></a>多线程应用程序编程接口</h4><ul><li>Pthreads<ul><li>Pthreads是指为线程创建和同步定义API的POSIX标准（IEEE 1003.1c）。</li><li>这是线程行为的规范，而不是实现。 </li></ul></li><li>Win32<ul><li>CreateThread，ExitThread和TerminateThread等。</li><li>POSIX Threads for Win32 （<a href="http://sources.redhat.com/pthreads-win32）" target="_blank" rel="noopener">http://sources.redhat.com/pthreads-win32）</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与线程&quot;&gt;&lt;/a&gt;进程与线程&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;传统意义上，一个进程只有一个控制线程。&lt;strong&gt;在这种情况下&lt;/strong&gt;进程是&lt;strong&gt;①资源分配单位和②调度单位&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;将上述两个概念分开并允许单个进程包括多个控制线程，得到线程。也就是说，进程用于将资源组合在一起，线程是派发（调度）在CPU上执行的实体。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;线程是现代操作系统中CPU使用的基本单位。也称为轻量级过程（LWP）。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记04 进程管理</title>
    <link href="http://daisine.me/os4/"/>
    <id>http://daisine.me/os4/</id>
    <published>2018-07-03T06:15:26.000Z</published>
    <updated>2018-07-03T06:21:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h4><ul><li>流程批处理系统出现之前：工作</li><li>多程序或分时：程序或任务</li><li><p>进程：正在运行的作业/程序/任务的抽象</p></li><li><p><strong><code>进程</code></strong>是执行中的程序，形成所有计算机的基础。</p><a id="more"></a></li><li><p>一个过程不仅仅是一个程序。它包括</p><ul><li><strong>文本段</strong>：可执行的机器代码    /程序代码</li><li><strong>数据段</strong>：包括全局变量</li><li>当前活动：通过程序计数器的值和处理器寄存器的内容表示</li><li><strong>堆栈段</strong>：包含临时数据，如函数参数，返回地址和局部变量 </li><li>(如果需要的话)<strong>堆</strong>：进程运行期间动态地分配内存</li><li>许多其他资源，如打开的文件等<br><img src="https://i.loli.net/2018/06/17/5b260aa24cf1d.png" width="50%" height="80%"></li></ul></li><li>程序只是被动实体，如存储在磁盘上包含一系列指令的文件内容(可执行文件)</li><li>进程时活动实体，它有一个程序计数器用来表示一个要执行的命令和相关资源的合集。</li><li>多个进程可能运行同一程序。尽管它们共享相同的文本段，但它们被当作两个独立的执行程序，数据段、堆、堆栈段不同。</li></ul><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><ul><li>当一个进程执行时，它会改变状态。过程的状态由其当前活动定义。</li><li>每个进程可能处于以下状态之一：<ul><li>新建：进程正在被创建。</li><li>运行：指令正在被执行。</li><li>等待：进程正在等待某个事件发生(如 I/O 完成或收到信号)。</li><li>就绪：进程等待分配处理器。</li><li>终止：进程完成执行。</li></ul></li><li>随着进程的运行，它将从当前状态转换到另一个状态。这五个状态中有六个过渡。<br><img src="https://i.loli.net/2018/06/17/5b26104f11cf7.png" width="80%" height="80%"></li></ul><h4 id="进程块"><a href="#进程块" class="headerlink" title="进程块"></a>进程块</h4><ul><li>每个进程在操作系统中由过程控制块（PCB）表示，也称为任务控制块。<ol><li>进程号是进程的唯一标识符，也称为PID。</li><li>程序计数器（PC）：是寄存器之一。</li><li>CPU调度信息：包括<strong>进程的优先级</strong>、调度队列的指针和其它调度参数。<br><img src="https://i.loli.net/2018/06/17/5b2610656be5b.png" width="30%" height="80%"></li></ol></li></ul><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>当运行进程因某种原因无法继续时，操作系统必须决定下一个要运行的进程。<strong>进程调度</strong>选择一个可用的进程到CPU上执行。</p><h5 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h5><ul><li>上下文切换：将 CPU 转向另一个进程需要保存当前进程的状态，并载入为新进程存储的状态。</li><li>是额外的开销。操作系统越复杂，上下文切换需要做的工作越多。</li><li>上下文切换时间与硬件支持有密切相关。根据处理器的不同。</li><li>上下文切换是一个性能瓶颈，程序员正在使用新的结构来尽可能地避免它。</li></ul><h5 id="调度队列"><a href="#调度队列" class="headerlink" title="调度队列"></a>调度队列</h5><ul><li>作业队列：由系统中的所有进程组成;</li><li>就绪队列：由等待CPU执行的进程组成;<br>-操作系统也有其他队列。<ul><li>I/O 设备队列：由等待特定 I/O设备的进程组成。<br><img src="https://i.loli.net/2018/06/17/5b2613f4c3e27.png" width="75%" height="80%"><br><img src="https://i.loli.net/2018/06/17/5b2614aca2536.png" width="75%" height="80%"></li></ul></li></ul><h5 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h5><p>调度程序从就绪队列中选择一个进程并为其分配CPU。我们称这个调度程序为CPU调度程序。</p><h4 id="合作进程"><a href="#合作进程" class="headerlink" title="合作进程"></a>合作进程</h4><ul><li>如果一个进程不会影响系统中其它的进程，而且也不被其它进程影响，那么它是一个独立进程。不与其它进程共享数据(临时的或长久的)的进程是独立进程。</li><li>如果一个进程会影响系统中其它的进程而且也被影响，那么它是一个协作进程。与其它进程共享数据的进程是协作进程。</li><li>进程协作的优点<ul><li><strong>信息共享</strong>：多个进程可能需要同一条信息。</li><li><strong>计算加速</strong>：将问题分解成几个可以并行运行的子任务;</li><li><strong>模块化</strong>：通过设计将不同功能分散到进程中。</li></ul></li><li>但是，协作进程的并发执行需要<strong>允许进程彼此通信</strong>并使其<strong>动作同步</strong>的机制。</li></ul><h5 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h5><ul><li>这是协作进程的通用范例。</li><li>生产者进程产生信息以供消费者进程消费。必须要又一个缓冲来被生产者填充并被消费者所使用。<ul><li><strong>无限缓冲</strong>：对缓冲大小没有限制。消费者可能不得不等待新项，但生产者总可以产生新项。</li><li><strong>有限缓冲</strong>：缓冲大小固定。如果缓冲为空，消费者必须等待；如果缓冲为满，生寒症必须等待。</li></ul></li><li>操作系统可以通过使用进程间通信（IPC）工具来提供缓冲区。<strong>程序员</strong>只是使用系统调用来填充或清空缓冲区。</li><li>缓冲区也可以位于生产者和消费者可以访问的<strong>共享存储器</strong>中。在这种情况下，<strong>程序员</strong>必须自己管理共享缓冲区。</li></ul><h4 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信(IPC)"></a>进程间通信(IPC)</h4><ul><li>在消费者-生产者问题中，缓冲区可以由操作系统提供。操作系统必须同步消费者和生产者对缓冲区的访问。</li><li>进程间通信(<strong>IPC</strong>)提供了一种机制，允许进程进行通信，并在非共享相同地址空间的情况下同步他们的动作。</li><li>eg.<strong>①Message-passing, ②pipe, ③socket, etc.</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;进程概念&quot;&gt;&lt;a href=&quot;#进程概念&quot; class=&quot;headerlink&quot; title=&quot;进程概念&quot;&gt;&lt;/a&gt;进程概念&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;流程批处理系统出现之前：工作&lt;/li&gt;
&lt;li&gt;多程序或分时：程序或任务&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进程：正在运行的作业/程序/任务的抽象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;进程&lt;/code&gt;&lt;/strong&gt;是执行中的程序，形成所有计算机的基础。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记03 操作系统结构</title>
    <link href="http://daisine.me/os3/"/>
    <id>http://daisine.me/os3/</id>
    <published>2018-07-03T06:14:39.000Z</published>
    <updated>2018-07-03T06:22:02.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>一个像现代操作系统一样庞大而复杂的系统必须仔细设计，才能正常运行并易于修改。</li><li>一种常用的方法是将任务分成小部件，而不是一个单一的系统。</li><li>这些组件中的每一个都应该是系统的一个明确定义的部分，具有详细定义的<strong>输入，输出和功能</strong>。</li><li><p>系统设计人员如何组织这些组件？</p><ul><li>简单结构（或没有结构）</li><li>分层结构</li><li>微内核</li><li>虚拟机</li></ul><a id="more"></a></li></ul><h4 id="简单结构"><a href="#简单结构" class="headerlink" title="简单结构"></a>简单结构</h4><ul><li>许多系统没有明确的结构。</li><li>他们从小、简单和有限的系统开始，然后演变成复杂的系统。</li><li>eg. MS-DOS和Unix</li></ul><h4 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h4><ul><li>操作系统分解成多个层，<strong>高层只能调用低一层的功能</strong>。</li><li>分层结构的主要难点在于：<ul><li>仔细定义每一层</li><li>效率较低。</li></ul></li><li>eg. The <strong>THE</strong> operating system by Dijkstra.</li></ul><h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4><ul><li>随着Unix操作系统的扩展，内核变得庞大而难以管理。</li><li>微内核方法通过<strong>从内核中删除所有非必要组件</strong>并将它们实现为系统级和用户级程序来构造操作系统。</li><li>提供精简的内核。哪些组件应该保留在微内核中？ <ul><li>CPU管理</li><li>内存管理</li><li>通信设备</li></ul></li><li>eg. ①卡内基梅隆大学的开源Mach(用作Apple Mac OS X和DEC Tru64 Unix的内核) ②QNX Inc.的QNX实时操作系统 ③Micorsoft Windows NT / XP</li></ul><h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><ul><li>从微内核进一步迈进：<ul><li>低级真实的硬件被“克隆”到几个相同的<strong>虚拟机</strong>中。</li><li>虚拟机提供的接口与底层裸机相同。</li></ul></li><li>然后，操作系统功能建立在虚拟机之上。<br><img src="https://i.loli.net/2018/06/17/5b2606003dd2f.png" width="70%" height="80%"></li><li>eg. ①IBM VM/370 ②VMware ③Microsoft Virtual PC ④Sun microsystem’s Java Virtual Machine (JVM).Sun微系统的Java虚拟机</li><li>虚拟机的优与劣<ul><li>虚拟机概念提供了<strong>对系统的全面保护</strong>。因为每个虚拟机都与其他所有虚拟机隔离开来。</li><li>然而，这种隔离<strong>不允许直接分享资源</strong></li><li>虚拟机系统是<strong>操作系统研究和开发</strong>的理想<strong>工具</strong>。</li><li>虚拟机的概念很难实现，因为需要<strong>准确地</strong>为底层机器提供一个完全相同的副本。</li></ul></li></ul><h4 id="政策和机制"><a href="#政策和机制" class="headerlink" title="政策和机制"></a>政策和机制</h4><ul><li><strong>政策：做什么</strong><br>eg. 用户应该无法读取其他用户的文件。</li><li><strong>机制：如何做</strong><br>eg. 在打开的系统调用中检查文件权限。</li><li><strong>政策与机制的分离</strong>是一个非常重要的原则。<ul><li>如果政策决定以后将改变，它可以提供最大的灵活性。</li></ul></li><li>两个极端：<ul><li>微内核：所有机制，几乎没有政策</li><li>Apple Macintosh：策略和机制绑定在一起</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;一个像现代操作系统一样庞大而复杂的系统必须仔细设计，才能正常运行并易于修改。&lt;/li&gt;
&lt;li&gt;一种常用的方法是将任务分成小部件，而不是一个单一的系统。&lt;/li&gt;
&lt;li&gt;这些组件中的每一个都应该是系统的一个明确定义的部分，具有详细定义的&lt;strong&gt;输入，输出和功能&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;系统设计人员如何组织这些组件？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单结构（或没有结构）&lt;/li&gt;
&lt;li&gt;分层结构&lt;/li&gt;
&lt;li&gt;微内核&lt;/li&gt;
&lt;li&gt;虚拟机&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记02 计算机系统结构</title>
    <link href="http://daisine.me/os2/"/>
    <id>http://daisine.me/os2/</id>
    <published>2018-07-03T06:14:00.000Z</published>
    <updated>2018-07-03T06:22:07.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Bootstrap-引导"><a href="#Bootstrap-引导" class="headerlink" title="Bootstrap 引导"></a>Bootstrap 引导</h4><ul><li>我们必须将操作系统内核从某些永久性存储（如磁盘和网络服务器）加载到内存中。装入内核以启动计算机的过程称为<strong>引导</strong>系统。</li><li>绝大多数计算机系统都有一小块代码，称为<strong>引导程序/引导装载程序</strong>。这段代码能定位内核，将它装入内存，开始执行。</li><li><strong>引导加载程序不是操作系统的一部分。</strong>引导程序被存储在固件中，而操作系统保存在磁盘上。</li><li><p>例子：</p><ul><li>NTLDR: 用于Windows NT / XP的boot-loader（驻留在C:\）。</li><li>GRUB: Unix / Linux的启动加载器之一。</li></ul><a id="more"></a></li></ul><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><ul><li>现代计算机和操作系统是<strong>由中断驱动</strong>的。<ul><li>外围设备使用**中断信号通知CPU发生了某些事情。</li></ul></li><li>当CPU发生中断时，它必须通过<strong>硬</strong>件、ISR中<strong>的汇编语言程序</strong>和<strong>C程序</strong>来服务中断：<ol><li>硬件：将一些寄存器和分支保存到<strong><code>中断服务程序</code></strong>（<strong><code>ISR</code></strong>）;</li><li>ISR中的汇编语言程序：必要时保存其余寄存器营造便利的环境;</li><li>ISR中的C语言程序：确实服务于中断，通常读取并缓冲来自外围设备的输入数据;</li><li>ISR中的C语言程序：返回在ISR中的汇编语言;</li><li>ISR中的汇编语言程序：恢复保存的寄存器并返回到被中断的位置。</li></ol></li></ul><h5 id="中断向量"><a href="#中断向量" class="headerlink" title="中断向量"></a>中断向量</h5><ul><li>通常，计算机系统具有多个外围设备。发生中断时，CPU必须知道哪个设备触发了它。</li><li>中断向量（Interrupt vector）是中断服务程序的入口地址，或中断向量表的下标，中断服务程序的入口地址存放在该数组中。<ul><li>计算机系统为每个设备分配一个唯一的<strong><code>中断请求号</code></strong>（例如，一个8-bit整数），简称<strong><code>IRQ</code></strong>。</li><li>中断向量表中存有所有ISR的地址。它是一个地址的数组。</li><li>在服务中断时，CPU使用<strong>IRQ</strong>(中断请求号)来<strong>索引中断向量</strong>，以获取ISR的地址并跳转到它。<br><img src="https://i.loli.net/2018/06/17/5b25d57c9fb57.png" width="80%" height="40%"> </li></ul></li></ul><h5 id="中断vs异常"><a href="#中断vs异常" class="headerlink" title="中断vs异常"></a>中断vs异常</h5><ul><li><code>中断</code>：<strong>异步</strong>，由<strong>外围设备</strong>触发</li><li><code>异常</code>：<strong>同步</strong>，处理器在执行指令时检测到错误情况（例如除零和无效内存访问）时会发生异常。</li><li>除上述以外，处理中断和异常是相同的。异常也称为<strong>软件生成的中断</strong>或<strong>同步中断</strong>。 </li></ul><h4 id="I-O结构"><a href="#I-O结构" class="headerlink" title="I/O结构"></a>I/O结构</h4><ul><li>当CPU使用外围设备进行 I/O 时，有两种方法可用：<ul><li>同步 I/O ：I/O 操作开始，等待 I/O 操作完成时将控制返回给用户进程。</li><li>异步 I/O ：并不等待输入输出结束，而是直接将控制返回给用户程序。<br><img src="https://i.loli.net/2018/06/17/5b25dac98ff90.png" width="80%" height="40%"> </li></ul></li><li>(外围)设备控制器中的寄存器被称为 <strong>I/O 端口</strong><ul><li>一个唯一的地址（称为<strong>端口</strong>，一个8/16-bit整数）被分配给设备控制器中的每一个寄存器。</li></ul></li><li>特殊的 I/O 指令旨在允许这些<strong>寄存器和内存之间的数据传输</strong>。</li><li>例如：IBM-PC<ul><li>16位 I/O 端口用于<strong>寻址</strong>设备控制器的寄存器。</li><li>两个特殊的 I/O 指令：IN和OUT包含在INTEL x86 CPU中。<br>1.IN reg，端口 - 从端口读取一个字节/字到CPU寄存器寄存器<br>2.OUT端口，reg  - 将CPU寄存器的内容写入端口。</li></ul></li></ul><h4 id="内存映射-I-O"><a href="#内存映射-I-O" class="headerlink" title="内存映射 I/O"></a>内存映射 I/O</h4><ul><li>在 I/O 端口的方法中，我们可以将 I/O 端口视为另一个单独的地址空间，与存储器地址空间无关。</li><li>设备控制器内的寄存器只是一个存储器。<ul><li>为什么不使用与内存相同的方法访问这些寄存器？</li><li>在这种情况下，（唯一的）<strong>内存地址</strong>被分配给每个寄存器，而<strong>不是</strong>一个<strong>端口地址</strong>。</li></ul></li><li><p>内存映射 I/O 。</p><ul><li>内存映射 I/O 使用<strong>相同的总线</strong>来寻址内存和I / O设备</li><li>为了容纳 I/O 设备，CPU<strong>可寻址空间</strong>的区域必须<strong>为 I/O 而不是内存预留</strong>。</li></ul></li><li><p>优点</p><ul><li>每个可以引用内存的指令也可以引用设备控制器寄存器。（设备驱动程序可以完全用C语言编写。）</li><li>不需要特殊的保护机制来保持用户进程不执行 I/O 。</li></ul></li><li>缺点<ul><li>现在大多数电脑都有某种形式的缓存记忆词。但是，缓存<strong><code>设备控制器寄存器</code></strong>将会产生灾难性的后果。</li></ul></li><li>现代计算机系统使用它们两个：<ul><li><strong>用于数据缓存</strong>的存储器映射 I/O 和<strong>用于命令寄存器</strong>的单独 I/O 端口，</li><li>就像Mobility Radeon 7500的例子一样。</li></ul></li></ul><h4 id="硬件保护"><a href="#硬件保护" class="headerlink" title="硬件保护"></a>硬件保护</h4><ul><li>为确保正常运行，我们必须保护操作系统和所有其他程序及其数据免受任何故障程序的影响。</li><li>不同的硬件保护方式：<ul><li><strong>双模式操作</strong>：防止用户程序占用部分操作系统，并使用它覆盖其他程序，甚至修改操作系统本身。</li><li><strong>特权指令</strong>：防止用户程序通过发出<strong>非法 I/O 指令</strong>而中断系统的正常操作。</li><li><strong>内存保护</strong>：防止用户程序<strong>直接访问</strong>其他用户程序或操作系统的<strong>内存</strong>。</li><li><strong>CPU保护</strong>：防止用户程序<strong>陷入无限循环</strong>，并且永远不会将控制权交还给操作系统。</li></ul></li></ul><h5 id="1-双模式操作"><a href="#1-双模式操作" class="headerlink" title="1. 双模式操作"></a>1. 双模式操作</h5><ul><li>用户模式：代表用户程序执行。</li><li>监控模式：代表操作系统执行。也称为管理员/系统/特权或内核模式。</li><li><strong><code>模式位</code></strong>被添加到计算机硬件以指示当前模式：监视器（0）或用户（1）。<ul><li>在<strong>系统启动时</strong>被设置为<strong>监视模式</strong>，然后加载操作系统，以<strong>用户模式</strong>启动<strong>用户程序</strong>。</li></ul></li><li>当发生中断或异常时硬件切换到监视模式。<ul><li>只要操作系统获得对计算机的控制权，就处于监视模式。</li><li>系统总是在将控制权交给用户程序前切换到用户模式。</li></ul></li><li>INTEL IA-32支持4种工作模式，命名为保护环。<ul><li>但是，运行在IA-32上的大多数操作系统只使用4个中的2个。环0为监视模式，环3为用户模式。<br><img src="https://i.loli.net/2018/06/17/5b25e64b601a8.png" width="70%" height="40%"> </li></ul></li></ul><h5 id="2-特权指令"><a href="#2-特权指令" class="headerlink" title="2. 特权指令"></a>2. 特权指令</h5><ul><li>所有 I/O 指令都是特权指令。<ul><li>硬件允许特权指令仅在监视器模式下执行。</li><li>如果这些指令在用户模式下执行，硬件不会执行指令，而是将其视为非法并生成异常。</li><li>eg. <strong>IN</strong>和<strong>OUT</strong>是INTEL IA-32中的2条<strong>特权指令</strong>。</li></ul></li><li>必须确保用户程序无法在监视模式下获得对计算机的控制权。</li><li>转移到用户模式操作，定时器管理，中断管理…</li></ul><h5 id="3-内存保护"><a href="#3-内存保护" class="headerlink" title="3. 内存保护"></a>3. 内存保护</h5><ul><li>为了保护内存，用两个寄存器来确定程序可以访问的合法地址的范围：<ul><li><strong>基地址寄存器</strong>：保存最小的合法物理内存地址</li><li><strong>界限地址寄存器</strong>：保存地址范围的大小。</li></ul></li><li>见内存管理章节<br><img src="https://i.loli.net/2018/06/17/5b25e8e5bc99d.png" width="80%" height="80%"> </li></ul><h5 id="4-CPU保护"><a href="#4-CPU保护" class="headerlink" title="4. CPU保护"></a>4. CPU保护</h5><ul><li>操作系统只有在有机会运行时才能执行一种策略。<ul><li>如果用户程序陷入死循环或不调用系统服务，并不将控制权返回到操作系统，则CPU不受操作系统的控制。</li></ul></li><li><strong>定时器</strong>：在给定的时间段后中断CPU，控制权自动交给操作系统以确保操作系统能维持对CPU的控制。<ul><li>发生中断时，<strong>操作系统将通过ISR获得控制权</strong>。</li></ul></li></ul><h5 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h5><ul><li>计数寄存器每经过一个时间周期，都要递减(减1)。</li><li>当计数器寄存器达到0时，定时器将中断CPU。</li><li>然后，计数器寄存器将重新加载<code>保持寄存器</code>的值并重复递减的步骤。</li><li>示例：IBM-PC中的计时器<ul><li>具有16位计数器和保持寄存器和脉冲的INTEL i8253可编程间隔定时器达到1193182Hz。<br><img src="https://i.loli.net/2018/06/17/5b25f4b3a9c3e.png" width="90%" height="80%"> </li></ul></li></ul><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><ul><li>操作系统本身没有任何用处，但它通过系统调用用户程序提供了一些有用的服务。如，从磁盘读取文件并通过网络适配器将数据发送到远程主机。</li><li><strong>系统调用</strong>：操作系统和用户程序之间的（明确定义的）接口。<ul><li>用户程序<strong>只能</strong>通过系统调用请求操作系统提供的服务。</li><li>系统调用接口因操作系统而异，也称为<strong>主管电话</strong>。</li></ul></li></ul><h5 id="系统调用v-s-库函数"><a href="#系统调用v-s-库函数" class="headerlink" title="系统调用v.s.库函数"></a>系统调用v.s.库函数</h5><ul><li>系统调用会<strong>陷入OS内核</strong>;而库函数没有。所以，<strong>系统调用比库函数慢得多</strong>。</li><li>库函数与用户定义的函数相同。用户可以用自己的版本替换现有的库函数，而系统调用则不能替换。</li><li>一个操作系统中的系统调用可能会成为另一个操作系统中的库函数，反之亦然。<br><img src="https://i.loli.net/2018/06/17/5b25fe9f393cb.png" width="60%" height="60%"> </li></ul><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p><img src="https://i.loli.net/2018/06/17/5b25f6b86d9dd.png" width="60%" height="80%"> </p><ul><li>1 - 3 准备参数；</li><li>4 调用系统调用的包装器（用汇编语言编写）；</li><li>5 将读取的<strong>系统调用号</strong>存储到寄存器中；</li><li>6 陷入操作系统；</li><li>7 通过使用<strong>系统调用号</strong>索引<strong>系统调用表</strong>获取<strong>系统调用服务程序</strong>以进行读取；</li><li>8 - 11 系统调用服务程序运行，并在完成时返回到用户程序。<br><img src="https://i.loli.net/2018/06/17/5b25fc997f84d.png" width="50%" height="80%"> </li><li>这里的驻留监视器（或简单的监视器）意味着操作系统</li><li>n是系统调用号。</li></ul><h5 id="陷入操作系统"><a href="#陷入操作系统" class="headerlink" title="陷入操作系统"></a>陷入操作系统</h5><ul><li>用户程序不能直接陷入操作系统。如何陷入操作系统？</li><li>方法1：异常（软件生成的中断）<ul><li>INTEL IA-32提供触发异常的指令INT。eg. Linux / FreeBSD使用INT 0x80陷入操作系统，Windows NT / XP使用INT 0x2e。 </li></ul></li><li>方法2：特殊指令。<ul><li>由于INT指令的额外开销，INTEL IA-32提供了两个特殊指令来陷入操作系统：<code>SYSENTER</code>和<code>SYSEXIT</code>。仅在Pentium II之后的处理器上支持，即Family 6，Model 3，Stepping 3。</li><li>ARM处理器使用swi (Short for SoftWare Interrupt) 陷入操作系统。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Bootstrap-引导&quot;&gt;&lt;a href=&quot;#Bootstrap-引导&quot; class=&quot;headerlink&quot; title=&quot;Bootstrap 引导&quot;&gt;&lt;/a&gt;Bootstrap 引导&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;我们必须将操作系统内核从某些永久性存储（如磁盘和网络服务器）加载到内存中。装入内核以启动计算机的过程称为&lt;strong&gt;引导&lt;/strong&gt;系统。&lt;/li&gt;
&lt;li&gt;绝大多数计算机系统都有一小块代码，称为&lt;strong&gt;引导程序/引导装载程序&lt;/strong&gt;。这段代码能定位内核，将它装入内存，开始执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引导加载程序不是操作系统的一部分。&lt;/strong&gt;引导程序被存储在固件中，而操作系统保存在磁盘上。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NTLDR: 用于Windows NT / XP的boot-loader（驻留在C:\）。&lt;/li&gt;
&lt;li&gt;GRUB: Unix / Linux的启动加载器之一。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记01 导论</title>
    <link href="http://daisine.me/os1/"/>
    <id>http://daisine.me/os1/</id>
    <published>2018-07-03T06:10:52.000Z</published>
    <updated>2018-07-03T06:22:15.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h4><ul><li>多个作业同时保存在主存储器中，CPU通过在作业之间切换来执行多个作业。<br><img src="https://i.loli.net/2018/06/17/5b25c15f99ea2.png" width="40%" height="40%"> </li></ul><h4 id="台式机的操作系统"><a href="#台式机的操作系统" class="headerlink" title="台式机的操作系统"></a>台式机的操作系统</h4><ul><li><p>这些计算机的操作系统从主机操作系统的开发中受益良多。</p><ul><li>Microsoft MS-DOS, Windows 9x/NT</li><li>Apple Macintosh, Mac OS X</li><li>IBM OS/2</li><li>Unix: Solaris by Sun microsystem, HP-UX by Hewlett-Packard, AIX by IBM, Free (as in freedom) software such as BSD (Berkeley Software Distribution) Unix, GNU/Linux</li></ul><a id="more"></a></li></ul><h4 id="实时-嵌入式系统"><a href="#实时-嵌入式系统" class="headerlink" title="(实时)嵌入式系统"></a>(实时)嵌入式系统</h4><ul><li><strong>嵌入式计算机</strong>通常用作<strong>工业控制系统</strong>等专用应用中的控制设备。通常他们资源有限：<ul><li>处理器缓慢、内存有限</li><li>小甚至没有显示屏幕、有限的电源</li><li>有限的功能，只具有很少甚至没有用户接口</li></ul></li><li>嵌入式系统几乎都运行<strong>实时操作系统</strong>。</li><li>他们资源有限：处理器缓慢、内存有限、小甚至没有显示屏幕、有限的电源 etc..<ul><li>Microsoft Windows CE (Consumer Electronics)</li><li>Windriver vxWorks </li><li>GNU / Linux</li></ul></li><li>一些控制设备具有时间要求，即实时：<ul><li><strong>硬实时</strong>：处理必须在固定时间约束内完成，不允许任何超出时限的错误。</li><li><strong>软实时</strong>：可以容忍偶然的超时错误。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;操作系统结构&quot;&gt;&lt;a href=&quot;#操作系统结构&quot; class=&quot;headerlink&quot; title=&quot;操作系统结构&quot;&gt;&lt;/a&gt;操作系统结构&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;多个作业同时保存在主存储器中，CPU通过在作业之间切换来执行多个作业。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2018/06/17/5b25c15f99ea2.png&quot; width=&quot;40%&quot; height=&quot;40%&quot;&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;台式机的操作系统&quot;&gt;&lt;a href=&quot;#台式机的操作系统&quot; class=&quot;headerlink&quot; title=&quot;台式机的操作系统&quot;&gt;&lt;/a&gt;台式机的操作系统&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这些计算机的操作系统从主机操作系统的开发中受益良多。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Microsoft MS-DOS, Windows 9x/NT&lt;/li&gt;
&lt;li&gt;Apple Macintosh, Mac OS X&lt;/li&gt;
&lt;li&gt;IBM OS/2&lt;/li&gt;
&lt;li&gt;Unix: Solaris by Sun microsystem, HP-UX by Hewlett-Packard, AIX by IBM, Free (as in freedom) software such as BSD (Berkeley Software Distribution) Unix, GNU/Linux&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>软件工程导论笔记</title>
    <link href="http://daisine.me/sei/"/>
    <id>http://daisine.me/sei/</id>
    <published>2018-06-20T01:48:06.000Z</published>
    <updated>2018-06-20T01:53:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-软件工程概述"><a href="#1-软件工程概述" class="headerlink" title="1. 软件工程概述"></a>1. 软件工程概述</h3><h4 id="软件的概念和特点"><a href="#软件的概念和特点" class="headerlink" title="软件的概念和特点"></a>软件的概念和特点</h4><p><code>软件</code>(广义)：计算机系统中与硬件相互依存的一部分  </p><blockquote><p><strong>程序</strong>：计算机可以接受的一系列指令，运行时可以提供所要求的功能和性能。<br><strong>数据</strong>：使得程序能够适当地操作信息的数据结构。<br><strong>文档</strong>：描述程序的研制过程、方法和使用的图文资料。 </p></blockquote><a id="more"></a><ul><li>软件所具有的<strong>复杂性</strong>、<strong>一致性</strong>、<strong>可变性</strong>、<strong>不可见性</strong>等特性，使得软件开发过程变得难以控制。</li><li>软件的特点：<ul><li>软件是一种<strong>逻辑实体</strong>，不是具体的物理实体。</li><li>软件产品的生产主要是研制。</li><li>软件具有<strong>“复杂性”</strong>，其开发和运行常受到计算机系统的限制。</li><li>软件<strong>成本昂贵</strong>，其开发方式目前尚未完全摆脱手工生产方式。</li><li>软件不存在磨损和老化问题，但存在<strong>退化问题</strong>。</li></ul></li></ul><h4 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h4><ul><li><code>软件危机</code>：落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。  </li><li>体现在：   <ol><li>软件产品无质量保证，可靠性差，甚至开发过程就夭折。  </li><li>软件生产率太低  </li><li>无法开发复杂程度高的软件</li><li>成本和进度估计不准</li><li>无统一科学的规范，软件不可维护</li><li>软件常不能满足用户的需求</li></ol></li><li>解决途径： <ol><li>管理措施:项目管理、配置管理、过程管理、质量控制</li><li>技术措施:开发过程、开发技术与方法和开发工具 </li></ol></li></ul><h4 id="软件工程的发展"><a href="#软件工程的发展" class="headerlink" title="软件工程的发展"></a>软件工程的发展</h4><ul><li>史前时代(1965-1967)<ol><li>软件开发没有方法可循</li><li>软件设计是在开发人员头脑中完成的隐藏过程</li><li>60世纪中期的软件危机</li></ol></li><li>瀑布过程模型(1968-1982) <ol><li>1968年提出“软件工程”</li><li>结构化开发方法</li><li>瀑布式软件生命周期模型 成为典型</li></ol></li><li>质量标准体系<ol><li>面向对象开发方法</li><li>软件过程改进运动</li><li>CMM/ISO9000/SPICE等 质量标准体系</li></ol></li><li>20世纪90年代至今<ol><li>敏捷开发方法流行</li><li>更紧密的团队协作</li><li>有效应对需求变化</li><li>快速交付高质量软件</li><li>迭代和增量开发过程 </li></ol></li></ul><h4 id="软件工程的定义"><a href="#软件工程的定义" class="headerlink" title="软件工程的定义"></a>软件工程的定义</h4><p><code>软件工程</code>是①将系统性的、规范化的、可定量的方法应用于软件的开发、运行和维护，即工程化应用到软件上；②对①中所述方法的研究。</p><blockquote><p>是一门指导计算机和维护的工程学科。</p></blockquote><h4 id="软件工程三要素"><a href="#软件工程三要素" class="headerlink" title="软件工程三要素"></a>软件工程三要素</h4><ol><li><strong>方法</strong>: 研究软件开发<strong>“如何做”</strong>的技术。涵盖了项目计划、需求分析、系统设计、程 序实现、测试与维护等一系列的开发活动如何来做。开发方法经历了从面向结构、面向对象、 面向组件到面向服务的发展工程。 </li><li><strong>过程</strong>: 为<strong>及时</strong>、<strong>合理</strong>地开发出满足用户需求的计算机软件而进行<strong>一系列有组织的活动</strong>。</li><li><strong>工具</strong>: 为过程和方法提供自动的或半自动的支持。这些软件工具被<strong>集成</strong>起来，建立起一个支持软件开发的系统，称之为<strong>计算机辅助软件工程 </strong>(CASE ，Computer Aided Software Engineering)。</li></ol><h3 id="2-软件过程模型"><a href="#2-软件过程模型" class="headerlink" title="2.软件过程模型"></a>2.软件过程模型</h3><p><code>软件过程模型</code>定义任务之间关系和规程和方法，软件过程模型是对软件过程的抽象描述。</p><h4 id="瀑布模型："><a href="#瀑布模型：" class="headerlink" title="瀑布模型："></a>瀑布模型：</h4><ul><li>瀑布模型：将软件生存周期各活动规定为依线性顺序联接的若干阶段的模型。一个系统的、顺序的软件开发方法。</li><li>该模型说明整个软件开发过程是按图中的各个阶段进行的，每个阶段的任务完成之后，产生右边相应的文档</li><li>优点：<ul><li>为项目提供了按阶段划分的检查点</li><li>当前一阶段完成后，只需要去关注后续阶段</li><li>可在迭代模型中应用瀑布模型</li></ul></li><li>缺点：<ul><li>各个阶段的划分完全固定，阶段之间产生了大量的文档，增加了工作量</li><li>由于开发过程是线性的，开发过程中很难响应用户的变更要求</li><li>早期错误要等到后期测试阶段才能发现</li><li>实际项目开发中很少遵守瀑布模型提出的顺序</li><li>客户要等到开发周期的晚期才能得到可执行的程序</li></ul></li></ul><h4 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h4><ul><li>为了描述、述软件开发过程中可能的回溯，尤其是维护阶段往往要经历上描述各个阶段，采用循环模型描述。</li><li>原型是一个部分开发的产品，用于加强对系统的理解，有助于明确需求和选择可行的设计策略。 </li></ul><h4 id="迭代式开发"><a href="#迭代式开发" class="headerlink" title="迭代式开发"></a>迭代式开发</h4><ul><li>迭代式开发：将描述、开发和验证等不同活动交织在一起，在开发过程中建立一系列版本，将系统一部分一部分地逐步交付。 </li></ul><h4 id="增量模型："><a href="#增量模型：" class="headerlink" title="增量模型："></a>增量模型：</h4><ul><li>增量模型：先开发主要功能模块，再开发次要功能模块，逐步完善直到构造全部功能。</li><li>优点：<ul><li>分步开发，降低复杂性和难度。</li><li>当配备的人员不能在设定的期限内完成产品时，它提供了一种先推出核心产品的途径。</li><li>可先发布部分功能给客户，对客户起到镇静剂的作用。</li><li>边开发边投入，可及早发现问题，减少投资风险。</li><li>适用于需求不完整的软件开发，可以灵活应对用户的需求变化。</li></ul></li><li>缺点：<ul><li>加入构件不能破坏已构造好的系统部分，这需要软件具备开放式的体系结构。 </li><li>需求改变过大会导致软件过程的控制失去整体性。</li><li>如果增量包之间存在相交的情况且未很好处理，则必须做全盘系统分析。</li></ul></li></ul><h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><ul><li>一种风险驱动型的过程模型，一种演进式软件过程模型。它结合了原型的<strong>迭代性质</strong>和瀑布模型的<strong>系统性和可控性</strong>特点。具有快速开发越来越完善软件版本的潜力。</li><li>螺旋模型将开发过程分为几个螺旋周期，每个螺旋周期可分为4个工作步骤:<ol><li>确定目标、方案和限制条件；</li><li>评估方案、标识风险和解决风险；</li><li>开发确认产品；</li><li>计划下一周期工作。</li></ol></li><li>优点：<ul><li>开发大型系统和软件的理想方法。</li><li>客户始终参与每个阶段的开发，每个阶段的成果需客户确认，避免错误的积累。</li><li>增加风险分析，一旦风险成立，原方案应终止、修订，力求风险可控。</li></ul></li><li>缺点：很难说服客服演进的方法是可控的，依赖于低昂的风险评估专家来保证成功。</li></ul><h4 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h4><ul><li>敏捷宣言<ul><li>个体和交互&gt;过程和工具</li><li>可以工作的软件&gt;面面俱到的文档</li><li>客户合作&gt;合同谈判</li><li>响应变化&gt;遵循计划</li></ul></li><li>极限编程(XP)：偏重编程实践 </li><li>Scrum开发方法：偏重项目管理<ul><li>特点：计划性、灵活性</li></ul></li></ul><h3 id="3-软件需求分析"><a href="#3-软件需求分析" class="headerlink" title="3. 软件需求分析"></a>3. 软件需求分析</h3><ul><li>目的：弄清用户对系统的细节要求，完整、准确、清晰、具体地回答目标系统 “做什么”。准确地理解用户 出的软件功能、性能及其环境的要求。</li><li>必要性：用户与开发者的知识领域不同，产生歧义;软件开发失败 50%是需求 不合理，早期错误易放大。</li></ul><h4 id="需求工程活动"><a href="#需求工程活动" class="headerlink" title="需求工程活动"></a>需求工程活动</h4><ul><li><strong>需求获取</strong><ul><li>需求获取技术：面谈、问卷调查、群体诱导技术、参与调查法、文档分析、原型化方法、需求讨论会..<br>。</li></ul></li><li><strong>需求分析与建模</strong></li><li>需求规约：软件需求规约(文档)</li><li><strong>需求管理</strong></li><li><p><strong>需求验证</strong></p></li><li><p>业务需求：反映企业/组织对软件系统的高层次目标要求，即软件系统的建设目标。</p></li><li>用户需求：用来描述用户使用产品必须要完成的任务，使用业务领域的术语描述，采用开发者与用户都能理解的语言和图形表达。</li><li>功能需求：开发人员必须实现的软件功能，结果在需求规格说明书中。</li><li>（也包括非功能需求）：如界面的交互性、数据的安全性、 数据的事务性、用户的并发性、响应的快速性、操作的实时性、错误与异常的恢复性、软件 的容错性等等<h4 id="需求分析方法"><a href="#需求分析方法" class="headerlink" title="需求分析方法"></a>需求分析方法</h4></li><li>功能分析方法：将系统看作若干功能模块的集合，每个功能又可以分解为若干子功能，子功能还可继续分解，分解的结果已经是系统的雏形。</li><li>结构化分析方法(SA法)：是一种以数据、数据的封闭性为基础，从问题空间到某种表示的映射方法，由数据流图（DFD图）表示。</li><li>信息建模法：是从数据的角度对现实世界建立模型的，基本工具是ER图。</li><li>面向对象的分析方法（OOA）的关键是识别问题域内的对象，分析它们之间的关系，并建立起三类模型。<ul><li>面向对象的特性有<strong>抽象性、封装性、继承性、多态性和消息机制</strong>等五大特性。</li></ul></li></ul><h4 id="结构化分析方法-SA法"><a href="#结构化分析方法-SA法" class="headerlink" title="结构化分析方法(SA法)"></a>结构化分析方法(SA法)</h4><ul><li>基本思想<ul><li>分解：对于一个复杂的系统，为了将复杂性降低到可以掌握的程度，可以把大问题分解成若干小问题，然后分别解决。</li><li>抽象：分解可以分层进行，即先考虑问题最本质的属性，暂把细节略去，以后再逐层添加细节，直至涉及到最详细的内容，</li></ul></li><li><strong>DFD图</strong><ul><li>箭头表示<strong>数据流</strong>(表示数据流的名称和数据的流向)</li><li>圆或椭圆表示<strong>加工</strong></li><li>双杠或者单杠表示<strong>数据存储</strong></li><li>矩形框表示数据的源点或终点，即<strong>外部实体</strong>(系统外与系统交互的人或实体)。</li></ul></li><li>分层DFD图<ul><li>先确定系统范围，画出顶层的DFD图。顶层图说明了系统的边界，<br>即系统的输入和输出数据流，顶层图只有一张。</li><li>逐层分解顶层DFD图，获得若干中间层DFD图。中间层的数据流图描述了某个加工的分解，而它的组成部分又要进一步分解。 </li><li>画出底层的DFD图。底层图由一些不能再分解的加工组成。</li></ul></li><li><strong>数据字典(DD)</strong>：描述数据流图中出现的所有数据和加工。<ul><li>分层数据流图只是表达了系统的“分解”，为了完整地描述这个系统，还需借助“数据词典”和“小说明”对图中的每个数据和加工给出解释。</li><li><strong>数据流条目</strong>：给出了DFD中数据流的定义，通常对数据流的简单描述为列出该数据流的各组成数据项。</li><li><strong>文件条目</strong>：给出某个文件的定义，文件的定义通常是列出文件记录的组成数据流，还可指出文件的组织方式。</li><li><strong>数据项条目</strong>：给出某个数据单项的定义，通常是该数据项的值类型、允许值等。</li><li><strong>加工条目</strong>：说明DFD中基本加工的处理逻辑。由于上层的加工是由下层的基本加工分解而来，只要有了基本加工的说明，就可理解其他加工。</li></ul></li></ul><h3 id="4-软件体系结构设计"><a href="#4-软件体系结构设计" class="headerlink" title="4.软件体系结构设计"></a>4.软件体系结构设计</h3><h4 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h4><ul><li>软件设计阶段要解决“如何做”的问题</li><li>软件所有的开发工作都将根据设计的方案进行</li><li>软件的总体结构设计决定了系统的质量</li><li><strong>软件设计包括软件结构设计、数据设计、接口设计和过程设计。</strong><ul><li>结构设计：定义软件系统<strong>各主要部件之间的关系</strong></li><li>数据设计：将分析时创建的模型转化为数据结构的定义</li><li>接口设计：描述软件内部、软件和操作系统之间及软件与人之间如何通信</li><li><strong>过程设计</strong>：把<strong>系统结构部件</strong>换成<strong>软件</strong>的过程描述。</li></ul></li></ul><h4 id="软件设计的任务"><a href="#软件设计的任务" class="headerlink" title="软件设计的任务"></a>软件设计的任务</h4><ul><li>将分析阶段获得的需求说明转换为计算机中可实现的系统。</li><li>完成系统的结构设计，包括：数据结构和程序结构，最后得到软件设计说明书。</li><li>对模块内部的过程进行设计。</li></ul><h4 id="软件设计阶段任务"><a href="#软件设计阶段任务" class="headerlink" title="软件设计阶段任务"></a>软件设计阶段任务</h4><ol><li><strong>划分模块，确定软件结构</strong>：开发方法不同，确定软件结构的方法也不同。例如SD法，是从分层的DFD图导出初始的结构图，再对初始的结构图进行改进，获得最终的结构图。一般包括确定系统的软件结构，分解模块，确定系统的模块层次关系。</li><li>确定<strong>系统的数据结构</strong>：数据结构的建立对于<strong>信息系统</strong>而言尤为重要。要确定数据的类型，组织、存取方式，相关程度及处理方式等。</li><li>设计<strong>用户界面</strong>：作为人机接口的用户界面起着越来越重要的作用，它直接影响到软件的寿命。</li></ol><h4 id="软件的层次结构"><a href="#软件的层次结构" class="headerlink" title="软件的层次结构"></a>软件的层次结构</h4><ul><li>模块：是程序对象有名字的集合(过程、函数、子程序、宏..)。</li><li>深度：表示软件结构从顶层模块到最底层模块的层数。</li><li>宽度：表示控制的总分布。</li><li>扇出度：一个模块直接控制下属的模块个数。</li><li>扇入度：一个模块的直接上属模块个数。</li><li>好的软件结构的形态准则：顶部宽度小，中部宽度大，底部宽度次之；在结构顶部有较高的扇出数，在底部有较高的扇入数。</li></ul><h4 id="软件结构图-SC图"><a href="#软件结构图-SC图" class="headerlink" title="软件结构图(SC图)"></a>软件结构图(SC图)</h4><ul><li>　结构图（Structure Chart，简称SC图）是精确表达软件结构的图形表示方法，它以特定的符号表示模块、模块间的调用关系和模块间信息的传递。<ul><li>模块（Module）：用矩形框表示，框中写有模块的名字，说明模块的功能。</li><li>调用：从一个模块指向另一个模块的箭头表示前一模块对后一模块的调用，一般是上层调用下层。</li><li>数据：调用箭头边上的小箭头表示调用时从一个模块传送给另一模块的数据。通常在短箭头附近应注有信息的名字。</li></ul></li></ul><h4 id="模块独立性"><a href="#模块独立性" class="headerlink" title="模块独立性"></a>模块独立性</h4><ul><li>模块独立性的度量标准：<ul><li>耦合性——用于描述<strong>模块之间</strong>联系的紧密程度。</li><li>内聚性——用于描述<strong>模块内部</strong>联系的紧密程度。</li></ul></li><li>模块独立性比较强的模块，具有：<strong>高内聚性、低耦合度</strong>。</li><li>内聚性低 &rarr; <strong>高</strong>：偶然型  &rarr; 逻辑型 &rarr; 瞬时型  &rarr; 通信型  &rarr; 顺序型  &rarr; <strong>功能性</strong></li><li>耦合性高 &rarr; <strong>低</strong>：内容耦合 &rarr; 公共耦合 &rarr; 控制耦合 &rarr; 复合耦合 &rarr; <strong>数据耦合</strong></li></ul><h4 id="软件设计-SD"><a href="#软件设计-SD" class="headerlink" title="软件设计(SD)"></a>软件设计(SD)</h4><ul><li>软件设计定义：软件设计是把软件需求（定义阶段）转换为软件的具体设计方案，即划分模块结构的过程，是软件开发阶段最重要的步骤。</li><li>软件设计划分：按工程管理角度划分为：概要（总体）设计和详细设计。<br>概要（总体）设计完成高层次结构设计；详细设计进行低层次过程设计，并穿插数据设计和接口设计。</li></ul><ol><li>概要/总体设计：分解模块，确定系统模块的层次结构。<ul><li>任务：① 划分模块 ② 确定模块功能 ③ 确定模块间调用关系 ④ 确定模块间界面</li><li>步骤：从DFD图导出初始的模块结构图，按照SD法设计总则，改进模块结构图。</li><li>得出：<strong>软件/模块结构图</strong>及其模块功能说明。</li></ul></li><li>详细设计：对模块图中每个模块的过程进行描述，把功能描述转变为精确的、结构化的过程描述。<ul><li>常用<strong>描述方式</strong>：伪代码，流程图，N-S图，PAD图…</li></ul></li></ol><blockquote><p>软件设计过程，概要设计是关键，根据需求确定<strong>软件和数据的总体框架</strong>，详细设计是进一步精化成软件的算法和数据结构。</p></blockquote><h4 id="软件结构化方法的优化准则"><a href="#软件结构化方法的优化准则" class="headerlink" title="软件结构化方法的优化准则"></a>软件结构化方法的优化准则</h4><ul><li>抽象：抽取事物最基本的特性和行为，忽略非基本的细节。采用分层次抽象的办法可以控制软件开发过程的复杂性，有利于软件的可理解性和开发过程的管理。</li><li>信息隐藏：采用封装技术，将程序模块的实现细节（过程或数据）隐藏起来，不被不需要这些信息的其它模块访问。</li><li>模块化：模块是程序中逻辑上相对独立的单元；模块的大小要适中；高内聚、低耦合。<ul><li>使开发工作更易于规划</li><li>可以定义和交付软件增量</li><li>容易实施变更</li><li>更有效地开展测试和调试</li></ul></li><li>一致性：整个软件系统（包括文档和程序）的各个模块均应使用一致的概念、符号和术语；程序内部接口应保持一致； </li></ul><h3 id="5-软件测试"><a href="#5-软件测试" class="headerlink" title="5. 软件测试"></a>5. 软件测试</h3><ul><li>软件测试是为了发现错误而运行程序的过程</li><li>软件测试的目的是发现程序中的错误，是为了证明程序有错， 而不是证明程序无错</li><li>测试对象不仅是程序，还应该包括开发过程中产生的所有产品，包括文档，其目的是为了尽早地、尽可能多的发现并排除软件中潜在的错误。<h4 id="软件测试分类"><a href="#软件测试分类" class="headerlink" title="软件测试分类"></a>软件测试分类</h4></li><li>程序执行角度<ul><li><strong>静态测试</strong>：通过人工分析或<strong>程序正确性证明</strong>的方式来确认程序正确性。</li><li><strong>动态测试</strong>：通过<strong>动态分析</strong>和<strong>程序测试</strong>等方式检查程序执行状态，以确认是否有问题。</li></ul></li><li>测试技术角度：<ul><li><strong>黑盒测试</strong>：将测试对象看做一个黑盒子，完全<strong>不考虑程序内部</strong>的逻辑结构和内部特性，只依据程序的<strong>需求规格说明书</strong>，检查<strong>程序的功能</strong>是否符合它的功能说明。</li><li><strong>白盒测试</strong>：把测试对象看做一个透明的盒子，允许测试人员<strong>利用程序内部</strong>的逻辑结构及有关信息，设计或选择测试用例，对程序所有<strong>逻辑路径</strong>进行测试。</li></ul></li><li>测试对象角度：</li><li><strong>单元测试</strong>：对软件基本组成单元进行的测试，其测试对象是软件设计的<strong>最小单位</strong>(<strong>模块</strong>或者类)。</li><li><strong>集成测试</strong>：在单元测试的基础上，将所有模块按照总体设计的要求组装成为<strong>子系统</strong>或<strong>系统</strong>进行的测试。测试对象是模块间的接口，其主要目的是找出在模块接口(包括系统体系结构)设计上的问题。</li><li><strong>功能测试</strong>：在已知产品所应具有的功能基础上，从<strong>用户角度</strong>来进行功能验证，以确认每个功能是否都能正常使用。</li><li><strong>性能测试</strong>：在实际或模拟实际的运行环境下，针对<strong>非功能特性</strong>所进行的测试。</li><li><strong>验收测试</strong>：软件产品完成了系统测试之后、产品发布之前进行的软件测试活动，其<strong>目的</strong>是验证软件的功能和性能是否能够满足用户所期望的要求。</li><li>人工干预角度：<ul><li><strong>手动测试</strong>：手工地输入测试数据并记录测试结果</li><li><strong>自动化测试</strong>：利用开发的软件测试工具或者脚本</li></ul></li></ul><h4 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h4><ul><li><strong>互审</strong>：程序员相互检查对方的代码</li><li><strong>走查</strong>：一个小组集体来走查程序或文档(分析方法：调用图、数据流分析图)</li><li><strong>会议</strong>：召开一个正式的会议，并有相应的记录、纪要、相应结果的文档。</li></ul><h4 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h4><h5 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h5><ul><li>逻辑覆盖法：<ul><li>语句覆盖：只覆盖可执行语句至少执行一次。</li><li>判定覆盖：又叫分支覆盖，对每个判定式取真、假各一次，使每个判定的每个分支都至少执行一次，同时满足语句覆盖。</li><li>条件覆盖：把程序中每个判断的每个条件为真和假各取值一次。 条件覆盖深入到判定中的每个条件，但不一定满足判定覆盖的要求。</li><li>判定/条件覆盖：同时满足判定、条件两种覆盖标准的取值。就是使得判定中每个条件的所有可能取值至少执行一次，同时每个判定本身所有取值至少执行一次。</li><li>条件组合覆盖：按每个判断的所有条件取值进行组合。这是 5 种覆盖中最强的覆盖。它不但可<strong>覆盖所有条件</strong>，还可<strong>覆盖所有判断的可取分支</strong>。</li></ul></li><li>基本路径覆盖法<ul><li>导出程序流程图的拓扑结构-流图(控制流程图)</li><li>计算流图 G 的环路复杂性 V(G)</li><li>确定只包含独立路径的基本路径集，设计测试用例</li></ul></li></ul><h5 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h5><ul><li>等价类划分法：<ul><li>对测试数据进行区间划分，从这些区间中选取典型值作为用例代表，认为测试等价类中的一个代表值的结果就等于对该类其它值的测试。</li><li>如果某个等价类的一个输入数据（代表值）测试中查出了错误，表示该等价类的其它值也有错误。</li><li>选择测试用例：① 为每个等价类编号 ② 使一个测试用例尽可能覆盖多个有效等价类<br>（<strong>注意：一个测试用例只能覆盖一个无效等价类。</strong>）</li><li><code>有效等价类</code>：对于程序的规格说明，是合理的、有意义的输入数据构成的集合。</li><li><code>无效等价类</code>：对于程序的规格说明，是不合理的、没有意义的输入数据构成的集合。</li></ul></li><li>边界值分析法：对输入或输出的边界值进行测试的一种方法。因为在等价类的边界处，是最可能出现错误的。<ul><li>步骤：划分等价类，选择测试用例，测试等价类边界。</li><li>边界选择原则：① 输入值范围的边界 ② 输入/输出值个数的边界 ③ 输出值域的边界 ④ 输入/输出有序集（如顺序文件、线性表）的边界</li></ul></li><li>错误推测法</li><li>因果图法</li></ul><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul><li>驱动模：模拟主程序或者调用模块的功能，用于向被测模块传递数据，接收、打印从被测模块返回的数据。<strong>一般只设计一个驱动模块</strong>。</li><li>桩模块：又称为假模块，用于模拟那些由被测模块所调用的下属模块的功能。可以设计<strong>一个或者多个桩模块</strong>，才能更好地对下属模块进行模拟。</li><li>测试方法以<strong>白盒法</strong>为主，驱动模块和桩模块都是额外开销。</li></ul><h4 id="集成-组装测试"><a href="#集成-组装测试" class="headerlink" title="集成/组装测试"></a>集成/组装测试</h4><ul><li>一次性集成方式：分别测试每个单元，再一次性将所有单元组装在一起进行测试。</li><li>渐增式集成方式：先对某几个单元进行测试，然后将这些单元逐步组装成较大的系统，在组装过程中边连接边测试。（自顶而下增值，自底而上增值，混合增值）<br>自顶而下增值，自底而上增值可以选择<strong>深度优先</strong>或者<strong>宽度优先</strong>增值</li><li>两种方式都需要设计驱动模块或桩模块，对每一个新组装的子系统进行测试主要采用黑盒法，对发现问题较多的子系统或模块应该用白盒法作回归测试。</li><li>集成过程原则：尽早测试关键模块  &rarr; 提高测试效率，尽早测试包含I/O的模块   &rarr; 为以后测试提供方便</li></ul><h4 id="系统-性能测试"><a href="#系统-性能测试" class="headerlink" title="系统/性能测试"></a>系统/性能测试</h4><ul><li>恢复测试：让软件强制地发生故障，然后来验证是否能恢复到正常工作。</li><li>安全测试：验证保护机制是否能够正常工作。</li><li>压力(强度)测试：在一种需要反常数量、频率或资源的方式下执行系统。</li><li>性能测试：测试软件在集成系统中的运行性能。</li></ul><h4 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h4><ul><li>测试的目的：显示存在错误</li><li>调试的目标：发现错误或导致程序失效的错误原因，并修改程序以修正错误。调试是测试之后的活动。</li><li><strong>三种调试方法</strong><ul><li>蛮力法(强行排错法)</li><li>返回法、回溯法</li><li>原因排除法 <h3 id="软件维护"><a href="#软件维护" class="headerlink" title="软件维护"></a>软件维护</h3></li></ul></li><li><code>软件维护</code>：在软件运行／维护阶段对软件产品进行<br>  的修改是所谓的维护。</li><li>软件维护类型<ul><li><strong>改正性维护</strong>：修改软件缺陷或者不足</li><li><strong>适应性维护</strong>：修改软件使其适应不同操作环境，主要包括硬件变化、操作系统变化或者其他支持软件变化。</li><li><strong>完善性维护</strong>：增加或修改系统功能，使其适应业务变化。</li><li><strong>预防性维护</strong>：采用先进的软件工程方法对需要维护的软件或软件中的某一部分（重新）进行设计、编制和测试。是为了提高软件的<strong>可维护性、可靠性</strong>等，为<strong>以后进一步改进软件</strong>打下良好基础。</li></ul></li><li>维护的副作用<ul><li>代码副作用</li><li>数据副作用</li><li>文档副作用。</li></ul></li><li>维护工作面临的困难：周期长、难度大、费用高。维护费用高</li></ul><h4 id="Point"><a href="#Point" class="headerlink" title="Point"></a>Point</h4><ul><li><strong>三层C/S结构</strong>包含表示层、功能层和数据层。</li><li><strong>软件</strong>由程序、数据和文档构成的。</li><li>从工程管理方面来分类，<strong>软件设计</strong>一般分为概要设计和详细设计，它们之间的关系是全局和局部。</li><li><strong>面向对象程序设计原则</strong>包括开闭原则、里氏替换原则、单一职责原则和依赖倒转原则。<ul><li><strong>开闭原则</strong>：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。抽象化是开闭原则的关键           </li><li><strong>单一职责原则</strong>：一个类只负责一个功能领域中的相应职责。或者说，一个类，应该只有一个引起它变化的原因。</li><li><strong>里氏替换原则</strong>：所有引用基类（父类）的地方必须能透明的使用其子类的对象。（实现开闭原则的重要方式之一）</li><li><strong>依赖倒转原则</strong>：抽象不应该依赖于细节，细节应当依赖于抽象。</li><li><strong>合成复用原则</strong>：尽量使用对象组合，而不是继承来达到复用的目的。</li></ul></li><li>在软件结构化设计方法中，指导模块划分的最重要原则是高内聚、低耦合。</li><li>需求分析最终结果是产生需求规格说明书。</li><li>模块独立性中，使得每个模块只完成一个相对独立的特定子功能，并且与其它模块的关系很简单。</li><li><strong>产品需求</strong>又可以细分为功能性需求和非功能性需求。</li><li><strong>需求内容来源</strong>于干系人、组织规章制度、业务过程和现有系统。</li><li>在<strong>需求工程过程</strong>中，最重要的工程活动包括需求获取、需求分析与建模、需求验证和需求管理。</li><li><strong>软件设计原则</strong>是系统分解和模块设计的基本标准，应用这些原则可以使代码更加灵活、易于维护和扩展。一些通用的原则包括抽象、封装、模块化、层次化和复用。</li><li>在测试过程中，需要考察<strong>模块间的接口</strong>和<strong>各模块之间联系**</strong>的测试属于集成测试。</li><li><strong>软件测试用例</strong>主要由输入用例和预期输出结果两部分组成</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-软件工程概述&quot;&gt;&lt;a href=&quot;#1-软件工程概述&quot; class=&quot;headerlink&quot; title=&quot;1. 软件工程概述&quot;&gt;&lt;/a&gt;1. 软件工程概述&lt;/h3&gt;&lt;h4 id=&quot;软件的概念和特点&quot;&gt;&lt;a href=&quot;#软件的概念和特点&quot; class=&quot;headerlink&quot; title=&quot;软件的概念和特点&quot;&gt;&lt;/a&gt;软件的概念和特点&lt;/h4&gt;&lt;p&gt;&lt;code&gt;软件&lt;/code&gt;(广义)：计算机系统中与硬件相互依存的一部分  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;程序&lt;/strong&gt;：计算机可以接受的一系列指令，运行时可以提供所要求的功能和性能。&lt;br&gt;&lt;strong&gt;数据&lt;/strong&gt;：使得程序能够适当地操作信息的数据结构。&lt;br&gt;&lt;strong&gt;文档&lt;/strong&gt;：描述程序的研制过程、方法和使用的图文资料。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
