<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hi, Dai</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://daisine.me/"/>
  <updated>2018-09-23T07:39:58.000Z</updated>
  <id>http://daisine.me/</id>
  
  <author>
    <name>Dai Sine</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac OS X下连接校园网VPN [L2TP方式]</title>
    <link href="http://daisine.me/macvpn/"/>
    <id>http://daisine.me/macvpn/</id>
    <published>2018-09-20T00:32:10.000Z</published>
    <updated>2018-09-23T07:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>以重庆大学校园网VPN为例，操作系统OS X 10.11.6。</p><ul><li>首先查看<a href="http://net.cqu.edu.cn/info/1025/1255.htm" target="_blank" rel="noopener">重庆大学校园网VPN说明</a>：</li></ul><blockquote><p>重庆大学VPN支持<strong>标准的PPTP和L2TP两种方式</strong>。用户在网络连接的设置中，新增虚拟专网VPN连接。VPN的地址请填写域名vpn.cqu.edu.cn，系统会自动解析相应地址。</p></blockquote> <a id="more"></a> <ul><li>打开<code>系统偏好设置</code> - &gt; <code>网络</code> - &gt; <code>右下角＋号</code>新建VPN服务<ul><li>接口：VPN</li><li>VPN类型：IPSec上的L2TP</li><li>服务名称：CQU VPN</li></ul></li><li>新建VPN完成后，<code>服务器地址</code>填写为<code>vpn.cqu.edu.cn</code>，账户名称为学号。</li><li><p>现在点击<code>链接</code>，输入密码(默认为身份证后六位)会提示，IPSec 共享密钥丢失。需要在终端进行进一步设置：</p><ul><li>在/etc/ppp/下创建options文件：<br><code>sudo vim /etc/ppp/options</code></li><li>在options文件中输入(键入A - &gt; INSERT)并保存(ESC - &gt; wq)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plugin L2TP.ppp</span><br><span class="line">l2tpnoipsec</span><br></pre></td></tr></table></figure></li><li><p>回到VPN设置，选择<code>高级</code>- &gt; <code>选项</code> - &gt; <code>通过VPN连接发送所有流量</code></p></li><li>再次点击连接VPN，连接成功。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以重庆大学校园网VPN为例，操作系统OS X 10.11.6。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先查看&lt;a href=&quot;http://net.cqu.edu.cn/info/1025/1255.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;重庆大学校园网VPN说明&lt;/a&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;重庆大学VPN支持&lt;strong&gt;标准的PPTP和L2TP两种方式&lt;/strong&gt;。用户在网络连接的设置中，新增虚拟专网VPN连接。VPN的地址请填写域名vpn.cqu.edu.cn，系统会自动解析相应地址。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记11 文件系统</title>
    <link href="http://daisine.me/os11/"/>
    <id>http://daisine.me/os11/</id>
    <published>2018-07-03T06:19:18.000Z</published>
    <updated>2018-10-29T03:16:09.247Z</updated>
    
    <content type="html"><![CDATA[<h4 id="文件系统接口-用户角度"><a href="#文件系统接口-用户角度" class="headerlink" title="文件系统接口(用户角度)"></a>文件系统接口(用户角度)</h4><h5 id="文件概念"><a href="#文件概念" class="headerlink" title="文件概念"></a>文件概念</h5><ul><li><strong><code>文件</code></strong>是逻辑外存单元的最小分配单元。</li><li><strong>类型</strong><ul><li>数据：数字字符，二进制…</li><li>程序</li></ul></li><li><p><strong>文件结构</strong></p><ul><li>无： 一个字节序列</li><li>简单的记录结构：①行 ②固定长度 ③可变长度</li><li>复杂结构：①格式化文档 ②对象文件 ③可执行文件</li></ul><a id="more"></a></li><li><strong>谁决定文件结构？</strong><ul><li>操作系统：可执行文件和共享库文件的结构</li><li>程序</li></ul></li><li><strong>文件属性</strong>：所有文件的信息都保存在目录结构中。<ul><li>名称：文件符号名称是唯一的、按照人们易读取的形式保存。</li><li>标识符：标示文件系统内文件的唯一标签，通常为人不可读。</li><li>类型：被支持不同类型的文件系统所使用。</li><li>位置：该信息指向设备和设备上文件位置的指针。</li><li>大小：文件当前大小，也可包括文件允许的最大容量值。</li><li>保护：决定谁能读、写、执行等的访问控制信息。</li><li>时间，日期和用户标识：文件创建、上次修改和赏赐访问的相关信息。这些数据用于保护、安全和使用跟踪。</li></ul></li><li><strong>文件操作</strong><ul><li>创建，打开，关闭，读，写，在文件内重定位(搜索目录相应条目)，删除，截短(删除内容保留属性，长度设置为0并释放)。</li><li>打开文件：当一个文件被打开时，除了存储在设备上的信息之外，还会执行几条数据来管理打开的文件<br>①<strong>文件指针</strong>：指向上次读取/写入位置的指针，这种指针对于打开文件的每个进程唯一。<br>②<strong>文件打开计数器</strong>：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间会不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件。该计数器跟踪打开和关闭的数量，当该计数为0 时，系统关闭文件，删除该条目。<br>③<strong>文件磁盘位置</strong>：绝大多数文件操作都要求系统修改文件数据。该信息保存在内存中以免为每个操作都从磁盘中读取。<br>④<strong>访问权限</strong>：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等)。该信息保存在进程的打开文件表中以便操作系统能允许或拒绝之后的 I/O 请求。</li></ul></li><li><strong>文件类型</strong><br><img src="https://i.loli.net/2018/06/19/5b2914df7a5d7.png" width="65%" height="80%"></li><li><strong>文件访问</strong>：文件访问<ul><li>顺序访问：从头开始读取所有字节/记录。不能跳转，但当存储设备是磁带时可以倒带或备份。</li><li>随机访问/直接访问：读/写顺序无限制。字节/记录以任何顺序读取，这种访问对数据库很重要。</li></ul></li></ul><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><ul><li><strong>目录操作</strong>：<ul><li>搜索文件</li><li>创建文件</li><li>删除文件</li><li>遍历目录</li><li>重命名文件</li><li>跟踪文件系统</li></ul></li><li><strong><code>单层目录结构</code></strong><ul><li>限制：①文件必须具有唯一名称(命名问题) ②(文件过多)分组问题<br><img src="https://i.loli.net/2018/06/19/5b28ff48b0896.png" width="55%" height="80%"></li></ul></li><li><strong><code>双层目录结构</code></strong><ul><li>为每个用户创建<strong>独立目录</strong></li><li>特点：①文件或目录可以按其路径定位 ②不同的用户可以使用相同文件名<br><img src="https://i.loli.net/2018/06/19/5b28ff4703f01.png" width="55%" height="80%"></li></ul></li><li><strong><code>树状目录结构</code></strong><ul><li>分组能力</li><li>禁止共享文件或目录</li><li>路径名有两种形式：①绝对路径名 ②相对路径名</li><li>每个进程都有一个当前目录，在启动时分配给它。<br><img src="https://i.loli.net/2018/06/19/5b28ff481348c.png" width="55%" height="80%"></li></ul></li><li><strong><code>无环图目录</code></strong>：树状结构目录的扩展<ul><li>允许目录含有共享子目录和文件。同一文件或子目录可出现在两个不同目录中。</li><li>某些操作系统不支持无环图目录，例如MS-DOS</li><li>UNIX/LINUX和Windows（7+）通过<strong>符号链接</strong>支持它<br><img src="https://i.loli.net/2018/06/19/5b29157df0de1.png" width="55%" height="80%"></li></ul></li></ul><h5 id="文件系统挂载"><a href="#文件系统挂载" class="headerlink" title="文件系统挂载"></a>文件系统挂载</h5><ul><li>文件系统在被系统上的进程使用之前必须安装/挂载。</li><li>目录结构可以建立在多个卷上。这些卷必须安装以使它们在文件系统命名空间可用。(U盘)</li><li>文件系统的安装位置称为<strong>安装点</strong>，为一个空目录。<ul><li>Windows操作系统在引导过程中安装包含FAT（-12，-16，-32）或NTFS文件系统的所有分区，分别是“C：”，“D：”等。</li><li>在UNIX / Linux中，系统管理员必须发出命令来在设备中安装文件系统。<code>mount -t iso9660 / mnt / cdrom / dev / cdrom</code></li></ul></li></ul><h5 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h5><ul><li>在多用户系统上共享文件是可取的。</li><li>大多数系统通过其唯一的用户标识或UID来识别用户。除了UID，一些系统还实现了组功能</li><li>每个组都分配一个唯一的组标识或GID。每个用户可以在一个或多个组中</li><li>当文件或目录最初创建时，它与用户的UID和GID相关联。拥有文件的用户是该文件的所有者。</li></ul><h5 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h5><ul><li>文件所有者应该能够控制可以完成什么以及由谁来完成</li><li>访问类型：读取（R），写入（W），执行（X），添加，删除，列表</li><li>访问控制列表（ACL）指定用户名和每个用户允许的访问类型。<ul><li>它用于执行细粒度的文件和目录保护。 ACL的主要问题是它们的长度。</li><li>因此，最常见的方法是将UNIX样式保护与ACL结合使用。</li><li>例如，Windows NT或更高版本以及Solaris 2.6或更高版本使用此组合方法。</li></ul></li></ul><h4 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h4><h5 id="文件系统结构"><a href="#文件系统结构" class="headerlink" title="文件系统结构"></a>文件系统结构</h5><ul><li>文件<ul><li>逻辑存储单元</li><li>相关信息的集合</li><li><strong>文件控制块(FCB)</strong>：包含文件的所有信息。在UNIX中，FCB通常称为inode</li></ul></li><li>文件系统：提供对磁盘的高效且便捷的访问，用以轻松地存储、定位和提取数据。<ul><li>在二级存储器中，采用分层结构实现文件系统能够最大限度地减少重复的代码。<br><img src="https://i.loli.net/2018/06/19/5b29075ab4052.png" width="20%" height="80%"></li></ul></li><li>一个典型的文件控制块FCB：<br><img src="https://i.loli.net/2018/06/19/5b29078f88bfe.png" width="35%" height="80%"></li></ul><h5 id="虚拟文件系统-VFS"><a href="#虚拟文件系统-VFS" class="headerlink" title="虚拟文件系统(VFS)"></a>虚拟文件系统(VFS)</h5><ul><li>问题：<ul><li>操作系统如何把多个文件系统整合成一个目录？</li><li>用户如何在访问文件系统空间时，可以无缝地在文件系统之间移动？</li></ul></li><li>虚拟文件系统(VFS)：</li><li>大多数操作系统包括UNIX使用面向对象的技术来简化，组织和模块化实现过程。  <ul><li>一个通用的文件系统接口与文件系统实现分离，文件系统接口包含“打开”，“关闭”，“读取”，“写入”和“查找”等系统调用。<br><img src="https://i.loli.net/2018/06/19/5b2909f0cae33.png" width="50%" height="80%"></li></ul></li><li><strong><code>VFS接口</code></strong>有两个重要功能：<ul><li>VFS层通过定义一个清晰的VFS接口，以将文件系统的通用操作和具体实现分开。</li><li>VFS提供了在网络上唯一标识一个文件的机制。VFS基于名为<strong>vnode</strong>的文件表示结构，该结构包含一个数值标识符以表示位于整个网络范围的唯一文件。</li></ul></li></ul><h5 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h5><ul><li>一些操作系统（包括UNIX）将目录完全视为文件<ul><li>它为每个文件或其子目录保存两条信息：文件/子目录名称和指向文件/子目录的FCB的指针（它们通常被组织成一个C“struct dirent”）</li></ul></li><li>一个目录可能包含很多文件或子目录，如何组织这些“dirent”？(Unix的一个结构体)</li><li><strong>线性列表</strong>：使用存储文件名和数据快指针的线性列表。<ul><li>√ 实现简单</li><li>× 搜索耗时</li></ul></li><li><strong>哈希表</strong>：线性列表存储结构 + 哈希数据结构<ul><li>√ 减少目录搜索时间，插入和删除也很简单。</li><li>× 其通常固定的大小和哈希函数对大小的依赖性。<strong>增长困难。</strong></li></ul></li><li>大多数操作系统使用“线性列表”来组织目录。</li></ul><h5 id="分配方法"><a href="#分配方法" class="headerlink" title="分配方法"></a>分配方法</h5><ul><li>如何为文件分配空间以便利用磁盘空间并快速访问文件？</li><li>三种主要分配方法<ol><li>连续分配</li><li>链接分配</li><li>索引分配</li></ol></li></ul><h5 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h5><ul><li>要求每个文件在磁盘上占用一组连续块。</li><li>优缺点：<ul><li>√ 简单：只有起始位置（块号）和长度（块数）保存在FCB中</li><li>√ 支持随机访问</li><li>√ 对缓存友好</li><li>× 产生外部碎片：动态存储分配问题</li><li>× 难以扩展文件<br><img src="https://i.loli.net/2018/06/19/5b290e7e8879c.png" width="50%" height="80%"></li></ul></li></ul><h5 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h5><ul><li>每个文件都是磁盘块的链接列表。<ul><li>FCB包含文件<strong>第一块的指针</strong>和<strong>最后一块的指针</strong>。</li><li>每个块包含一个指向下一个块的指针。</li><li>这些指针对用户不可见，因此，如果每个块是512字节,磁盘地址（指针）为4个字节，则用户看到508个字节的块。</li></ul></li><li>优缺点：<ul><li>√ 简单：只需要起始地址</li><li>√ 不浪费空间</li><li>√ 指针需要额外的空间</li><li>√ 没有随机存取，(用单项链表)只能顺序访问</li><li>× 可靠性：分散在整个磁盘上的指针</li></ul></li><li>指针的开销可以通过将几个块收集到一个称为群集的较大块中来降低</li><li>为了解决简单链接分配的问题，每个分区开始处的一段磁盘被放置在一旁，以包含一个包含文件系统所有指针的表。</li><li>文件分配表(FAT)：一个简单但有效的磁盘空间分配方法，<strong>用于MS-DOS和OS/2</strong>。<ul><li>每一个卷的开始部分用于存储该FAT。</li><li>每块都在该表中有一项。</li><li>该表可以通过块号码来索引。<br><img src="https://i.loli.net/2018/06/19/5b29116fb0aca.png" width="60%" height="80%"></li></ul></li></ul><h5 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h5><ul><li>将所有指向文件磁盘块的指针合并到一个位置：索引块。索引块包含一系列磁盘块地址。</li><li>解决了连续分配的外部碎片和大小声明问题。<br><img src="https://i.loli.net/2018/06/19/5b2912b622534.png" width="45%" height="80%"></li><li>优缺点<ul><li>√ 支持直接/随机访问</li><li>√ 没有外部碎片(但有索引块的开销)。</li><li>× 需要索引表。  </li></ul></li><li>索引块的大小：<ol><li>链接方案</li><li>多级索引</li><li>(以上两种)组合方案 (这是大多数UNIX文件系统使用的方案)<br><img src="  https://i.loli.net/2018/06/19/5b2913335d5d3.png" width="55%" height="80%"></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;文件系统接口-用户角度&quot;&gt;&lt;a href=&quot;#文件系统接口-用户角度&quot; class=&quot;headerlink&quot; title=&quot;文件系统接口(用户角度)&quot;&gt;&lt;/a&gt;文件系统接口(用户角度)&lt;/h4&gt;&lt;h5 id=&quot;文件概念&quot;&gt;&lt;a href=&quot;#文件概念&quot; class=&quot;headerlink&quot; title=&quot;文件概念&quot;&gt;&lt;/a&gt;文件概念&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;文件&lt;/code&gt;&lt;/strong&gt;是逻辑外存单元的最小分配单元。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;数据：数字字符，二进制…&lt;/li&gt;
&lt;li&gt;程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;文件结构&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无： 一个字节序列&lt;/li&gt;
&lt;li&gt;简单的记录结构：①行 ②固定长度 ③可变长度&lt;/li&gt;
&lt;li&gt;复杂结构：①格式化文档 ②对象文件 ③可执行文件&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记10 虚拟内存</title>
    <link href="http://daisine.me/os10/"/>
    <id>http://daisine.me/os10/</id>
    <published>2018-07-03T06:19:15.000Z</published>
    <updated>2018-10-29T03:16:41.459Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul><li>自从有了计算机以来，我们就希望能够方便、高效地使用(今天仍然)十分有限的内存：<ol><li>用户总是可以认为自己计算机的<strong>内存大到足够运行任何程序</strong>。</li><li>程序员可以认为自己的程序将运行<strong>在巨大、连续的内存</strong>中。不需要用overlay或swap等技术来自己管理内存。</li><li>进程在运行过程中<strong>不能访问(包括读写)其他进程的数据</strong>，更<strong>不能访问属于操作系统的数据</strong>。而且某一个进程引起的问题不会波及到操作系统或其他进程。</li><li>由于内存有限，应该尽可能地<strong>共享一些公用的代码和数据</strong>。</li></ol></li><li><p>前面介绍的各种技术解决了上述问题的某一些方面，但没有提出一个整体的解决方案。</p><ul><li>虚拟内存技术基于已有的各种技术给出了一个完整的解决方案, 是20世纪计算机技术最重要的发明之一。</li></ul><a id="more"></a></li></ul><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><ul><li><strong><code>虚拟内存</code></strong>：将用户逻辑内存与物理内存的分离。<ul><li>为每个进程提供一个巨大的，连续的和私有的逻辑内存，可能比物理内存大得多。只有部分程序需要在内存中执行。</li><li>允许地址空间被多个进程共享，更有效的进程创建。<br><img src="https://i.loli.net/2018/06/19/5b28aed7c426e.png" width="40%" height="80%"></li></ul></li><li>虚拟内存可通过以下方式实现：<ul><li><strong>按需调页</strong></li><li>按需分段  </li></ul></li></ul><h4 id="按需调页"><a href="#按需调页" class="headerlink" title="按需调页"></a>按需调页</h4><ul><li><strong><code>按需调页</code></strong>：仅在需要时才调入相应的页，即<strong><code>懒惰交换</code></strong>。<ul><li>需要更少的 I/O 。</li><li>需要更少的内存。</li><li>响应更快。</li><li>更多的进程。</li></ul></li><li><strong>交换程序</strong>是对<strong>整个进程</strong>进行操作，而<strong>调页程序</strong>只对<strong>单个页</strong>进行操作。 因此按需调页需要使用调页程序。<br><img src="https://i.loli.net/2018/06/19/5b28b017d35a8.png" width="45%" height="80%"></li><li><strong><code>有效-无效位</code></strong>：当操作系统调度某个进程运行时，判断该进程的页面是否已经调入内存中。<ul><li>！每个页表项(PTE)都有一个有效无效位关联。</li><li>设置为“有效”：关联页面合法且在内存中。</li><li>设置为“有效”：该页面不合法(不在该进程的逻辑地址空间中)，或者是合法的，但是在磁盘上。<br><img src="https://i.loli.net/2018/06/19/5b28b144e932a.png" width="45%" height="80%"></li></ul></li><li>在MMU中的地址转换期间，如果PTE中的有效-无效位是“无效”<ol><li>CPU触发一个<strong><code>页面错误陷阱</code></strong>(<strong>page-fault</strong> trap)陷入操作系统。这种陷阱是由于操作系统未能将所需的页调入内存中引起的。</li><li>操作系统检查内部页表（通常与PCB一起保存）来确定该引用是合法还是非法的地址访问。<br>①引用非法，OS终止进程；②引用有效但尚未调入页面，OS将调入该页面。</li><li>找到一个空闲帧。</li><li>调度一个磁盘操作，以便将所需的页面调入刚分配的帧。</li><li>当磁盘操作完成后，修改进程的内部表和页表，以表示该页已在内存中</li><li>(CPU自动执行)重新开始因陷阱而中断的指令。进程现在能访问所需的页，就好像它似乎总在内存中。<br><img src="https://i.loli.net/2018/06/19/5b28b58f5e1f1.png" width="58%" height="80%"></li></ol></li><li>架构要求(硬件)<ol><li><strong>页表</strong>：该表能够通过<code>有效-无效位</code>或保护位，将条目设定为无效。</li><li><strong>次级存储器</strong>：该次级存储器用来保护不在内存中的页。次级存储器通常为快速硬盘。它通常称为交换设备，用于交换的这部分磁盘称为<strong><code>交换空间</code></strong>。</li><li>能在发生页面错误后<strong>准确重新执行指令</strong>。在出现页错误时，保持中断进程的状态(寄存器、条件代码、指令计数器)，必须能够按完全相同的位置和地址重新开始执行进程)。对于绝大多数情况，这种要求容易满足。</li></ol></li></ul><h4 id="页面置换"><a href="#页面置换" class="headerlink" title="页面置换"></a>页面置换</h4><ul><li>如果增加了多道程序的程度。那么会<strong><code>过度分配</code></strong>内存。</li><li>发生页面错误时，没有可用的空闲帧。如何进行？<ul><li>在内存中找到一个没有被充分使用的帧，将其分页。</li></ul></li><li><strong><code>页面替换</code></strong>：修改页<code>错误处理程序</code>以包括页置换。<strong>页面置换可以在较小的物理内存上提供大的虚拟内存</strong><br><img src="https://i.loli.net/2018/06/19/5b28ba339487d.png" width="58%" height="80%"><ol><li>查找所需页在磁盘上的位置。</li><li>查找一个空闲帧：<br>①如果有空闲帧，那么就使用它。<br>②如果没有空闲帧，那么就使用<strong>页面置换算法</strong>以选择一个<strong>牺牲“帧”</strong>。<br>③将“牺牲”帧的内容写到磁盘上，改变页表和帧表。</li><li>将所需页读入(新)空闲帧，改变页表和帧表。</li><li>重启用户进程。<br><img src="https://i.loli.net/2018/06/19/5b28bb1c5ee42.png" width="58%" height="80%"></li></ol></li><li>注意：<ul><li>如果没有帧空闲，则需要两次页传输：一次换入和一次换出。页面处理时间加倍。</li><li>可以通过将每页或帧与<strong>修改位</strong>（或<strong>脏位</strong>）通过硬件关联，来降低额外开销。<br>①每当页面被修改时，硬件就会设置该页的修改位以表示该页已修改。<br>②<strong>当修改位被设置时，才需要进行页换出操作。</strong></li></ul></li><li>页面置换是按需调页的基础。</li></ul><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><ul><li>算法目标：得到最低的页面错误率。</li><li>为了方便研究各种页面置换算法，计算各个算法所产生的页面错误，引入如下概念：<ul><li>引用串：内存引用的字符串。 通常以页面为单位。</li></ul></li><li>通过在引用串上运行页面置换算法，并计算该引用串上的<code>页面错误</code>数来评估算法。</li><li>页错误和帧数量图：<br><img src="https://i.loli.net/2018/06/19/5b28bde285b5f.png" width="40%" height="80%"></li><li>类型<ul><li>FIFO页置换</li><li>最优置换</li><li>LRU页置换</li><li>近似LRU页置换（二次机会算法）</li></ul></li></ul><h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><ul><li>页面错误率：0 ≤ p ≤ 1.0。<ul><li>如果p = 0，则不存在页面错误;</li><li>如果p = 1，则每个引用都会出现页面错误</li></ul></li><li>有效访问时间(EAT)<br>EAT = (1 - p) × (内存访问时间)+p × (页面错误时间)</li><li>一般来说，内存访问时间远小于处理页面错误的时间。因此，我们可以假设EAT与p成正比，即页面错误率。</li></ul><h5 id="FIFO页置换"><a href="#FIFO页置换" class="headerlink" title="FIFO页置换"></a>FIFO页置换</h5><ul><li>FIFO页置换：置换最旧的页。<br><img src="https://i.loli.net/2018/06/19/5b28c00a3454e.png" width="60%" height="80%"></li><li><strong><code>Belady</code>异常</strong>：一般情况下，page-fault会随着frame的数量增加而减少。但如果采用FIFO算法，<strong>情况有时并非如此</strong>。<br><img src="https://i.loli.net/2018/06/19/5b28c00a2b78c.png" width="40%" height="80%"></li></ul><h5 id="最优置换-OPT-MIN"><a href="#最优置换-OPT-MIN" class="headerlink" title="最优置换(OPT / MIN)"></a>最优置换(OPT / MIN)</h5><ul><li>最优置换：置换最长时间不会使用的页。</li><li>最优页面置换算法是所有算法中产生页错误率最低的。</li><li>最优置换难以实现，因为需要参考串的未来的知识。最优算法主要用于研究。<br><img src="https://i.loli.net/2018/06/19/5b28c1260fab8.png" width="60%" height="80%"></li></ul><h5 id="LRU页置换-最近最少使用算法"><a href="#LRU页置换-最近最少使用算法" class="headerlink" title="LRU页置换/最近最少使用算法"></a>LRU页置换/最近最少使用算法</h5><ul><li>FIFO算法使用的是页面调入的时间。OPT算法使用的是页将来使用的时间。</li><li>LRU页置换：置换最近最少使用的页面。近似的最佳页面替换。<br><img src="https://i.loli.net/2018/06/19/5b28c20f69818.png" width="60%" height="80%"></li><li>LRU置换可能需要一定的硬件支持来为页帧确定一个排序序列。有两种可行实现：①计数器 ②栈</li></ul><h5 id="近似LRU页置换"><a href="#近似LRU页置换" class="headerlink" title="近似LRU页置换"></a>近似LRU页置换</h5><ul><li>二次机会页置换算法/时钟置换算法：基本算法是FIFO置换算法。<ul><li>当要选择一个页时，检查其引用位。</li><li>如果值为0，则直接置换。如果访问位是1，就给它第二次机会。并选择下一个FIFO页面。</li><li>当一个页面得到第二次机会时，它的访问位就清为0，它的到达时间就置为当前时间。如果该页在此期间被访问过，则访问位置为1。  </li></ul></li><li>可以采用循环队列实现。<br><img src="https://i.loli.net/2018/06/19/5b28c30cbe814.png" width="45%" height="80%"><br><img src="https://i.loli.net/2018/06/19/5b28c30cbf0e9.png" width="50%" height="80%"></li></ul><h4 id="为什么虚拟内存运行良好？"><a href="#为什么虚拟内存运行良好？" class="headerlink" title="为什么虚拟内存运行良好？"></a>为什么虚拟内存运行良好？</h4><ul><li><strong><code>局部模型</code></strong>：<ul><li>局部：经常使用的页的集合。当进程执行时，它从一个局部移向另一个局部。</li><li>一个程序通常由多个不同局部组成。它们可能<strong>重叠</strong>(共享页面)。</li></ul></li><li>局部模型也是缓存工作正常的原因。</li><li>内存引用模式中的局部性：<br><img src="https://i.loli.net/2018/06/19/5b28c77b89a47.png" width="30%" height="80%"></li></ul><h4 id="颠簸"><a href="#颠簸" class="headerlink" title="颠簸"></a>颠簸</h4><ul><li>如果系统没有“足够”的帧，页面错误率非常高。 这导致：<ul><li>CPU利用率低。</li><li>长期调度员认为需要提高多程序的程度。</li><li>系统中增加了更多进程。</li></ul></li><li>颠簸：是一个系统忙于将页面导入和导出并且没有任何用处的情况。<ul><li>原因：所有局部大小的总和 &gt; 总内存大小<br><img src="https://i.loli.net/2018/06/19/5b28c84c5483c.png" width="40%" height="80%"></li></ul></li></ul><h4 id="工作集合模型"><a href="#工作集合模型" class="headerlink" title="工作集合模型"></a>工作集合模型</h4><ul><li><strong><code>工作集合模型</code></strong>是基于局部性假设的。<ul><li>该模型使用参数 &Delta; 定义<strong>工作集合窗口</strong></li><li>这最近 &Delta; 个引用的页面集合称为<strong>工作集合</strong>。因此，工作集是进程的局部性的近似值。</li></ul></li><li><p>将WSS<sub>i</sub>表示为最近进程P<sub>i</sub>的工作集。D为总的帧需求量。</p><ul><li>D = &Sigma; WSS<sub>i</sub></li><li>如果D &gt; 可用帧的数量，有的进程就会得不到足够的帧，从而会出现颠簸。<br><img src="https://i.loli.net/2018/06/19/5b28c9f434159.png" width="70%" height="80%"></li></ul></li><li><p>使用工作集合模型</p><ul><li>操作系统监视每个进程的工作集合，并为其分配大于其工作集合的帧数。</li><li>如果还有空闲帧，那么可以启动另一进程。</li><li>如果所有工作集合大小之后 &gt; 可用帧的总数，那么操作系统会选择暂停一个进程。</li><li>工作集合策略可以防止颠簸，并尽可能保持多道程序的程度。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;自从有了计算机以来，我们就希望能够方便、高效地使用(今天仍然)十分有限的内存：&lt;ol&gt;
&lt;li&gt;用户总是可以认为自己计算机的&lt;strong&gt;内存大到足够运行任何程序&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;程序员可以认为自己的程序将运行&lt;strong&gt;在巨大、连续的内存&lt;/strong&gt;中。不需要用overlay或swap等技术来自己管理内存。&lt;/li&gt;
&lt;li&gt;进程在运行过程中&lt;strong&gt;不能访问(包括读写)其他进程的数据&lt;/strong&gt;，更&lt;strong&gt;不能访问属于操作系统的数据&lt;/strong&gt;。而且某一个进程引起的问题不会波及到操作系统或其他进程。&lt;/li&gt;
&lt;li&gt;由于内存有限，应该尽可能地&lt;strong&gt;共享一些公用的代码和数据&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前面介绍的各种技术解决了上述问题的某一些方面，但没有提出一个整体的解决方案。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟内存技术基于已有的各种技术给出了一个完整的解决方案, 是20世纪计算机技术最重要的发明之一。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记09 内存管理</title>
    <link href="http://daisine.me/os9/"/>
    <id>http://daisine.me/os9/</id>
    <published>2018-07-03T06:17:35.000Z</published>
    <updated>2018-10-29T03:17:43.457Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内存管理介绍"><a href="#内存管理介绍" class="headerlink" title="内存管理介绍"></a>内存管理介绍</h4><ul><li>进程管理回顾 <ul><li>进程管理提供了一个虚拟的机器接口，让每一个进程都以为是自己在独占CPU，如下图所示:<br><img src="https://i.loli.net/2018/06/18/5b27ad8cd9ef4.png" width="50%" height="80%"></li></ul></li><li><p>内存管理的任务：提供一个虚拟的机器接口，让每一个进程都以为是自己在独占RAM。</p><a id="more"></a></li></ul><h4 id="基本方法-以MS-DOS为例"><a href="#基本方法-以MS-DOS为例" class="headerlink" title="基本方法 - 以MS-DOS为例"></a>基本方法 - 以MS-DOS为例</h4><ul><li>MS-DOS (Microsoft Disk Operating System)<ul><li>单用户、单任务 只能访问1MB内存：INTEL 8086/80286只有20根地址线</li><li>没有任何保护机制：INTEL 8086/80286没有提供硬件保护机制支持</li></ul></li><li>在MS-DOS中, MS-DOS自己要占用1/3左右; 剩余部分留给系统唯一的进程使用。</li><li>问题1：如果某个MS-DOS下的应用程序<strong>需要超过640K的内存才能运行</strong>,怎么办?</li><li><strong><code>覆盖</code></strong>：一种允许内存能分配的小于一个进程中所需空间的技术。<ul><li><strong>基本原理</strong>：只保留在任何给定时间需要的指令和数据。程序运行时<strong>并非任何时候都要访问程序及数据的各个部分</strong>，因此可以把用户空间分成一个固定区和若干个覆盖区。经常活跃的部分放在固定区，其余部分按调用关系分段。在覆盖区和外存(即磁盘)中屡次<strong>调入调出</strong>。除了程序本身外，程序员还要提供一个所谓的“overlay driver”来负责模块的调入调出。</li><li>无论进程在运行时占有多大的内存,在某一段时间内，它<strong>只会访问其中的一部分</strong>。</li><li><strong>打破</strong>了必须将一个进程的全部信息装入主存后才能运行的<strong>限制</strong>。</li></ul></li><li>目前覆盖技术已经<strong>很少被使用</strong>，除了在一些内存资源相当紧张的<code>嵌入式系统</code>中。</li><li><p>假设MS-DOS支持多任务,即系统中有多个进程。</p><ul><li>进程必须在内存中才能运行。</li><li>运行中的进程可能会申请额外的内存。</li></ul></li><li><p>问题2：假设系统目前有两个进程：P<sub>1</sub>和P<sub>2</sub>，而且系统已经没有内存可以使用。此时，正在运行的P<sub>1</sub>又要申请更多的内存才能继续运行，怎么办?</p></li><li><strong><code>交换</code></strong>：一个进程可以<strong>暂时</strong>从内存交换到backing-store，然后再加载到内存中<strong>继续执行</strong>。<ul><li>OS可以将(不在运行的)P<sub>2</sub>交换到backing-store中，同时释放P<sub>2</sub>所占用的内存，并分配给P<sub>1</sub>让其继续运行。</li><li>当调度器重新调度P<sub>2</sub>运行时，OS从backing-store中加载P2到内存继续运行。</li><li>此时可能要把P<sub>1</sub>交换到backing-store中以释放足够的内存空间供P<sub>2</sub>运行。<br><img src="https://i.loli.net/2018/06/18/5b27b3384a591.png" width="50%" height="80%"></li></ul></li><li><strong>Swap方法存在的限制</strong>：<ul><li>要求计算机必须有<strong>足够大的备份存储</strong>。备份存储一般是快速、大容量的硬盘。</li><li><strong>上下文切换要花费大量的时间</strong>：主要用于磁盘数据传输。调度算法的设计尤其重要，应尽量减少上下文切换。</li><li>被swap-out的进程必须被重新swap-in到<strong>相同的内存地址</strong>才能继续运行。</li></ul></li><li>这种原始的swap-in/out已经<strong>很少被使用</strong>。但是，swap的思想非常重要：当系统内存不足时，可以向备份存储“借”一部分来使用。</li></ul><h4 id="多任务系统的内存管理"><a href="#多任务系统的内存管理" class="headerlink" title="多任务系统的内存管理"></a>多任务系统的内存管理</h4><ul><li>多任务环境下会带来许多内存管理问题：<ul><li>重定位(relocation)问题</li><li>内存保护(protection)问题</li><li>内存分配(allocation)问题</li></ul></li></ul><h5 id="源程序变成进程的过程："><a href="#源程序变成进程的过程：" class="headerlink" title="源程序变成进程的过程："></a>源程序变成进程的过程：</h5><ul><li>程序员编写的<strong>源代码</strong>必须先被编译成<strong>目标文件</strong>。</li><li>然后通过<strong>链接器</strong>链接成<strong>可执行文件</strong>。</li><li>最后由操作系统<strong>加载</strong>可执行文件到内存从而<strong>形成进程</strong>。</li></ul><h5 id="重定位-amp-地址绑定概念"><a href="#重定位-amp-地址绑定概念" class="headerlink" title="重定位 &amp; 地址绑定概念"></a>重定位 &amp; 地址绑定概念</h5><ul><li>在多任务的环境中，可执行文件可能会被加载到内存中的任何位置运行。</li><li>链接器在生成可执行文件时必须确定程序中各个符号(如函数、全局变量)的地址。<ul><li>把程序中的符号映射为地址的过程叫做<strong><code>地址绑定</code></strong>。</li></ul></li><li>事实上，由于链接器无法预知程序将被加载到哪个内存位置，因此无法完成绝对的地址绑定。</li><li>因此，链接器只能假定程序中第一条指令的地址是0，从而用相对于它的<strong>偏移量</strong>来进行相对的<strong>地址绑定</strong>。</li><li>这样的程序只能被加载到0地址的内存运行。如果该程序被加载到其他非0的地址，必须对程序中所引用的地址进行修改才能运行，这个修改过程就称为<strong><code>重定位</code></strong>。</li><li>几个概念：<ul><li>逻辑地址：指<strong>程序中引用的地址</strong>，亦即CPU产生的地址。</li><li>物理地址：指系统中内存单元所看到的地址。</li><li>内存管理单元：指专门完成逻辑地址到物理地址<strong>转换</strong>的硬件单元，一般是CPU的一部分。<br><img src="https://i.loli.net/2018/06/18/5b27b73f52d0f.png" width="50%" height="80%"></li></ul></li><li>这里介绍的是最简单的重定位技术，只是冰山一角。</li><li>今天使用的操作系统(如Windows, Linux)所采用的重定位技术相当复杂，涉及到编译器、链接器、可执行文件、函数库、操作 系统内核和硬件等多个组件之间的协作才能完成。</li></ul><h5 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h5><ul><li>在多任务的环境中，必须要保护各个进程的内存不被其他进程访问或破坏。<ul><li>其实，即使在单任务的环境中也存在着操作系统如何保护自己不被应用程序访问或破坏的问题。 在MS-DOS中，应用程序可以合法地把MS-DOS的内核所占的内存全部破坏。</li></ul></li><li>对应用程序访问的每一个内存地址进行检查，看是否超出了内存范围。为了获得最好的性能，一般用<strong><code>内存管理单元</code></strong>(MMU)通过硬件来实现这种检查的功能。</li><li>内存保护是现代操作系统必备的功能之一，它需要硬件的支持才能实施保护。</li><li>后面讲解的各种内存管理方法都包含有内存保护的方法。<br><img src="https://i.loli.net/2018/06/18/5b27b98f2c33e.png" width="60%" height="80%"></li></ul><h5 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h5><ul><li>在多任务的环境中，操作系统需要为每个新创建的进程分配一定数量的内存才能运行。当进程退出时，操作系统要回收它所占用的内存。</li><li>操作系统如何有效地管理内存的分配和回收，以尽量满足进程的需求？这个问题也称为<strong><code>动态内存分配问题</code></strong>。</li><li>操作系统有一张表格，用于指出哪些内存可用和哪些内存已被占用。可用内存块称为<strong>孔</strong>。<ul><li>最初，所有内存都可用于用户进程。</li><li>当有新进程需要内存时，为该内存查找足够大的孔。</li><li>当一个进程终止时，它将释放内存，如果新的孔与其他孔相邻，这些相邻的孔合并形成一个更大的孔。<br><img src="https://i.loli.net/2018/06/18/5b27beab9738f.png" width="50%" height="80%"></li></ul></li><li>分配算法<ul><li><strong>首次适应</strong>：分配第一个足够大的孔。</li><li><strong>最佳适应</strong>：分配最小的足够大的孔。</li><li><strong>最差适应</strong>：分配最大的孔。 </li></ul></li><li>另一种方法：把系统内存分成固定大小的内存块，操作系统以块为单位进行内存的分配和释放。最终分配给进程的内存可能会比所请求要多一点，称多出来的这部分为<strong><code>内部碎片</code></strong>。</li><li>分配主要解决在多任务的环境中，操作系统采用什么算法进行内存的分配和回收，减少<strong><code>外部碎片</code></strong>或<strong>内部碎片</strong>，提高内存利用率。相对于外部碎片，内部碎片的情况不是很严重。</li><li>事实上，内存的分配和回收问题不仅出现在OS中，应用程序面临着同样的问题。<ul><li>当进程被创建时,操作系统会采用某种算法分配一块足够大的内存给进程,由进程自己管理(其中的一部分)。</li><li>eg. heap由进程自己管理。库函数new/delete(或malloc/free)就是操纵heap中的内存。它们所采用的分配与回收算法非常通用，相应的空间和时间利用率也很一般。在一个大型的项目中，已有的库函数可能不会满足应用的要求，需要自己开发更好的来替换它们以负责heap中内存的分配与回收。</li></ul></li></ul><h4 id="分页内存管理"><a href="#分页内存管理" class="headerlink" title="分页内存管理"></a>分页内存管理</h4><ul><li>基本内存管理方法存在着很大的限制：<ul><li>每个进程所占用的物理内存<strong>必须连续</strong>。</li><li>系统可能会<strong>产生大量外部碎片</strong>，最后不可避免地要进行compaction。</li><li>对<strong>整个进程</strong>进行(<strong>交换</strong>)swap-in/swap-out非常地<strong>耗时</strong>。</li></ul></li><li>分页很好地解决了上面的问题：<ul><li>进程所占用的物理内存<strong>不必连续</strong>。</li><li>没有外部碎片，但是会<strong>产生</strong>一定的<strong>内部碎片</strong>。</li><li>对进程所占用的<strong>部分内存</strong>进行swap-in/swapout。</li></ul></li><li>在早期，分页系统主要由<strong>硬件</strong>来实现。如今分页由<strong>硬件和操作系统</strong>共同完成。</li><li>基本概念：<ul><li>将物理内存分为固定大小的块，称为<strong><code>帧</code></strong>。</li><li>将逻辑内存也分为同样大小的块，称为<strong><code>页</code></strong>。</li><li><strong><code>页表</code></strong>包含每页所在物理内存的基地址，用于页到帧的映射。</li><li>页表的一个条目称为<strong><code>页表项（PTE）</code></strong>。</li></ul></li><li>把逻辑地址分成两部分: <ul><li>第一部分称为<strong><code>页号(p)</code></strong>，页号作为页表的索引。 </li><li>第二部分称为<strong><code>页偏移(d)</code></strong>。</li></ul></li><li>地址转换：在页表的帮助下，MMU把CPU产生的逻辑地址转换成物理地址。</li><li>过程如图：<br><img src="https://i.loli.net/2018/06/18/5b27c49f4dbb7.png" width="50%" height="80%"></li><li>两个例子：<br><img src="https://i.loli.net/2018/06/18/5b27c48c6758f.png" width="37%" height="80%"><br><img src="https://i.loli.net/2018/06/18/5b27c486e7c06.png" width="37%" height="80%"></li><li>页 &amp; 帧:<ul><li>它们的大小必须相同，都是2的幂次方。</li><li>具体由CPU体系结构决定，常见的有1K、4K、8K、4M等。</li></ul></li><li>地址划分<ul><li>如果逻辑地址空间的大小为2<sup>m</sup>，而page或frame的大小为2<sup>n</sup>(n &lt; m)，那么逻辑地址的划分如图所示：<br><img src="https://i.loli.net/2018/06/18/5b27c4e64d7b4.png" width="37%" height="80%"></li></ul></li></ul><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><ul><li>分页的一个重要方面是用户的内存视图和实际物理内存之间的明确分离。地址翻译硬件使这些差异得到调和。该<strong>映射对用户是隐藏的</strong>，由操作系统控制。</li><li>由于是操作系统在控制地址映射，它必须记录系统物理内存的使用状况。<ul><li>通常使用一个称为<strong><code>帧表</code></strong>的数据结构来保存系统中每一个帧的状态，如果占用，被哪个(些)进程的哪个页所占用。</li><li>为每一个进程保存一个页表，只包括进程所拥有的那些页。</li></ul></li></ul><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ul><li>页表必须被保存在内存中。CPU中的两个寄存器记录了它的信息:<ul><li>页表基寄存器(PTBR)：保存了页表的地址。</li><li>页表长度寄存器(PTLR)：保存了页表的大小。</li></ul></li><li>因此在分页中,每一个内存访问都需要两次内存操作：一次访问页表，一次访问内存数据。考虑到CPU访问内存的频率，这种<strong>地址转换成了系统性能的颈瓶</strong>。</li><li>为了提高地址转换效率，MMU中包含了一个高速缓存称为<strong><code>转换表缓冲区(TLBs)</code></strong>。</li><li>TLB条目由<strong>键和值</strong>组成，当关联内存根据定值查找时，会同时与所有键进行比较，如果找到条目，那么就得到相应的值域。<ul><li>TLB这种查找方式比较快。但由于硬件昂贵，通常TLB的条目数并不多，在64-1024之间。</li><li>A的地址转换：如果A在TLB（<strong>TLB命中</strong>）中，则将帧取出。否则，从<strong>内存中的页表获取帧。</strong><br><img src="https://i.loli.net/2018/06/18/5b27c9366d11f.png" width="47%" height="80%"></li></ul></li><li><strong>性能</strong>：假设<ul><li>TLB查找时间 = x</li><li>存储器周期时间为1微秒（10<sup>-6</sup>秒)</li><li>TLB命中率 = y，在TLB中找到页码的次数的概率百分比。</li></ul></li><li>有效访问时间 EAT = (1 + x) y + (2 + x) (1 - y) = 2 + x - y</li></ul><h5 id="内存保护-1"><a href="#内存保护-1" class="headerlink" title="内存保护"></a>内存保护</h5><ul><li>在<strong>分页系统</strong>中，<strong>内存保护是以页为单位</strong>。 <ul><li>保护信息通常都保存在PTE中， 可以提供只读、读写和执行(RWX - Read, Write, eXecute)保护。</li></ul></li><li>此外，不是所有的PTE都可以使用。因此，PTE中的一位表示该PTE是否可以使用(valid/invalid)。<ul><li>仅当该位有效时，MMU才能用它进行地址转换。 否则，MMU将通过异常向OS报告错误。<br><img src="https://i.loli.net/2018/06/20/5b29bf28312c1.png" width="50%" height="80%"></li></ul></li></ul><h5 id="页表问题"><a href="#页表问题" class="headerlink" title="页表问题"></a>页表问题</h5><ul><li>假设：<ul><li>逻辑地址空间大小：2<sup>32</sup>，即4GB。</li><li>page和frame的大小：2<sup>12</sup>，即4KB。</li><li>sizeof(PTE) = 4B。</li></ul></li><li>一个页表要消耗多少内存?<ul><li>(2<sup>32</sup> / 2 <sup>12</sup>) × 4 = 4MB</li></ul></li><li>记住：每一个进程都需要一个页表。</li><li>一个只有256MB内存的系统如何能同时运行几十个进程呢?</li></ul><h5 id="页表结构"><a href="#页表结构" class="headerlink" title="页表结构"></a>页表结构</h5><ul><li>事实上，很少的进程会使用整个地址空间(如32位机器上的4GB和64位机器上的2<sup>64</sup>B );<ul><li>页表中大部分的PTE都是处于invalid状态。 </li><li>OS无法预测一个进程的页表大小，因此只能根据进程使用内存的情况动态地伸缩。 </li><li>显然线性的页表结构太简单，不能满足这个要求，需要新的页表结构。</li></ul></li><li>现有的页表结构:<ul><li>层次型页表 Hierarchical Page Tables</li><li>哈希页表 Hashed Page Tables</li><li>反向页表 Inverted Page Tables</li></ul></li></ul><h5 id="层次型页表"><a href="#层次型页表" class="headerlink" title="层次型页表"></a>层次型页表</h5><ul><li>这种方法采用“树”结构来组织页表,形成一个层次结构的页表。<ul><li>根据这颗树的深度可以分为:一、二、三级页表等。其中，一级页表(也称为单级页表)就退化成了线性页表。</li><li>这里以32位逻辑地址、页面大小为4KB为例来讲解二级页表。</li></ul></li><li>二级页表设计：<ul><li>把一个巨大的线性页表分割成很多小的页表。</li><li>然后通过一个称为<strong><code>外页表</code></strong>(outer page table)的表把这些小页表组织起来。<br><img src="https://i.loli.net/2018/06/19/5b2895ea7742b.png" width="40%" height="80%"></li><li>采用二级页表的逻辑地址与地址转换<br><img src="https://i.loli.net/2018/06/19/5b2896f44e766.png" width="46%" height="80%"><br><img src="https://i.loli.net/2018/06/19/5b28982d23bff.png" width="35%" height="80%"></li></ul></li></ul><h4 id="帧管理"><a href="#帧管理" class="headerlink" title="帧管理"></a>帧管理</h4><ul><li>前面介绍了页面的管理，以及页面到帧的映射。但是，<strong>最终保存数据的地方是帧</strong>，而不是页面。 </li><li>操作系统需要管理系统中所有帧的分配和回收,<ul><li>当进程被创建时，操作系统要分配足够多的帧给它，并在该进程的页表中做相应的映射。</li><li>当进程退出时，操作系统回收它所占用的帧。</li></ul></li><li>最简单的方法是维护一个空闲帧链表。如图所示:<br><img src="https://i.loli.net/2018/06/19/5b2897f562b1d.png " width="47%" height="80%"></li></ul><h4 id="页面共享"><a href="#页面共享" class="headerlink" title="页面共享"></a>页面共享</h4><ul><li>在<strong>分页系统</strong>中,显然应该<strong>以页面为单位进行内存共享</strong>。<ul><li>eg. 假设系统中有三个用户同时运行某个编辑器在编辑各自的文件，显然编辑器的代码可以被共享，而各自的文件数据则是私有的。<br><img src="https://i.loli.net/2018/06/19/5b28990756fee.png" width="47%" height="80%"></li></ul></li></ul><h4 id="分段内存管理"><a href="#分段内存管理" class="headerlink" title="分段内存管理"></a>分段内存管理</h4><ul><li>为什么分段？<ul><li>通常用户<strong>不会</strong>将内存视为一个<strong>线性字节数组</strong>，有的包含指令而其它的包含数据。</li><li>用户通常愿意将内存视为一组<strong>长度不同的段的集合</strong>。分段就是支持这种</li></ul></li><li><strong><code>分段</code></strong>把进程的<strong>逻辑地址空间</strong>分成一个个<strong>大小不等</strong>的段，每一段集中了一种类型的数据，如代码，数据，栈等等。<ul><li>与分页系统一样，这些段在物理内存中也不一定是连续的</li></ul></li></ul><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><ul><li><p>逻辑地址由有序对组成：&lt;segment-number, offset&gt; (&lt;段号，段内偏移&gt;)。(为了简单，段是编号的段号而不是通过段名来引用)<br><img src="https://i.loli.net/2018/06/19/5b28ab03eefee.png" width="20%" height="80%">&lt;img src=”<a href="https://i.loli.net/2018/06/19/5b28ab0404f03.png&quot;" target="_blank" rel="noopener">https://i.loli.net/2018/06/19/5b28ab0404f03.png&quot;</a> width=40%” height=”80%” /&gt;</p></li><li><p><strong><code>段表</code></strong>用于将逻辑地址映射到物理地址。 每个表项都有</p><ul><li>段基地址：含该段在内存中开始的物理地址。</li><li>界限：指定该段的长度。<strong>段表长度不固定，页表固定。</strong></li><li>保护位(RWX)。</li></ul></li><li>段基地址寄存器(STBR)：指向段表在存储器中的位置。</li><li>段界限寄存器(STLR)：表示进程使用的段的个数。  </li><li>地址转换：<br><img src="https://i.loli.net/2018/06/19/5b28ab040db5c.png" width="45%" height="80%"></li><li>在<strong>分段系统</strong>中，<strong>内存的保护与共享以段为单位</strong></li><li>由于段的长度是根据需要变化的,因此分段会产生<strong>外部碎片</strong>。<ul><li>这个问题的严重程度与<strong>操作系统的内存分配算法</strong>和<strong>进程各个段的平均大小</strong>有关。</li></ul></li><li>由于系统无法预测各个进程使用内存的状况，<strong>外部碎片很难控制</strong>。因此，单纯的分段系统目前很少使用。</li><li>各个硬件产商也不再支持单纯的分段系统。<ul><li>INTEL 80386以前的CPU只支持分段,而80386以后(包括80386) 的CPU则增加了分页支持。</li></ul></li></ul><h4 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h4><ul><li>分页和分段系统有各自的优缺点，因此人们就考虑结合分页和分段，这就形成了段页式内存管理。</li><li>段页式内存管理的地址转换包括两个步骤：<strong>先分段，再分页。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;内存管理介绍&quot;&gt;&lt;a href=&quot;#内存管理介绍&quot; class=&quot;headerlink&quot; title=&quot;内存管理介绍&quot;&gt;&lt;/a&gt;内存管理介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;进程管理回顾 &lt;ul&gt;
&lt;li&gt;进程管理提供了一个虚拟的机器接口，让每一个进程都以为是自己在独占CPU，如下图所示:&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2018/06/18/5b27ad8cd9ef4.png&quot; width=&quot;50%&quot; height=&quot;80%&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内存管理的任务：提供一个虚拟的机器接口，让每一个进程都以为是自己在独占RAM。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记08 死锁</title>
    <link href="http://daisine.me/os8/"/>
    <id>http://daisine.me/os8/</id>
    <published>2018-07-03T06:17:31.000Z</published>
    <updated>2018-07-03T06:21:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h4><ul><li><p>如果集合中的每个进程正在等待只有集合中的另一个进程可能导致的事件，则会导致一组进程死锁。    </p><ul><li>Kansas立法机构通过的一个法律：当两列列车在十字路口逼近时，它们要完全停下来，且在一列列车开走之前，另一列列车不能启动。</li><li>只有一个方向的交通：桥的每个部分都可以被视为一个资源。如果发生死锁，则可以解决一辆车是否备份（抢占资源并回滚），可能需要“备份几辆汽车。 饥饿是可能的。</li></ul><a id="more"></a></li></ul><p>#####系统模型</p><ul><li>一个系统由有限数量的资源组成，分配给多个竞争过程。</li><li>资源被分成几种类型：资源类型R<sub>1</sub>，R<sub>2</sub>，…，R<sub>m</sub>，例如CPU周期，内存空间和 I/O 设备。</li><li>每个资源类型R<sub>i</sub>都有W<sub>i</sub>实例操作来使用资源<ol><li><strong>申请</strong>：如果不能立即授予请求，则请求进程必须等待直到它获得该资源为止。</li><li><strong>使用</strong>：进程正在使用该资源。</li><li><strong>释放</strong>：进程释放资源。</li></ol></li></ul><h4 id="死锁特征"><a href="#死锁特征" class="headerlink" title="死锁特征"></a>死锁特征</h4><ul><li>如果以下4个条件同时满足，则会出现死锁：<ol><li>互斥：至少有一个资源必须处于非共享模式，即一次只有一个进程可以使用该资源。 </li><li>占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其它资源所占有。</li><li>非抢占：资源不能抢占，即资源只能在进程完成任务后自动释放。</li><li>循环等待：有一组等待进程{P<sub>0</sub>，P<sub>1</sub>，… ，P<sub>n</sub>}，P<sub>0</sub>等待的资源由P<sub>1</sub>占有，P<sub>1</sub>等待的资源由P<sub>2</sub>占有，… ，P<sub>n-1</sub>等待的资源由P<sub>n</sub>占有，并且P<sub>n</sub>等待的资源由P<sub>0</sub>占有。</li></ol></li></ul><blockquote><p>所有4个条件必须同时满足才会出现死锁。循环等待条件意味着占有并等待条件，这样的4个条件并不完全独立。</p></blockquote><h4 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h4><ul><li>死锁问题可用称为<strong>系统资源分配图</strong>的有向图进行更精确地描述。</li><li>该图由一组顶点集合V和一组边集合E组成。</li><li>V被分成两种类型：<ul><li>P = {P<sub>0</sub>，P<sub>1</sub>，…，P<sub>n</sub>}，系统中的所有进程的集合。</li><li>R = {R<sub>0</sub>，R<sub>1</sub>，…，R<sub>m</sub>}，系统中所有资源类型的集合。</li></ul></li><li>申请边：P<sub>i</sub> → R<sub>j</sub></li><li>分配边：R<sub>j</sub> → P<sub>i</sub><br><img src="https://i.loli.net/2018/06/18/5b27ab5721290.png" width="25%" height="80%"><br><img src="https://i.loli.net/2018/06/18/5b27ab5ac25d8.png" width="33%" height="80%"></li><li>如果资源分配图不包含环，则系统中的<strong>任何进程都不会</strong>死锁;</li><li>如果资源分配图包含环，则<strong>可能存在</strong>死锁。</li></ul><h4 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h4><ul><li>可以设计一个协议来预防或避免死锁，确保系统永远不会进入死锁状态。</li><li>可以允许系统进入死锁状态，检测并从中恢复。</li><li>可以完全忽略这个问题，并假设系统中永远不会发生死锁。(鸵鸟算法)<ul><li>大多数操作系统都使用该解决方案，包括Windows和Unix。</li><li>由于死锁<strong>很少发生</strong>，并且死锁预防、死锁避免或死锁检测和恢复<strong>算法成本很高</strong>。</li><li>这是便利性和正确性之间的权衡。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;死锁问题&quot;&gt;&lt;a href=&quot;#死锁问题&quot; class=&quot;headerlink&quot; title=&quot;死锁问题&quot;&gt;&lt;/a&gt;死锁问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果集合中的每个进程正在等待只有集合中的另一个进程可能导致的事件，则会导致一组进程死锁。    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kansas立法机构通过的一个法律：当两列列车在十字路口逼近时，它们要完全停下来，且在一列列车开走之前，另一列列车不能启动。&lt;/li&gt;
&lt;li&gt;只有一个方向的交通：桥的每个部分都可以被视为一个资源。如果发生死锁，则可以解决一辆车是否备份（抢占资源并回滚），可能需要“备份几辆汽车。 饥饿是可能的。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记07 进程同步</title>
    <link href="http://daisine.me/os7/"/>
    <id>http://daisine.me/os7/</id>
    <published>2018-07-03T06:17:28.000Z</published>
    <updated>2018-07-03T06:21:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul><li>协作进程可以通过内核提供的IPC工具共享一块内存。一个进程中的多个线程可以通过使用全局变量来共享一段内存。</li><li>共享数据的并发访问可能会导致数据不一致。 保持数据一致性需要机制来确保协作进程的有序执行。</li><li><p>对生产者和消费者问题的解决方案：允许同时在缓冲区内最多只有（BSIZE - 1）项。</p><a id="more"></a></li><li><p>假设我们通过添加一个变量计数器来修改代码。<br><img src="https://i.loli.net/2018/06/18/5b275da7bfa0f.png" width="40%" height="80%"><img src="https://i.loli.net/2018/06/18/5b275daa58ac3.png" width="45%" height="80%"></p></li><li>需要注意的是，可能由于这两个进程并发操作变量counter，而得到不正确的运行结果。</li><li><strong><code>竞争条件</code></strong>：多个进程并发地访问和操作同一数据且执行结果与访问发生的特定顺序有关。<ul><li>为避免竞争条件，需要保证一段时间内只有一个进程能够操作变量。</li><li>为了实现这种保证，要求进行一定形式的<strong><code>进程同步</code></strong>。</li></ul></li></ul><h4 id="临界区问题"><a href="#临界区问题" class="headerlink" title="临界区问题"></a>临界区问题</h4><ul><li><strong><code>临界区</code></strong>：一段访问共享资源的代码。</li><li>竞态条件的解决方案必须满足以下4个要求：<ol><li>相互排斥：任何两个进程不能同时处于临界区。</li><li>前进：临界区外运行的进程不能阻塞其他进程尝试进入其临界区，以确定谁能下一个进入临界区。且这种选择不能无限推迟。</li><li>有限等待：没有任何一个进程需要无限期等待进入其临界区。</li><li>速度：不应该对CPU的速度和数量做任何假设。 </li></ol></li><li>临界区问题：设计一个以便进程协作的协议。<ul><li>每个进程必须请求允许进入其临界区。实现这一请求的代码段称为<strong>进入区</strong>。</li><li>临界区之后可有<strong>退出区</strong>。其余代码为<strong>剩余区</strong>。 </li></ul></li></ul><h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p><img src="https://i.loli.net/2018/06/18/5b2765a247934.png" width="45%" height="80%"></p><blockquote><p>First &amp; Second try都不满足“前进”这个要求。Third try即为Peterson算法，满足四个要求。</p></blockquote><h4 id="硬件同步"><a href="#硬件同步" class="headerlink" title="硬件同步"></a>硬件同步</h4><ul><li>可以使用简单的硬件指令来解决竞争条件。</li></ul><ol><li>单处理器环境(通常为非抢占内核所用)：<strong>禁用中断</strong></li><li>多处理器环境：<strong>特殊指令</strong> ①TSL（Test and Set Lock）②SWAP</li></ol><h5 id="禁用中断"><a href="#禁用中断" class="headerlink" title="禁用中断"></a>禁用中断</h5><ul><li>禁止中断，就能确保当前指令序列的执行不会被中断。由于其它指令不可能执行，共享变量不会被意外修改。</li><li>进程就可以访问共享内存而不用担心受到任何其他进程干预。</li><li>缺点<ol><li>用户进程不应该禁用中断。</li><li>在多处理器系统中不可行。</li></ol></li></ul><h5 id="TSL-and-SWAP"><a href="#TSL-and-SWAP" class="headerlink" title="TSL and SWAP"></a>TSL and SWAP</h5><ul><li>TSL和SWAP指令分别具有以下功能：<br><img src="https://i.loli.net/2018/06/18/5b276be04718e.png" width="75%" height="80%"></li><li>TSL和SWAP是以<strong>原子方式</strong>执行的，即作为一个<strong>不间断单元</strong>执行。</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>上述解决方案有一个共同缺点：<strong>繁忙等待</strong>。 <ul><li>当进程处于临界区时，其他进程尝试进入临界区必须在进入区代码中循环。 </li><li>繁忙等待浪费了一些其他进程可能可以有效使用的CPU周期。</li></ul></li><li>这种类型的解决方案也被称为<strong>自旋锁</strong>。<ul><li>因为该过程在等待锁的过程时定时“旋转”，一直在循环抢锁。 </li><li>自旋锁<strong>仅在多处理器系统中</strong>有用。可以避免一次上下文切换。</li></ul></li></ul><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul><li>上一节描述的基于硬件的临界区问题的解决方案并不容易推广到更复杂的问题。为了克服这个困难，我们可以使用一个名为semaphore的同步工具。它由Edsger Dijkstra发明并首次在THE操作系统中使用。</li><li><strong><code>信号量S</code></strong>是个整数变量，<strong>除初始化之外</strong>，只能通过两个标准的<strong>原子操作</strong>来访问：P(down) 和V(up）。<br><img src="https://i.loli.net/2018/06/18/5b276ff356715.png" width="65%" height="80%"></li><li>“value”的大小是<strong>可用资源(&gt;0)的数量</strong>或<strong>等待信号量(&lt;0)的进程的数量</strong>。</li><li>P 和 V 必须以原子方式执行。<ul><li>有两种方法：①禁用单处理器系统或中断 ②多处理器系统中的自旋锁。</li></ul></li></ul><h5 id="二进制信号量"><a href="#二进制信号量" class="headerlink" title="二进制信号量"></a>二进制信号量</h5><ul><li>上述的信号量构造通常被称为计数信号量。因为它的值可以覆盖不受限制的域。</li><li>二进制信号量是一个整数值范围只在0和1之间的信号量。<ul><li>在某些硬件体系结构上实现比计数信号量更简单。计数信号可以使用二进制信号量来实现。<br><img src="https://i.loli.net/2018/06/18/5b277a3576f4b.png" width="80%" height="80%"><br><img src="https://i.loli.net/2018/06/18/5b277a3524a9e.png" width="80%" height="80%"></li></ul></li></ul><h5 id="死锁与饥饿"><a href="#死锁与饥饿" class="headerlink" title="死锁与饥饿"></a>死锁与饥饿</h5><ul><li>虽然信号量为进程同步提供了一种方便有效的机制，但它们的不正确使用仍然会导致难以检测到的错误。<ul><li>eg. 假设生产者循环中的两个P操作按顺序颠倒过来。</li></ul></li><li>集合中的每个进程正在等待只有集合中的另一个进程可能导致的事件，则会导致一组进程<strong>死锁</strong>。</li><li>与死锁有关的另一个问题：饥饿/不确定阻塞，即进程在信号量内无限期地等待。<ul><li>例如，解决<code>读者-作者问题</code>的方法可能会导致饥饿。</li><li>通过使用FCFS调度策略可以避免饥饿。</li></ul></li></ul><h4 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h4><ul><li>生产者-消费者问题</li><li>读者-作者的问题<ul><li>一个数据库可以为多个并发进程所共享。</li><li>读者可能只需要读取数据库，写者可能需要更新数据库(即读和写)。</li><li>多个读者可以同时访问共享数据，写者对共享数据有<strong>排他的访问</strong>。</li></ul></li><li>哲学家进餐问题</li></ul><h5 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h5><ul><li>访问缓冲区时使用信号量互斥锁来保护临界区，初始化为值1。</li><li>empty被初始化为值BSIZE(缓冲项个数)，full被初始化为0。生产者为消费者生产满缓冲项，消费者为生产者生产空缓冲项。<br><img src="https://i.loli.net/2018/06/18/5b2774f9a0ad0.png" width="65%" height="80%"></li></ul><h5 id="读者-作者的问题"><a href="#读者-作者的问题" class="headerlink" title="读者-作者的问题"></a>读者-作者的问题</h5><ul><li>信号量<code>wrt</code>用于保护共享数据对象，初始化为值1。</li><li>变量readcount用来跟踪多少进程正在读对象，初始化为0。</li><li>另一个信号量mutex用于确保在更新变量readcount时的互斥，初始化为1。<br><img src="https://i.loli.net/2018/06/18/5b2774a70cbcf.png" width="65%" height="80%"></li></ul><h5 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h5><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><ul><li>管程：是一组方法、变量、函数..的集合。</li><li>管程结构确保了<strong>只有一个进程可以在管程中处于活动状态</strong>。在实现互斥方面很有用。<br><img src="https://i.loli.net/2018/06/18/5b278148f0f3e.png" width="40%" height="80%"><img src="https://i.loli.net/2018/06/18/5b278156992a9.png" width="48%" height="80%"><br><img src="https://i.loli.net/2018/06/18/5b2784cd6bc52.png" width="35%" height="80%"></li></ul><h5 id="带条件变量的管程"><a href="#带条件变量的管程" class="headerlink" title="带条件变量的管程"></a>带条件变量的管程</h5><ul><li>管程内部可定义condition类型的变量以提供同步机制，称其为<strong><code>条件变量</code></strong>。条件型变量c实际上是一个指针，它指向一个等待该条件的PCB队列。</li><li>它只与两个操作相关联：<ul><li>c.wait()：意味着调用它的进程会被挂起，直到另一个进程调用</li><li>c.signal()：重新启动一个悬挂的进程。</li><li>请注意，如果没有进程挂起，那么signal()没有任何影响。</li></ul></li><li>管程模式下的 x.signal() 和信号量的 signal() 区别在于： <ul><li>信号量操作 signal() 会影响信号量的状态</li><li>管程下的 c.signal() 在 c 不存在挂起进程的情况下没有任何影响。</li></ul></li></ul><h5 id="c-signal（）之后会发生什么？"><a href="#c-signal（）之后会发生什么？" class="headerlink" title="c.signal（）之后会发生什么？"></a>c.signal（）之后会发生什么？</h5><ul><li>假设一个进程P调用c.signal（），另一个进程Q被条件变量c阻塞。</li><li>P完成c.signal（）后，可能P和Q在监视器内同时处于活动状态。</li><li>这将打破显示器的属性！ 存在三种可能性：<ul><li>Hoare风格：暂停P并让Q运行。 </li><li>Brinch-Hansen风格：P必须立即离开显示器。 </li><li>Mesa风格（Mesa是一种编程语言）：让P运行并暂停Q.</li></ul></li></ul><h5 id="语言支持"><a href="#语言支持" class="headerlink" title="语言支持"></a>语言支持</h5><ul><li>管程结构需要编程语言支持才有用。也就是说，编译器必须识别管程结构并生成代码以支持其功能。</li><li>示例：Java（仅包含一个条件变量的Mesa样式监视器）<ul><li>通过将关键字synchronized添加到方法声明中，Java保证一旦任何线程开始执行该方法，就不允许其他线程开始执行该类中的任何其他同步方法。</li><li>Java提供了两种操作：等待并通知阻塞线程，唤醒线程。</li></ul></li></ul><h4 id="信号量与管程的关系"><a href="#信号量与管程的关系" class="headerlink" title="信号量与管程的关系"></a>信号量与管程的关系</h4><ul><li>信号量和管程在功能上是等效的。</li><li>但是它们的使用和实现是非常不同的。<br><img src="https://i.loli.net/2018/06/18/5b2785f39478e.png" width="35%" height="80%"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;协作进程可以通过内核提供的IPC工具共享一块内存。一个进程中的多个线程可以通过使用全局变量来共享一段内存。&lt;/li&gt;
&lt;li&gt;共享数据的并发访问可能会导致数据不一致。 保持数据一致性需要机制来确保协作进程的有序执行。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对生产者和消费者问题的解决方案：允许同时在缓冲区内最多只有（BSIZE - 1）项。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记06 CPU调度</title>
    <link href="http://daisine.me/os6/"/>
    <id>http://daisine.me/os6/</id>
    <published>2018-07-03T06:16:50.000Z</published>
    <updated>2018-07-03T06:21:33.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>CPU调度是多道程序操作系统的基础。通过在进程之间切换CPU，操作系统可以提高计算机的<strong>吞吐率</strong>。</li><li>在内核级支持线程的操作系统中，是线程被操作系统调度，而不是进程。</li><li><p>调度是操作系统的基本功能。 几乎所有的计算机资源在使用前都要调度。 CPU调度对操作系统设计来说很重要。</p><a id="more"></a></li></ul><h5 id="CPU-I-O-区间周期"><a href="#CPU-I-O-区间周期" class="headerlink" title="CPU- I/O 区间周期"></a>CPU- I/O 区间周期</h5><ul><li>CPU的成功调度依赖于进程的如下属性：<ul><li>进程执行由<strong>CPU执行</strong>和 <strong>I/O 等待周期</strong>组成</li><li>进程在这两个状态之间切换。</li><li>由CPU区间开始- I/O 区间 -..-最后的CPU区间通过系统请求终止执行。</li></ul></li><li>CPU区间时间曲线图：通常为指数/超指数形式，具有大量短CPU区间和少量长CPU区间。<br><img src="https://i.loli.net/2018/06/18/5b274fd5857b6.png" width="35%" height="80%"><br><img src="https://i.loli.net/2018/06/18/5b2750265b65e.png" width="55%" height="80%"> </li></ul><h5 id="CPU调度程序"><a href="#CPU调度程序" class="headerlink" title="CPU调度程序"></a>CPU调度程序</h5><ul><li>每当CPU空闲时，操作系统就必须从就绪队列中选择一个进程来执行。晋城选择由<strong>短期调度程序</strong>或CPU调度程序来执行。</li><li>CPU调度决策可在如下4种情况下发生：<ol><li>当一个进程从运行切换到等待状态。</li><li>当一个进程从运行状态切换到就绪状态。</li><li>当一个进程从等待切换到就绪状态。</li><li>当一个进程终止。</li></ol></li><li>当调度只能发生1和4两种情况下，称调度方案是<strong>非抢占的/协作</strong>的，否则，称调度方案是<strong>抢占的</strong>。</li><li>抢占调度：对访问共享数据是有代价的，对操作系统内核的设计也有影响。</li></ul><h4 id="调度标准"><a href="#调度标准" class="headerlink" title="调度标准"></a>调度标准</h4><ul><li>CPU使用率：使CPU尽可能忙。</li><li>吞吐量：一个时间单元内所完成的进程的数量。</li><li>周转时间：从进程提交到进程完成的时间段。</li><li>等待时间：进程在就绪队列中等待的时间量。</li><li>响应时间：从提交请求到产生第一个响应所花费的时间量。</li></ul><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><h5 id="先到先服调度-FCFS"><a href="#先到先服调度-FCFS" class="headerlink" title="先到先服调度(FCFS)"></a>先到先服调度(FCFS)</h5><ul><li>先请求CPU的进程先分配CPU</li><li>非抢占：一旦CPU被分配给了一个进程，该进程就会保持CPU直到释放CPU位置。  </li><li>1 - 2 - 3进程等待时间: P1 = 0; P2 = 24; P3 = 27; 平均等待时间: (0 + 24 + 27) / 3 = 17 </li><li>2 - 3 - 1进程等待时间: P1 = 6; P2 = 0; P3 = 3; 平均等待时间: (6 + 0 + 3) / 3 = 3<br><img src="https://i.loli.net/2018/06/18/5b27443f91882.png" width="35%" height="80%"><br><img src="https://i.loli.net/2018/06/18/5b274417bceb8.png" width="49%" height="80%"><br><img src="https://i.loli.net/2018/06/18/5b274425dba0b.png" width="49%" height="80%"></li></ul><h5 id="最短作业优先调度-SJF"><a href="#最短作业优先调度-SJF" class="headerlink" title="最短作业优先调度(SJF)"></a>最短作业优先调度(SJF)</h5><ul><li>将每个进程与其下一个CPU区间段相关联。当CPU为空闲时，它会赋给具有最短CPU区间的进程。</li><li>SJF调度算法可证明为最佳，对给定的一组进程，平均等待时间最短。</li><li>具有理论价值，无法实现，因为没有办法知道下一个CPU区间的长度。</li><li>两种方案：<ul><li>非抢占：一旦CPU给予该进程，它就不可能被抢占。eg. 平均等待时间: (0 + 6 + 3 + 7)/4 = 4.</li><li>抢占：如果一个到达的新的进程CPU区间长度小于当前执行进程的剩余时间，则抢占。也被称为最短剩余时间优先（SRTF）调度。eg. 平均等待时间: (9 + 1 + 0 + 2)/4 = 3.   </li></ul></li></ul><p><img src="https://i.loli.net/2018/06/18/5b2750dbb6036.png" width="25%" height="80%">   <img src="https://i.loli.net/2018/06/18/5b2750cd7f5a5.png" width="35%" height="80%"><img src="https://i.loli.net/2018/06/18/5b2750d34e6ca.png" width="35%" height="80%"></p><h5 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h5><ul><li>每一个进程都有一个优先级与其关联。具有最高优先级的进程会分配到CPU。</li><li>优先级通常为固定区间的数字。此处用小数字表示高优先级。</li><li>SJF算法是优先级调度的一个特例，其优先级为下一个CPU区间的倒数。CPU区间越大，优先级越小。</li><li>优先级调度可以是抢占或非抢占的<br><img src="https://i.loli.net/2018/06/18/5b2754621eca0.png" width="35%" height="80%"><img src="https://i.loli.net/2018/06/18/5b27545d3e4a1.png" width="50%" height="80%"></li><li>存在的问题<ol><li>饥饿/无穷阻塞：低优先级进程可能永远不会执行。</li><li>优先级反转：高优先级进程需要访问资源，被另一个优先级较低的进程持有，该低优先级进程不运行则不释放资源。</li></ol></li><li>解决办法<ul><li>老化：逐渐增加在系统中等待很长时间的进程的优先级。</li></ul></li></ul><h5 id="轮转法调度-RR"><a href="#轮转法调度-RR" class="headerlink" title="轮转法调度(RR)"></a>轮转法调度(RR)</h5><ul><li>轮转法调度算法专门为分时系统设计。类似FCFS调度，但增加了抢占以切换进程。</li><li>定义一个较小时间单元，称为<strong>时间片</strong>，通常为10-100ms。</li><li>将就绪队列作为循环队列。CPU调度程序循环就绪队列，为每个进程分配不超过一个时间片的CPU。<ol><li>进程只需要小于时间片的CPU区间，释放CPU，继续就绪队列的下一个进程。</li><li>进程的CPU区间比时间片长，经过这段时间片的CPU区间，进程被抢占并加入到就绪队列的末尾。</li></ol></li><li>如果在就绪队列中有n个进程并且时间量为q，那么每个进程会得到 1 / n 的CPU时间，其长度不超过q时间单元。每个进程必须等到的CPU时间不超过 ( n - 1 ) q 个时间单元，直到它的下一个时间片为止。</li><li>性能很大程度上依赖于时间片的大小<ul><li>时间片非常大 ➡ FCFS</li><li>时间片很小 ➡ 时间片要比上下文切换时间长，否则开销太高。</li></ul></li></ul><h5 id="多级队列调度"><a href="#多级队列调度" class="headerlink" title="多级队列调度"></a>多级队列调度</h5><ul><li>就绪队列被分成多个独立队列。</li><li>根据进程的属性，如内存大小、进程优先级、进程类型etc，一个进程被永久地分配到一个队列。</li><li>每个队列有自己的调度算法<ul><li>eg. 前台队列（用于交互式进程）使用RR算法调度，后台队列（用于批处理）使用FCFS算法调度。<br><img src="https://i.loli.net/2018/06/18/5b275848a05ce.png" width="40%" height="80%"></li></ul></li></ul><h5 id="多级反馈队列调度"><a href="#多级反馈队列调度" class="headerlink" title="多级反馈队列调度"></a>多级反馈队列调度</h5><ul><li>一个进程可以在各个队列之间移动。<ul><li>eg. 如果进程使用过多CPU时间，那么它就被转移到更低优先级队列。<br><img src="https://i.loli.net/2018/06/18/5b2758db6dfa5.png" width="40%" height="80%"></li></ul></li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>在实践中正确实施比在原则上正确实施要困难得多。因此，调度程序很少做出最佳选择。</li><li>解决方案：<strong>调度策略和调度机制的分离</strong>。也就是说，调度算法以某种方式被参数化，但参数可以由用户填写。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;CPU调度是多道程序操作系统的基础。通过在进程之间切换CPU，操作系统可以提高计算机的&lt;strong&gt;吞吐率&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在内核级支持线程的操作系统中，是线程被操作系统调度，而不是进程。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调度是操作系统的基本功能。 几乎所有的计算机资源在使用前都要调度。 CPU调度对操作系统设计来说很重要。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记05 线程管理</title>
    <link href="http://daisine.me/os5/"/>
    <id>http://daisine.me/os5/</id>
    <published>2018-07-03T06:16:07.000Z</published>
    <updated>2018-07-03T06:21:43.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><ul><li>传统意义上，一个进程只有一个控制线程。<strong>在这种情况下</strong>进程是<strong>①资源分配单位和②调度单位</strong>。</li><li>将上述两个概念分开并允许单个进程包括多个控制线程，得到线程。也就是说，进程用于将资源组合在一起，线程是派发（调度）在CPU上执行的实体。</li><li><p>线程是现代操作系统中CPU使用的基本单位。也称为轻量级过程（LWP）。</p><a id="more"></a></li><li><p>多线程</p><ul><li>在同一个进程中允许多个线程。</li><li>进程是<strong>资源分配的单位</strong>，线程是<strong>调度的单位</strong>。</li><li><strong>共享</strong>属于同一进程的资源，例如是<strong>代码段，数据段，打开的文件</strong>和信号等。</li><li>一个进程中的每个线程都有一个<strong>私有线程上下文</strong>（包括<strong>CPU寄存器集</strong>和<strong>其他状态信息：?函数参数，变量，返回地址etc</strong>）和一个<strong>私有堆栈</strong>。<br><img src="https://i.loli.net/2018/06/18/5b2736316b722.png" width="75%" height="80%"></li></ul></li><li>进程：①地址空间 ②全局变量 ③打开的文件 ④子进程 ⑤未决(pending)警报 ⑥信号和信号处理程序 ⑦计数信息</li><li>线程：①程序计数器 ②寄存器 ③堆 ④状态</li></ul><h4 id="多线程编程优点"><a href="#多线程编程优点" class="headerlink" title="多线程编程优点"></a>多线程编程优点</h4><ul><li><strong>响应度高</strong>：即使一个或多个线程被阻塞或正在执行冗长的操作，允许其他线程继续响应用户。</li><li><strong>资源共享</strong>：由于同一进程内的线程共享内存和资源，它们可以在不调用内核的情况下相互通信。它能允许一个应用进程在同一地址空间有多个不同的活动进程。</li><li><strong>经济</strong>：创建一个新线程比一个进程花费的时间和资源要少得多。在同一个进程中，线程比上下文切换花费的时间更少。</li><li><strong>多处理器体系结构的利用</strong>：通过为每个CPU分配一个线程可以实现并行，在多CPU上使用多线程加强了并发功能。</li></ul><h4 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h4><ul><li>多线程实现的地方：<strong>不一定在内核实现</strong><ul><li>用户线程：在用户空间实现。</li><li>内核线程：在内核实现。</li><li>通过组合用户线程和内核线程的混合方案。</li></ul></li></ul><h5 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h5><ul><li>它在内核之外用户空间的<strong>线程库</strong>实现。<ul><li>线程库是为线程创建，调度和管理提供支持的库。</li><li>就内核而言，它正在管理普通的单线程进程。</li></ul></li><li>eg. ①Mach C-threads ②Solaris 2 UI-threads</li><li>优点<ul><li>线程管理和上下文切换不需要陷入内核。这将节省大量的CPU周期。</li><li>允许每个进程拥有自己的自定义调度算法。</li></ul></li><li>缺点<ul><li>执行阻塞系统调用的任何用户级线程都将导致整个进程阻塞。即使其他线程已准备好在进程中运行。</li><li>在多处理器的系统上，不能调度用户级线程并行执行。</li></ul></li></ul><h5 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h5><ul><li>由操作系统直接支持。内核在内核空间执行线程创建，调度和管理。</li><li>eg. ①Windows NT / XP ②Solaris</li><li>优点和缺点：和用户线程的相反。</li></ul><h4 id="多线程应用程序编程接口"><a href="#多线程应用程序编程接口" class="headerlink" title="多线程应用程序编程接口"></a>多线程应用程序编程接口</h4><ul><li>Pthreads<ul><li>Pthreads是指为线程创建和同步定义API的POSIX标准（IEEE 1003.1c）。</li><li>这是线程行为的规范，而不是实现。 </li></ul></li><li>Win32<ul><li>CreateThread，ExitThread和TerminateThread等。</li><li>POSIX Threads for Win32 （<a href="http://sources.redhat.com/pthreads-win32）" target="_blank" rel="noopener">http://sources.redhat.com/pthreads-win32）</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与线程&quot;&gt;&lt;/a&gt;进程与线程&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;传统意义上，一个进程只有一个控制线程。&lt;strong&gt;在这种情况下&lt;/strong&gt;进程是&lt;strong&gt;①资源分配单位和②调度单位&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;将上述两个概念分开并允许单个进程包括多个控制线程，得到线程。也就是说，进程用于将资源组合在一起，线程是派发（调度）在CPU上执行的实体。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;线程是现代操作系统中CPU使用的基本单位。也称为轻量级过程（LWP）。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记04 进程管理</title>
    <link href="http://daisine.me/os4/"/>
    <id>http://daisine.me/os4/</id>
    <published>2018-07-03T06:15:26.000Z</published>
    <updated>2018-07-03T06:21:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h4><ul><li>流程批处理系统出现之前：工作</li><li>多程序或分时：程序或任务</li><li><p>进程：正在运行的作业/程序/任务的抽象</p></li><li><p><strong><code>进程</code></strong>是执行中的程序，形成所有计算机的基础。</p><a id="more"></a></li><li><p>一个过程不仅仅是一个程序。它包括</p><ul><li><strong>文本段</strong>：可执行的机器代码    /程序代码</li><li><strong>数据段</strong>：包括全局变量</li><li>当前活动：通过程序计数器的值和处理器寄存器的内容表示</li><li><strong>堆栈段</strong>：包含临时数据，如函数参数，返回地址和局部变量 </li><li>(如果需要的话)<strong>堆</strong>：进程运行期间动态地分配内存</li><li>许多其他资源，如打开的文件等<br><img src="https://i.loli.net/2018/06/17/5b260aa24cf1d.png" width="50%" height="80%"></li></ul></li><li>程序只是被动实体，如存储在磁盘上包含一系列指令的文件内容(可执行文件)</li><li>进程时活动实体，它有一个程序计数器用来表示一个要执行的命令和相关资源的合集。</li><li>多个进程可能运行同一程序。尽管它们共享相同的文本段，但它们被当作两个独立的执行程序，数据段、堆、堆栈段不同。</li></ul><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><ul><li>当一个进程执行时，它会改变状态。过程的状态由其当前活动定义。</li><li>每个进程可能处于以下状态之一：<ul><li>新建：进程正在被创建。</li><li>运行：指令正在被执行。</li><li>等待：进程正在等待某个事件发生(如 I/O 完成或收到信号)。</li><li>就绪：进程等待分配处理器。</li><li>终止：进程完成执行。</li></ul></li><li>随着进程的运行，它将从当前状态转换到另一个状态。这五个状态中有六个过渡。<br><img src="https://i.loli.net/2018/06/17/5b26104f11cf7.png" width="80%" height="80%"></li></ul><h4 id="进程块"><a href="#进程块" class="headerlink" title="进程块"></a>进程块</h4><ul><li>每个进程在操作系统中由过程控制块（PCB）表示，也称为任务控制块。<ol><li>进程号是进程的唯一标识符，也称为PID。</li><li>程序计数器（PC）：是寄存器之一。</li><li>CPU调度信息：包括<strong>进程的优先级</strong>、调度队列的指针和其它调度参数。<br><img src="https://i.loli.net/2018/06/17/5b2610656be5b.png" width="30%" height="80%"></li></ol></li></ul><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>当运行进程因某种原因无法继续时，操作系统必须决定下一个要运行的进程。<strong>进程调度</strong>选择一个可用的进程到CPU上执行。</p><h5 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h5><ul><li>上下文切换：将 CPU 转向另一个进程需要保存当前进程的状态，并载入为新进程存储的状态。</li><li>是额外的开销。操作系统越复杂，上下文切换需要做的工作越多。</li><li>上下文切换时间与硬件支持有密切相关。根据处理器的不同。</li><li>上下文切换是一个性能瓶颈，程序员正在使用新的结构来尽可能地避免它。</li></ul><h5 id="调度队列"><a href="#调度队列" class="headerlink" title="调度队列"></a>调度队列</h5><ul><li>作业队列：由系统中的所有进程组成;</li><li>就绪队列：由等待CPU执行的进程组成;<br>-操作系统也有其他队列。<ul><li>I/O 设备队列：由等待特定 I/O设备的进程组成。<br><img src="https://i.loli.net/2018/06/17/5b2613f4c3e27.png" width="75%" height="80%"><br><img src="https://i.loli.net/2018/06/17/5b2614aca2536.png" width="75%" height="80%"></li></ul></li></ul><h5 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h5><p>调度程序从就绪队列中选择一个进程并为其分配CPU。我们称这个调度程序为CPU调度程序。</p><h4 id="合作进程"><a href="#合作进程" class="headerlink" title="合作进程"></a>合作进程</h4><ul><li>如果一个进程不会影响系统中其它的进程，而且也不被其它进程影响，那么它是一个独立进程。不与其它进程共享数据(临时的或长久的)的进程是独立进程。</li><li>如果一个进程会影响系统中其它的进程而且也被影响，那么它是一个协作进程。与其它进程共享数据的进程是协作进程。</li><li>进程协作的优点<ul><li><strong>信息共享</strong>：多个进程可能需要同一条信息。</li><li><strong>计算加速</strong>：将问题分解成几个可以并行运行的子任务;</li><li><strong>模块化</strong>：通过设计将不同功能分散到进程中。</li></ul></li><li>但是，协作进程的并发执行需要<strong>允许进程彼此通信</strong>并使其<strong>动作同步</strong>的机制。</li></ul><h5 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h5><ul><li>这是协作进程的通用范例。</li><li>生产者进程产生信息以供消费者进程消费。必须要又一个缓冲来被生产者填充并被消费者所使用。<ul><li><strong>无限缓冲</strong>：对缓冲大小没有限制。消费者可能不得不等待新项，但生产者总可以产生新项。</li><li><strong>有限缓冲</strong>：缓冲大小固定。如果缓冲为空，消费者必须等待；如果缓冲为满，生寒症必须等待。</li></ul></li><li>操作系统可以通过使用进程间通信（IPC）工具来提供缓冲区。<strong>程序员</strong>只是使用系统调用来填充或清空缓冲区。</li><li>缓冲区也可以位于生产者和消费者可以访问的<strong>共享存储器</strong>中。在这种情况下，<strong>程序员</strong>必须自己管理共享缓冲区。</li></ul><h4 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信(IPC)"></a>进程间通信(IPC)</h4><ul><li>在消费者-生产者问题中，缓冲区可以由操作系统提供。操作系统必须同步消费者和生产者对缓冲区的访问。</li><li>进程间通信(<strong>IPC</strong>)提供了一种机制，允许进程进行通信，并在非共享相同地址空间的情况下同步他们的动作。</li><li>eg.<strong>①Message-passing, ②pipe, ③socket, etc.</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;进程概念&quot;&gt;&lt;a href=&quot;#进程概念&quot; class=&quot;headerlink&quot; title=&quot;进程概念&quot;&gt;&lt;/a&gt;进程概念&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;流程批处理系统出现之前：工作&lt;/li&gt;
&lt;li&gt;多程序或分时：程序或任务&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进程：正在运行的作业/程序/任务的抽象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;进程&lt;/code&gt;&lt;/strong&gt;是执行中的程序，形成所有计算机的基础。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记03 操作系统结构</title>
    <link href="http://daisine.me/os3/"/>
    <id>http://daisine.me/os3/</id>
    <published>2018-07-03T06:14:39.000Z</published>
    <updated>2018-07-03T06:22:02.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>一个像现代操作系统一样庞大而复杂的系统必须仔细设计，才能正常运行并易于修改。</li><li>一种常用的方法是将任务分成小部件，而不是一个单一的系统。</li><li>这些组件中的每一个都应该是系统的一个明确定义的部分，具有详细定义的<strong>输入，输出和功能</strong>。</li><li><p>系统设计人员如何组织这些组件？</p><ul><li>简单结构（或没有结构）</li><li>分层结构</li><li>微内核</li><li>虚拟机</li></ul><a id="more"></a></li></ul><h4 id="简单结构"><a href="#简单结构" class="headerlink" title="简单结构"></a>简单结构</h4><ul><li>许多系统没有明确的结构。</li><li>他们从小、简单和有限的系统开始，然后演变成复杂的系统。</li><li>eg. MS-DOS和Unix</li></ul><h4 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h4><ul><li>操作系统分解成多个层，<strong>高层只能调用低一层的功能</strong>。</li><li>分层结构的主要难点在于：<ul><li>仔细定义每一层</li><li>效率较低。</li></ul></li><li>eg. The <strong>THE</strong> operating system by Dijkstra.</li></ul><h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4><ul><li>随着Unix操作系统的扩展，内核变得庞大而难以管理。</li><li>微内核方法通过<strong>从内核中删除所有非必要组件</strong>并将它们实现为系统级和用户级程序来构造操作系统。</li><li>提供精简的内核。哪些组件应该保留在微内核中？ <ul><li>CPU管理</li><li>内存管理</li><li>通信设备</li></ul></li><li>eg. ①卡内基梅隆大学的开源Mach(用作Apple Mac OS X和DEC Tru64 Unix的内核) ②QNX Inc.的QNX实时操作系统 ③Micorsoft Windows NT / XP</li></ul><h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><ul><li>从微内核进一步迈进：<ul><li>低级真实的硬件被“克隆”到几个相同的<strong>虚拟机</strong>中。</li><li>虚拟机提供的接口与底层裸机相同。</li></ul></li><li>然后，操作系统功能建立在虚拟机之上。<br><img src="https://i.loli.net/2018/06/17/5b2606003dd2f.png" width="70%" height="80%"></li><li>eg. ①IBM VM/370 ②VMware ③Microsoft Virtual PC ④Sun microsystem’s Java Virtual Machine (JVM).Sun微系统的Java虚拟机</li><li>虚拟机的优与劣<ul><li>虚拟机概念提供了<strong>对系统的全面保护</strong>。因为每个虚拟机都与其他所有虚拟机隔离开来。</li><li>然而，这种隔离<strong>不允许直接分享资源</strong></li><li>虚拟机系统是<strong>操作系统研究和开发</strong>的理想<strong>工具</strong>。</li><li>虚拟机的概念很难实现，因为需要<strong>准确地</strong>为底层机器提供一个完全相同的副本。</li></ul></li></ul><h4 id="政策和机制"><a href="#政策和机制" class="headerlink" title="政策和机制"></a>政策和机制</h4><ul><li><strong>政策：做什么</strong><br>eg. 用户应该无法读取其他用户的文件。</li><li><strong>机制：如何做</strong><br>eg. 在打开的系统调用中检查文件权限。</li><li><strong>政策与机制的分离</strong>是一个非常重要的原则。<ul><li>如果政策决定以后将改变，它可以提供最大的灵活性。</li></ul></li><li>两个极端：<ul><li>微内核：所有机制，几乎没有政策</li><li>Apple Macintosh：策略和机制绑定在一起</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;一个像现代操作系统一样庞大而复杂的系统必须仔细设计，才能正常运行并易于修改。&lt;/li&gt;
&lt;li&gt;一种常用的方法是将任务分成小部件，而不是一个单一的系统。&lt;/li&gt;
&lt;li&gt;这些组件中的每一个都应该是系统的一个明确定义的部分，具有详细定义的&lt;strong&gt;输入，输出和功能&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;系统设计人员如何组织这些组件？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单结构（或没有结构）&lt;/li&gt;
&lt;li&gt;分层结构&lt;/li&gt;
&lt;li&gt;微内核&lt;/li&gt;
&lt;li&gt;虚拟机&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记02 计算机系统结构</title>
    <link href="http://daisine.me/os2/"/>
    <id>http://daisine.me/os2/</id>
    <published>2018-07-03T06:14:00.000Z</published>
    <updated>2018-07-03T06:22:07.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Bootstrap-引导"><a href="#Bootstrap-引导" class="headerlink" title="Bootstrap 引导"></a>Bootstrap 引导</h4><ul><li>我们必须将操作系统内核从某些永久性存储（如磁盘和网络服务器）加载到内存中。装入内核以启动计算机的过程称为<strong>引导</strong>系统。</li><li>绝大多数计算机系统都有一小块代码，称为<strong>引导程序/引导装载程序</strong>。这段代码能定位内核，将它装入内存，开始执行。</li><li><strong>引导加载程序不是操作系统的一部分。</strong>引导程序被存储在固件中，而操作系统保存在磁盘上。</li><li><p>例子：</p><ul><li>NTLDR: 用于Windows NT / XP的boot-loader（驻留在C:\）。</li><li>GRUB: Unix / Linux的启动加载器之一。</li></ul><a id="more"></a></li></ul><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><ul><li>现代计算机和操作系统是<strong>由中断驱动</strong>的。<ul><li>外围设备使用**中断信号通知CPU发生了某些事情。</li></ul></li><li>当CPU发生中断时，它必须通过<strong>硬</strong>件、ISR中<strong>的汇编语言程序</strong>和<strong>C程序</strong>来服务中断：<ol><li>硬件：将一些寄存器和分支保存到<strong><code>中断服务程序</code></strong>（<strong><code>ISR</code></strong>）;</li><li>ISR中的汇编语言程序：必要时保存其余寄存器营造便利的环境;</li><li>ISR中的C语言程序：确实服务于中断，通常读取并缓冲来自外围设备的输入数据;</li><li>ISR中的C语言程序：返回在ISR中的汇编语言;</li><li>ISR中的汇编语言程序：恢复保存的寄存器并返回到被中断的位置。</li></ol></li></ul><h5 id="中断向量"><a href="#中断向量" class="headerlink" title="中断向量"></a>中断向量</h5><ul><li>通常，计算机系统具有多个外围设备。发生中断时，CPU必须知道哪个设备触发了它。</li><li>中断向量（Interrupt vector）是中断服务程序的入口地址，或中断向量表的下标，中断服务程序的入口地址存放在该数组中。<ul><li>计算机系统为每个设备分配一个唯一的<strong><code>中断请求号</code></strong>（例如，一个8-bit整数），简称<strong><code>IRQ</code></strong>。</li><li>中断向量表中存有所有ISR的地址。它是一个地址的数组。</li><li>在服务中断时，CPU使用<strong>IRQ</strong>(中断请求号)来<strong>索引中断向量</strong>，以获取ISR的地址并跳转到它。<br><img src="https://i.loli.net/2018/06/17/5b25d57c9fb57.png" width="80%" height="40%"> </li></ul></li></ul><h5 id="中断vs异常"><a href="#中断vs异常" class="headerlink" title="中断vs异常"></a>中断vs异常</h5><ul><li><code>中断</code>：<strong>异步</strong>，由<strong>外围设备</strong>触发</li><li><code>异常</code>：<strong>同步</strong>，处理器在执行指令时检测到错误情况（例如除零和无效内存访问）时会发生异常。</li><li>除上述以外，处理中断和异常是相同的。异常也称为<strong>软件生成的中断</strong>或<strong>同步中断</strong>。 </li></ul><h4 id="I-O结构"><a href="#I-O结构" class="headerlink" title="I/O结构"></a>I/O结构</h4><ul><li>当CPU使用外围设备进行 I/O 时，有两种方法可用：<ul><li>同步 I/O ：I/O 操作开始，等待 I/O 操作完成时将控制返回给用户进程。</li><li>异步 I/O ：并不等待输入输出结束，而是直接将控制返回给用户程序。<br><img src="https://i.loli.net/2018/06/17/5b25dac98ff90.png" width="80%" height="40%"> </li></ul></li><li>(外围)设备控制器中的寄存器被称为 <strong>I/O 端口</strong><ul><li>一个唯一的地址（称为<strong>端口</strong>，一个8/16-bit整数）被分配给设备控制器中的每一个寄存器。</li></ul></li><li>特殊的 I/O 指令旨在允许这些<strong>寄存器和内存之间的数据传输</strong>。</li><li>例如：IBM-PC<ul><li>16位 I/O 端口用于<strong>寻址</strong>设备控制器的寄存器。</li><li>两个特殊的 I/O 指令：IN和OUT包含在INTEL x86 CPU中。<br>1.IN reg，端口 - 从端口读取一个字节/字到CPU寄存器寄存器<br>2.OUT端口，reg  - 将CPU寄存器的内容写入端口。</li></ul></li></ul><h4 id="内存映射-I-O"><a href="#内存映射-I-O" class="headerlink" title="内存映射 I/O"></a>内存映射 I/O</h4><ul><li>在 I/O 端口的方法中，我们可以将 I/O 端口视为另一个单独的地址空间，与存储器地址空间无关。</li><li>设备控制器内的寄存器只是一个存储器。<ul><li>为什么不使用与内存相同的方法访问这些寄存器？</li><li>在这种情况下，（唯一的）<strong>内存地址</strong>被分配给每个寄存器，而<strong>不是</strong>一个<strong>端口地址</strong>。</li></ul></li><li><p>内存映射 I/O 。</p><ul><li>内存映射 I/O 使用<strong>相同的总线</strong>来寻址内存和I / O设备</li><li>为了容纳 I/O 设备，CPU<strong>可寻址空间</strong>的区域必须<strong>为 I/O 而不是内存预留</strong>。</li></ul></li><li><p>优点</p><ul><li>每个可以引用内存的指令也可以引用设备控制器寄存器。（设备驱动程序可以完全用C语言编写。）</li><li>不需要特殊的保护机制来保持用户进程不执行 I/O 。</li></ul></li><li>缺点<ul><li>现在大多数电脑都有某种形式的缓存记忆词。但是，缓存<strong><code>设备控制器寄存器</code></strong>将会产生灾难性的后果。</li></ul></li><li>现代计算机系统使用它们两个：<ul><li><strong>用于数据缓存</strong>的存储器映射 I/O 和<strong>用于命令寄存器</strong>的单独 I/O 端口，</li><li>就像Mobility Radeon 7500的例子一样。</li></ul></li></ul><h4 id="硬件保护"><a href="#硬件保护" class="headerlink" title="硬件保护"></a>硬件保护</h4><ul><li>为确保正常运行，我们必须保护操作系统和所有其他程序及其数据免受任何故障程序的影响。</li><li>不同的硬件保护方式：<ul><li><strong>双模式操作</strong>：防止用户程序占用部分操作系统，并使用它覆盖其他程序，甚至修改操作系统本身。</li><li><strong>特权指令</strong>：防止用户程序通过发出<strong>非法 I/O 指令</strong>而中断系统的正常操作。</li><li><strong>内存保护</strong>：防止用户程序<strong>直接访问</strong>其他用户程序或操作系统的<strong>内存</strong>。</li><li><strong>CPU保护</strong>：防止用户程序<strong>陷入无限循环</strong>，并且永远不会将控制权交还给操作系统。</li></ul></li></ul><h5 id="1-双模式操作"><a href="#1-双模式操作" class="headerlink" title="1. 双模式操作"></a>1. 双模式操作</h5><ul><li>用户模式：代表用户程序执行。</li><li>监控模式：代表操作系统执行。也称为管理员/系统/特权或内核模式。</li><li><strong><code>模式位</code></strong>被添加到计算机硬件以指示当前模式：监视器（0）或用户（1）。<ul><li>在<strong>系统启动时</strong>被设置为<strong>监视模式</strong>，然后加载操作系统，以<strong>用户模式</strong>启动<strong>用户程序</strong>。</li></ul></li><li>当发生中断或异常时硬件切换到监视模式。<ul><li>只要操作系统获得对计算机的控制权，就处于监视模式。</li><li>系统总是在将控制权交给用户程序前切换到用户模式。</li></ul></li><li>INTEL IA-32支持4种工作模式，命名为保护环。<ul><li>但是，运行在IA-32上的大多数操作系统只使用4个中的2个。环0为监视模式，环3为用户模式。<br><img src="https://i.loli.net/2018/06/17/5b25e64b601a8.png" width="70%" height="40%"> </li></ul></li></ul><h5 id="2-特权指令"><a href="#2-特权指令" class="headerlink" title="2. 特权指令"></a>2. 特权指令</h5><ul><li>所有 I/O 指令都是特权指令。<ul><li>硬件允许特权指令仅在监视器模式下执行。</li><li>如果这些指令在用户模式下执行，硬件不会执行指令，而是将其视为非法并生成异常。</li><li>eg. <strong>IN</strong>和<strong>OUT</strong>是INTEL IA-32中的2条<strong>特权指令</strong>。</li></ul></li><li>必须确保用户程序无法在监视模式下获得对计算机的控制权。</li><li>转移到用户模式操作，定时器管理，中断管理…</li></ul><h5 id="3-内存保护"><a href="#3-内存保护" class="headerlink" title="3. 内存保护"></a>3. 内存保护</h5><ul><li>为了保护内存，用两个寄存器来确定程序可以访问的合法地址的范围：<ul><li><strong>基地址寄存器</strong>：保存最小的合法物理内存地址</li><li><strong>界限地址寄存器</strong>：保存地址范围的大小。</li></ul></li><li>见内存管理章节<br><img src="https://i.loli.net/2018/06/17/5b25e8e5bc99d.png" width="80%" height="80%"> </li></ul><h5 id="4-CPU保护"><a href="#4-CPU保护" class="headerlink" title="4. CPU保护"></a>4. CPU保护</h5><ul><li>操作系统只有在有机会运行时才能执行一种策略。<ul><li>如果用户程序陷入死循环或不调用系统服务，并不将控制权返回到操作系统，则CPU不受操作系统的控制。</li></ul></li><li><strong>定时器</strong>：在给定的时间段后中断CPU，控制权自动交给操作系统以确保操作系统能维持对CPU的控制。<ul><li>发生中断时，<strong>操作系统将通过ISR获得控制权</strong>。</li></ul></li></ul><h5 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h5><ul><li>计数寄存器每经过一个时间周期，都要递减(减1)。</li><li>当计数器寄存器达到0时，定时器将中断CPU。</li><li>然后，计数器寄存器将重新加载<code>保持寄存器</code>的值并重复递减的步骤。</li><li>示例：IBM-PC中的计时器<ul><li>具有16位计数器和保持寄存器和脉冲的INTEL i8253可编程间隔定时器达到1193182Hz。<br><img src="https://i.loli.net/2018/06/17/5b25f4b3a9c3e.png" width="90%" height="80%"> </li></ul></li></ul><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><ul><li>操作系统本身没有任何用处，但它通过系统调用用户程序提供了一些有用的服务。如，从磁盘读取文件并通过网络适配器将数据发送到远程主机。</li><li><strong>系统调用</strong>：操作系统和用户程序之间的（明确定义的）接口。<ul><li>用户程序<strong>只能</strong>通过系统调用请求操作系统提供的服务。</li><li>系统调用接口因操作系统而异，也称为<strong>主管电话</strong>。</li></ul></li></ul><h5 id="系统调用v-s-库函数"><a href="#系统调用v-s-库函数" class="headerlink" title="系统调用v.s.库函数"></a>系统调用v.s.库函数</h5><ul><li>系统调用会<strong>陷入OS内核</strong>;而库函数没有。所以，<strong>系统调用比库函数慢得多</strong>。</li><li>库函数与用户定义的函数相同。用户可以用自己的版本替换现有的库函数，而系统调用则不能替换。</li><li>一个操作系统中的系统调用可能会成为另一个操作系统中的库函数，反之亦然。<br><img src="https://i.loli.net/2018/06/17/5b25fe9f393cb.png" width="60%" height="60%"> </li></ul><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p><img src="https://i.loli.net/2018/06/17/5b25f6b86d9dd.png" width="60%" height="80%"> </p><ul><li>1 - 3 准备参数；</li><li>4 调用系统调用的包装器（用汇编语言编写）；</li><li>5 将读取的<strong>系统调用号</strong>存储到寄存器中；</li><li>6 陷入操作系统；</li><li>7 通过使用<strong>系统调用号</strong>索引<strong>系统调用表</strong>获取<strong>系统调用服务程序</strong>以进行读取；</li><li>8 - 11 系统调用服务程序运行，并在完成时返回到用户程序。<br><img src="https://i.loli.net/2018/06/17/5b25fc997f84d.png" width="50%" height="80%"> </li><li>这里的驻留监视器（或简单的监视器）意味着操作系统</li><li>n是系统调用号。</li></ul><h5 id="陷入操作系统"><a href="#陷入操作系统" class="headerlink" title="陷入操作系统"></a>陷入操作系统</h5><ul><li>用户程序不能直接陷入操作系统。如何陷入操作系统？</li><li>方法1：异常（软件生成的中断）<ul><li>INTEL IA-32提供触发异常的指令INT。eg. Linux / FreeBSD使用INT 0x80陷入操作系统，Windows NT / XP使用INT 0x2e。 </li></ul></li><li>方法2：特殊指令。<ul><li>由于INT指令的额外开销，INTEL IA-32提供了两个特殊指令来陷入操作系统：<code>SYSENTER</code>和<code>SYSEXIT</code>。仅在Pentium II之后的处理器上支持，即Family 6，Model 3，Stepping 3。</li><li>ARM处理器使用swi (Short for SoftWare Interrupt) 陷入操作系统。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Bootstrap-引导&quot;&gt;&lt;a href=&quot;#Bootstrap-引导&quot; class=&quot;headerlink&quot; title=&quot;Bootstrap 引导&quot;&gt;&lt;/a&gt;Bootstrap 引导&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;我们必须将操作系统内核从某些永久性存储（如磁盘和网络服务器）加载到内存中。装入内核以启动计算机的过程称为&lt;strong&gt;引导&lt;/strong&gt;系统。&lt;/li&gt;
&lt;li&gt;绝大多数计算机系统都有一小块代码，称为&lt;strong&gt;引导程序/引导装载程序&lt;/strong&gt;。这段代码能定位内核，将它装入内存，开始执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引导加载程序不是操作系统的一部分。&lt;/strong&gt;引导程序被存储在固件中，而操作系统保存在磁盘上。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NTLDR: 用于Windows NT / XP的boot-loader（驻留在C:\）。&lt;/li&gt;
&lt;li&gt;GRUB: Unix / Linux的启动加载器之一。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统笔记01 导论</title>
    <link href="http://daisine.me/os1/"/>
    <id>http://daisine.me/os1/</id>
    <published>2018-07-03T06:10:52.000Z</published>
    <updated>2018-07-03T06:22:15.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h4><ul><li>多个作业同时保存在主存储器中，CPU通过在作业之间切换来执行多个作业。<br><img src="https://i.loli.net/2018/06/17/5b25c15f99ea2.png" width="40%" height="40%"> </li></ul><h4 id="台式机的操作系统"><a href="#台式机的操作系统" class="headerlink" title="台式机的操作系统"></a>台式机的操作系统</h4><ul><li><p>这些计算机的操作系统从主机操作系统的开发中受益良多。</p><ul><li>Microsoft MS-DOS, Windows 9x/NT</li><li>Apple Macintosh, Mac OS X</li><li>IBM OS/2</li><li>Unix: Solaris by Sun microsystem, HP-UX by Hewlett-Packard, AIX by IBM, Free (as in freedom) software such as BSD (Berkeley Software Distribution) Unix, GNU/Linux</li></ul><a id="more"></a></li></ul><h4 id="实时-嵌入式系统"><a href="#实时-嵌入式系统" class="headerlink" title="(实时)嵌入式系统"></a>(实时)嵌入式系统</h4><ul><li><strong>嵌入式计算机</strong>通常用作<strong>工业控制系统</strong>等专用应用中的控制设备。通常他们资源有限：<ul><li>处理器缓慢、内存有限</li><li>小甚至没有显示屏幕、有限的电源</li><li>有限的功能，只具有很少甚至没有用户接口</li></ul></li><li>嵌入式系统几乎都运行<strong>实时操作系统</strong>。</li><li>他们资源有限：处理器缓慢、内存有限、小甚至没有显示屏幕、有限的电源 etc..<ul><li>Microsoft Windows CE (Consumer Electronics)</li><li>Windriver vxWorks </li><li>GNU / Linux</li></ul></li><li>一些控制设备具有时间要求，即实时：<ul><li><strong>硬实时</strong>：处理必须在固定时间约束内完成，不允许任何超出时限的错误。</li><li><strong>软实时</strong>：可以容忍偶然的超时错误。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;操作系统结构&quot;&gt;&lt;a href=&quot;#操作系统结构&quot; class=&quot;headerlink&quot; title=&quot;操作系统结构&quot;&gt;&lt;/a&gt;操作系统结构&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;多个作业同时保存在主存储器中，CPU通过在作业之间切换来执行多个作业。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2018/06/17/5b25c15f99ea2.png&quot; width=&quot;40%&quot; height=&quot;40%&quot;&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;台式机的操作系统&quot;&gt;&lt;a href=&quot;#台式机的操作系统&quot; class=&quot;headerlink&quot; title=&quot;台式机的操作系统&quot;&gt;&lt;/a&gt;台式机的操作系统&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这些计算机的操作系统从主机操作系统的开发中受益良多。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Microsoft MS-DOS, Windows 9x/NT&lt;/li&gt;
&lt;li&gt;Apple Macintosh, Mac OS X&lt;/li&gt;
&lt;li&gt;IBM OS/2&lt;/li&gt;
&lt;li&gt;Unix: Solaris by Sun microsystem, HP-UX by Hewlett-Packard, AIX by IBM, Free (as in freedom) software such as BSD (Berkeley Software Distribution) Unix, GNU/Linux&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>软件工程导论笔记</title>
    <link href="http://daisine.me/sei/"/>
    <id>http://daisine.me/sei/</id>
    <published>2018-06-20T01:48:06.000Z</published>
    <updated>2018-06-20T01:53:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-软件工程概述"><a href="#1-软件工程概述" class="headerlink" title="1. 软件工程概述"></a>1. 软件工程概述</h3><h4 id="软件的概念和特点"><a href="#软件的概念和特点" class="headerlink" title="软件的概念和特点"></a>软件的概念和特点</h4><p><code>软件</code>(广义)：计算机系统中与硬件相互依存的一部分  </p><blockquote><p><strong>程序</strong>：计算机可以接受的一系列指令，运行时可以提供所要求的功能和性能。<br><strong>数据</strong>：使得程序能够适当地操作信息的数据结构。<br><strong>文档</strong>：描述程序的研制过程、方法和使用的图文资料。 </p></blockquote><a id="more"></a><ul><li>软件所具有的<strong>复杂性</strong>、<strong>一致性</strong>、<strong>可变性</strong>、<strong>不可见性</strong>等特性，使得软件开发过程变得难以控制。</li><li>软件的特点：<ul><li>软件是一种<strong>逻辑实体</strong>，不是具体的物理实体。</li><li>软件产品的生产主要是研制。</li><li>软件具有<strong>“复杂性”</strong>，其开发和运行常受到计算机系统的限制。</li><li>软件<strong>成本昂贵</strong>，其开发方式目前尚未完全摆脱手工生产方式。</li><li>软件不存在磨损和老化问题，但存在<strong>退化问题</strong>。</li></ul></li></ul><h4 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h4><ul><li><code>软件危机</code>：落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。  </li><li>体现在：   <ol><li>软件产品无质量保证，可靠性差，甚至开发过程就夭折。  </li><li>软件生产率太低  </li><li>无法开发复杂程度高的软件</li><li>成本和进度估计不准</li><li>无统一科学的规范，软件不可维护</li><li>软件常不能满足用户的需求</li></ol></li><li>解决途径： <ol><li>管理措施:项目管理、配置管理、过程管理、质量控制</li><li>技术措施:开发过程、开发技术与方法和开发工具 </li></ol></li></ul><h4 id="软件工程的发展"><a href="#软件工程的发展" class="headerlink" title="软件工程的发展"></a>软件工程的发展</h4><ul><li>史前时代(1965-1967)<ol><li>软件开发没有方法可循</li><li>软件设计是在开发人员头脑中完成的隐藏过程</li><li>60世纪中期的软件危机</li></ol></li><li>瀑布过程模型(1968-1982) <ol><li>1968年提出“软件工程”</li><li>结构化开发方法</li><li>瀑布式软件生命周期模型 成为典型</li></ol></li><li>质量标准体系<ol><li>面向对象开发方法</li><li>软件过程改进运动</li><li>CMM/ISO9000/SPICE等 质量标准体系</li></ol></li><li>20世纪90年代至今<ol><li>敏捷开发方法流行</li><li>更紧密的团队协作</li><li>有效应对需求变化</li><li>快速交付高质量软件</li><li>迭代和增量开发过程 </li></ol></li></ul><h4 id="软件工程的定义"><a href="#软件工程的定义" class="headerlink" title="软件工程的定义"></a>软件工程的定义</h4><p><code>软件工程</code>是①将系统性的、规范化的、可定量的方法应用于软件的开发、运行和维护，即工程化应用到软件上；②对①中所述方法的研究。</p><blockquote><p>是一门指导计算机和维护的工程学科。</p></blockquote><h4 id="软件工程三要素"><a href="#软件工程三要素" class="headerlink" title="软件工程三要素"></a>软件工程三要素</h4><ol><li><strong>方法</strong>: 研究软件开发<strong>“如何做”</strong>的技术。涵盖了项目计划、需求分析、系统设计、程 序实现、测试与维护等一系列的开发活动如何来做。开发方法经历了从面向结构、面向对象、 面向组件到面向服务的发展工程。 </li><li><strong>过程</strong>: 为<strong>及时</strong>、<strong>合理</strong>地开发出满足用户需求的计算机软件而进行<strong>一系列有组织的活动</strong>。</li><li><strong>工具</strong>: 为过程和方法提供自动的或半自动的支持。这些软件工具被<strong>集成</strong>起来，建立起一个支持软件开发的系统，称之为<strong>计算机辅助软件工程 </strong>(CASE ，Computer Aided Software Engineering)。</li></ol><h3 id="2-软件过程模型"><a href="#2-软件过程模型" class="headerlink" title="2.软件过程模型"></a>2.软件过程模型</h3><p><code>软件过程模型</code>定义任务之间关系和规程和方法，软件过程模型是对软件过程的抽象描述。</p><h4 id="瀑布模型："><a href="#瀑布模型：" class="headerlink" title="瀑布模型："></a>瀑布模型：</h4><ul><li>瀑布模型：将软件生存周期各活动规定为依线性顺序联接的若干阶段的模型。一个系统的、顺序的软件开发方法。</li><li>该模型说明整个软件开发过程是按图中的各个阶段进行的，每个阶段的任务完成之后，产生右边相应的文档</li><li>优点：<ul><li>为项目提供了按阶段划分的检查点</li><li>当前一阶段完成后，只需要去关注后续阶段</li><li>可在迭代模型中应用瀑布模型</li></ul></li><li>缺点：<ul><li>各个阶段的划分完全固定，阶段之间产生了大量的文档，增加了工作量</li><li>由于开发过程是线性的，开发过程中很难响应用户的变更要求</li><li>早期错误要等到后期测试阶段才能发现</li><li>实际项目开发中很少遵守瀑布模型提出的顺序</li><li>客户要等到开发周期的晚期才能得到可执行的程序</li></ul></li></ul><h4 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h4><ul><li>为了描述、述软件开发过程中可能的回溯，尤其是维护阶段往往要经历上描述各个阶段，采用循环模型描述。</li><li>原型是一个部分开发的产品，用于加强对系统的理解，有助于明确需求和选择可行的设计策略。 </li></ul><h4 id="迭代式开发"><a href="#迭代式开发" class="headerlink" title="迭代式开发"></a>迭代式开发</h4><ul><li>迭代式开发：将描述、开发和验证等不同活动交织在一起，在开发过程中建立一系列版本，将系统一部分一部分地逐步交付。 </li></ul><h4 id="增量模型："><a href="#增量模型：" class="headerlink" title="增量模型："></a>增量模型：</h4><ul><li>增量模型：先开发主要功能模块，再开发次要功能模块，逐步完善直到构造全部功能。</li><li>优点：<ul><li>分步开发，降低复杂性和难度。</li><li>当配备的人员不能在设定的期限内完成产品时，它提供了一种先推出核心产品的途径。</li><li>可先发布部分功能给客户，对客户起到镇静剂的作用。</li><li>边开发边投入，可及早发现问题，减少投资风险。</li><li>适用于需求不完整的软件开发，可以灵活应对用户的需求变化。</li></ul></li><li>缺点：<ul><li>加入构件不能破坏已构造好的系统部分，这需要软件具备开放式的体系结构。 </li><li>需求改变过大会导致软件过程的控制失去整体性。</li><li>如果增量包之间存在相交的情况且未很好处理，则必须做全盘系统分析。</li></ul></li></ul><h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><ul><li>一种风险驱动型的过程模型，一种演进式软件过程模型。它结合了原型的<strong>迭代性质</strong>和瀑布模型的<strong>系统性和可控性</strong>特点。具有快速开发越来越完善软件版本的潜力。</li><li>螺旋模型将开发过程分为几个螺旋周期，每个螺旋周期可分为4个工作步骤:<ol><li>确定目标、方案和限制条件；</li><li>评估方案、标识风险和解决风险；</li><li>开发确认产品；</li><li>计划下一周期工作。</li></ol></li><li>优点：<ul><li>开发大型系统和软件的理想方法。</li><li>客户始终参与每个阶段的开发，每个阶段的成果需客户确认，避免错误的积累。</li><li>增加风险分析，一旦风险成立，原方案应终止、修订，力求风险可控。</li></ul></li><li>缺点：很难说服客服演进的方法是可控的，依赖于低昂的风险评估专家来保证成功。</li></ul><h4 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h4><ul><li>敏捷宣言<ul><li>个体和交互&gt;过程和工具</li><li>可以工作的软件&gt;面面俱到的文档</li><li>客户合作&gt;合同谈判</li><li>响应变化&gt;遵循计划</li></ul></li><li>极限编程(XP)：偏重编程实践 </li><li>Scrum开发方法：偏重项目管理<ul><li>特点：计划性、灵活性</li></ul></li></ul><h3 id="3-软件需求分析"><a href="#3-软件需求分析" class="headerlink" title="3. 软件需求分析"></a>3. 软件需求分析</h3><ul><li>目的：弄清用户对系统的细节要求，完整、准确、清晰、具体地回答目标系统 “做什么”。准确地理解用户 出的软件功能、性能及其环境的要求。</li><li>必要性：用户与开发者的知识领域不同，产生歧义;软件开发失败 50%是需求 不合理，早期错误易放大。</li></ul><h4 id="需求工程活动"><a href="#需求工程活动" class="headerlink" title="需求工程活动"></a>需求工程活动</h4><ul><li><strong>需求获取</strong><ul><li>需求获取技术：面谈、问卷调查、群体诱导技术、参与调查法、文档分析、原型化方法、需求讨论会..<br>。</li></ul></li><li><strong>需求分析与建模</strong></li><li>需求规约：软件需求规约(文档)</li><li><strong>需求管理</strong></li><li><p><strong>需求验证</strong></p></li><li><p>业务需求：反映企业/组织对软件系统的高层次目标要求，即软件系统的建设目标。</p></li><li>用户需求：用来描述用户使用产品必须要完成的任务，使用业务领域的术语描述，采用开发者与用户都能理解的语言和图形表达。</li><li>功能需求：开发人员必须实现的软件功能，结果在需求规格说明书中。</li><li>（也包括非功能需求）：如界面的交互性、数据的安全性、 数据的事务性、用户的并发性、响应的快速性、操作的实时性、错误与异常的恢复性、软件 的容错性等等<h4 id="需求分析方法"><a href="#需求分析方法" class="headerlink" title="需求分析方法"></a>需求分析方法</h4></li><li>功能分析方法：将系统看作若干功能模块的集合，每个功能又可以分解为若干子功能，子功能还可继续分解，分解的结果已经是系统的雏形。</li><li>结构化分析方法(SA法)：是一种以数据、数据的封闭性为基础，从问题空间到某种表示的映射方法，由数据流图（DFD图）表示。</li><li>信息建模法：是从数据的角度对现实世界建立模型的，基本工具是ER图。</li><li>面向对象的分析方法（OOA）的关键是识别问题域内的对象，分析它们之间的关系，并建立起三类模型。<ul><li>面向对象的特性有<strong>抽象性、封装性、继承性、多态性和消息机制</strong>等五大特性。</li></ul></li></ul><h4 id="结构化分析方法-SA法"><a href="#结构化分析方法-SA法" class="headerlink" title="结构化分析方法(SA法)"></a>结构化分析方法(SA法)</h4><ul><li>基本思想<ul><li>分解：对于一个复杂的系统，为了将复杂性降低到可以掌握的程度，可以把大问题分解成若干小问题，然后分别解决。</li><li>抽象：分解可以分层进行，即先考虑问题最本质的属性，暂把细节略去，以后再逐层添加细节，直至涉及到最详细的内容，</li></ul></li><li><strong>DFD图</strong><ul><li>箭头表示<strong>数据流</strong>(表示数据流的名称和数据的流向)</li><li>圆或椭圆表示<strong>加工</strong></li><li>双杠或者单杠表示<strong>数据存储</strong></li><li>矩形框表示数据的源点或终点，即<strong>外部实体</strong>(系统外与系统交互的人或实体)。</li></ul></li><li>分层DFD图<ul><li>先确定系统范围，画出顶层的DFD图。顶层图说明了系统的边界，<br>即系统的输入和输出数据流，顶层图只有一张。</li><li>逐层分解顶层DFD图，获得若干中间层DFD图。中间层的数据流图描述了某个加工的分解，而它的组成部分又要进一步分解。 </li><li>画出底层的DFD图。底层图由一些不能再分解的加工组成。</li></ul></li><li><strong>数据字典(DD)</strong>：描述数据流图中出现的所有数据和加工。<ul><li>分层数据流图只是表达了系统的“分解”，为了完整地描述这个系统，还需借助“数据词典”和“小说明”对图中的每个数据和加工给出解释。</li><li><strong>数据流条目</strong>：给出了DFD中数据流的定义，通常对数据流的简单描述为列出该数据流的各组成数据项。</li><li><strong>文件条目</strong>：给出某个文件的定义，文件的定义通常是列出文件记录的组成数据流，还可指出文件的组织方式。</li><li><strong>数据项条目</strong>：给出某个数据单项的定义，通常是该数据项的值类型、允许值等。</li><li><strong>加工条目</strong>：说明DFD中基本加工的处理逻辑。由于上层的加工是由下层的基本加工分解而来，只要有了基本加工的说明，就可理解其他加工。</li></ul></li></ul><h3 id="4-软件体系结构设计"><a href="#4-软件体系结构设计" class="headerlink" title="4.软件体系结构设计"></a>4.软件体系结构设计</h3><h4 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h4><ul><li>软件设计阶段要解决“如何做”的问题</li><li>软件所有的开发工作都将根据设计的方案进行</li><li>软件的总体结构设计决定了系统的质量</li><li><strong>软件设计包括软件结构设计、数据设计、接口设计和过程设计。</strong><ul><li>结构设计：定义软件系统<strong>各主要部件之间的关系</strong></li><li>数据设计：将分析时创建的模型转化为数据结构的定义</li><li>接口设计：描述软件内部、软件和操作系统之间及软件与人之间如何通信</li><li><strong>过程设计</strong>：把<strong>系统结构部件</strong>换成<strong>软件</strong>的过程描述。</li></ul></li></ul><h4 id="软件设计的任务"><a href="#软件设计的任务" class="headerlink" title="软件设计的任务"></a>软件设计的任务</h4><ul><li>将分析阶段获得的需求说明转换为计算机中可实现的系统。</li><li>完成系统的结构设计，包括：数据结构和程序结构，最后得到软件设计说明书。</li><li>对模块内部的过程进行设计。</li></ul><h4 id="软件设计阶段任务"><a href="#软件设计阶段任务" class="headerlink" title="软件设计阶段任务"></a>软件设计阶段任务</h4><ol><li><strong>划分模块，确定软件结构</strong>：开发方法不同，确定软件结构的方法也不同。例如SD法，是从分层的DFD图导出初始的结构图，再对初始的结构图进行改进，获得最终的结构图。一般包括确定系统的软件结构，分解模块，确定系统的模块层次关系。</li><li>确定<strong>系统的数据结构</strong>：数据结构的建立对于<strong>信息系统</strong>而言尤为重要。要确定数据的类型，组织、存取方式，相关程度及处理方式等。</li><li>设计<strong>用户界面</strong>：作为人机接口的用户界面起着越来越重要的作用，它直接影响到软件的寿命。</li></ol><h4 id="软件的层次结构"><a href="#软件的层次结构" class="headerlink" title="软件的层次结构"></a>软件的层次结构</h4><ul><li>模块：是程序对象有名字的集合(过程、函数、子程序、宏..)。</li><li>深度：表示软件结构从顶层模块到最底层模块的层数。</li><li>宽度：表示控制的总分布。</li><li>扇出度：一个模块直接控制下属的模块个数。</li><li>扇入度：一个模块的直接上属模块个数。</li><li>好的软件结构的形态准则：顶部宽度小，中部宽度大，底部宽度次之；在结构顶部有较高的扇出数，在底部有较高的扇入数。</li></ul><h4 id="软件结构图-SC图"><a href="#软件结构图-SC图" class="headerlink" title="软件结构图(SC图)"></a>软件结构图(SC图)</h4><ul><li>　结构图（Structure Chart，简称SC图）是精确表达软件结构的图形表示方法，它以特定的符号表示模块、模块间的调用关系和模块间信息的传递。<ul><li>模块（Module）：用矩形框表示，框中写有模块的名字，说明模块的功能。</li><li>调用：从一个模块指向另一个模块的箭头表示前一模块对后一模块的调用，一般是上层调用下层。</li><li>数据：调用箭头边上的小箭头表示调用时从一个模块传送给另一模块的数据。通常在短箭头附近应注有信息的名字。</li></ul></li></ul><h4 id="模块独立性"><a href="#模块独立性" class="headerlink" title="模块独立性"></a>模块独立性</h4><ul><li>模块独立性的度量标准：<ul><li>耦合性——用于描述<strong>模块之间</strong>联系的紧密程度。</li><li>内聚性——用于描述<strong>模块内部</strong>联系的紧密程度。</li></ul></li><li>模块独立性比较强的模块，具有：<strong>高内聚性、低耦合度</strong>。</li><li>内聚性低 &rarr; <strong>高</strong>：偶然型  &rarr; 逻辑型 &rarr; 瞬时型  &rarr; 通信型  &rarr; 顺序型  &rarr; <strong>功能性</strong></li><li>耦合性高 &rarr; <strong>低</strong>：内容耦合 &rarr; 公共耦合 &rarr; 控制耦合 &rarr; 复合耦合 &rarr; <strong>数据耦合</strong></li></ul><h4 id="软件设计-SD"><a href="#软件设计-SD" class="headerlink" title="软件设计(SD)"></a>软件设计(SD)</h4><ul><li>软件设计定义：软件设计是把软件需求（定义阶段）转换为软件的具体设计方案，即划分模块结构的过程，是软件开发阶段最重要的步骤。</li><li>软件设计划分：按工程管理角度划分为：概要（总体）设计和详细设计。<br>概要（总体）设计完成高层次结构设计；详细设计进行低层次过程设计，并穿插数据设计和接口设计。</li></ul><ol><li>概要/总体设计：分解模块，确定系统模块的层次结构。<ul><li>任务：① 划分模块 ② 确定模块功能 ③ 确定模块间调用关系 ④ 确定模块间界面</li><li>步骤：从DFD图导出初始的模块结构图，按照SD法设计总则，改进模块结构图。</li><li>得出：<strong>软件/模块结构图</strong>及其模块功能说明。</li></ul></li><li>详细设计：对模块图中每个模块的过程进行描述，把功能描述转变为精确的、结构化的过程描述。<ul><li>常用<strong>描述方式</strong>：伪代码，流程图，N-S图，PAD图…</li></ul></li></ol><blockquote><p>软件设计过程，概要设计是关键，根据需求确定<strong>软件和数据的总体框架</strong>，详细设计是进一步精化成软件的算法和数据结构。</p></blockquote><h4 id="软件结构化方法的优化准则"><a href="#软件结构化方法的优化准则" class="headerlink" title="软件结构化方法的优化准则"></a>软件结构化方法的优化准则</h4><ul><li>抽象：抽取事物最基本的特性和行为，忽略非基本的细节。采用分层次抽象的办法可以控制软件开发过程的复杂性，有利于软件的可理解性和开发过程的管理。</li><li>信息隐藏：采用封装技术，将程序模块的实现细节（过程或数据）隐藏起来，不被不需要这些信息的其它模块访问。</li><li>模块化：模块是程序中逻辑上相对独立的单元；模块的大小要适中；高内聚、低耦合。<ul><li>使开发工作更易于规划</li><li>可以定义和交付软件增量</li><li>容易实施变更</li><li>更有效地开展测试和调试</li></ul></li><li>一致性：整个软件系统（包括文档和程序）的各个模块均应使用一致的概念、符号和术语；程序内部接口应保持一致； </li></ul><h3 id="5-软件测试"><a href="#5-软件测试" class="headerlink" title="5. 软件测试"></a>5. 软件测试</h3><ul><li>软件测试是为了发现错误而运行程序的过程</li><li>软件测试的目的是发现程序中的错误，是为了证明程序有错， 而不是证明程序无错</li><li>测试对象不仅是程序，还应该包括开发过程中产生的所有产品，包括文档，其目的是为了尽早地、尽可能多的发现并排除软件中潜在的错误。<h4 id="软件测试分类"><a href="#软件测试分类" class="headerlink" title="软件测试分类"></a>软件测试分类</h4></li><li>程序执行角度<ul><li><strong>静态测试</strong>：通过人工分析或<strong>程序正确性证明</strong>的方式来确认程序正确性。</li><li><strong>动态测试</strong>：通过<strong>动态分析</strong>和<strong>程序测试</strong>等方式检查程序执行状态，以确认是否有问题。</li></ul></li><li>测试技术角度：<ul><li><strong>黑盒测试</strong>：将测试对象看做一个黑盒子，完全<strong>不考虑程序内部</strong>的逻辑结构和内部特性，只依据程序的<strong>需求规格说明书</strong>，检查<strong>程序的功能</strong>是否符合它的功能说明。</li><li><strong>白盒测试</strong>：把测试对象看做一个透明的盒子，允许测试人员<strong>利用程序内部</strong>的逻辑结构及有关信息，设计或选择测试用例，对程序所有<strong>逻辑路径</strong>进行测试。</li></ul></li><li>测试对象角度：</li><li><strong>单元测试</strong>：对软件基本组成单元进行的测试，其测试对象是软件设计的<strong>最小单位</strong>(<strong>模块</strong>或者类)。</li><li><strong>集成测试</strong>：在单元测试的基础上，将所有模块按照总体设计的要求组装成为<strong>子系统</strong>或<strong>系统</strong>进行的测试。测试对象是模块间的接口，其主要目的是找出在模块接口(包括系统体系结构)设计上的问题。</li><li><strong>功能测试</strong>：在已知产品所应具有的功能基础上，从<strong>用户角度</strong>来进行功能验证，以确认每个功能是否都能正常使用。</li><li><strong>性能测试</strong>：在实际或模拟实际的运行环境下，针对<strong>非功能特性</strong>所进行的测试。</li><li><strong>验收测试</strong>：软件产品完成了系统测试之后、产品发布之前进行的软件测试活动，其<strong>目的</strong>是验证软件的功能和性能是否能够满足用户所期望的要求。</li><li>人工干预角度：<ul><li><strong>手动测试</strong>：手工地输入测试数据并记录测试结果</li><li><strong>自动化测试</strong>：利用开发的软件测试工具或者脚本</li></ul></li></ul><h4 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h4><ul><li><strong>互审</strong>：程序员相互检查对方的代码</li><li><strong>走查</strong>：一个小组集体来走查程序或文档(分析方法：调用图、数据流分析图)</li><li><strong>会议</strong>：召开一个正式的会议，并有相应的记录、纪要、相应结果的文档。</li></ul><h4 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h4><h5 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h5><ul><li>逻辑覆盖法：<ul><li>语句覆盖：只覆盖可执行语句至少执行一次。</li><li>判定覆盖：又叫分支覆盖，对每个判定式取真、假各一次，使每个判定的每个分支都至少执行一次，同时满足语句覆盖。</li><li>条件覆盖：把程序中每个判断的每个条件为真和假各取值一次。 条件覆盖深入到判定中的每个条件，但不一定满足判定覆盖的要求。</li><li>判定/条件覆盖：同时满足判定、条件两种覆盖标准的取值。就是使得判定中每个条件的所有可能取值至少执行一次，同时每个判定本身所有取值至少执行一次。</li><li>条件组合覆盖：按每个判断的所有条件取值进行组合。这是 5 种覆盖中最强的覆盖。它不但可<strong>覆盖所有条件</strong>，还可<strong>覆盖所有判断的可取分支</strong>。</li></ul></li><li>基本路径覆盖法<ul><li>导出程序流程图的拓扑结构-流图(控制流程图)</li><li>计算流图 G 的环路复杂性 V(G)</li><li>确定只包含独立路径的基本路径集，设计测试用例</li></ul></li></ul><h5 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h5><ul><li>等价类划分法：<ul><li>对测试数据进行区间划分，从这些区间中选取典型值作为用例代表，认为测试等价类中的一个代表值的结果就等于对该类其它值的测试。</li><li>如果某个等价类的一个输入数据（代表值）测试中查出了错误，表示该等价类的其它值也有错误。</li><li>选择测试用例：① 为每个等价类编号 ② 使一个测试用例尽可能覆盖多个有效等价类<br>（<strong>注意：一个测试用例只能覆盖一个无效等价类。</strong>）</li><li><code>有效等价类</code>：对于程序的规格说明，是合理的、有意义的输入数据构成的集合。</li><li><code>无效等价类</code>：对于程序的规格说明，是不合理的、没有意义的输入数据构成的集合。</li></ul></li><li>边界值分析法：对输入或输出的边界值进行测试的一种方法。因为在等价类的边界处，是最可能出现错误的。<ul><li>步骤：划分等价类，选择测试用例，测试等价类边界。</li><li>边界选择原则：① 输入值范围的边界 ② 输入/输出值个数的边界 ③ 输出值域的边界 ④ 输入/输出有序集（如顺序文件、线性表）的边界</li></ul></li><li>错误推测法</li><li>因果图法</li></ul><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul><li>驱动模：模拟主程序或者调用模块的功能，用于向被测模块传递数据，接收、打印从被测模块返回的数据。<strong>一般只设计一个驱动模块</strong>。</li><li>桩模块：又称为假模块，用于模拟那些由被测模块所调用的下属模块的功能。可以设计<strong>一个或者多个桩模块</strong>，才能更好地对下属模块进行模拟。</li><li>测试方法以<strong>白盒法</strong>为主，驱动模块和桩模块都是额外开销。</li></ul><h4 id="集成-组装测试"><a href="#集成-组装测试" class="headerlink" title="集成/组装测试"></a>集成/组装测试</h4><ul><li>一次性集成方式：分别测试每个单元，再一次性将所有单元组装在一起进行测试。</li><li>渐增式集成方式：先对某几个单元进行测试，然后将这些单元逐步组装成较大的系统，在组装过程中边连接边测试。（自顶而下增值，自底而上增值，混合增值）<br>自顶而下增值，自底而上增值可以选择<strong>深度优先</strong>或者<strong>宽度优先</strong>增值</li><li>两种方式都需要设计驱动模块或桩模块，对每一个新组装的子系统进行测试主要采用黑盒法，对发现问题较多的子系统或模块应该用白盒法作回归测试。</li><li>集成过程原则：尽早测试关键模块  &rarr; 提高测试效率，尽早测试包含I/O的模块   &rarr; 为以后测试提供方便</li></ul><h4 id="系统-性能测试"><a href="#系统-性能测试" class="headerlink" title="系统/性能测试"></a>系统/性能测试</h4><ul><li>恢复测试：让软件强制地发生故障，然后来验证是否能恢复到正常工作。</li><li>安全测试：验证保护机制是否能够正常工作。</li><li>压力(强度)测试：在一种需要反常数量、频率或资源的方式下执行系统。</li><li>性能测试：测试软件在集成系统中的运行性能。</li></ul><h4 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h4><ul><li>测试的目的：显示存在错误</li><li>调试的目标：发现错误或导致程序失效的错误原因，并修改程序以修正错误。调试是测试之后的活动。</li><li><strong>三种调试方法</strong><ul><li>蛮力法(强行排错法)</li><li>返回法、回溯法</li><li>原因排除法 <h3 id="软件维护"><a href="#软件维护" class="headerlink" title="软件维护"></a>软件维护</h3></li></ul></li><li><code>软件维护</code>：在软件运行／维护阶段对软件产品进行<br>  的修改是所谓的维护。</li><li>软件维护类型<ul><li><strong>改正性维护</strong>：修改软件缺陷或者不足</li><li><strong>适应性维护</strong>：修改软件使其适应不同操作环境，主要包括硬件变化、操作系统变化或者其他支持软件变化。</li><li><strong>完善性维护</strong>：增加或修改系统功能，使其适应业务变化。</li><li><strong>预防性维护</strong>：采用先进的软件工程方法对需要维护的软件或软件中的某一部分（重新）进行设计、编制和测试。是为了提高软件的<strong>可维护性、可靠性</strong>等，为<strong>以后进一步改进软件</strong>打下良好基础。</li></ul></li><li>维护的副作用<ul><li>代码副作用</li><li>数据副作用</li><li>文档副作用。</li></ul></li><li>维护工作面临的困难：周期长、难度大、费用高。维护费用高</li></ul><h4 id="Point"><a href="#Point" class="headerlink" title="Point"></a>Point</h4><ul><li><strong>三层C/S结构</strong>包含表示层、功能层和数据层。</li><li><strong>软件</strong>由程序、数据和文档构成的。</li><li>从工程管理方面来分类，<strong>软件设计</strong>一般分为概要设计和详细设计，它们之间的关系是全局和局部。</li><li><strong>面向对象程序设计原则</strong>包括开闭原则、里氏替换原则、单一职责原则和依赖倒转原则。<ul><li><strong>开闭原则</strong>：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。抽象化是开闭原则的关键           </li><li><strong>单一职责原则</strong>：一个类只负责一个功能领域中的相应职责。或者说，一个类，应该只有一个引起它变化的原因。</li><li><strong>里氏替换原则</strong>：所有引用基类（父类）的地方必须能透明的使用其子类的对象。（实现开闭原则的重要方式之一）</li><li><strong>依赖倒转原则</strong>：抽象不应该依赖于细节，细节应当依赖于抽象。</li><li><strong>合成复用原则</strong>：尽量使用对象组合，而不是继承来达到复用的目的。</li></ul></li><li>在软件结构化设计方法中，指导模块划分的最重要原则是高内聚、低耦合。</li><li>需求分析最终结果是产生需求规格说明书。</li><li>模块独立性中，使得每个模块只完成一个相对独立的特定子功能，并且与其它模块的关系很简单。</li><li><strong>产品需求</strong>又可以细分为功能性需求和非功能性需求。</li><li><strong>需求内容来源</strong>于干系人、组织规章制度、业务过程和现有系统。</li><li>在<strong>需求工程过程</strong>中，最重要的工程活动包括需求获取、需求分析与建模、需求验证和需求管理。</li><li><strong>软件设计原则</strong>是系统分解和模块设计的基本标准，应用这些原则可以使代码更加灵活、易于维护和扩展。一些通用的原则包括抽象、封装、模块化、层次化和复用。</li><li>在测试过程中，需要考察<strong>模块间的接口</strong>和<strong>各模块之间联系**</strong>的测试属于集成测试。</li><li><strong>软件测试用例</strong>主要由输入用例和预期输出结果两部分组成</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-软件工程概述&quot;&gt;&lt;a href=&quot;#1-软件工程概述&quot; class=&quot;headerlink&quot; title=&quot;1. 软件工程概述&quot;&gt;&lt;/a&gt;1. 软件工程概述&lt;/h3&gt;&lt;h4 id=&quot;软件的概念和特点&quot;&gt;&lt;a href=&quot;#软件的概念和特点&quot; class=&quot;headerlink&quot; title=&quot;软件的概念和特点&quot;&gt;&lt;/a&gt;软件的概念和特点&lt;/h4&gt;&lt;p&gt;&lt;code&gt;软件&lt;/code&gt;(广义)：计算机系统中与硬件相互依存的一部分  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;程序&lt;/strong&gt;：计算机可以接受的一系列指令，运行时可以提供所要求的功能和性能。&lt;br&gt;&lt;strong&gt;数据&lt;/strong&gt;：使得程序能够适当地操作信息的数据结构。&lt;br&gt;&lt;strong&gt;文档&lt;/strong&gt;：描述程序的研制过程、方法和使用的图文资料。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络笔记05 链路层</title>
    <link href="http://daisine.me/cn5/"/>
    <id>http://daisine.me/cn5/</id>
    <published>2018-06-08T04:35:04.000Z</published>
    <updated>2018-06-08T05:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="5-1-链路层概述"><a href="#5-1-链路层概述" class="headerlink" title="5.1 链路层概述"></a>5.1 链路层概述</h3><ul><li>基本概念:<ul><li>主机和路由器：结点</li><li>相邻结点的通信信道：链路 eg.wired links, wireless links, LANs</li><li>链路层的数据分组</li><li>帧 <code>frame</code>: 封装网络层的数据报 </li></ul></li><li>链路层的背景<ul><li>在不同的链路当中使用不同的协议来传输数据报:e.g.,<br>第一个链路以太网Ethernet，第二个链路是帧中继网络，第三个网络是802.11</li><li>不同的链路提供的服务也不同</li></ul></li></ul><a id="more"></a> <h4 id="链路层的服务"><a href="#链路层的服务" class="headerlink" title="链路层的服务"></a>链路层的服务</h4><ul><li>成帧, 链路接入: <ul><li>将数据报封装成帧, 加上首部和尾部字段</li><li>多路访问(接入)</li><li>“MAC” 地址用于标识发送结点和接收节点</li></ul></li><li>相邻结点间的可靠传输：<ul><li>保证无差错地经链路层移动每个网络层数据报</li><li>在错误率低的链路中(光纤,某类双绞线)中不需提供，而无线链路:具有较高的错误率</li></ul></li><li>流控制: 匹配相邻结点的 (发送/接收)速度</li><li>差错检验: <ul><li>由信号衰减、噪声等产生差错</li><li>接收结点需要检测是否出现bit差错: 丢弃错误帧，告知发送结点重传(可选) </li></ul></li><li>差错恢复（可选）: 接收结点可以发现并修复bit差错，不需发送结点进行重传</li><li>半 / 全双工: 半双工指结点不能在发送的时候同时接收数据</li></ul><h4 id="链路层协议在何处实现"><a href="#链路层协议在何处实现" class="headerlink" title="链路层协议在何处实现"></a>链路层协议在何处实现</h4><ul><li>(most)在每个主机上(硬件)：链路层协议在<code>网络适配器</code>/<code>网络接口卡</code>上部署 <ul><li>a.k.a. network interface card NIC<br>Ethernet card, PCMCI card, 802.11 (wifi) card</li><li>通过系统总线接入系统</li><li>适配器上还包括物理层协议</li></ul></li><li>(少数)在运行于主机CPU上的软件中实现</li></ul><blockquote><p>链路层是软件、硬件的结合体，即此处是协议栈中软件与硬件交接的地方</p></blockquote><h3 id="5-2-差错检验和纠正"><a href="#5-2-差错检验和纠正" class="headerlink" title="5.2 差错检验和纠正"></a>5.2 差错检验和纠正</h3><ul><li>EDC = 差错检验和纠正比特(redundancy)</li><li>D = 数据, 保护首部信息</li><li>差错检验并不是100% 可靠，也有可能出现<strong>未检出比特差错</strong><br><img src="https://i.loli.net/2018/06/06/5b17b5ba7d457.png" width="60%" height="60%"> </li></ul><h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><ul><li>单个奇偶校验位: 检测单个bit差错(当差错“突发”式聚集，偶数个/奇数个bit差错)</li><li>二维奇偶校验: 检测和<strong>恢复</strong>单个比特差错<h4 id="检验和方法"><a href="#检验和方法" class="headerlink" title="检验和方法"></a>检验和方法</h4></li><li><p>目标: 检测数据分组的差错(传输层)</p></li><li><p>发送方:把报文段分成16bit的整数序列</p><ul><li>检验和: 16bit的整数序列求和</li><li>将检验和封装到TCP/UDP首部</li></ul></li><li>接收方:计算接收报文段的检验和<ul><li>与首部中的检验和字段进行比对:不同 - &gt; error detected 相同 - &gt; no error detected. </li></ul></li><li>与链路层使用CRC相比，提供相对较弱的差错保护。<ul><li>因为<strong>运输层</strong>的差错检验用<strong>软件</strong>实现，采取简单而快速的方法</li><li>而<strong>链路层</strong>的差错检验在适配器中用<strong>专用的硬件</strong>实现，能够快速执行更复杂的CRC操作</li></ul></li></ul><blockquote><p>检验和比对结果相同是不是绝对没出错？</p></blockquote><h4 id="循环冗余检测"><a href="#循环冗余检测" class="headerlink" title="循环冗余检测"></a>循环冗余检测</h4><ul><li>将数据分组<strong>D</strong>看作一个二进制整数</li><li>双方协商一个r+1的<strong>生成多项式，G</strong><ul><li>G的最高比特位为1</li></ul></li><li>目标: 选择长度为r的附加比特, R, 使得<ul><li>用 <strong>&lt;D,R&gt;</strong> 对G进行模2除法 </li><li>接收方也知道 <strong>G</strong>, 用 <strong>&lt;D,R&gt;</strong> 除以<strong>G</strong>. </li><li>如果余数不为零: error detected!</li><li>可以检测小于r+1个比特的差错</li></ul></li><li>广泛应用于多种链路协议(Ethernet, 802.11 WiFi, ATM)  </li><li>其他用途：CRC32: 压缩文件检验 / CRC 可作为hash函数<br><img src="https://i.loli.net/2018/06/06/5b17b92459d0c.png" width="30%" height="30%"> </li></ul><h2 id="5-3-多址访问协议"><a href="#5-3-多址访问协议" class="headerlink" title="5.3 多址访问协议"></a>5.3 多址访问协议</h2><h4 id="两种类型的“链路”"><a href="#两种类型的“链路”" class="headerlink" title="两种类型的“链路”:"></a>两种类型的“链路”:</h4><ul><li>点对点链路：链路一端的单个发送方和另一端的单个接收方<br>eg. <code>PPP</code>：拨号接入 <code>HDLC</code>：高级数据链路控制</li><li>广播链路：(共享链路和物理媒介)<br>eg. <code>Ethernet</code>：以太网 <code>802.11 wireless LAN</code>：wifi无线局域网</li></ul><h3 id="多址访问协议"><a href="#多址访问协议" class="headerlink" title="多址访问协议"></a>多址访问协议</h3><ul><li>只有一个信道，供多对通信实体访问</li><li>两个以上的并发通信: 干扰<ul><li>碰撞：如果同一时刻两个以上的结点同时发送信息    (信号纠缠在一起，发送的数据帧都会出错(丢失))</li></ul></li><li>分布式的算法<ul><li>结点怎么共享链路，如：确定哪个结点在什么时候可以发送数据</li><li>结点之间的协同也使用相同的链路，没有“带外信道”进行协同</li></ul></li></ul><h4 id="理想的多路访问协议"><a href="#理想的多路访问协议" class="headerlink" title="理想的多路访问协议"></a>理想的多路访问协议</h4><p>设广播信道的带宽为R bps </p><ol><li>当结点需要传输数据, 它可以充分利用带宽R.  </li><li>当M个结点需要传输数据, 每个结点可以平均使用带宽 R/M  </li><li>完全分布式控制:<br>不需要特殊的结点来协调(不需要主持人)<br>不需要时钟同步、划分时隙  </li><li>简单、易于实现  </li></ol><h4 id="多址访问协议：分类"><a href="#多址访问协议：分类" class="headerlink" title="多址访问协议：分类"></a>多址访问协议：分类</h4><ul><li>信道划分协议<ul><li>将信道划分为小的分片 “pieces” (时隙, 频段, 编码)</li><li>将每个信道分片分配给特定的用途，“各行其道，避免撞车”</li></ul></li><li>随机访问协议：信道不进行划分, 允许产生碰撞，重点是怎么从碰撞中“恢复”</li><li>轮流协议：结点按次序轮流传送数据</li></ul><h4 id="信道划分多址访问协议"><a href="#信道划分多址访问协议" class="headerlink" title="信道划分多址访问协议"></a>信道划分多址访问协议</h4><h5 id="TDMA-分时多址访问"><a href="#TDMA-分时多址访问" class="headerlink" title="TDMA: 分时多址访问"></a>TDMA: 分时多址访问</h5><ul><li>按照时间的“回合”来访问链路 </li><li>每个结点分配固定长度的时间间隙(time slot)<br>(length = pkt trans time) in each round </li><li>没有发送数据的时隙就空闲起(是一种浪费) </li></ul><h5 id="FDMA-分频多址访问"><a href="#FDMA-分频多址访问" class="headerlink" title="FDMA: 分频多址访问"></a>FDMA: 分频多址访问</h5><ul><li>信道根据频谱划分成若干个频段</li><li>每个结点使用固定的频段</li><li>不发送数据的结点所在的频段空闲 </li></ul><p><img src="https://i.loli.net/2018/06/06/5b17bd9ab1583.png" width="60%" height="60%"> </p><h5 id="CDMA-码分多址访问"><a href="#CDMA-码分多址访问" class="headerlink" title="CDMA: 码分多址访问"></a>CDMA: 码分多址访问</h5><p>为每个接入的结点分配一种不同的编码。如果精心挑选这些编码，CDMA具有不同的结点能够同时传输的性质。</p><blockquote><p>类似：很多人之间使用不同的语言交流。</p></blockquote><h4 id="随机多址访问协议"><a href="#随机多址访问协议" class="headerlink" title="随机多址访问协议"></a>随机多址访问协议</h4><ul><li>当结点需要发送数据时: 利用链路的全带宽来发送数据，不需要结点之间事先协调</li><li>两个以上的结点传输 ➜ 产生“碰撞”</li><li>随机多址访问协议将规约: 怎样检测碰撞，怎样从碰撞中恢复 (e.g., 延迟一下传输)</li><li>随机多址访问协议的案例: 时隙ALOHA, ALOHA, CSMA, CSMA/CD, CSMA/CA<h5 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h5></li><li>假设:<ul><li>所有帧的长度相同: L</li><li>划分成等长的时隙: t<br>时隙为传输1个帧的时间, t= L/R</li><li>结点只能在时隙开始时传输帧</li><li>结点必须保持<strong>时钟同步</strong></li><li>如果两个结点在一个时隙内传数据，所有结点都可以检测到碰撞</li></ul></li><li>操作:当结点准备传输一个帧<ul><li><strong>如果没有碰撞</strong>: 结点就在下一个时隙传输该帧</li><li><strong>如果产生碰撞</strong>: 结点就以<strong>概率p</strong>重传帧直到成功传输完该帧</li></ul></li><li>时隙ALOHA是<strong>高度分散</strong>的，因为每个节点检测碰撞并独立决定何时重传。<br><img src="https://i.loli.net/2018/06/06/5b17c1739ac0f.png" width="50%" height="50%"> </li></ul><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>单个活动结点:可充分利用带宽(相比TDMA)</td><td>碰撞后要等待, 浪费时隙</td></tr><tr><td>分布式</td><td>空闲时隙</td></tr><tr><td>简单</td><td>结点需要快速检测出碰撞、时钟同步</td></tr></tbody></table><h5 id="纯ALOHA"><a href="#纯ALOHA" class="headerlink" title="纯ALOHA"></a>纯ALOHA</h5><ul><li>非时隙Aloha: 更简单, 不需要时钟同步</li><li>当帧封装好，待发送时：马上发送该帧(不需要等待到时隙的开始) </li><li>增加了碰撞的概率:<br>如下图：t0时刻发送的帧与其他时刻发送的帧产生了碰撞<br><img src="https://i.loli.net/2018/06/06/5b17c173ae5a6.png" width="60%" height="60%"> </li></ul><h5 id="CSMA-载波监听多址访问"><a href="#CSMA-载波监听多址访问" class="headerlink" title="CSMA (载波监听多址访问)"></a>CSMA (载波监听多址访问)</h5><ul><li>传输之前先监听信道:<ul><li>如果信道空闲: 传输整个帧</li><li>如果信道忙碌, 推迟发送帧</li></ul></li><li>监听，仍然会产生碰撞: 信道传输时延产生“异步”</li><li>碰撞: 整个数据帧就会丢失(可惜)</li><li>注意: 距离和传播时延对碰撞检测的作用</li></ul><h5 id="CSMA-CD-具有碰撞检测的CSMA"><a href="#CSMA-CD-具有碰撞检测的CSMA" class="headerlink" title="CSMA/CD (具有碰撞检测的CSMA)"></a>CSMA/CD (具有碰撞检测的CSMA)</h5><ul><li>载波监听/碰撞检测<ul><li>在较短的时间检测到碰撞，并终止碰撞的传输，避免信道的浪费。</li></ul></li><li>碰撞检测功能: <ul><li>在有线网络中容易实现: 比较发送和接收信号 </li><li>在无线网络中难以检测: 接收信号衰减严重 </li></ul></li></ul><h5 id="CSMA-CD-算法描述"><a href="#CSMA-CD-算法描述" class="headerlink" title="CSMA/CD 算法描述"></a>CSMA/CD 算法描述</h5><ol><li>网卡接收到网络层的数据报，封装成帧</li><li>如果网卡检测到信道是空闲的, 则开始传输帧；如果信道是繁忙的, 则等到信道空闲后再传输.</li><li>如果网卡在传输帧的整个过程中没有检测到其他帧的传输, 则网卡成功传输该帧；</li><li>如果网卡检测到其他帧的传输，则取消发送该帧，并发送一个拥堵信号(jam signal)</li><li>取消之后, 网卡等待一个随机时间量，然后返回步骤2 (<strong>二进制指数回退</strong>): <ul><li>发生m次碰撞, 网卡从{0,1,2, …, 2m-1}中随机选择一个数K, 等待 K·512 比特时间后返回步骤2</li></ul></li></ol><ul><li>什么是<code>比特时间</code>？<br>如1Gbps，每比特时间是10<sup>-9</sup>s，若K=1023，则等待时间 t = 1023<em> </em>512<em> </em>10<sup>-9</sup>= 50 μs </li></ul><h4 id="轮流多址访问协议"><a href="#轮流多址访问协议" class="headerlink" title="轮流多址访问协议"></a>轮流多址访问协议</h4><ul><li>信道划分多址访问协议:<ul><li>在负荷高的时候：信道利用率、公平性等都比较好</li><li>在负荷低的时候：信道访问的产生时延(空闲时隙)，哪怕只有1个活动结点，链路的利用率也只有1/N! </li></ul></li><li>随机多址访问协议<ul><li>负荷低的时候：效率高，单个结点可以利用整个带宽</li><li>负荷高的时候：经常发送碰撞</li></ul></li><li>“轮流” 协议<ul><li>无论负荷高还是低，都可以有效利用网络</li></ul></li></ul><h5 id="轮询-Polling"><a href="#轮询-Polling" class="headerlink" title="轮询 Polling"></a>轮询 Polling</h5><ul><li>主结点按次序“邀请” 从发送数据</li><li>主要用于 “哑终端” </li><li>存在的问题: 引入轮询时延, 单点故障 (master)<h5 id="令牌传递协议-Token-passing"><a href="#令牌传递协议-Token-passing" class="headerlink" title="令牌传递协议 Token-passing"></a>令牌传递协议 Token-passing</h5></li><li>按照次序传递令牌: 得到令牌的结点可以传数据.</li><li>一个称为<code>令牌</code>的小的特殊帧在节点之间以某种固定次序进行交换</li><li>存在的问题: 令牌开销，单点故障(token)</li></ul><h4 id="多址访问协议总结"><a href="#多址访问协议总结" class="headerlink" title="多址访问协议总结"></a>多址访问协议总结</h4><ul><li>信道划分：分时, 分频</li><li>随机访问 (dynamic), <ul><li>ALOHA, S-ALOHA, CSMA, CSMA/CD</li><li>载波监听: easy in some technologies (wire), hard in others (wireless)</li><li>CSMA/CD used in Ethernet</li><li>CSMA/CA used in 802.11</li></ul></li><li>轮流访问<ul><li>polling, token passing</li><li>Bluetooth, FDDI, IBM Token Ring </li></ul></li></ul><h2 id="5-4-局域交换网"><a href="#5-4-局域交换网" class="headerlink" title="5.4 局域交换网"></a>5.4 局域交换网</h2><h3 id="链路层寻址和地址解析协议"><a href="#链路层寻址和地址解析协议" class="headerlink" title="链路层寻址和地址解析协议"></a>链路层寻址和地址解析协议</h3><h4 id="链路层编址"><a href="#链路层编址" class="headerlink" title="链路层编址"></a>链路层编址</h4><ul><li>MAC地址(LAN地址/物理地址)：烧写在网卡的ROM中</li><li>功能：<ul><li>给每一个<strong>网络接口</strong>编的地址</li><li>在<strong>局域网</strong>内工作</li><li>将数据帧从一个<strong>网络接口</strong>传输到<strong>物理连接</strong>的另外一个<strong>网络接口</strong></li></ul></li><li>6字节/48bit MAC地址(-分16进制)，如：1A-2F-BB-76-09-AD，共有<strong>2<sup>48</sup></strong>个可能的MAC地址</li><li>MAC 地址 vs IP地址<ul><li>工作在不同的协议层次</li><li>IP地址是在广域网/互联网中寻址</li><li>IP地址可以<strong>动态改变</strong>，MAC地址一般是<strong>固定</strong>的(也不会重复)</li><li>IP地址是<strong>层次结构</strong>，MAC地址是<strong>扁平结构</strong></li></ul></li><li>分配MAC地址？<ul><li>IEEE (国际电气和电子工程师协会)：设备生产商向IEEE购买MAC地址段</li></ul></li></ul><h4 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议: ARP"></a>地址解析协议: ARP</h4><ul><li>每个IP结点(主机或路由器端口)，在链路层有一个ARP表<br>&lt; IP address; MAC address; TTL&gt;</li></ul><p>A想给B发送数据报，且B的MAC地址不在A的ARP表中<br>——A通过链路广播来发送查询分组(帧)</p><ul><li><strong>广播</strong>的目的MAC地址：FF-FF-FF-FF-FF-FF<ul><li>who has IP address x.x.x.x，</li><li>tell a.a.a.a (A’s IP地址)</li></ul></li><li>局域网内的所有主机都会收到这个广播的查询帧</li><li>B收到这个APR查询后，向A回应自己的MAC地址<ul><li>B封装一个响应数据帧，发送到A的MAC地址</li><li>这次是<strong>单播</strong>，不是广播</li></ul></li><li>A收到B的响应之后，将它存入ARP表中</li><li>APR是<strong>“即插即用”</strong>的协议: 结点<strong>自主创建/更新</strong>ARP表，不需网络管理员干预</li></ul><h4 id="跨子网的地址解析"><a href="#跨子网的地址解析" class="headerlink" title="跨子网的地址解析"></a>跨子网的地址解析</h4><p><img src="https://i.loli.net/2018/06/06/5b17c62386e2a.png" width="70%" height="70%"> </p><p>如何穿过路由器<br>设：A知道B的IP地址，A知道路由器的IP地址/MAC地址(如何知道？)</p><ul><li>A创建IP数据报(源IP<sub>A</sub>, 目的IP<sub>B</sub>)</li><li>A创建链路帧(源MAC<strong><sub>A</sub></strong>, 目的MAC<strong><sub>R1</sub></strong>) </li><li>数据帧从A到达R，R解析数据帧，提交到IP层</li><li>R封装数据帧(源MAC<strong><sub>R2</sub></strong>, 目的MAC<strong><sub>B</sub></strong>)</li><li>R将IP数据报向B的子网转发</li><li>B收到数据帧，并解析数据帧并向上层提交数据报</li></ul><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><ul><li>有线局域网<ul><li>以太网：802.3  CDMA/CD</li><li>令牌环网：802.5</li></ul></li><li>无线局域网<ul><li>wifi: 802.11  CSMA/CA</li><li>…   802.15<br><img src="https://i.loli.net/2018/06/06/5b17c7e1f289b.png" width="40%" height="70%"> </li></ul></li><li>以太网是<strong>最典型的局域网</strong></li><li>以太网是局域网技术的主流 <ul><li>网络接口(网卡)造价低廉</li><li>简单(相比于令牌网和ATM)</li><li>速度不断升级: 10 Mbps – 10 Gbps </li></ul></li></ul><h4 id="以太网帧结构"><a href="#以太网帧结构" class="headerlink" title="以太网帧结构"></a>以太网帧结构</h4><p><img src="https://i.loli.net/2018/06/06/5b17c910ac45a.png" width="60%" height="70%"> </p><ul><li>前同步码: 共8个字节<ul><li>前七个字节都为：10101010, 最后一个字节为：10101011</li><li>用于发送方和接收方的<strong>时钟同步</strong></li></ul></li><li>MAC地址: 共12个字节，目的地址和源地址各6个字节<ul><li>接收方的网卡收到帧，如果<strong>目的地址</strong>是<strong>自己的MAC地址</strong>或者<strong>目的地址</strong>是<strong>广播地址</strong>，则解析该帧并向网络层提交；否则<strong>丢弃该帧</strong>。</li></ul></li><li>类型: 2个字节，<ul><li>标识封装上层协议的类别，可能是IP数据报 / APR数据分组 / 其他链路层数据分组</li></ul></li><li>CRC: 4字节(32bit) 循环冗余检测码</li></ul><h5 id="以太网提供的服务"><a href="#以太网提供的服务" class="headerlink" title="以太网提供的服务"></a>以太网提供的服务</h5><ul><li>无连接服务：发送方和接收方不需要事先握手</li><li>不可靠的通信<ul><li>链路层的接收方不会给发送方确认(ACK/NAK都不发送)</li><li>存在问题：帧出错/丢失了怎么办？</li></ul></li><li>尽最大努力交付<ul><li>碰撞后：二进制指数回退</li></ul></li></ul><h5 id="以太网标准系列"><a href="#以太网标准系列" class="headerlink" title="以太网标准系列"></a>以太网标准系列</h5><ul><li>802.3</li><li>相同的MAC协议(CSMA/CD)和帧结构</li><li>不同的物理层<ul><li>不同的传输速度：2Mbps/10Mbps/100Mbps/1Gbps/10Gbps</li><li>不同的物理媒体：光纤、同轴电缆、双绞线</li></ul></li></ul><h3 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h3><h4 id="以太网的拓扑结构"><a href="#以太网的拓扑结构" class="headerlink" title="以太网的拓扑结构"></a>以太网的拓扑结构</h4><ul><li>总线结构(1990s): 所有的结点都在一个碰撞域(和其他结点都可能碰撞)</li><li>星型结构(当今主流): 通过交换机进行局域网连接，碰撞域隔离：结点不相互碰撞</li></ul><h4 id="链路层交换机-1"><a href="#链路层交换机-1" class="headerlink" title="链路层交换机"></a>链路层交换机</h4><ul><li>工作在链路层的网络设备</li><li>作用：<ul><li>存储、转发以太网帧</li><li>检测帧的目标MAC地址，选择性地发送到1个或多个输出链路</li></ul></li><li><strong>透明的</strong>：主机观测不到交换机的存在(交换机的接口没有MAC地址)</li><li>即插即用、自学习：交换机不需要配置</li><li>“交换”的含义：A-A’ 和 B-B’可以并行传输，不会碰撞</li><li>如何进行转发? <strong>交换机(/转发)表</strong> &lt; interface<sub>m</sub>, MAC<sub>x</sub> , TTL &gt;</li><li>如何生成转发表？<code>自学习机制</code> </li><li>双工，任何交换机接口能够同时发送和接收</li><li>性质</li><li>消除碰撞：交换机的缓存帧绝不会在网段伤同时传输多于一个帧</li><li>异质的连接：交换机将链路彼此隔离，因此局域网的不同链路能够以不同速率运行且能够在不同媒体上运行</li><li>管理：提供强化的安全性，并且易于管理。</li></ul><table><thead><tr><th></th><th>交换机</th><th>路由器</th></tr></thead><tbody><tr><td>存储转发</td><td>链路层设备</td><td>网络层设备</td></tr><tr><td>转发表</td><td>自学习</td><td>路由选择算法</td></tr><tr><td>适用于</td><td>小网络：几个局域网网段</td><td>几千台主机组成的更大网络</td></tr></tbody></table><h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><ul><li>动机<ul><li>出于网络管理的需要: 将局域网分成更多的组，更方便地管理用户</li><li>流量隔离: ARP/DHCP广播, 自学习产生flood</li><li>网络安全/隐私的考虑</li></ul></li><li>手段: 使用支持VLAN的交换机<ul><li>“三层”交换机: 带路由(工作在网络层、第三层)功能的交换机；使得单个交换机能够物理隔离出多个“子网”</li><li>多个交换机进行VLANs: 对以太网帧封装格式进行扩展：802.1Q, 增加了VLAN标签字段</li></ul></li></ul><h3 id="一次Web请求所要做的工作"><a href="#一次Web请求所要做的工作" class="headerlink" title="一次Web请求所要做的工作"></a>一次Web请求所要做的工作</h3><ul><li>物理连接：WLAN(802.3) or WIFI(802.11)</li><li>配置主机IP等参数<ul><li>手工配置</li><li>动态主机配置：DHCP</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) DHCP RequestAPP layer：DHCP MessageUDP封装：Sport 68 Dport 67ChecksumIP封装：SIP：0.0.0.0</span><br><span class="line">DIP：255.255.255.255(广播)(2) Framing DHCP-UDP-IP数据报MAC地址DMAC：FF-FF-FF-FF-FF-FFSMAC：bb-bb-bb-bb-bb-bbCRC</span><br><span class="line">(3) 交换机转发Frame链路泛洪(flooding)Why？(4) 路由器(DHCP服务器)解析帧 - &gt; 向上提交 - &gt; 接收到DHCP请求(5) DHCP ACKAPP Layer：提供CIDR编址信息- 分配给Bob的IP- Gateway- SubMask- DNS ServerUDP封装：Sport 67, Dport 68IP封装： SIP: DHCP服务器的IP    DIP: 255.255.255.255Framing：DMAC bb-bb-bb-bb-bb-bb     SMAC：DHCP服务器的MAC(6) 交换机转发帧不再泛洪(Why?), 自学习(7) 客户机接收到DHCP响应逐层解析数据分组, 操作系统为客户机机配置网络参数</span><br></pre></td></tr></table></figure><ul><li>浏览器输入HTTP请求，但需要得知目的IP</li><li>DNS查询、ARP查询</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(8) 客户机DNS请求APP Layer：DNS报文服务器的主机名查询类别：-type=aUDP封装：Sport bobport   Dport 53IP封装：SIP: bob的IP  DIP: DNS SeverFraming</span><br><span class="line">问题来了：DMAC? 网关的MAC地址是多少？(9) 需要知道网关的MAC(10) ARP查询客户机网卡- 封装ARP查询报文“Who has 网关IP，Tell Bob”- FramingDMAC：FF-FF-FF-FF-FF-FFSMAC：bb-bb-bb-bb-bb-bb(11) ARP响应- 网关接口 - 封装ARP响应报文 - FramingDMAC：bb-bb-bb-bb-bb-bbSMAC：网关的MAC(12) 客户机获得网关的MAC(13) FramingDMAC: 刚刚从ARP查询得知SMAC: bb-bb-bb-bb-bb-bb</span><br></pre></td></tr></table></figure><ul><li>路由选择到DNS服务器</li></ul><p><code>`</code><br>(14) DNS查询到达网关路由器</p><ul><li>存储</li><li>转发：通过转发表来确定输出链路<br>(15) Comcast网络边界路由器们</li><li>存储</li><li>转发：通过转发表来确定输出链路<br>(16) DNS Server收到查询报文</li><li>DNS缓存中没有记录<ul><li>向上级DNS迭代查新</li></ul></li><li>DNS缓存中有记录<ul><li>封装DNS回答报文, 通过网络交付<br>(17)Bob便携机从DNS报文中抽取出服务器的IP地址<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Web客户-服务器交互：TCP和HTTP</span><br><span class="line"></span><br><span class="line">```(18) HTTP和TCP的合作：套接字- 浏览器创建Socket (四元组标识) - Sport：浏览器随机生成;  Dport：80 - SIP：Bob的IP; DIP：Google WWW的IP(刚刚通过DNS查询到)- TCP三次握手开始, 客户端发送TCP SYN请求(19) 路由转发…(20) 服务器对连接请求做出响应 TCP SYN ACK(21) 客户机收到SYN ACK --套接字创建成功！！(22) HTTP请求 --HTTP GET报文(23) 报文进入套接字- TCP封装</span><br><span class="line"> - 端口号 - 序号</span><br><span class="line"> - 确认号……(23) HTTP响应- Sever读取HTTP请求- 找到Web对象- 封装HTTP响应- 发送到TCP套接字中(24) Bob终于收到了报文！</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;5-1-链路层概述&quot;&gt;&lt;a href=&quot;#5-1-链路层概述&quot; class=&quot;headerlink&quot; title=&quot;5.1 链路层概述&quot;&gt;&lt;/a&gt;5.1 链路层概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;基本概念:&lt;ul&gt;
&lt;li&gt;主机和路由器：结点&lt;/li&gt;
&lt;li&gt;相邻结点的通信信道：链路 eg.wired links, wireless links, LANs&lt;/li&gt;
&lt;li&gt;链路层的数据分组&lt;/li&gt;
&lt;li&gt;帧 &lt;code&gt;frame&lt;/code&gt;: 封装网络层的数据报 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;链路层的背景&lt;ul&gt;
&lt;li&gt;在不同的链路当中使用不同的协议来传输数据报:e.g.,&lt;br&gt;第一个链路以太网Ethernet，第二个链路是帧中继网络，第三个网络是802.11&lt;/li&gt;
&lt;li&gt;不同的链路提供的服务也不同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络笔记04 网络层</title>
    <link href="http://daisine.me/cn4/"/>
    <id>http://daisine.me/cn4/</id>
    <published>2018-06-08T04:33:57.000Z</published>
    <updated>2018-06-08T04:57:43.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="4-1-网络层概述"><a href="#4-1-网络层概述" class="headerlink" title="4.1 网络层概述"></a>4.1 网络层概述</h3><ul><li>网络层服务和协议: 提供主机之间的<strong>逻辑通信</strong>。</li><li>在<strong>端系统</strong>中<ul><li>发送方：将报文段封装成<strong>数据报</strong>，提交给数据链路层。</li><li>接收方：将数据报解析成报文段，提交给运输层。</li></ul></li><li>在<strong>网络核心</strong>节点中<ul><li>路由器：转发数据报，交付到目的主机<a id="more"></a> </li></ul></li></ul><h4 id="分组转发和路由选择"><a href="#分组转发和路由选择" class="headerlink" title="分组转发和路由选择"></a>分组转发和路由选择</h4><ul><li>网络的两个主要功能<ul><li><strong>分组转发</strong>：分组到达路由器的输入链路，路由器将分组移动到正确的输出链路</li><li><strong>路由选择</strong>：确定分组的路径<br><img src="https://i.loli.net/2018/06/06/5b17832ee7016.png" width="40%" height="40%"></li><li>(第三个功能 可选)<strong>建立连接</strong>  </li><li>在某些网络体系中存在连接:ATM (异步传输模式), 帧中继, MPLS</li><li>在交付数据报之前，要建立虚拟的连接：主机和路由器都参与连接</li></ul></li><li>网络层 v.s. 运输层 连接服务:<ul><li>网络层: 两个主机以及中间的路由器创建的虚电路</li><li>运输层: 两个进程直接建立连接的端到端连接，中间的路由器不参与</li></ul></li></ul><h4 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h4><p>网络层能够提供的<strong>数据交付服务</strong>包括:</p><ul><li>当运输层向网络层<strong>传递一个分组</strong>时:<ul><li>确保交付</li><li>具有时延上界确保交付</li></ul></li><li>为给定的源和目的地之间的<strong>分组数据流</strong>提供的交付服务:<ul><li>有序分组交付</li><li>确保最低带宽</li><li>确保最大时延抖动</li><li>安全性服务</li></ul></li></ul><h3 id="4-2-虚电路和数据报网络"><a href="#4-2-虚电路和数据报网络" class="headerlink" title="4.2 虚电路和数据报网络"></a>4.2 虚电路和数据报网络</h3><table><thead><tr><th>数据报网络</th><th>虚电路网络</th></tr></thead><tbody><tr><td>无连接的服务</td><td>面向连接的服务</td></tr><tr><td>目标地址决定路径</td><td>分组携带虚电路ID</td></tr><tr><td>分组的路径可能<strong>会改变</strong></td><td>分组的路径<strong>不变</strong></td></tr><tr><td>类比: 自驾、问路</td><td>类比：火车</td></tr></tbody></table><h4 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h4><ul><li>端到端的路径类似于电话线路<ul><li>性能稳定</li><li>网络行为与端到端的路径紧密相关</li></ul></li><li><strong>3个阶段</strong>：建立连接、数据传输、虚电路拆除</li><li>每个数据分组携带虚电路标识<ul><li><strong>不是目标主机的地址</strong></li><li>可能要给虚电路预留资源：链路带宽、路由器缓存</li></ul></li><li>虚电路的<strong>组成</strong>：端到端的路径，虚电路标识，路由器中的转发表</li><li>虚电路<strong>标识</strong>：不是目的地址，一个连接中的虚电路号<strong>在不同的链路中</strong>可能<strong>标识不同</strong></li><li>虚电路的转发表: 路由器维护连接的状态信息</li><li>虚电路的<strong>信令协议</strong>：用于建立、维护、拆除虚电路，在ATM, frame-relay(帧中继), X.25等网络体系中使用；<strong>因特网中不再采用信令协议</strong>。</li></ul><h4 id="数据报网络——无连接的分组交换网络"><a href="#数据报网络——无连接的分组交换网络" class="headerlink" title="数据报网络——无连接的分组交换网络"></a>数据报网络——无连接的分组交换网络</h4><ul><li>网络层不需要建立连接</li><li>路由器：不需要维护端到端连接的状态，网络层不再有“连接”的概念</li><li>分组通过<strong>目的主机的地址</strong>来转发：一个端到端通信中，<strong>相同目的地址</strong>的分组可能走<strong>不同的路径</strong></li><li>数据报网络的转发表<ul><li>由于有40亿多IP地址, 转发表的记录是针对IP地址段</li><li>目的IP地址封装在数据报的首部</li><li><strong>最长前缀匹配</strong></li></ul></li></ul><h4 id="虚电路网络-vs-数据报网络"><a href="#虚电路网络-vs-数据报网络" class="headerlink" title="虚电路网络 vs. 数据报网络"></a>虚电路网络 vs. 数据报网络</h4><table><thead><tr><th>虚电路网络</th><th>数据报网络</th></tr></thead><tbody><tr><td>在电话网的基础上演化而来</td><td>计算机之间通信的网络</td></tr><tr><td>类似人的通信: 时延/可靠性/需要较多服务保障</td><td>弹性服务, 没有严格的时延需求</td></tr><tr><td>哑终端: 端系统较简单，如电话，网络较复杂</td><td>智能终端: 可控制处理差错，网络核心简单、边缘复杂</td></tr><tr><td></td><td>多种链路类型：特性不同，难以统一服务类型</td></tr></tbody></table><h4 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h4><h3 id="4-3-路由器的工作原理"><a href="#4-3-路由器的工作原理" class="headerlink" title="4.3 路由器的工作原理"></a>4.3 路由器的工作原理</h3><h4 id="路由器的体系结构"><a href="#路由器的体系结构" class="headerlink" title="路由器的体系结构"></a>路由器的体系结构</h4><ul><li>两个主要功能：分组转发、路由选择  </li><li>四个主要构件：输入、输出端口；路由选择处理器、交换结构<br><img src="https://i.loli.net/2018/06/06/5b178cfd397cf.png" width="50%" height="50%"> </li></ul><h4 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h4><p><img src="https://i.loli.net/2018/06/06/5b178cfd3210b.png" width="50%" height="50%"> </p><ul><li>链路终端：物理层，Bit信号接收</li><li>链路层协议接收端：数据链路层，e.g.以太网 参见第5章</li><li>查找转发排队：分布式交换<ul><li>转发：给定目的地址, 在路由转发表查找输出链路 (“match plus action”)</li><li>目标：匹配链路速度</li><li>排队：输入速度大于输出速度，产生队列</li></ul></li></ul><h4 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h4><ul><li>作用：将分组从输入端口的缓存</li><li>交换速度: rate at which packets can be transfer from inputs to outputs</li><li>三种类型的交换结构：经内存交换、经总线交换、经互联网络交换</li></ul><h4 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h4><p><img src="https://i.loli.net/2018/06/06/5b178cfd2f6ec.png" width="50%" height="50%"> </p><blockquote><p>缓存：输入速度大于输出时，将分组缓存/排队</p></blockquote><h3 id="4-4-IP-网际协议"><a href="#4-4-IP-网际协议" class="headerlink" title="4.4 IP:网际协议"></a>4.4 IP:网际协议</h3><p><img src="https://i.loli.net/2018/06/06/5b178f1377a25.png" width="50%" height="50%"> </p><h4 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h4><ul><li>网络层IP数据报：<ul><li>可封装为运输层的报文段(帧)：为上层提供服务 TCP/UDP</li><li>可封装<strong>ICMP</strong>控制报文—工作在<strong>网络层</strong><br><img src="https://i.loli.net/2018/06/06/5b1790cb0ea40.png" width="60%" height="60%"> </li></ul></li><li>版本(4 bits)：IP协议的版本号(4 或 6)，不同版本的IP数据报首部字段不同，路由器能确定如何解释剩余字段</li><li>首部长度(4 bits)：4 bytes为1个单位，20字节固定首部长度+扩展首部(选项字段)</li><li>服务类型(8 bits)：低时延、高吞吐量、实时、可靠性等<br>，告知路由器，以便按需调度(排队、转发)</li><li>数据报长度(16 bits)：IP数据报的总长度(单位为字节)，理论上最大长度为2<sup>16</sup>-1字节，实际：1500字节。</li><li>16比特标识 + 标志 + 片偏移（16 bits + 3 bits + 13 bits)：用于IP数据报的分片和组装，后面详解。</li><li>生存次数(8 bits)：IP数据报最多能通过多少个节点<ul><li>每经过一个路由器，TTL减1</li><li>TTL=0时数据分组将被丢弃，意味着没有为分组找到合适的路径</li></ul></li><li>上层协议(8 bits)：IP数据报到达终点后才会使用，告诉接收方顶层使用什么协议。<code>6：TCP</code>  <code>17：UDP</code></li><li>首部检验和(16 bits)：只对首部字段检验，每个路由器都要检验，因为TTL减1的性质，每跳后首部检验和都会变化。</li><li>源IP地址、目的IP地址(各32bits)：用于对主机、路由器进行网络标识</li><li>选项字段 + 填充(长度可变，4 bytes的整数倍)：用于对IP协议的扩展</li></ul><h4 id="IP数据报的分片和组装"><a href="#IP数据报的分片和组装" class="headerlink" title="IP数据报的分片和组装"></a>IP数据报的分片和组装</h4><ul><li>网络链路最大传输单元(MTU) <ul><li>链路中能传送数据分组最大尺寸</li><li>不同链路的最大传输单元不同</li></ul></li><li>跨越不同网络时，需要将大数据报分片<ul><li>在边界路由器拆分成片</li><li>到目的地(端系统)后将分片组装</li><li>IP 首部中有3个字段<code>标识</code> <code>标志</code> <code>片偏移</code>：是否分片，如何组装</li></ul></li></ul><blockquote><p>为坚持网络内核保持简单的原则。IPv4的设计者决定将数据报的重新组装工作放到端系统中，而不是放到网络路由器中。<br>例子：P224 表4-2</p></blockquote><h4 id="IPv4网络编址"><a href="#IPv4网络编址" class="headerlink" title="IPv4网络编址"></a>IPv4网络编址</h4><ul><li>IP 地址: 对主机和路由器网络接口进行标识，32bit </li><li>接口: 主机(路由器)与链路之间的边界<ul><li>路由器有多个接口(路由器与它的任意一条链路之间的边界)</li><li>主机一般有1-2个网络接口 (e.g. wired Ethernet, wireless 802.11)</li></ul></li><li>IP地址是对每个网络接口进行编址</li><li>网络接口之间如何连接(链路层问题 5/6章)<ul><li>有线以太网的接口通过以太网交换机相互连接</li><li>无线局域网的接口通过无线基站连接. </li></ul></li></ul><blockquote><p>点分十进制：223.1.1.1 = 11011111 00000001 00000001 00000001</p></blockquote><h5 id="子网划分-将高位IP相同的端口划分为子集，不通过路由器转发而进行通信"><a href="#子网划分-将高位IP相同的端口划分为子集，不通过路由器转发而进行通信" class="headerlink" title="子网划分:将高位IP相同的端口划分为子集，不通过路由器转发而进行通信"></a>子网划分:将高位IP相同的端口划分为子集，不通过路由器转发而进行通信</h5><ul><li>IP地址分两段：高位：子网标识，低位：主机标识</li><li>子网划分方法:使用<strong>路由器的端口</strong>将网络划分成独立的”孤岛”，每个”孤岛”为一个子网</li><li>子网掩码：/24记法 前24bit是子网标识，置为1。<br>子网掩码: 255.255.255.<strong>0</strong><br>aka: 11111111 11111111 11111111 <strong>00000000</strong></li></ul><p><img src="https://i.loli.net/2018/06/06/5b17979878a32.png" width="30%" height="30%"> </p><h5 id="子网划分方法-CIDR"><a href="#子网划分方法-CIDR" class="headerlink" title="子网划分方法 CIDR"></a>子网划分方法 CIDR</h5><ul><li>(旧)分类编址：IP地址分为四类，根据规模划分子网<ul><li>A：0.0.0.0-127.0.0.0，126个网络× 16777214个地址</li><li>B：128.0.0.0-191.254.0.0，16256个网络×65534个地址</li><li>C：192.0.0.0-223.254.254.0，2064512个网络×254个地址</li><li>D：224-254，用于组播和调查等特殊用途</li></ul></li><li>CIDR：无类别域间路由选择<ul><li>子网标识部分的长度任意选择(不对子网分类)</li><li>地址格式：a.b.c.d / x ，x 是子网标识的长度(子网掩码)<br>200.23.16.0/23 子网掩码:  255.255.254.0</li><li>分层编址的优点：路由聚集</li></ul></li></ul><h5 id="组织机构获得IP地址块-子网-的方法："><a href="#组织机构获得IP地址块-子网-的方法：" class="headerlink" title="组织机构获得IP地址块(子网)的方法："></a>组织机构获得IP地址块(子网)的方法：</h5><ul><li>从ISP的地址空间中来获得一个地址块</li><li>ICANN向区域性因特网注册机构分配地址，这些记过一起形成了ICANN的地址支持组织，处理本地域内的地址分配/管理。</li></ul><h5 id="获取主机地址：DHCP-动态主机配置协议"><a href="#获取主机地址：DHCP-动态主机配置协议" class="headerlink" title="获取主机地址：DHCP 动态主机配置协议"></a>获取主机地址：DHCP 动态主机配置协议</h5><p>获取主机地址:手动配置 / 动态主机配置<br><strong>DHCP: 动态主机配置协议</strong></p><ul><li>DHCP协议不仅仅配置IP地址，还有其他重要的联网参数：<ul><li>网关地址(邻接路由器网络接口的IP地址)</li><li>DNS服务器的名字和IP地址</li><li>子网掩码</li></ul></li><li>DHCP工作的协议栈：<strong>工作在应用层</strong>，port：67(目的端口)、68(源端口)，传输层：UDP</li><li>4个步骤：<ul><li>DHCP服务器发现：客户在UDP分组向端口67发送<code>DHCP发现报文</code>，使用广播地址 255.255.255.255 并且使用源地址 0.0.0.0。链路层将该帧<strong>广播</strong>到<strong>所有</strong>与该子网连接的子网。</li><li>DHCP服务器提供：<code>DHCP提供报文</code>，同样使用<strong>广播</strong>地址 255.255.255.255。每台服务器提供的报文有收到的<strong>发现报文的事务ID</strong>，<strong>向客户推荐的IP地址</strong>，<strong>网络掩码</strong>以及<strong>IP地址租用期</strong>。</li><li>DHCP请求：新到达的客户从一个或多个服务器提供中选择一个，并向选中服务器提供一个<code>DHCP请求报文</code>进行响应，回显配置参数。仍然使用<strong>广播</strong>地址。</li><li>DHCP ACK：<code>DHCP ACK报文</code>，对DHCP请求报文进行响应，证实所要求的参数</li></ul></li></ul><h4 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换: NAT"></a>网络地址转换: NAT</h4><ul><li>动机<ul><li>多个用户可以使用一个IP接入互联网</li><li>不需要再从ISP获得地址段</li><li>内部设备的地址更改不需要告知外部网络</li><li>更换ISP后，内网的地址不需要变更</li><li>内网的结构被屏蔽(出于安全的考虑)</li></ul></li><li>NAT的实现: 端口/地址映射，NAT路由器上的一张<strong>NAT转换表</strong><br><img src="https://i.loli.net/2018/06/06/5b179ecc1c356.png" width="70%" height="70%"> </li><li>NAT的争议<ul><li>优势：有效解决IPv4地址空间的问题</li><li>问题：IETF对NAT提出了质疑<ul><li>路由器应该仅仅工作在网络层，但是NAT Router触及了运输层(端口)！端口号原本是用作进程编址的。</li></ul></li><li>NAT违反了端到端原则：主机之间应该直接对话，节点不应介入修改IP地址和端口号</li><li>IPv4的地址空间应该过度到IPv6来解决</li></ul></li><li>Anyway，NAT已经成为因特网的重要组件</li><li>NAT的穿越：外网的客户端怎么主动连接NAT内网的服务器？<ul><li>在NAT Router上静态配置映射</li><li>使用UPnP协议，通用即插即用协议</li><li>中继穿越</li></ul></li></ul><h4 id="因特网控制报文协议-ICMP"><a href="#因特网控制报文协议-ICMP" class="headerlink" title="因特网控制报文协议: ICMP"></a>因特网控制报文协议: ICMP</h4><ul><li>用途：主机/路由器直接沟通网络层的信息，如：错误报告<br>、回声响应(echo request/reply)</li><li>协议层次: 被看做是IP的一部分，ICMP报文由IP协议封装。但从体系结构上讲它是位于IP之上的。</li><li>ICMP报文格式：<ul><li>类型+编码：各1字节，用于标识ICMP数据报的类型、用途 <code>P236 图4-23</code></li><li>初始IP首部：20字节，初始数据内容：8字节</li></ul></li><li>ICMP应用：TraceRoute<ul><li>用来判断源和目的地址见所有路由器的名字、地址和数量。</li><li>向目的主机发送一系列普通IP数据报。这些数据报都携带了一个不可达UDP端口号和UDP报文段，TTL分别设置为1, 2, 3…</li><li>第n个数据报到达第n个路由器，TTL刚好过期。</li><li>根据IP协议规则，路由器丢弃该数据报病发送一个ICMP告警报文给源主机，该告警报文包含了路由器的名字和地址</li></ul></li></ul><h4 id="IPV6简要介绍"><a href="#IPV6简要介绍" class="headerlink" title="IPV6简要介绍"></a>IPV6简要介绍</h4><ul><li>IPv6 的动机<ul><li>初始动机：32-bits的IPv4地址空间很快就会耗尽</li><li>其他动机：首部字段：提高处理和转发速度，提高服务质量</li></ul></li></ul><h5 id="IPv6-数据报格式"><a href="#IPv6-数据报格式" class="headerlink" title="IPv6 数据报格式"></a>IPv6 数据报格式</h5><p><img src="https://i.loli.net/2018/06/06/5b17a3609039c.png" width="50%" height="50%"> </p><ul><li>版本：6</li><li>流量类型：同IPv4的服务类型</li><li>流标签：标识一条数据报的流</li><li>有效载荷长度：数据的长度</li><li>下一个首部：相当于IPv4的上层协议</li><li>跳限制：相当于IPv4的TTL</li><li>源地址和目的地址：各128位(RFC 4291)</li><li>数据：IPv6数据报的有效载荷部分</li><li>其他方面：<ul><li>取消分片/重装：在发送端分片，网络不进行分片和组装</li><li>取消首部Checksum：中间路由器不再进行检验，提高效率</li><li>取消选项字段：通过“下一个首部”来扩展</li></ul></li></ul><blockquote><p>首部40 bytes的固定长度，在该版本中不允许分片</p></blockquote><h5 id="从IPv4到IPv6的迁移"><a href="#从IPv4到IPv6的迁移" class="headerlink" title="从IPv4到IPv6的迁移"></a>从IPv4到IPv6的迁移</h5><ul><li>不能一下子将所有的路由器全部升级到IPv6</li><li>IPv4 和 IPv6 路由器混杂工作 <code>隧道技术</code>: <ul><li>IPv6 的数据报，封装成IPv4数据报，以便在IPv4的路由器上面进行处理</li></ul></li></ul><h3 id="4-5-路由选择算法"><a href="#4-5-路由选择算法" class="headerlink" title="4.5 路由选择算法"></a>4.5 路由选择算法</h3><h4 id="路由选择介绍"><a href="#路由选择介绍" class="headerlink" title="路由选择介绍"></a>路由选择介绍</h4><ul><li>网络结点的核心功能</li><li>网络的建模 <code>图论模型</code> : 图(Graph) ，点(Node)-路由器，边(Edge)-链路，权(cost)-网络的开销(链路长度/链路速度/链路费用)<br>图: G = (N,E)<br>N = 路由结点的集合= { u, v, w, x, y, z }<br>E = 链路的集合={ (u,v), (u,x), (u,w), (v,x), (v,w), (x,w), (x,y), (w,y), (w,z), (y,z) }</li><li>路由选择：寻找图中一个点到其他点的最”短”路径</li></ul><blockquote><p>图的概念也可以用于其它类型的网络，如: P2P, N 是Peer的集合，E是TCP连接的集合</p></blockquote><h5 id="路由选择算法的分类"><a href="#路由选择算法的分类" class="headerlink" title="路由选择算法的分类"></a>路由选择算法的分类</h5><ul><li>全局式路由选择算法 or 分布式路由选择算法<ul><li>全局式: 结点知道完整的网络拓扑。eg. 链路状态算法</li><li>分布式: 结点只知道自己的邻居是谁。eg.距离向量算法</li></ul></li><li>静态路由选择算法  or 动态路由选择算法 <ul><li>静态：路由信息不经常变化</li><li>动态：路由信息随网络状态经常变化</li></ul></li><li>负载敏感路由选择算法 or 负载迟钝路由选择算法<ul><li>负载名感算法中，链路费用会动态地变化以反应出底层链路的当前拥塞水平。 </li></ul></li></ul><h4 id="链路状态路由选择算法-LS"><a href="#链路状态路由选择算法-LS" class="headerlink" title="链路状态路由选择算法: LS"></a>链路状态路由选择算法: LS</h4><ul><li>算法输入：<ul><li>网络的完整拓扑</li><li>所有结点都知道完整拓扑</li><li>通过链路状态广播来实现 </li><li>所有结点的网络拓扑相同</li></ul></li><li>算法输出：计算本结点到其他结点的最短路径，并为该结点生成转发表</li><li>迭代算法: 经过k次迭代，得到k个结点的最“短”路径</li><li>标记:<ul><li>c(x, y): x到y链路的费用；如果x和y不是邻居,则c(x, y) = ∞</li><li>D(v): 在当前迭代中，从源结点到目标结点v的最低费用</li><li>p(v): 从源到v沿着当前最“短”路径中，v的前置结点</li><li>N’: 结点子集，如果从源到v的最短路径已确知，v在N’中.</li></ul></li><li>算法结构：初始化，迭代k次（网络中有k个结点）</li><li>算法复杂性：对于n个结点，每次迭代: 检测所有没在N’中的结点，n(n+1)/2 相当于: O(n<sup>2</sup>)</li><li>算法优化后的复杂度: O(n log n)</li><li>算法特点：  <ul><li><strong>分布式</strong>：每个结点都要从一个或多个邻居结点获得某些信息，作为算法的输入  </li><li><strong>迭代的</strong>：交换信息的过程要持续，迭代计算  </li><li><strong>异步的</strong>：不要求所有结点步伐一致地操作  </li></ul></li></ul><h4 id="距离向量-DV-路由选择算法"><a href="#距离向量-DV-路由选择算法" class="headerlink" title="距离向量(DV)路由选择算法"></a>距离向量(DV)路由选择算法</h4><ul><li><code>BF方程</code> 设：d<sub>x</sub>(y)为x结点到y节点的最短路径</li><li>则：d<sub>x</sub>(y) = min<sub>v</sub> {c(x, v) + d<sub>v</sub>(y) }</li><li><p>其中：</p><ul><li>v是x的邻居，x与y不是邻居，则选择x-v-…-y的一条最短路径</li><li>直观地：就是选择邻居(next router)</li></ul></li><li><p>距离向量: x到其他结点y的距离: D<sub>x</sub> = [D<sub>x</sub>(y): y ∈ N]</p></li><li><p>对于任意结点x</p><ul><li>了解它自己到每个邻居v的距离：D<sub>x</sub>(v) = c(x, v)</li><li>因此得出它自己的距离向量D<sub>x</sub> = [Dx(y): y ∈ N]</li><li>另一方面，x通过与邻居v交换信息，也了解它每个邻居v的距离向量：D<sub>v</sub> = [D<sub>v</sub>(y): y ∈ N]</li></ul></li><li><p>算法基本思想: </p><ul><li>随着时间的推移，每个节点都会与邻居交换距离向量，当x结点从邻居处接收到距离向量，它便通过 B-F方程更新自己的距离向量:D<sub>x</sub>(y) ← min<sub>v</sub>{c(x,v) + Dv(y)}    for each node y ∊ N</li><li>经过有限次迭代, 费用估计 D<sub>x</sub>(y) 收敛到实际最低费用 d<sub>x</sub>(y) </li><li>节点的三个活动：<code>等待</code> 来自链路或者邻居的信息，<code>计算</code> 更新DV，<code>通知</code> 向邻居更新自己的DV。</li></ul></li><li>算法特点<ul><li>迭代, 异步: 每次本地迭代由以下两种情况触发: 本地链路的费用发生变化的时候 or 从邻居获得更新的DV之后</li><li>分布式:节点DV更新后通知邻居，邻居更新DV后再通知它们的邻居 </li></ul></li></ul><blockquote><p>链路费用改变与链路故障、 增加毒性逆转</p></blockquote><table><thead><tr><th></th><th>LS</th><th>DV</th></tr></thead><tbody><tr><td>报文复杂性</td><td>G(N, E), 需发送O(NE)个报文</td><td>只需邻居之间交互报文</td></tr><tr><td>收敛速度</td><td>O(N<sup>2</sup>)，可能存在震荡</td><td>收敛速度不均(路由环路问题、无穷计数问题)</td></tr><tr><td>健壮性</td><td>结点广播变化的链路费用，每个结点独立创建自己的转发表</td><td>费用变化，逐层告知，一个不正确的结点计算值会扩散到整个网络</td></tr></tbody></table><h3 id="4-6-因特网中的路由选择"><a href="#4-6-因特网中的路由选择" class="headerlink" title="4.6 因特网中的路由选择"></a>4.6 因特网中的路由选择</h3><h3 id="4-7-广播和多播路由选择"><a href="#4-7-广播和多播路由选择" class="headerlink" title="4.7 广播和多播路由选择"></a>4.7 广播和多播路由选择</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;4-1-网络层概述&quot;&gt;&lt;a href=&quot;#4-1-网络层概述&quot; class=&quot;headerlink&quot; title=&quot;4.1 网络层概述&quot;&gt;&lt;/a&gt;4.1 网络层概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;网络层服务和协议: 提供主机之间的&lt;strong&gt;逻辑通信&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;端系统&lt;/strong&gt;中&lt;ul&gt;
&lt;li&gt;发送方：将报文段封装成&lt;strong&gt;数据报&lt;/strong&gt;，提交给数据链路层。&lt;/li&gt;
&lt;li&gt;接收方：将数据报解析成报文段，提交给运输层。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;网络核心&lt;/strong&gt;节点中&lt;ul&gt;
&lt;li&gt;路由器：转发数据报，交付到目的主机
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络笔记03 运输层</title>
    <link href="http://daisine.me/cn3/"/>
    <id>http://daisine.me/cn3/</id>
    <published>2018-06-08T04:33:05.000Z</published>
    <updated>2018-06-08T04:44:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="3-1-概述和运输层服务"><a href="#3-1-概述和运输层服务" class="headerlink" title="3.1 概述和运输层服务"></a>3.1 概述和运输层服务</h3><ul><li>提供了不同主机中应用进程之间的<code>逻辑通信</code>而非物理通信</li><li>运输层协议工作在<strong>端系统</strong>中<ul><li>发送方：将报文封装成报文段，提交给网络层</li><li>接收方：解析成报文，提交给应用层</li></ul></li><li>提供了两种协议 TCP &amp; UDP<a id="more"></a> </li></ul><h4 id="运输层和网络层的关系"><a href="#运输层和网络层的关系" class="headerlink" title="运输层和网络层的关系"></a>运输层和网络层的关系</h4><ul><li>从通信和信息处理的角度看，运输层向上面的<strong>应用层</strong>提供通信服务，属于<strong>面向通信部分的最高层</strong>，同时也是<strong>用户功能中的最底层</strong>。</li><li>网络层：<strong>主机</strong>之间的逻辑通信</li><li>运输层：<strong>进程</strong>之间的逻辑通信</li></ul><p><img src="https://i.loli.net/2018/06/05/5b169835a9038.png" width="40%" height="40%"></p><h4 id="运输层的服务"><a href="#运输层的服务" class="headerlink" title="运输层的服务"></a>运输层的服务</h4><ul><li>可靠的、有序的交付：<code>TCP</code><ul><li>面向连接的逻辑通信：握手机制</li><li>流控制：发送速度不能大于接收速度</li><li>拥塞控制：从发送端系统感知、避免网络的拥塞</li></ul></li><li>不可靠的、无序的交付：<code>UDP</code><ul><li>不提供必要的服务</li><li>尽最大努力向网络交付数据</li></ul></li><li>运输层没有提供的服务<ul><li>最低时延保障</li><li>最低带宽保障</li></ul></li></ul><h4 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h4><ul><li>多路分解：将运输层报文段中的数据交付到正确的套接字</li><li><p>多路复用：在源主机从不同的套接字中收集数据快，并为每个数据快封装上首部信息从而生成报文段，并将报文段传递到网络层<br><img src="https://i.loli.net/2018/06/05/5b1698361410c.png" width="60%" height="60%"></p></li><li><p>端口：</p><ul><li>使用16bit的整数来标识进程</li><li>在不同主机上，相同端口可能有不同的用途</li><li>两种类型的端口<br>0~1023 :  周知端口，用于标准协议，如FTP/HTTP/SMTP<br>1024~65535:  扩展端口，用于特定协议或客户端进程标识</li></ul></li><li>套接字：<ul><li>UDP套接字：目的IP地址 + 一个目的端口号 </li><li>TCP套接字：源端口号 + 源主机IP地址 + 目的端口号 + 目的主机IP地址</li></ul></li></ul><h5 id="多路分解的机制"><a href="#多路分解的机制" class="headerlink" title="多路分解的机制"></a>多路分解的机制</h5><ul><li>主机收到IP数据报<ul><li>数据报有源IP和目的IP</li><li>数据报中封装了应用报文</li><li>每个报文段中标识着源端口号和目的端口号 </li></ul></li><li>主机使用IP地址+端口号来定向应用进程的套接字</li></ul><h5 id="无连接的复用和分解"><a href="#无连接的复用和分解" class="headerlink" title="无连接的复用和分解"></a>无连接的复用和分解</h5><ul><li>使用<code>端口号</code>创建套接字: DatagramSocket mySocket1 = new DatagramSocket(99111);</li><li>UDP 套接字使用二元组来标识 :(dest IP address, dest port number)</li><li>当主机收到UDP报文:识别报文首部的目的端口号，将报文提交给该端口号对应的应用进程</li><li><strong>不同主机</strong>发送过来的报文，只要<strong>目的端口号</strong>相同，都提交给<strong>相同的套接字</strong></li></ul><h5 id="面向连接的复用和分解"><a href="#面向连接的复用和分解" class="headerlink" title="面向连接的复用和分解"></a>面向连接的复用和分解</h5><ul><li>TCP 套接字是一个四元组，包括: source IP address, source port number, dest IP address, dest port number</li><li>接收端的主机通过这四个值来定位到对应的套接字</li><li>服务器端的应用进程可能有并发的TCP套接字：每个套接字由一个四元组来标识</li><li>如：Web服务器对为个连接的客户端创建不同的套接字：非持久性连接HTTP对每个请求创建一个套接字</li><li><strong>不同主机</strong>发送过来的报文，即使<strong>目的端口号</strong>相同，<strong>不是</strong>都提交给相同的的套接字</li></ul><h3 id="3-3-无连接运输：UDP"><a href="#3-3-无连接运输：UDP" class="headerlink" title="3.3 无连接运输：UDP"></a>3.3 无连接运输：UDP</h3><ul><li>不提供额外服务的运输层协议：让网络尽最大努力交付，不能解决<strong>分组失序、丢失</strong>问题</li><li>是一个<strong>无连接</strong>的运输协议：UDP协议的发送端和接收端没有“握手”机制，每个分组单独处理，分组互不关联</li><li>优点：<ul><li>时延：没有连接(握手)的过程，减少时延</li><li>简单：没有连接状态管理，</li><li>高效：首部字段短<strong>(8 bytes)</strong></li><li>快速：可以<strong>突发式地传输</strong></li></ul></li></ul><p>基于UDP的应用：</p><ul><li>DNS：因特网目录服务，域名解析系统</li><li>SNMP：简单网络管理协议</li><li>流媒体传输</li><li>因特网电话</li></ul><p>基于UDP协议，如何实现可靠传输？</p><ul><li>将可靠传输的机制放在<code>应用层</code></li><li>在<code>应用程序</code>中定义<code>差错控制</code>的机制</li></ul><h5 id="UDP报文段结构"><a href="#UDP报文段结构" class="headerlink" title="UDP报文段结构"></a>UDP报文段结构</h5><p><img src="https://i.loli.net/2018/06/06/5b17294ed150c.png" width="40%" height="40%">  </p><ul><li>提供差错检验: 检验和</li><li>没有差错控制</li><li>长度: 报文段的总长度</li><li>UDP检验和的计算：<br><img src="https://i.loli.net/2018/06/06/5b17336a6347d.png" width="40%" height="40%">  </li></ul><h3 id="3-4-可靠传输原理"><a href="#3-4-可靠传输原理" class="headerlink" title="3.4 可靠传输原理"></a>3.4 可靠传输原理</h3><p><code>不可靠信道</code>的特点决定了可靠服务传输的复杂性<br><code>可靠数据传输</code>：为上层实体提供的服务抽象是，数据可以通过一条<code>可靠的信道</code>进行传输。借助于可靠信道，传输比特就不会受到损坏或丢失。</p><p><img src="https://i.loli.net/2018/06/05/5b16a2795eb54.png" width="50%" height="50%"><img src="https://i.loli.net/2018/06/05/5b16a27ec0049.png" width="50%" height="50%"></p><ul><li>过程：<ul><li>逐渐引入问题，bit差错-&gt;分组丢失……</li><li>发送端和接收端的协议逐渐丰富，版本演进</li></ul></li><li>工具：<ul><li>有限状态机(Finite State Machine, FSM)</li><li>分别定义发送方和接收方的状态(行为)</li></ul></li></ul><p><code>rdt1.0</code>：    <strong>理想信道</strong>中的数据传输<br><code>rdt2.x</code>：处理信道中的<strong>bit差错</strong><br><code>rdt3.0</code>：处理信道中的<strong>bit差错</strong>和<strong>分组丢失</strong>  </p><h4 id="rdt1-0：经完全可靠信道的可靠数据传输"><a href="#rdt1-0：经完全可靠信道的可靠数据传输" class="headerlink" title="rdt1.0：经完全可靠信道的可靠数据传输"></a>rdt1.0：经完全可靠信道的可靠数据传输</h4><ul><li>前提：下层信道是可靠的。底层信道没有bit差错、分组丢失</li><li>发送端和接收端的有限状态机：发送端向底层信道发送数据，接收端从底层信道读取数据</li></ul><h4 id="rdt2-0：处理bit差错"><a href="#rdt2-0：处理bit差错" class="headerlink" title="rdt2.0：处理bit差错"></a>rdt2.0：处理bit差错</h4><ul><li><code>检测bit差错？</code>差错检测：checksum()</li><li><code>恢复bit差错？</code>接收方反馈：<ul><li>肯定确认：接收方告诉发送方数据分组正确到达</li><li>否定确认：接收方告诉发送方数据分组出错</li><li>重传：发送方收到否定确认后重传该分组</li></ul></li><li>rdt2.0的机制：<code>停止等待协议</code>(Automatic Repeat reQuest, <code>ARQ</code>)<ul><li>检测：接收方检测bit差错</li><li>反馈：接收方发送确认消息(ACK或NAK)给发送方</li></ul></li></ul><p><code>rdt2.0存在的问题</code>：当接收方的ACK/NAK信息出错时，可能导致接受方数据重复。<br><code>解决办法</code>：识别重复的数据分组rdt2.1</p><h4 id="rdt2-1：处理“混淆的确认”——为分组编号"><a href="#rdt2-1：处理“混淆的确认”——为分组编号" class="headerlink" title="rdt2.1：处理“混淆的确认”——为分组编号"></a>rdt2.1：处理“混淆的确认”——为分组编号</h4><ul><li>识别重复分组：为数据分组进行编号 - &gt; 接收方丢弃重复分组 - &gt; 重传肯定确认(ACK)</li><li><p>序号空间最小为多少？理论上1个bit就够了，因为它可让接收方知道发送方是否正在重传前一个分组。</p></li><li><p>发送端:</p><ul><li>为分组编号：两个编号 {0,1}足矣</li><li>必须检测确认信息是否出错 </li><li>状态数量翻倍(相对于rdt2.0)：在状态值中必须记录当前的数据分组号是0 还是 1。</li></ul></li><li>接收端:<ul><li>必须检测数据分组是否出错</li><li>必须检测数据分组是否重复，状态值暗示了期待的分组号</li></ul></li></ul><p><code>rdt2.1存在的问题</code>：接收方不知道最后的确认信息是否被发送方正确收到。</p><h4 id="rdt2-2：小改进——不要否定确认-NAK-的协议"><a href="#rdt2-2：小改进——不要否定确认-NAK-的协议" class="headerlink" title="rdt2.2：小改进——不要否定确认(NAK)的协议"></a>rdt2.2：小改进——不要否定确认(NAK)的协议</h4><ul><li>和rdt2.1的功能相同</li><li>只使用肯定确认(ACK)，对ACK进行编号{0,1}足矣</li><li>发送方收到重复编号的ACK等同于收到NAK，此时发送方将重传分组</li></ul><h4 id="rdt3-0：处理信道中的bit差错和分组丢失"><a href="#rdt3-0：处理信道中的bit差错和分组丢失" class="headerlink" title="rdt3.0：处理信道中的bit差错和分组丢失"></a>rdt3.0：处理信道中的bit差错和分组丢失</h4><ul><li>差错控制：检测、确认、重传</li><li>处理分组丢失(如何让发送方认识到分组丢失了？)：<ul><li>基于时间的重传机制：发送端设置“ 定时器 ” timer ，超时重发</li><li>接收方仍然会收到重复分组：rdt2.2通过对分组编号能够处理冗余分组的情况</li></ul></li></ul><h4 id="停止等待-gt-流水线可靠数据传输协议"><a href="#停止等待-gt-流水线可靠数据传输协议" class="headerlink" title="停止等待 - &gt;流水线可靠数据传输协议"></a>停止等待 - &gt;流水线可靠数据传输协议</h4><p><code>rdt3.0</code>是一个<code>停等协议</code>，效率较低。<br>eg. 对于1Gbps的链路，有15ms的<strong>端到端时延</strong>，传输一个1KB的数据分组，链路的利用率有多少？吞吐率是多少？</p><ul><li>传输时延 = L/R = 8 kbit ÷ 10<sup>9</sup> bit/s =8 μs</li><li>利用率=传输时延 / (往返时延+传输时延)<br>=传输时延/(2 <em> 端到端时延+传输时延)<br>=0.008÷(2 </em> 15+0.008)<br>=0.00027  </li><li>意味着：每30ms传输1KB的数据，在1G的链路上只有33kB的吞吐量</li></ul><p><code>流水线</code>：发送方发送一个数据分组之后，在对方确认之前，可以继续发其他分组。</p><blockquote><p>成倍地提高网络的通信效率<br>但需要考虑流水线中如何实现差错控制(分组丢失、损坏或延时后如何重传？)</p></blockquote><ul><li>必须增加序号范围</li><li>协议的发送方和接收方两端可能需要缓存多个分组(以备重传)</li><li>所需序号范围和对缓存的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。</li></ul><h5 id="回退N步-GBN-滑动窗口协议"><a href="#回退N步-GBN-滑动窗口协议" class="headerlink" title="回退N步(GBN)/滑动窗口协议"></a>回退N步(GBN)/滑动窗口协议</h5><p>发送方：</p><ul><li>允许发送方发送多个分组，而不需等待确认</li><li>未确认的分组数 &lt; N (窗口长度)<ul><li>发送方的缓存容量是有限度的</li><li>不能让发送方“肆无忌惮”地发数据，否则跟UDP没太大区别</li><li><code>流控制</code>的需要：发送速率不能大于接收速率</li><li><code>拥塞控制</code>的需要：不要擅自给网络添堵</li></ul></li><li>发送方设置<code>定时器</code>：用于处理丢失重传问题<ul><li>定时器数目多多益善，但注意定时器也耗费资源!</li></ul></li></ul><p>接收方：</p><ul><li>接收方没有缓存(降低成本)</li><li>只接收有序的分组(向上提交)，会丢弃失序的分组</li><li>接收方确认分组：<ul><li><code>分组丢失—数据失序</code> 接收方丢弃失序分组</li><li><code>确认丢失—累积确认</code> ack3 ：小于等于序号3的分组都被确认收到</li><li><code>分组出错—重复确认</code> 接收方重复确认，发送方可在超时之前就重传</li></ul></li></ul><p><strong>滑动窗口</strong>(slide window)：窗口长度是固定的：N<br> <img src="https://i.loli.net/2018/06/06/5b174116e50a3.png" width="60%" height="60%"></p><h5 id="选择重传SR"><a href="#选择重传SR" class="headerlink" title="选择重传SR"></a>选择重传SR</h5><p>发送方：</p><ul><li>发送方有缓存(滑动窗口)</li><li>允许发送方发送多个分组，而不需等待确认</li><li>发送方有选择地重传：哪个分组的ack没收到，就重传那个分组</li></ul><p>接收方：</p><ul><li>接收方有缓存(滑动窗口)</li><li>分组失序：把分组缓存，向上层有序提交分组</li><li>接收方确认分组：<ul><li><code>分组丢失—数据失序</code> 接收方：缓存失序分组，逐个确认正确收到的分组</li><li><code>确认丢失—超时事件</code> 发送方重传</li><li><code>分组出错—重复确认</code> 接收方重复确认，发送方可在超时之前就重传(果断处之)<br><img src="https://i.loli.net/2018/06/06/5b174858862aa.png" width="80%" height="80%"></li></ul></li></ul><h4 id="实现可靠传输的基础构件"><a href="#实现可靠传输的基础构件" class="headerlink" title="实现可靠传输的基础构件"></a>实现可靠传输的基础构件</h4><ul><li>检验和</li><li>定时器</li><li>序号: 序号空间</li><li>确认: 确认序号/累积确认/重复确认/逐一确认(/否定确认）</li><li>窗口、流水线：窗口尺寸N、窗口变量：base， nextsqnum<h3 id="3-5-面向连接的运输：TCP"><a href="#3-5-面向连接的运输：TCP" class="headerlink" title="3.5 面向连接的运输：TCP"></a>3.5 面向连接的运输：TCP</h3><h4 id="TCP协议概述"><a href="#TCP协议概述" class="headerlink" title="TCP协议概述"></a>TCP协议概述</h4></li><li>因特网中最复杂的协议之一</li><li>端到端协议：一个发送方，一个接收方(不会广播)</li><li>可靠传输：<ul><li>有序的字节流传输：无损坏、无间隔、非冗余、按序交付。(差错检验、重传、累积确认、定时器、序号、确认号)</li><li>流水线协议：提供流控制和拥塞控制</li></ul></li><li>TCP是全双工协议<ul><li>在一个TCP连接中，数据流是双向的，发送方/接收方 可以发送数据，也可以接收数据</li><li>MSS最大报文段长度：实际指报文段应用层数据的最大长度，不包括TCP首部长度。</li></ul></li><li>TCP是面向连接的协议<ul><li>通过“握手”(交换控制信息)，初始化发送方和接收方的状态</li><li>连接状态完全保留在两个端系统中，TCP协议只在端系统中运行。中间的网络元素不会维持TCP的连接状态。P155</li></ul></li><li>TCP可实现流控制<ul><li>发送方的发送速度不能超过接收方的接收速度</li></ul></li></ul><h4 id="TCP可靠运输"><a href="#TCP可靠运输" class="headerlink" title="TCP可靠运输"></a>TCP可靠运输</h4><h5 id="TCP的序号、确认号"><a href="#TCP的序号、确认号" class="headerlink" title="TCP的序号、确认号"></a>TCP的序号、确认号</h5><ul><li>序号空间：[0—2<sup>32</sup>]</li><li>序号规则：<ul><li>面向<strong>字节流</strong>编序号：报文段的编号是该报文段数据中第一个字节的编号<br>Seq<sub>(i+1)</sub> == Seq<sub>(i)</sub> + L<sub>segment(i)</sub>  </li><li>不是对报文段编号</li></ul></li><li><code>确认号</code>ACK：期望的下一个报文段 <ul><li>ACK<sub>(0)</sub> == 0 </li><li>ACK<sub>(i)</sub> == Seq<sub>(i)</sub>+ 1</li></ul></li></ul><p><img src="https://i.loli.net/2018/06/06/5b175013a695c.png" width="70%" height="70%"></p><h5 id="TCP的确认和重传机制"><a href="#TCP的确认和重传机制" class="headerlink" title="TCP的确认和重传机制"></a>TCP的确认和重传机制</h5><ul><li>流水线协议</li><li>GBN和SR的混合体</li><li>此外，接收端也有定时器  </li></ul><table><thead><tr><th></th><th>事件</th><th>TCP接收方的动作</th></tr></thead><tbody><tr><td>延迟确认</td><td>期望序号的报文段按序到达，之前的报文段都已经被确认</td><td>延迟500ms确认新到的分组(为累积确认做准备)</td></tr><tr><td>累积确认</td><td>期望序号的报文段按序到达，另一个按序报文等待确认</td><td>立即发送单个累积确认，确认两个按序报文段</td></tr><tr><td>冗余确认</td><td>比期望序号大的报文段到达。检测出间隔</td><td>立即发送冗余确认(<strong>重复确认</strong>)，指示下一个期待字节的序号</td></tr><tr><td>立即确认</td><td>失序后最低望序号的报文段到达</td><td>立即发送确认(不延迟500ms)</td></tr><tr><td>快速重传</td><td>发送方收到3个冗余确认</td><td>超时之前重发报文段，避免无谓的等待</td></tr><tr><td>加倍超时</td><td>发送方产生一次超时重传</td><td>发送方加倍超时间隔。是一种有限形式的<code>拥塞控制</code></td></tr></tbody></table><blockquote><p>累积确认还可以解决<strong>确认丢失的问题</strong>: 发送方不会重传分组</p></blockquote><h4 id="往返时间估计"><a href="#往返时间估计" class="headerlink" title="往返时间估计"></a>往返时间估计</h4><p>TCP往返时间估计是为了解决<code>TCP协议的发送方如何设置定时器的时间间隔</code>的问题。<br><code>超时时间间隔</code>应大于RTT(往返时间)，但由于路由器的拥塞和端系统负载的变化，RTT总是在波动。</p><ul><li>超时时间间隔过小：累积确认到达之前，会产生不必要的重传！</li><li>超时时间间隔过大：对分组丢失的反映迟钝，降低了传输效率。累积确认、快速重传可以解决一些问题，但还是需要充分估计RTT。</li></ul><p><strong>估计RTT</strong><br>SampleRTT:<strong>某个</strong>报文段被发出，到收到确认的时间间隔。</p><blockquote><p>TCP仅在某个时刻做一次SampleRTT测量，SampleRTT的值也会波动。因此需要统计学意义上的测量和估计</p></blockquote><p><code>指数加权移动平均(EWMA)</code> <strong>EstimatedRTT</strong> = ( 1 - &alpha; ) <em> EstimatedRTT + &alpha; </em> SampleRTT<br><code>RFC 6298</code>: &alpha; = 0.125</p><p><code>估计RTT偏差</code> <strong>DevRTT</strong> = ( 1 -     &beta; ) <em> DevRTT + &beta; </em> | SampleRTT - EstimatedRTT |<br><code>RFC 6298</code>: &beta; = 0.25</p><p><code>设置超时时间间隔</code> <strong>TimeoutInterval</strong> = EstimatedRTT + 4 * DevRTT</p><h4 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h4><p><img src="https://i.loli.net/2018/06/06/5b175bfd35763.png" width="50%" height="50%">  </p><ul><li>源端口和目的端口(各占 2 字节)：是运输层与应用层的服务接口，实现对运输层的复用和分解。</li><li>序号(4 字节)：TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是<strong>本报文段所发送的数据的第一个字节的序号。</strong></li><li>确认号(4 字节)：是期望收到对方的下一个报文段的数据的第一个字节的序号。 </li><li>数据偏移/首部长度( 4 bit )：指示了以32 bit(4 字节为计算单位)的字为单位的TCP首部长度。若无选项字段，TCP长度固定为20字节。</li><li>保留字段( 6 bit )：保留为今后使用，目前均置为 0。</li><li>6个比特位 <ul><li><code>URG</code> 紧急比特位( 1 bit )：当 URG 为1时，告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。 </li><li><code>ACK</code> 确认比特位( 1 bit )：只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。 </li><li><code>PSH</code> 推送比特位( 1 bit )：接收推送比特位置 1 的报文段，接收方就应立即将数据交给上层，而不需缓存该报文段。 </li><li><code>RST</code> 复位比特位( 1 bit )：当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。 </li><li><code>SYN</code> 同步比特位( 1 bit )：同步比特 SYN = 1，就表示这是一个连接请求或确认连接的报文段。 </li><li><code>FIN</code> 终止比特位( 1 bit )：用来释放一个连接。当FIN = 1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 </li></ul></li><li>接收窗口( 2 字节 )：用于流量控制。TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限</li><li>检验和( 2 字节 )：检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。 </li><li>紧急指针( 2 字节 )：紧急指针指出在本报文段中的紧急数据的最后一个字节的序号。  </li><li>选项字段( 长度可变 )：目前只规定了一种选项，即最大报文段长度 MSS ；告诉对方 TCP“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。” </li><li>填充字段( 长度可变 )：使整个首部长度是 4 字节的整数倍。 </li></ul><h4 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h4><ul><li>目标：速度匹配 - &gt; 发送速度不能大于接收速度</li><li>原因：接收方的缓存空间有限，接收方提交数据的速度有限</li><li>机制：<ul><li>接收窗口：接收缓存中的剩余空间</li><li>接收方在向发送方确认时，随时告诉对方自己接收窗口的大小</li></ul></li></ul><p><img src="https://i.loli.net/2018/06/06/5b176f56448b8.png" width="50%" height="50%">  </p><h4 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h4><p>TCP是“面向连接”的运输协议</p><ul><li>运输之前，要先建立“逻辑连接”</li><li>初始化TCP的参数：序号、缓存</li><li>客户端发起连接：Socket clientSocket = new Socket(“hostname”, “port#”);</li><li>服务器端等待连接：Socket connectionSocket = welcomeSocket.accept();</li><li>通过三次握手建立连接<br><img src="https://i.loli.net/2018/06/06/5b17723a41cfa.png" width="70%" height="70%">  </li><li>关闭连接<br><img src="https://i.loli.net/2018/06/06/5b17712a0c33b.png" width="70%" height="70%">  </li></ul><h3 id="3-6-拥塞控制原理"><a href="#3-6-拥塞控制原理" class="headerlink" title="3.6 拥塞控制原理"></a>3.6 拥塞控制原理</h3><h4 id="网络拥塞"><a href="#网络拥塞" class="headerlink" title="网络拥塞"></a>网络拥塞</h4><ul><li>通俗地讲：由于过多的端点高速发送大量的数据，导致网络(路由器)难以胜任数据的转发</li><li>不同于流控制是匹配发送端和接收端的速度</li><li>拥塞的表现：<strong>分组重传作为网络拥塞的征兆</strong><ul><li>数据分组的丢失(路由器的缓存溢出)</li><li>产生较长的时延(在路由器缓存排队)</li></ul></li><li>拥塞控制是网络中的关键问题  </li></ul><p>通过对<strong>异步传递方式</strong>(ATM)网络中<strong>可用比特率</strong>(ABR)服务中的拥塞控制的讨论来总结本节</p><p><strong>拥塞情况1</strong>: 两个发送方和一台具有<strong>无限缓存</strong>的路由器</p><ul><li>链路的带宽：R </li><li>没有重传、流控制和拥塞控制</li></ul><p><strong>拥塞情况2</strong>:两个发送方和一台具有<strong>有限缓存</strong>的路由器</p><ul><li>链路的带宽：R</li><li>有分组重传控制:<br>应用层：(初始数据)λ<sub>in</sub> = (吞吐率)λ<sub>out</sub><br>运输层：(供给载荷)λ´<sub>in</sub> ≥ λ<sub>in</sub>  (λ´in包括了重传的数据分组)</li></ul><p><strong>拥塞情况3</strong> ：四发送方和一台具有有限缓存的多台路由器和多条路径<br>新的拥塞代价: 一个路由器将分组丢失，这个路径上先前的路由器也做了无用功</p><table><thead><tr><th>理想情况</th><th>拥塞情况1</th><th>拥塞情况2</th></tr></thead><tbody><tr><td>发送方”神知”路由器是否有可用缓存空间</td><td>路由器缓存溢出，丢失分组</td><td>路由器缓存中出现转发队列</td></tr><tr><td>只在路由器有缓存空间的情况下才发数据</td><td>发送方只在分组丢失的情况下重传</td><td>发送方产生超时事件</td></tr><tr><td>结果：不会丢失分组 λ´<sub>in</sub> = λ <sub>in</sub></td><td>代价：发送方会重传丢失的分组 λ´<sub>in</sub> &gt; λ<sub>in</sub></td><td>代价：发送方会重传延时的分组 λ´<sub>in</sub> &gt; λ<sub>in</sub></td></tr></tbody></table><blockquote><p>吞吐量、时延与主机发送速率的函数关系</p></blockquote><h4 id="拥塞控制的方法"><a href="#拥塞控制的方法" class="headerlink" title="拥塞控制的方法"></a>拥塞控制的方法</h4><ul><li>端到端拥塞控制:<ul><li>网络层不提供显式拥塞反馈</li><li>端点通过<strong>超时和冗余确认</strong>来感知是否发生了拥塞</li><li><strong>工作在运输层</strong>：通过TCP实现拥塞控制</li></ul></li><li>网络辅助的拥塞控制:<ul><li>路由器会告知端点产生了拥塞</li><li>使用特殊的分组来告知阻塞</li><li><strong>工作在链路层</strong><h3 id="3-7-TCP拥塞控制"><a href="#3-7-TCP拥塞控制" class="headerlink" title="3.7 TCP拥塞控制"></a>3.7 TCP拥塞控制</h3></li></ul></li><li>发送方感知网络的拥塞程度，来限制发送速度<ul><li>感知网络拥塞：发送方产生超时事件 / 收到接收方的3个冗余确认</li><li>控制拥塞：发送方设计一个动态调节的“阀门”——<strong>拥塞窗口</strong></li></ul></li></ul><h5 id="拥塞窗口-cwnd"><a href="#拥塞窗口-cwnd" class="headerlink" title="拥塞窗口(cwnd)"></a>拥塞窗口(cwnd)</h5><ul><li>发送端的一个<strong>动态参数</strong>，用于控制发送速度，初始值为1MSS(最大报文段长度)</li><li>拥塞窗口的工作机制<ul><li>限制向网络中传输的数据: LastByteSent-LastByteAcked &le; cwnd</li><li>TCP传输速率也是动态的<br>粗略地估计，在一个RTT内可以传输cwnd个字节: rate ≈ cwnd / RTT bytes/sec<br><img src="https://i.loli.net/2018/06/06/5b177b0688cc6.png" width="40%" height="40%"> </li></ul></li></ul><p><strong>拥塞窗口的动态调节策略</strong></p><ul><li>在拥塞产生之前，保守地增加拥塞窗口的大小<ul><li><code>加性增</code>: 每次增加1MSS个字节，直到检测到丢包事件</li></ul></li><li>在感知到拥塞后，迅速地减小拥塞窗口的大小<ul><li><code>乘性减</code>: 发生丢包事件后，拥塞窗口马上缩小一半</li></ul></li></ul><p><strong>TCP拥塞控制算法</strong><br>缓慢启动</p><ul><li>连接开始，速率翻倍提高，直到发生第一个丢包事件<ul><li>拥塞窗口初始值为1MSS</li><li>每经历1RTT，拥塞窗口翻倍(*2)</li><li>收到ACK后便进行更新</li></ul></li><li>初始速度很低，然后指数增长</li><li>产生超时事件：拥塞窗口重设为1MSS，重新慢启动</li><li>收到3个冗余确认：拥塞窗口减半，然后线性增长</li></ul><p>拥塞避免(提前采取措施)</p><ul><li>设定一个门限(阈yù值)</li><li>拥塞窗口达到门限值后，进入加性增长：每次增加1MSS</li><li>产生丢包事件后，收缩窗口、阈值<ul><li>阈值：缩减为拥塞窗口的一半</li><li>超时：拥塞窗口重新进入慢启动</li><li>三个冗余ACK：拥塞窗口从新的阈值开始加性增加</li></ul></li></ul><p>快速恢复：TCP的可选功能。<br><code>TCP Tahoe</code>：没有快速恢复，<code>TCP Reno</code>：综合了快速恢复</p><blockquote><p>TCP拥塞控制算法(慢启动、拥塞避免和快速恢复)的完整FSM描述</p></blockquote><p><img src="https://i.loli.net/2018/06/06/5b178146265e4.png" width="45%" height="45%"></p><p><strong>TCP吞吐量的宏观描述</strong><br>平均吞吐量是拥塞窗口和RTT的函数：<br>设W为丢包事件产生后的拥塞窗口大小，平均窗口大小约 3/4 W，平均吞吐量为3/4W per RTT<br>一条连接的平均吞吐量 = 0.75 * W / RTT<br><strong>经高带宽路径的TCP吞吐量</strong><br>网格和云计算需要高速的链路和吞吐量  </p><p>eg. 1500Bytes报文段, 100ms RTT, 为了获得10 Gbps的吞吐率<br>设平均拥塞窗口W = 83,333Bytes<br>考虑到丢包情况的吞吐率, 设丢包率为L [Mathis 1997]:<br>一条连接的平均吞吐量 = </p><blockquote><p>为了达到10Gbps的吞吐量，丢包率要非常低，小于L = 2·10-10!<br>针对高速的TCP设计，目前还在不断演化中</p></blockquote><p><strong>TCP的公平性</strong></p><ul><li>公平性的目标：<ul><li>如果 K个TCP连接共享一个带宽为R的链路</li><li>每个TCP连接拥有的平均传输率为 R/K</li><li>eg.设有两个相互竞争的连接，公平性的体现：两条连接实现的带宽最终将沿着平等带宽的共享曲线波动。它们最终会收敛该状态。</li><li>公平性和UPD、公平性和并行TCP连接</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;3-1-概述和运输层服务&quot;&gt;&lt;a href=&quot;#3-1-概述和运输层服务&quot; class=&quot;headerlink&quot; title=&quot;3.1 概述和运输层服务&quot;&gt;&lt;/a&gt;3.1 概述和运输层服务&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;提供了不同主机中应用进程之间的&lt;code&gt;逻辑通信&lt;/code&gt;而非物理通信&lt;/li&gt;
&lt;li&gt;运输层协议工作在&lt;strong&gt;端系统&lt;/strong&gt;中&lt;ul&gt;
&lt;li&gt;发送方：将报文封装成报文段，提交给网络层&lt;/li&gt;
&lt;li&gt;接收方：解析成报文，提交给应用层&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;提供了两种协议 TCP &amp;amp; UDP
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络笔记02 应用层</title>
    <link href="http://daisine.me/cn2/"/>
    <id>http://daisine.me/cn2/</id>
    <published>2018-06-08T04:31:36.000Z</published>
    <updated>2018-06-08T04:38:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-1-应用层协议原理"><a href="#2-1-应用层协议原理" class="headerlink" title="2.1 应用层协议原理"></a>2.1 应用层协议原理</h2><h4 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h4><p>应用程序研发很可能利用两种主流的体系结构之一:<br><strong><code>客户-服务端体系结构</code>:</strong></p><ul><li>服务器: <ul><li>持续地工作(365*24)  </li><li>固定的、周知的地址(<code>IP地址</code>)  </li><li>备有数据中心  <a id="more"></a> </li></ul></li><li>客户端:<ul><li>与服务器端通信  </li><li>间歇地工作  </li><li>可能更换地址  </li><li>客户端不直接通信(客户总能通过该服务器的IP地址<code>发送分组</code>来与其进行联系)  </li></ul></li></ul><p><strong><code>对等/P2P体系结构</code>:</strong></p><ul><li>没有常开的服务器</li><li>任意端系统之间直接通信  </li><li>端系统是对等的  </li><li>具有自扩展性  </li><li>间歇地工作  </li><li>管理起来比较复杂  </li><li>适用于流量密集型的应用，如文件共享、下载加速、IP电话、IPTV  </li></ul><h4 id="进程通信P59"><a href="#进程通信P59" class="headerlink" title="进程通信P59"></a>进程通信P59</h4><p><code>进程</code>：主机上运行的程序。<br><code>进程之间如何通信</code>：</p><ul><li>同一主机内部(操作系统)：<ul><li>管道、共享内存</li><li>由操作系统控制</li></ul></li><li>不同主机之间<ul><li>主机可能安装了不同的操作系统</li><li>使用<code>套接字(Socket)</code>机制，<code>API</code></li><li>通过网络建立通信</li></ul></li></ul><p><strong>客户和服务器进程</strong>：发起通信的进程被标识为客户，在会话开始时等待联系的进程是服务器。</p><p><strong>进程与计算机网络之间的接口<code>套接字</code></strong><br>是应用程序进程和运输层协议之间的接口, 类似于“门”的概念。通过套接字，不同端系统的进程可以进行网络通信。</p><blockquote><p>由于套接字也成为应用程序和网络之间的<strong>应用程序接口/API</strong>套接字是一种软件接口(API)</p></blockquote><p><strong>进程寻址</strong>：主机由<code>IP地址</code>标识。<code>目的地端口号</code>用于标识运行在接收主机上的接收进程/接收套接字。</p><h4 id="可供应用层使用的运输服务P61"><a href="#可供应用层使用的运输服务P61" class="headerlink" title="可供应用层使用的运输服务P61"></a>可供应用层使用的运输服务P61</h4><ul><li>可靠数据传输<ul><li>正确：数据差错检验</li><li>完整：分组丢失后重传</li><li>eg.需要可靠传输的应用：文件传输、邮件、远程访问..</li></ul></li><li><code>吞吐量</code>：可用吞吐量就是发送进程向接收进程交付比特的速率。<ul><li>越大当然越好</li><li>应用程序对吞吐量的需求不同</li><li><code>带宽敏感的应用</code>：带宽敏感，具有吞吐量要求的应用程序多媒体传输</li><li><code>弹性应用</code>：根据情况或多或少利用可供使用的吞吐量，如电子邮件、文件传输、Web传送…</li></ul></li><li>定时/实时性：<ul><li>保证较小的时间延迟，</li><li>eg.因特网电话、会议 </li></ul></li><li>安全<ul><li>数据不被非法读取、篡改、伪造等</li><li>提供加解密、认证、签名等机制(SSL／TLS)</li><li>eg.电子交易、保密通信</li></ul></li></ul><table><thead><tr><th style="text-align:center">应用</th><th style="text-align:center">数据丢失</th><th style="text-align:center">吞吐量(书上是带宽)</th><th style="text-align:center">时间敏感</th></tr></thead><tbody><tr><td style="text-align:center">文件传输</td><td style="text-align:center">不能丢失</td><td style="text-align:center">弹性</td><td style="text-align:center">no</td></tr><tr><td style="text-align:center">电子邮件</td><td style="text-align:center">不能丢失</td><td style="text-align:center">弹性</td><td style="text-align:center">no</td></tr><tr><td style="text-align:center">Web文档</td><td style="text-align:center">不能丢失</td><td style="text-align:center">弹性</td><td style="text-align:center">no</td></tr><tr><td style="text-align:center">实时媒体</td><td style="text-align:center">容忍丢失</td><td style="text-align:center">audio: 5kbps-1Mbps; video:10kbps-5Mbps</td></tr><tr><td style="text-align:center">yes, 100’s msec</td></tr><tr><td style="text-align:center">存储媒体</td><td style="text-align:center">容忍丢失</td><td style="text-align:center">同上</td><td style="text-align:center">yes, few secs</td></tr><tr><td style="text-align:center">交互式游戏</td><td style="text-align:center">容忍丢失</td><td style="text-align:center">few kbps up</td><td style="text-align:center">yes, 100’s msec</td></tr><tr><td style="text-align:center">即时通讯</td><td style="text-align:center">不能丢失</td><td style="text-align:center">弹性</td><td style="text-align:center">yes and no</td></tr></tbody></table><h4 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h4><p><strong>TCP：可靠传输服务</strong></p><ul><li>保障收发进程之间的可靠传输<ul><li>流控制: 发送速度不大于接收速度 </li><li>拥塞控制: 对发送速度进行调节</li><li>分组排序、丢失重传等</li></ul></li><li>是一种面向连接服务</li><li>但不能保障: <ul><li>带宽(吞吐量)</li><li>最低时延</li><li>安全性</li></ul></li></ul><p><strong>UDP：尽力交付服务</strong></p><ul><li>不保证收发进程的可靠传输<ul><li>没有流控制</li><li>没有拥塞控制</li><li>没有分组排序和重传机制</li></ul></li><li>是一种无连接服务 </li><li>也不能保障<ul><li>带宽(吞吐量)</li><li>最低时延</li><li>安全性</li></ul></li></ul><table><thead><tr><th>应用类别</th><th>应用层协议</th><th>依靠的传输协议</th></tr></thead><tbody><tr><td>电子邮件</td><td>SMTP [RFC 2821]</td><td>TCP</td></tr><tr><td>远程访问控制</td><td>Telnet [RFC 854]</td><td>TCP</td></tr><tr><td>Web</td><td>HTTP [RFC 2616]</td><td>TCP</td></tr><tr><td>文件传输</td><td>FTP [RFC 959]</td><td>TCP</td></tr><tr><td>流式多媒体</td><td>HTTP(如yotube)</td><td>TCP</td></tr><tr><td>因特网电话</td><td>SIP[RFC 3261]、RTP{RFC 3550]、或专用的(如Skype)</td><td>UDP/TCP</td></tr></tbody></table><h4 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h4><p><code>应用层协议</code>定义了运行在不同端系统上的应用程序进程如何相互传递报文。</p><ul><li>报文类别，如：request, response </li><li>报文格式(语法)：报文的字段有哪些；字段描述</li><li>报文语义: 报文的处理方法；报文的各个字段的含义</li><li>报文处理规则：请求和相应时如何发送报文；处理流程</li><li>通用协议如何规约<ul><li>通过RFC来定义标准化</li><li>允许互操作</li></ul></li><li>非标准化的专用协议：可由开发者自己定制，如：Skype</li></ul><p>应用层协议只是网络应用的一部分。如，Web的应用层协议为HTTP，但是Web应用的组成部分包括文档格式标准(HTML)，Web浏览器，Web服务器以及一个应用层协议HTTP。</p><h2 id="2-2-Web和HTTP"><a href="#2-2-Web和HTTP" class="headerlink" title="2.2 Web和HTTP"></a>2.2 Web和HTTP</h2><h4 id="WWW、HTTP"><a href="#WWW、HTTP" class="headerlink" title="WWW、HTTP"></a>WWW、HTTP</h4><p><code>World Wide Web</code>：万维网，因特网中最重要的应用<br><code>HTTP</code>：超文本传输协议，Web的应用层协议</p><h4 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h4><ul><li>client/server 模式<ul><li>client: 浏览器，请求，接收和， “现实” Web对象</li><li>server: Web服务器程序，响应客户端的请求，如返回Web对象</li></ul></li><li>依赖于TCP的传输服务:<ul><li>客户端初始化一个TCP连接 (创建TCP套接字)到服务器端, <strong>默认目标端口80</strong></li><li>服务器端接收TCP的连接请求</li><li>HTTP协议开始工作：客户端请求Web对象，服务器端响应</li><li>TCP连接终止</li></ul></li><li>HTTP是“无状态”协议:<ul><li>服务器不维持客户端的状态(历史)：不需要维护哪个客户端在什么时候做了什么</li><li>只要客户端请求即予以响应，来者不拒</li></ul></li><li>维持“状态”是一件复杂的事情：要记录历史数据，并保证一致性</li><li>可以让应用程序来处理，如开发Web应用程序、进行会话管理、记录流程、日志etc</li></ul><h4 id="HTTP的两种连接方式"><a href="#HTTP的两种连接方式" class="headerlink" title="HTTP的两种连接方式"></a>HTTP的两种连接方式</h4><ul><li>非持久性连接  HTTP/1.0：建立TCP连接后最多只能请求一个Web对象<ul><li>浏览器并发TCP/HTTP连接</li><li>为每一个请求的对象建立和维护全新的连接，需要分配TCP缓冲区和保持TCP变量(负担)</li><li>每一个对象经受两倍往返时间rrt的交付时延</li></ul></li><li>持久性连接  HTTP/1.1：在一个TCP连接期间可以请求多个Web对象<ul><li>HTTP/1.1默认使用的是带流水线方式的持久性连接，效率更高</li></ul></li></ul><h4 id="HTTP的报文格式"><a href="#HTTP的报文格式" class="headerlink" title="HTTP的报文格式"></a>HTTP的报文格式</h4><ul><li>报文编码：ASCII(人类可读)</li><li>报文类别：<ul><li>请求报文 (客户端发送，服务器端处理)</li><li>响应报文 (服务器端发送，客户端处理)</li></ul></li></ul><p><strong>请求报文</strong><br><img src="https://i.loli.net/2018/06/05/5b16313172444.png" width="60%" height="60%"></p><ul><li>请求方法<ul><li>GET: 获取Web对象，扩展URL(可提交数据)，实体体为空</li><li>POST: 提交Web表单，封装在实体数据</li><li>HEAD: 调试</li><li>PUT: 上传Web对象(HTTP/1.1)</li><li>DELETE: 删除Web对象(HTTP/1.1)</li></ul></li><li>URL<ul><li>Web路径：/folder </li><li>Web对象标识：/object.obj </li><li>Web对象?参数：/object.obj?p1&amp;p2 </li></ul></li></ul><p><strong>响应报文</strong><br><img src="https://i.loli.net/2018/06/05/5b163340844fb.png" width="60%" height="60%"></p><table><thead><tr><th>状态码</th><th>短语</th></tr></thead><tbody><tr><td>200</td><td>OK 请求成功</td></tr><tr><td>301</td><td>Moved Permanently 请求的对象已经被永久转移了</td></tr><tr><td>400</td><td>Bad Request 一个通用差错代码，指示该请求不能被服务器理解</td></tr><tr><td>404</td><td>Not Found 被请求的文档不再服务器上</td></tr><tr><td>505</td><td>HTTP Version Not Supported 服务器不支持请求报文使用的HTTP协议版本</td></tr><tr><td>304</td><td>Not Modified ，原来缓冲的文档还可以继续使用P77</td></tr></tbody></table><h4 id="用户与服务器的交互-cookie"><a href="#用户与服务器的交互-cookie" class="headerlink" title="用户与服务器的交互: cookie"></a>用户与服务器的交互: cookie</h4><ul><li>HTTP是无状态协议：如何让服务器知道用户先前做过什么？ Cookie<ul><li>在HTTP请求和响应的首部行设定cookie</li><li>客户端保存cookies</li><li>服务器端通过cookie与后台数据库关联</li></ul></li></ul><p><strong>P73 图2-10 跟踪用户状态</strong><br>cookie可以在无状态的HTTP之上建立一个用户会话层，主要用于：<strong>授权，购物车，推荐，用户会话状态管理，个性化推荐</strong></p><ul><li>怎样保持状态? <ul><li>协议：通过复杂的交互过程</li><li>cookies：让报文内容承载状态信息</li><li>应用程序：如会话管理</li></ul></li></ul><h4 id="Web缓存P74"><a href="#Web缓存P74" class="headerlink" title="Web缓存P74"></a>Web缓存P74</h4><ul><li>Web代理服务器<ul><li>用户可以通过代理服务器访问外部网站</li><li>既是客户端，又是服务器</li></ul></li><li>Web缓存的作用<ul><li>减少请求/响应时间</li><li>流量本地化</li><li>减少接入网络流量</li><li>更好地实现内容分发(eg.CDN)</li></ul></li></ul><p>#####实例分析：<br>假设：</p><ul><li>Web对象的平均长度: 1M bits</li><li>客户端的平均请求率:15个/sec</li><li>客户端的数据传输速率: 1.50 Mbps</li><li>从浏览器到服务器的往返时间: 2 sec</li><li>接入网络的带宽: 15 Mbps</li></ul><p>结果：</p><ul><li>局域网流量强度: 15%</li><li><strong>接入网流量强度 = 100%(!problem)</strong></li><li>total delay = Internet delay 2秒+ <strong>access delay 若干分钟(排队时延)</strong>+ LAN delay 若干微秒</li></ul><p>昂贵的改进方法——增加接入链路的速率<br>接入网络的带宽: 15 Mbps - &gt; 100 Mbps</p><ul><li>局域网流量强度: 15%</li><li><strong>接入网流量强度 = 15%</strong></li><li>total delay = Internet delay 2秒+ <strong>access delay 若干毫秒</strong>+ LAN delay 若干微秒</li></ul><p><img src="https://i.loli.net/2018/06/05/5b164472d62ae.png" width="40%" height="40%"><img src="https://i.loli.net/2018/06/05/5b1645e4f3442.png" width="35%" height="435%"></p><p>另一种改进方法：在机构网络中安装一个Web缓存器<br>如何计算设置缓存后的时延:</p><ul><li>设缓存中对象的命中率为 0.4<ul><li>40% 的请求可以在缓存中获取</li><li>60% 的请求在远程服务器获取 </li></ul></li><li>接入链路利用率: <ul><li>60% 的请求在远程服务器获取 </li><li>接入网络传输速度 = 0.6*15 Mbps = 9 Mbps </li><li>利用率= 9Mbps/15Mbps =60%</li></ul></li><li>平均时延(概率)<ul><li>= 0.6 <em> 服务器端时延 +0.4 </em> 缓存时延</li><li>= 0.6 (2.01) + 0.4 (~msecs) </li><li>= ~ 1.2 secs</li></ul></li></ul><h4 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h4><p>Web缓存的问题：如何保证缓存中的对象是最新的？<br><code>条件GET方法</code>：HTTP协议中的一种机制，允许缓存器证实它的对象是最新的</p><ul><li>目标: 如果缓存中的对象是新的，就没必要再去远程服务器获取<ul><li>减少时延</li><li>降低外部带宽利用率</li></ul></li><li>缓存: 为每个对象设置版本信息<ul><li>If-modified-since: <date></date></li></ul></li><li>服务器: 如果缓存的对象是最新的，服务器端不需再响应: <ul><li>HTTP/1.0 304 Not Modified</li></ul></li></ul><h3 id="2-3-FTP-文件传输协议"><a href="#2-3-FTP-文件传输协议" class="headerlink" title="2.3 FTP: 文件传输协议"></a>2.3 FTP: 文件传输协议</h3><ul><li>向远程服务器端收发文件</li><li>client/server 模式<ul><li>client: 初始化连接(任何时候都是从客户端发起)</li><li>server: 远程主机</li></ul></li><li>ftp server: port 21，20<ul><li>服务器端默认<code>端口号21</code> 用于对客户端认证</li><li>服务器会在接收到文件传输请求时，打开<code>端口号20</code>的端口来进行传输数据文件。</li></ul></li></ul><p>FTP客户端连接服务器端使用TCP提供可靠传输服务有两类连接：控制、传输 </p><ul><li>控制连接：<ul><li>服务器端默认端口号：21</li><li>建立控制连接时需要对客户端验证</li><li>客户端向服务器端发送交互式命令</li><li>是有状态的协议，可控制客户端的最近登录验证、历史信息等</li><li>控制连接是<strong>持久性</strong>的</li></ul></li><li>传输连接：<ul><li>服务器端接收到文件传输的请求时，会打开传输连接(20端口)用于文件传输</li><li>当这个文件传输结束后，第二个连接会被服务器端关闭</li><li>传输连接是<strong>非持久性</strong>的</li><li>“带外传输”</li></ul></li></ul><p>一些常用命令P79:</p><ul><li>sent as ASCII text over control channel</li><li>USER username：用于向服务器传送用户标识</li><li>PASS password：用于向服务器发送用户口令</li><li>LIST return list of file in current directory</li><li>RETR filename retrieves (gets) file</li><li>STOR filename stores (puts) file onto remote host</li></ul><p>常见的服务器响应代码：</p><ul><li>status code and phrase (as in HTTP)</li><li>331 Username OK, password required(用户名OK，需要口令)</li><li>125 data connection already open; transfer starting(数据连接已经打开，开始传送)</li><li>425 Can’t open data connection(无法打开数据连接)</li><li>452 Error writing file(写文件差错)</li></ul><h3 id="2-4-因特网中的电子邮件"><a href="#2-4-因特网中的电子邮件" class="headerlink" title="2.4 因特网中的电子邮件"></a>2.4 因特网中的电子邮件</h3><p><strong>三个主要组件</strong></p><ul><li>用户代理：即：邮件收发读写软件<ul><li>eg.Outlook, Foxmail, Thundbird</li></ul></li><li>邮件服务器：发送、接收邮件</li><li>邮件协议<ul><li>发送协议：SMTP </li><li>接收协议：PoP3、IMAP</li><li>报文协议：MIME</li></ul></li></ul><h4 id="简单邮件传输协议-SMTP"><a href="#简单邮件传输协议-SMTP" class="headerlink" title="简单邮件传输协议:SMTP"></a>简单邮件传输协议:SMTP</h4><ul><li>使用TCP的可靠传输服务,</li><li>端口号：25</li><li>直接传输: 从发送端的服务器到接收端的服务器</li><li>传输的三个阶段:握手(greeting)、报文传输、结束</li><li>使用交互式命令<ul><li>commands: ASCII text</li><li>response: status code and phrase</li></ul></li><li>报文编码格式：7-bit ASCII</li></ul><p><img src="https://i.loli.net/2018/06/05/5b164b692f1ea.png" width="80%" height="80%"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> S: 220 hamburger.edu  C: HELO crepes.fr  S: 250  Hello crepes.fr, pleased to meet you  C: MAIL FROM: &lt;alice@crepes.fr&gt;  S: 250 alice@crepes.fr... Sender ok  C: RCPT TO: &lt;bob@hamburger.edu&gt;  S: 250 bob@hamburger.edu ... Recipient ok  C: DATA  S: 354 Enter mail, end with &quot;.&quot; on a line by itself  C: Do you like ketchup?  C: How about pickles?  C: .  S: 250 Message accepted for delivery  C: QUIT  S: 221 hamburger.edu closing connection</span><br><span class="line">```- SMTP：持久性连接 - 在一个连接中可以进行多次操作 - 可以发送多个邮件、群发邮件 - 通过退出(Quit)来关闭连接- SMTP：报文都是7bit ASCII编码- SMTP：使用 crlf.crlf 作为报文结束符|SMTP|HTTP|</span><br><span class="line">|---|----|</span><br><span class="line">|推协议(push):向服务器端发送|拉协议(pull)：向服务器端请求||使用ASCII对报文进行编码|使用ASCII对报文进行编码|</span><br><span class="line">|报文可以封装**多个对象**(email附件)|每个响应报文只能封装1个web对象|- RFC 822: 用于定义邮件的格式: - 首部行</span><br></pre></td></tr></table></figure><p> From: alice&amp;crepes.fr<br> To: <a href="mailto:bob@hamburger.edh" target="_blank" rel="noopener">bob@hamburger.edh</a><br> Subject: Searching for the meaning of life</p><pre><code> - Body: 邮件正文(ASCII characters only，BASE 64编码)#### 邮件访问协议(接收方) - POP: Post Office Protocol [RFC 1939] - 认证(agent &lt;--&gt;server)和下载 - IMAP: Internet Mail Access Protocol [RFC 1730] - 更多的功能(更复杂) - 可在服务器端操作邮件- HTTP: Hotmail , Yahoo! Mail, etc.**POP3**- 认证阶段 - 客户端命令:</code></pre><p> user: declare username<br> pass: password</p><pre><code>- 服务器端响应:</code></pre><p>+OK<br>-ERR<br><code>`</code></p><ul><li>传输阶段, 客户端的命令:<ul><li>list: 列出邮件的索引</li><li>retr: 根据编号接收邮件</li><li>dele: 删除某个编号的邮件</li><li>quit</li></ul></li></ul><table><thead><tr><th>POP3</th><th>IMAP</th></tr></thead><tbody><tr><td>download and delete 在其他客户端无法读取</td><td>报文都在服务器端存储</td></tr><tr><td>download-and-keep 客户端和服务器端双份</td><td>允许用户创建文件夹</td></tr><tr><td>POP3是无状态的协议</td><td>在会话周期内维护用户的状态</td></tr></tbody></table><h3 id="2-5-因特网的目录服务"><a href="#2-5-因特网的目录服务" class="headerlink" title="2.5 因特网的目录服务"></a>2.5 因特网的目录服务</h3><p>因特网中标识一个主机：</p><ul><li>主机名：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>, mail.cqu.edu.cn ……  </li></ul><blockquote><p>人容易记住某个主机的名字，而不是IP地址<br>主机别名：一个主机也会有很多别名<br><strong><code>域名</code></strong>：.edu .cn .uk</p></blockquote><ul><li>IP地址：32bit 编码 (点分十进制表示：202.202.0.35)<ul><li>机器之间相互识别</li><li>路由器通过IP地址对分组进行路由、转发</li></ul></li></ul><h4 id="DNS-因特网的目录服务"><a href="#DNS-因特网的目录服务" class="headerlink" title="DNS 因特网的目录服务"></a>DNS 因特网的目录服务</h4><p><strong>DNS提供的服务</strong>(因特网中的一个核心服务)：</p><ul><li>将主机名映射为IP地址</li><li>可对服务器的负载进行均衡</li><li>获得主机别名对应的规范化主机名及主机的IP地址</li><li>邮件服务器别名</li></ul><h4 id="DNS工作机理概述"><a href="#DNS工作机理概述" class="headerlink" title="DNS工作机理概述"></a>DNS工作机理概述</h4><ul><li>DNS工作在应用层：<ul><li>DNS服务不直接与用户打交道</li><li>不封装用户的应用数据报文</li><li>只协助源主机查询出目标主机的IP地址</li><li>DNS是一个分布式的数据库系统：</li></ul></li><li>DNS是一个分布式的数据库系统：<ul><li>通过<strong>层级化</strong>的域名服务器进行工作</li></ul></li><li>DNS的分布式查询方式: <ul><li><code>迭代查询</code></li><li><code>递归查询</code></li></ul></li></ul><p><img src="https://i.loli.net/2018/06/05/5b1684e9b46fa.png" width="40%" height="40%"><img src="https://i.loli.net/2018/06/05/5b1684ea021d6.png" width="40%" height="40%"></p><ul><li>DNS的缓存机制<ul><li>作用：改善时延、减少DNS报文数量</li><li>服务器查询到映射关系后，将会缓存此映射关系</li><li>每个缓存的映射关系具有一定的生命周期（如2天）</li><li>顶级DNS服务器一般缓存本地DNS服务器的映射关系（减少根服务器的负担）</li><li>由IETF制定并维护标准 RFC 2136</li><li>本地主机上面也有缓存</li></ul></li></ul><blockquote><p><strong>层级化的域名服务器</strong></p></blockquote><ul><li>根DNS服务器：用于查询顶级DNS服务器的地址</li><li>顶级DNS服务器：用于查询下一级或权威DNS服务器的地址<ul><li>提供了权威的主机名和IP地址映射，由组织机构或服务提供商来维护</li><li>eg. .net/.edu/.org/.com/.uk/.cn</li></ul></li><li>权威DNS服务器：组织机构自身的DNS服务器<ul><li>提供了权威的主机名和IP地址映射，由组织机构或服务提供商来维护</li></ul></li><li>本地DNS服务器：<ul><li>不属于严格意义上层级DNS体系</li><li>每个本地ISP、公司、大学都会部署</li><li>主机的DNS查询都会先提交给本地DNS服务器</li><li>具有缓存和代理的功能</li></ul></li></ul><blockquote><p><strong>为什么要分布式、层级化？而不是集中化？</strong></p></blockquote><p>集中化的问题：</p><ul><li>单点故障：会导致全局失效</li><li>通信容量：会导致拥塞</li><li>远距离的集中式数据库：增大时延</li><li>维护困难</li><li>难于扩展</li></ul><h4 id="DNS记录"><a href="#DNS记录" class="headerlink" title="DNS记录"></a>DNS记录</h4><ul><li>使用分布式的数据库来存储资源记录</li><li>资源记录格式：四元组<ul><li>RR format: (name, value, type, ttl)</li></ul></li><li>name：主机名或域名</li><li>value：主机名映射的IP地址或DNS服务器名</li><li>type：记录类型<ul><li>Type=A，value是该主机名对应的IP地址；(<a href="http://www.cqu.edu.cn" target="_blank" rel="noopener">www.cqu.edu.cn</a>, 202.202.0.35, A)</li><li>Type=NS， value是该域名中的DNS服务器；(cqu.edu.cn, dns.cqu.edu.cn, NS)</li><li>Type=CNAME，value是该主机名对应的规范主机名</li><li>Type=MX， value是该邮件服务器名对应的规范主机名</li></ul></li><li>ttl：记录的生存周期(time to live)</li></ul><h4 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h4><p><img src="https://i.loli.net/2018/06/06/5b17294ee77f3.png" width="65%" height="65%"><br>查询报文、回答报文：两者格式相同</p><ul><li>报文首部(12 bytes)</li><li>标识符(16bit)：匹配查询和回答</li><li>标志位(16bit)：是查询 还是 回答；是否权威的回答；希望递归；递归可用</li><li>问题：name, type</li><li>回答：name, value, type, ttl，可能有多个记录</li><li>权威</li><li>附加</li></ul><h4 id="向DNS数据库中插入记录"><a href="#向DNS数据库中插入记录" class="headerlink" title="向DNS数据库中插入记录"></a>向DNS数据库中插入记录</h4><ul><li>机构注册：向权威机构注册本机构的DNS信息<ul><li>向相关机构注册本机构的域名</li><li>向上级DNS服务器注册本机构的权威DNS服务器<br>Type=NS：该域中的权威DNS服务器是哪个主机(networkutopia.com,dns1.networkutopia.com, NS)<br>Type=A：权威DNS服务器的IP地址是多少(dns1.networkutopia.com,212.212.212.1, A)</li></ul></li><li>权威DNS服务器中的记录更新<ul><li>对组织机构内部的主机、地址映射信息进行维护：<code>静态配置</code>、<code>动态更新</code></li></ul></li></ul><h3 id="2-6-P2P应用"><a href="#2-6-P2P应用" class="headerlink" title="2.6 P2P应用"></a>2.6 P2P应用</h3><h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><ul><li>纯P2P架构<ul><li>没有Sever</li><li>任意端系统可以直连</li><li>端点间歇连接</li><li>可能会更换IP地址</li></ul></li><li>典型应用<ul><li>文件分发：BitTorrent</li><li>流媒体传输：Kankan</li><li>因特网电话：Skype</li></ul></li><li>混合架构<ul><li>Server：追踪器、帐户管理等</li></ul></li></ul><h4 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h4><ul><li>一台服务器S向N个主机(peers)分发一个大文件(大小为F bits)<ul><li>服务器的<strong>上载</strong>能力u<sub>s</sub>；</li><li>端点i的<strong>上载</strong>和<strong>下载</strong>能力分别为u<sub>i</sub>和d<sub>i</sub>；</li></ul></li></ul><h5 id="1-使用C-S模式进行分发"><a href="#1-使用C-S模式进行分发" class="headerlink" title="1.使用C/S模式进行分发"></a>1.使用C/S模式进行分发</h5><ul><li>服务器端：<ul><li>S必须向每个客户端上载1个拷贝</li><li>发送1个拷贝的时间：t=F/u<sub>s</sub></li><li>发送N个拷贝的时间：t<sub>total</sub>=NF/u<sub>s</sub></li></ul></li><li>客户端<ul><li>每个端点必须获得一个拷贝</li><li>设dmin=客户端的最低下载速率</li><li>客户端的最长下载时间：F/d<sub>min</sub></li><li>文件分发时间：D<sub>c/s</sub>≥max{NF/u<sub>s</sub>, F/d<sub>min</sub>}，随着N的增加，时间线性增长</li></ul></li></ul><h5 id="2-使用P2P进行分发"><a href="#2-使用P2P进行分发" class="headerlink" title="2.使用P2P进行分发"></a>2.使用P2P进行分发</h5><ul><li>服务器端<ul><li>S必须上载至少1个拷贝</li><li>所需上载时间：t<sub>u=</sub>F/u<sub>s</sub></li></ul></li><li>客户端<ul><li>每个端点必须获得一个拷贝：td=F/d<sub>min</sub></li></ul></li><li>客户群<ul><li>必须下载N个拷贝，总体上载速率为u<sub>s</sub>+∑u<sub>i</sub></li></ul></li><li>文件分发时间：Dp2p≥max{F/u<sub>s</sub>, F/d<sub>min</sub>, NF/(u<sub>s</sub>+ ∑u<sub>i</sub>)}</li></ul><p><img src="https://i.loli.net/2018/06/05/5b168eccad419.png" width="50%" height="50%"><img src="https://i.loli.net/2018/06/05/5b168ec27b402.png" width="40%" height="40%"></p><h4 id="BitTorrent文件分发协议"><a href="#BitTorrent文件分发协议" class="headerlink" title="BitTorrent文件分发协议"></a>BitTorrent文件分发协议</h4><ul><li>文件被分为大小为256Kb的块</li><li>洪流中的端点发送和接收这些文件块</li></ul><p><img src="https://i.loli.net/2018/06/05/5b1690647bcfa.png" width="40%" height="40%"></p><ul><li>请求文件块：最稀缺优先<ul><li>在某一时刻：不同的端点，文件块集也不同</li><li>在某段时间：Alice周期性地向邻居索问他们的文件块索引，随后请求这些所需的文件块</li><li>最稀缺优先原则</li><li>所有邻居中某个块的数量最少，则先请求这个块。Why?</li></ul></li><li>响应文件块：礼尚往来<ul><li>疏通：确定给自己发送块最快的几个对等方</li><li>tit-for-tat：看谁对我好(给我传的快)，我也对他好(给她/他传得也快)</li></ul></li></ul><h4 id="分布式哈希表DHT"><a href="#分布式哈希表DHT" class="headerlink" title="分布式哈希表DHT"></a>分布式哈希表DHT</h4><ul><li>基于P2P模式的分布式数据库</li><li>数据库的基本思想：键值对<ul><li>键：账号，值：口令(eg. 键：学号，值：成绩)</li></ul></li><li>集中式数据库<ul><li>C/S架构</li></ul></li><li>分布式数据库<ul><li>P2P架构</li><li>在大量的peer上面存储键值对</li><li>分布式哈希表DHT </li></ul></li></ul><p>DHT的应用：一个peer通过键来查询，获得这个键对应的值</p><blockquote><p>应用场景：<br>键：”Logen” ；Alice通过这个键来查询谁有这个影片<br>值：拥有这个影片副本的peer(IP地址)</p></blockquote><h5 id="如何创建分布式哈希表？"><a href="#如何创建分布式哈希表？" class="headerlink" title="如何创建分布式哈希表？"></a>如何创建分布式哈希表？</h5><ul><li>核心问题：怎么把键值对分配到peer中?</li><li>基本思想：<ul><li>把每个键都通过Hash变成整数，并为每个peer进行<strong>整数标识</strong></li><li>把键值对插入到<strong>与这个整数最接近的端点</strong>中</li></ul></li><li>具体操作：<ul><li>用n bit的整数(如n=64),可表示的整数区间为[0, 2n-1]</li><li>把每个键都用整数表示：Key=hash(“Logen”)=20161858，所以称之为分布式hash表 </li></ul></li><li>插入键值：<ul><li>规则：把键值插入到与peer ID最接近的peer上</li><li>与这个整数相等的节点，或与这个整数最临近的后继节点</li></ul></li></ul><h5 id="怎样查找出键值对"><a href="#怎样查找出键值对" class="headerlink" title="怎样查找出键值对"></a>怎样查找出键值对</h5><table><thead><tr><th>环状DHT，覆盖网络</th><th>具有捷径的环状DHT</th></tr></thead><tbody><tr><td>每个节点只知道它的邻居(前驱、后继)</td><td>每个节点知道它的邻居以及它的两个捷径</td></tr><tr><td>算法复杂度(最差情况): O(N)</td><td>算法复杂度: O(log N)</td></tr></tbody></table><ul><li>对等方扰动: 等同于链表中删除一个节点<ul><li>Peer记住它的两个后继定时检查两个后继是否存在(Ping一下)</li><li>若直接后继退离，将第二后继设为直接后继</li></ul></li><li>Peer可能随时加入：<ul><li>查询：先问一下DHT自己的前驱和后继是谁</li><li>通知：向前驱和后继发送报文</li><li>更新：本节点、前驱和后继均要更新</li></ul></li></ul><h3 id="2-7-TCP套接字编程"><a href="#2-7-TCP套接字编程" class="headerlink" title="2.7 TCP套接字编程"></a>2.7 TCP套接字编程</h3><p><code>套接字</code>：在主机端、由应用进程创建、由操作系统控制的接口，一个应用进程可以向另一个进程发送或接收报文。<br><code>套接字编程</code>：对应于传输层的服务，有两种类型的套接字</p><ul><li><code>四元组</code>TCP：可靠的，面向字节流的传输，封装为报文段(segment)</li><li><code>二元组</code>UDP：不可靠的传输，封装为用户数据报(user datagram)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2-1-应用层协议原理&quot;&gt;&lt;a href=&quot;#2-1-应用层协议原理&quot; class=&quot;headerlink&quot; title=&quot;2.1 应用层协议原理&quot;&gt;&lt;/a&gt;2.1 应用层协议原理&lt;/h2&gt;&lt;h4 id=&quot;网络应用程序体系结构&quot;&gt;&lt;a href=&quot;#网络应用程序体系结构&quot; class=&quot;headerlink&quot; title=&quot;网络应用程序体系结构&quot;&gt;&lt;/a&gt;网络应用程序体系结构&lt;/h4&gt;&lt;p&gt;应用程序研发很可能利用两种主流的体系结构之一:&lt;br&gt;&lt;strong&gt;&lt;code&gt;客户-服务端体系结构&lt;/code&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器: &lt;ul&gt;
&lt;li&gt;持续地工作(365*24)  &lt;/li&gt;
&lt;li&gt;固定的、周知的地址(&lt;code&gt;IP地址&lt;/code&gt;)  &lt;/li&gt;
&lt;li&gt;备有数据中心
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络笔记01 计算机网络和因特网</title>
    <link href="http://daisine.me/cn1/"/>
    <id>http://daisine.me/cn1/</id>
    <published>2018-06-08T04:28:56.000Z</published>
    <updated>2018-06-08T04:47:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-什么是因特网"><a href="#1-1-什么是因特网" class="headerlink" title="1.1 什么是因特网"></a>1.1 什么是因特网</h2><h3 id="具体构成描述-硬件和软件组成"><a href="#具体构成描述-硬件和软件组成" class="headerlink" title="具体构成描述(硬件和软件组成)"></a>具体构成描述(硬件和软件组成)</h3><p><strong>因特网</strong>是网络的网络，是一个世界范围的计算机网络。 </p><blockquote><ol><li>连接数以亿计的设备: <code>主机/端系统</code>通过服务提供商(ISP)接入因特网进行互联。 <code>运行各种网络应用</code>  </li><li><code>主机/端系统</code>通过通信链路和分组交换机连接到一起</li><li>通信链路:<br>&ensp;&ensp; <code>传输媒介</code>: 同轴电缆、铜线、光线、无线电<br>&ensp;&ensp; <code>传输速率</code>: 带宽  </li><li>交换设备: <code>路由器</code> <code>链路层交换机</code><a id="more"></a> </li></ol></blockquote><p><strong>协议</strong>是对因特网中消息的发送和接收进行控制。</p><p>因特网中最主要的协议统称为<code>TCP/IP</code>。</p><blockquote><p>TCP: 传输控制协议<br>IP: 网络协议，定义了在路由器端系统之间发送和接收的分组格式<br>HTTP, Skype(Skype的通讯协议是不公开的)</p></blockquote><p><strong>因特网标准</strong>是指关于互联网相关的技术与方法论的技术规范，由互联网工程任务组（IETF）创建与发布。</p><blockquote><p>RFC<code>请求评论</code>: 定义了TCP，IP，HTTP和SMTP等协议。<br>其他组织: IEEE 802 LAN/MAN标准华委员会制定了<code>以太网</code>和<code>无线WiFi</code>的标准</p></blockquote><h3 id="服务描述-基础设施向分布式应用程序提供的服务"><a href="#服务描述-基础设施向分布式应用程序提供的服务" class="headerlink" title="服务描述(基础设施向分布式应用程序提供的服务)"></a>服务描述(基础设施向分布式应用程序提供的服务)</h3><p><strong>服务描述:</strong><code>因特网</code>是为应用程序提供服务的基础设施。因特网应用程序运行在<code>端系统</code>上</p><blockquote><p>为各种应用提供通信服务Web, VoIP, email, 在线游戏, 电子商务, 社会网络<br>提供应用程序编程接口(API)</p></blockquote><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>一个协议定义了在两个或多个实体之间交换的<code>报文格式</code>和<code>次序</code>，以及报文发送和/或接收一条报文或其他事件所采取的<code>动作</code>。</p><blockquote><p>机器之间的通信，所有通信都遵照某种协议  </p></blockquote><ul><li>语法: 定义数据格式、编码等  </li><li>语义: 定义控制信息  </li><li>同步: 定义速度和排序等信息</li></ul><h2 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h2><p><strong>端系统=主机</strong>位于因特网的边缘，运行应用程序。</p><blockquote><p>client/server模式: 主机有时被划分为客户和服务器这两类。<br>P2P模式</p></blockquote><h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><p>接入网：是将端系统连接到其边缘路由器的<code>物理链路</code>。</p><ol><li>家庭接入: <ul><li><code>DSL</code>数据用户线路：以电话线为传输介质的传输技术组合<br>，利用本地电话公司现有的电话线路连接到DSL中心局。</li><li><code>电缆因特网接入</code>：利用有线电视公司现有的有线电视基础设施。频分复用: 按照频段分成不用的信道</li><li>FTTH, 拨号, 卫星</li></ul></li><li>企业(和家庭)接入:以太网, WiFi</li><li>广域无线接入:3G, LTE</li></ol><p><strong>物理媒体</strong>: 被<em>传输器-接收器</em>跨越传播电磁波或光脉冲来发送比特。</p><blockquote><p><strong>引导型媒体</strong><br>双绞线:五类:100-1000Mbps;六类:10Gbp<br>同轴电缆:10-100Mbps<br>光纤:抗干扰性强<br><strong>非引导型媒体</strong><br>陆地无线电信道<br>卫星无线电信道: 同步卫星(时延),近地卫星(需要解决覆盖问题)</p></blockquote><h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h2><p><code>网络核心</code>即由互联因特网段系统的分组交换机和链路构成的网状结构。<br>数据在网络中的传输方式：</p><p><strong>分组交换</strong>: 报文被分成小的数据库: 分组</p><blockquote><p>每个分组占用全部宽带，用户可以共享网络通信资源。</p></blockquote><p>它是一种存储——转发交换方式，即将到达交换机的分组先送到存储器暂时存储和处理，等到相应的输出电路有空闲时再送出。    </p><blockquote><p>由于数据进入交换节点后要经历存储转发这一过程，从而引起的<code>转发时延</code>（包括接受分组、检验正确性、排队、发送时间等），而且网络的通信量越大，造成的时延就越大，<code>实时性较差</code>。<br>分组丢失(丢包): 缓存空间大小有限，一个到达的分组可能发现缓存被充满，到达的分组或已排队的分组之一将被丢弃。<br>可能出现失序，丢失或重复分组，分组到达目的节点时，对分组按编号进行排序等工作，增加了麻烦。</p></blockquote><p><strong>分组交换的两种方法<code>网络层</code></strong></p><ul><li>数据报网络(现在网络更多使用这一类)  </li></ul><blockquote><p>目标地址确定下一站<br>数据包路径不一定相同</p></blockquote><ul><li>虚电路网络(对延时有要求，即时)</li></ul><blockquote><p>虚电路编号来确定路径<br>数据包的路径相同</p></blockquote><p><strong>电路交换</strong>: 是一种”面向连接”的方式，通过<code>频分复用</code>或<code>时分复用</code>来实现的。  </p><blockquote><p>在通信的全部时间内，通话的两个用户始终占用端到端的固定传输带宽<br>使用电路交换来传输计算机数据时，线路的传输效率往往很低<br>通信资源被划分成小片</p></blockquote><p><code>频分复用FMD</code>: 将用于传输信道的总带宽划分成若干个子频带，每一个子信道传输1路信号。为保证各子信带中所传输的信号互不干扰，在各子信道之间设立隔离带。(收音机频道)<br><code>时分复用TMD</code>: 时间被划分为固定区间的帧(非常短的时间)，每帧又被划分为固定数量的时隙。   </p><table><thead><tr><th style="text-align:left">电路交换</th><th style="text-align:left">分组交换</th></tr></thead><tbody><tr><td style="text-align:left">面向连接</td><td style="text-align:left">无连接</td></tr><tr><td style="text-align:left">电路交换需要先建立连接，所以有时间开销</td><td style="text-align:left">无需建立连接，省掉了一部分时间开销。</td></tr><tr><td style="text-align:left">占用通信链路直到整段报文传输结束链接断开，<code>通信链路利用率低。</code></td><td style="text-align:left">报文被分割成小的分组，通信链路只在传输一个分组的时候被占用，传输结束链路继续被使用，<code>利用率较高。</code>允许用户的“突发式”传输。</td></tr><tr><td style="text-align:left">建立连接，数据传输<code>稳定</code>，快速，适用于系统间高质量的大数据传输情况。</td><td style="text-align:left">传输大数据时效率偏低，且容易<code>丢失数据。</code></td></tr></tbody></table><p><strong>网络中的网络</strong><br>端系统通过ISP(因特网服务提供商)接入互联网</p><blockquote><p>家庭<br>公司或高校</p></blockquote><p>接入的ISP直接必须互联<br>互联的网络非常复杂</p><p>分层思想: 去中心， 一个中心容易出现单点故障<br>经济和国家策略: 不能一家独享，需要多个ISP来竞争</p><blockquote><ol><li>全球承载ISP  </li><li>区域ISP    </li><li>对等连接</li><li>因特网交换点IXP: 允许不同的因特网服务提供商(ISPs)在它们的自动系统之间通过对等协议来交换因特网通信。是一个汇合点，多个ISP在这里共同对等  </li><li>内容提供商网络(如Google): 减少了向顶层ISP支付的费用</li></ol></blockquote><h2 id="1-4-延迟、丢包和吞吐量"><a href="#1-4-延迟、丢包和吞吐量" class="headerlink" title="1.4 延迟、丢包和吞吐量"></a>1.4 延迟、丢包和吞吐量</h2><p><strong>时延</strong>是数据（一个报文/分组/甚至比特）从网络或链路的一端传送到另一端所需的时间.<br><code>节点处理时延</code>包括选择输出链路，差错检验等因素。取决于节点的处理性能，一般在毫秒数量级。<br><code>排队时延</code> 是排队等待接点的输出链路发送数据分组所需的时间。取决于节点的拥塞情况。 </p><blockquote><p>排队时延与分组丢失(丢包): 缓存空间大小有限，一个到达的分组可能发现缓存被充满，到达的分组或已排队的分组之一将被丢弃</p></blockquote><p><code>传输时延</code> 设输出链路带宽为R，将长度为L的分组发送到链路中所需的时间d<sub>trans</sub>=L/R<br><code>传播时延</code>分组在链路上”奔跑”完全程所需的时间。设链路长度d，传播速度s，d<sub>prop</sub>=d/s  </p><p><strong>端到端的时延</strong><br>假设源主机和目的主机之间有N-1台路由器，并且该网络是<code>无拥塞</code>的。那么端到端时延为：d<sub>end-end</sub>=N(d<sub>proc</sub>+d<sub>trans</sub>+d<sub>prop</sub>)</p><p><strong>吞吐量</strong>是网络的发送和接收端传输数据的速率。</p><blockquote><p>瞬时吞吐量: 某个时间间隔内<br>平均吞吐量: 一段较长时间内<br>瓶颈链路: 约束着整个端到端的链路吞吐量</p></blockquote><p>因特网的实际情况: 主干网的速度很高，连接的瓶颈在于接入网。<br>当没有其他干扰流量时，吞吐量近似为沿着源和目的地之间路径的最小传输速率。</p><h2 id="1-5-协议层次和服务模型"><a href="#1-5-协议层次和服务模型" class="headerlink" title="1.5 协议层次和服务模型"></a>1.5 协议层次和服务模型</h2><p><strong>分层</strong>: 将复杂问题分成小问题，分而治之<br><strong>协议分层</strong>   </p><ol><li>应用层: 网络应用程序机器应用层协议留存的地方(HTTP/SMTP/FTP..) </li><li>运输层: 提供应用成端点之间传送应用层报文的服务(TCP/UDP)  </li><li>网络层: 将<code>数据报</code>的网络层分组从一台主机移动到另一台主机(IP协议/路由选择协议..)  </li><li>链路层: 将整个<code>帧</code>(链路层分组)从一个网络元素移动到临近的网络元素,一个数据报从源到目的地,可能经过不同链路上不同链路层协议处理, 提供的服务取决于应用于该链路的特定链路层协议.(以太网/WiFi/PPP)  </li><li>物理层: 将帧一个一个比特从一个节点移动到下一个节点</li></ol><blockquote><p>实际因特网协议栈比ISO/OSI参考模型少了两层协议: <code>会话层</code>(数据交换的定界和同步)和<code>表示层</code>(数据压缩/加密/描述),原因是这两层协议由开发者决定是否重要来进行设计。</p></blockquote><p><strong>封装</strong><br>在每一层，一个分组具有两种类型的字段: 首部字段喝有效载荷子段。有效载荷子段通常是来自上一层的分组。</p><p><img src="https://i.loli.net/2018/04/24/5adee3f813667.png" width="70%" height="70%"> </p><p><strong>TCP/IP协议族</strong></p><p><img src="https://i.loli.net/2018/04/24/5adea8a4111be.png" width="70%" height="70%"> </p><h2 id="1-6面对攻击的网络"><a href="#1-6面对攻击的网络" class="headerlink" title="1.6面对攻击的网络"></a>1.6面对攻击的网络</h2><p><strong>被放入计算机的有害程序</strong><br>恶意软件: 多数恶意软件是自我复制的。</p><blockquote><p>以病毒形式扩散: 需要某种形式的用户交互来感染用户设备的恶意软件<br>以蠕虫形势扩散: 无需任何明显用户交互就能进入设备的恶意软件</p></blockquote><p><strong>攻击服务器和网络基础设施</strong><br><code>拒绝服务攻击</code>(Denial-of-Service/DoS attack)<br>大多数因特网DOS攻击属于下列三种类型之一:</p><blockquote><p>弱点攻击<br>带宽洪泛<br>连接洪泛  </p></blockquote><p>相比于来自单一主机的Dos攻击，分布式DoS(Distributed DoS/DDoS)更加难以检测和防范。  </p><p><strong>嗅探分组</strong><br>在无线传输设备的附近放一台被动的接收机，该接受机就能得到传输的每个分组的副本。这些分组包含了各种敏感信息，包括口令和隐秘的个人信息等。  </p><blockquote><p>记录每个流经的分组副本的被动接受机称为<code>分组嗅探器</code><br>分组嗅探软件如Wireshark等可以对嗅探到的分组进行离线分析，就能得出敏感信息  </p></blockquote><p><strong>伪装用户</strong><br><code>IP哄骗</code>: 将具有虚假源地址的分组注入因特网的能力</p><blockquote><p>生成具有任意源地址、分组内容和目的地址的分组，接收方执行分组内容的命令(eg.修改转发表)。</p></blockquote><p><code>端点鉴别</code>: 一种使我们能够确信一个报文源自我们认为它应当来自的地方的机制</p><blockquote><p>在相互信任的用户之间的通信是一种例外而不是规则</p></blockquote><h2 id="1-7-计算机网络和因特网的历史"><a href="#1-7-计算机网络和因特网的历史" class="headerlink" title="1.7 计算机网络和因特网的历史"></a>1.7 计算机网络和因特网的历史</h2><p><strong>分组交换的发展: 1961～1972</strong><br><strong>专用网络和网络互联: 1972～1980</strong><br><strong>网络的激增: 1980～1990</strong><br><strong>因特网爆炸: 20世纪90年代</strong><br><strong>最新发展</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-1-什么是因特网&quot;&gt;&lt;a href=&quot;#1-1-什么是因特网&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是因特网&quot;&gt;&lt;/a&gt;1.1 什么是因特网&lt;/h2&gt;&lt;h3 id=&quot;具体构成描述-硬件和软件组成&quot;&gt;&lt;a href=&quot;#具体构成描述-硬件和软件组成&quot; class=&quot;headerlink&quot; title=&quot;具体构成描述(硬件和软件组成)&quot;&gt;&lt;/a&gt;具体构成描述(硬件和软件组成)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;因特网&lt;/strong&gt;是网络的网络，是一个世界范围的计算机网络。 &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;连接数以亿计的设备: &lt;code&gt;主机/端系统&lt;/code&gt;通过服务提供商(ISP)接入因特网进行互联。 &lt;code&gt;运行各种网络应用&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;主机/端系统&lt;/code&gt;通过通信链路和分组交换机连接到一起&lt;/li&gt;
&lt;li&gt;通信链路:&lt;br&gt;&amp;ensp;&amp;ensp; &lt;code&gt;传输媒介&lt;/code&gt;: 同轴电缆、铜线、光线、无线电&lt;br&gt;&amp;ensp;&amp;ensp; &lt;code&gt;传输速率&lt;/code&gt;: 带宽  &lt;/li&gt;
&lt;li&gt;交换设备: &lt;code&gt;路由器&lt;/code&gt; &lt;code&gt;链路层交换机&lt;/code&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库原理笔记C08 数据库系统的设计</title>
    <link href="http://daisine.me/sql08/"/>
    <id>http://daisine.me/sql08/</id>
    <published>2018-06-04T03:45:53.000Z</published>
    <updated>2018-06-08T04:58:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="8-1-数据库系统设计概述"><a href="#8-1-数据库系统设计概述" class="headerlink" title="8.1 数据库系统设计概述"></a>8.1 数据库系统设计概述</h2><ol><li>需求分析阶段：需求收集和分析，得到<code>数据字典</code>和<code>数据流图</code>。</li><li>概念结构设计阶段：对用户需求综合、归纳与抽象，形成概念模型，用<code>E-R图</code>表示。</li><li>逻辑结构设计阶段：将概念结构转换为某个DBMS所支持的<code>关系模型</code>/<code>数据模型</code>，对关系模型进行优化。</li><li>物理设计阶段：根据具体计算机系统(DBMS和硬件)的特点，为<strong>给定的数据库模型</strong>确定合理的<code>存储结构</code>和<code>存取方法</code>，并对物理结构进行评价。</li><li>数据库实施阶段：建立数据库，编制与调试应用程序，组织数据入库，程序试运行。</li><li>数据库运行和维护阶段：数据库应用系统投入运行后，需要进行备份和维护，对于出现的问题需要不断调整和修改，直到满足用户需求。<a id="more"></a></li></ol><h2 id="8-2-系统需求分析"><a href="#8-2-系统需求分析" class="headerlink" title="8.2 系统需求分析"></a>8.2 系统需求分析</h2><h3 id="需求分析的必要性"><a href="#需求分析的必要性" class="headerlink" title="需求分析的必要性"></a>需求分析的必要性</h3><p>需求分析的重点是调查、收集与分析用户在数据管理中的信息要求、处理要求、安全性与完整性要求。</p><h3 id="需求分析的方法"><a href="#需求分析的方法" class="headerlink" title="需求分析的方法"></a>需求分析的方法</h3><ol><li>调查组织机构情况。了解组织部门的组成情况，各部门的职责等。</li><li>调查各部门的业务活动情况。包括了解各个部门输入和使用什么数据、如何加工处理这些数据、输出什么信息、输出到什么部门、输出结果的格式是什么等。</li><li>在熟悉业务活动的基础上，协助用户明确对新系统的各种要求。</li></ol><h3 id="数据流图和数据字典"><a href="#数据流图和数据字典" class="headerlink" title="数据流图和数据字典"></a>数据流图和数据字典</h3><p>需求分析阶段收集到的基础数据用数据字典和一组DFD表达，它们是下一步进行概念设计的基础。</p><h2 id="8-3-概念结构的设计"><a href="#8-3-概念结构的设计" class="headerlink" title="8.3 概念结构的设计"></a>8.3 概念结构的设计</h2><p>概念结构设计的任务是在需求分析阶段产生的需求说明书的基础上，按照特定的方法，将其抽象为一个不依赖于任何具体机器的数据模型，即概念模型。概念模型又称概念结构，它可用 E-R图进行描述。</p><blockquote><p>目前还没确定数据库的类型(eg. 关系数据库..etc)</p></blockquote><h3 id="概念模型的特点、设计方法和步骤"><a href="#概念模型的特点、设计方法和步骤" class="headerlink" title="概念模型的特点、设计方法和步骤"></a>概念模型的特点、设计方法和步骤</h3><ul><li><p>概念模型的特点：</p><ul><li>能真实和充分反映现实设计；</li><li>能满足用户对数据处理的需求；</li><li>易于被用户理解，用户才可参与到数据库设计中；</li><li>易于更改，以满足用户需求的修改和扩充；易于向数据模型转换。</li></ul></li><li><p>概念模型的设计方法：</p><ul><li>自顶向下方法</li><li>自定向上方法</li><li>逐步扩张方法</li><li>混合策略方法 </li></ul></li></ul><h3 id="数据抽象与局部视图设计"><a href="#数据抽象与局部视图设计" class="headerlink" title="数据抽象与局部视图设计"></a>数据抽象与局部视图设计</h3><ul><li>数据抽象的三种方法<ul><li>分类</li><li>聚集</li><li>概括</li></ul></li><li>局部视图的设计<ul><li>明确局部应用的范围</li><li>设计分E-R图</li><li>确定实体之间的联系，产生局部模型</li></ul></li></ul><h3 id="视图的集成"><a href="#视图的集成" class="headerlink" title="视图的集成"></a>视图的集成</h3><ul><li>合并分E-R图，生成初步E-R图：分E-R图间的冲突主要由属性冲突、命名冲突和结构重提三种。</li><li>消除不必要的冗余，设计基本E-R图：用分析方法消除冗余；用规范化理论消除冗余。</li></ul><h2 id="8-4-数据库逻辑结构的设计"><a href="#8-4-数据库逻辑结构的设计" class="headerlink" title="8.4 数据库逻辑结构的设计"></a>8.4 数据库逻辑结构的设计</h2><p>数据库逻辑结构设计的主要任务：将概念模型转换为某一DBMS所支持的数据类型</p><p>###逻辑结构设计过程</p><ul><li>选择最合适的数据模型，并按转换规则将概念模型转换为选定的数据模型</li><li>从支持这种数据模型的DBMS中选出最佳的DBMS，并根据选定DBMS的特点和限制对数据模型进行优化</li><li>通过优化方法将其转换为优化的数据模型</li></ul><p>###概念模型转换为关系模型<br><strong>实体集的转换规则</strong><br>一个实体集转换为关系模型中的一个关系，实体的属性就是关系的属性，实体的标识符就是关系的键，关系的结果就是关系模式。  </p><p><strong>实体集间联系的转换规则</strong>   </p><ul><li>1 : 1 联系的转换方法 <ul><li>将一个 1 : 1 联系转换为一个独立的关系：与该联系相连的各实体集的键以及联系本身的属性转换为关系，且<strong>每个实体的键</strong>均是该关系的候选键。</li><li>将一个 1 : 1 联系与<strong>任意一端</strong>实体集所对应的关系合并：在被合并关系中增加属性，新增的属性为联系本身的属性和联系相关的另一个实体集的键。</li></ul></li><li>1 : n 联系的转换方法 <ul><li>将一个 1 : n 联系转换为一个独立的关系：与该联系相连的各实体集的键以及联系本身的属性转换为关系，且该关系的键为 <strong>n 端实体的键</strong>。</li><li>将一个 1 : n联系与 <strong>n 端</strong>实体集所对应的关系合并：在n端实体集增加新属性，新属性由联系对应的 1 端实体集的键和联系自身的属性构成，新增属性后原关系的键不变。</li></ul></li><li>m : n 联系的转换方法<ul><li>将一个 m : n 联系转换为一个关系：与该联系相连的各实体集的键以及联系本身的属性转换为关系的属性，新关系的键为两个相连实体键的组合。(<strong>该键为多属性构成的组合键</strong>)</li></ul></li></ul><h2 id="8-5-数据库物理结构的设计"><a href="#8-5-数据库物理结构的设计" class="headerlink" title="8.5 数据库物理结构的设计"></a>8.5 数据库物理结构的设计</h2><p>物理设计阶段：根据具体计算机系统(DBMS和硬件)的特点，为<strong>给定的数据库模型</strong>确定合理的<code>存储结构</code>和<code>存取方法</code>，并对物理结构进行评价。希望设计的物理数据库结构能够满足<strong>事务在数据库上</strong>：</p><ul><li>运行相应时间少</li><li>存储空间利用率高</li><li>事务吞吐量大</li></ul><p><strong>确定关系模式的存取方法</strong>：1.索引法 2.聚簇法<br><strong>确定关系模式的存储结构</strong>：确定数据的存放位置和结构。(启发性规则P257)</p><p><strong>评价物理结构</strong>：物理设计过程中需要对时间效率、空间效率、维护代价和各种用户要求进行权衡。评价方法<strong>完全依赖于所用的DBMS</strong>，主要从定量估算各种方案的存储结构、存储时间和维护代价入手，对估算结果进行权衡比较，取一个较优合理的物理结构。根据用户需求修改设计。</p><h2 id="8-6-数据库的实施和维护"><a href="#8-6-数据库的实施和维护" class="headerlink" title="8.6 数据库的实施和维护"></a>8.6 数据库的实施和维护</h2><h3 id="数据库的实施"><a href="#数据库的实施" class="headerlink" title="数据库的实施"></a>数据库的实施</h3><p>数据库的实施阶段任务：</p><ul><li>设计人员用DBMS提供的数据定义(DDL)语言和其他使用程序将数据库逻辑设计和物理设计结果严格描述出来，使数据模型成为DBMS可以接受的源代码</li><li>经过调试产生目标模式，完成建立定义数据库结构的工作</li><li><strong>组织数据入库</strong>，并运行应用程序进行调试</li></ul><blockquote><p>相当于软件工程中代码编写和调试的阶段<br>组织数据入是数据库实施阶段最主要的工作：手工逐条录入、数据录入子系统</p></blockquote><h3 id="数据库的试运行"><a href="#数据库的试运行" class="headerlink" title="数据库的试运行"></a>数据库的试运行</h3><ul><li>实际运行数据库应用程序，执行对数据库的各项操作，测试<strong>应用程序功能</strong>是否满足要求</li><li>测试系统的<strong>性能指标</strong>，分析是否符合设计目标</li></ul><blockquote><p>注意：(1)数据库的试运行操作应<strong>分步进行</strong> (2)数据库的实施和调试不可能一次完成</p></blockquote><h3 id="数据库的运行和维护"><a href="#数据库的运行和维护" class="headerlink" title="数据库的运行和维护"></a>数据库的运行和维护</h3><p>数据库的维护工作主要包括以下几方面：</p><ul><li>数据库的转储和恢复</li><li>对数据库的安全性和完整性进行控制</li><li>对数据库的性能进行监督、分析和改造</li><li>对数据库进行<strong>(部分)重组织和重构造</strong>(数据库运行一段时间后，由于记录不断增删改会使数据库的物理存储情况变坏)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;8-1-数据库系统设计概述&quot;&gt;&lt;a href=&quot;#8-1-数据库系统设计概述&quot; class=&quot;headerlink&quot; title=&quot;8.1 数据库系统设计概述&quot;&gt;&lt;/a&gt;8.1 数据库系统设计概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;需求分析阶段：需求收集和分析，得到&lt;code&gt;数据字典&lt;/code&gt;和&lt;code&gt;数据流图&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;概念结构设计阶段：对用户需求综合、归纳与抽象，形成概念模型，用&lt;code&gt;E-R图&lt;/code&gt;表示。&lt;/li&gt;
&lt;li&gt;逻辑结构设计阶段：将概念结构转换为某个DBMS所支持的&lt;code&gt;关系模型&lt;/code&gt;/&lt;code&gt;数据模型&lt;/code&gt;，对关系模型进行优化。&lt;/li&gt;
&lt;li&gt;物理设计阶段：根据具体计算机系统(DBMS和硬件)的特点，为&lt;strong&gt;给定的数据库模型&lt;/strong&gt;确定合理的&lt;code&gt;存储结构&lt;/code&gt;和&lt;code&gt;存取方法&lt;/code&gt;，并对物理结构进行评价。&lt;/li&gt;
&lt;li&gt;数据库实施阶段：建立数据库，编制与调试应用程序，组织数据入库，程序试运行。&lt;/li&gt;
&lt;li&gt;数据库运行和维护阶段：数据库应用系统投入运行后，需要进行备份和维护，对于出现的问题需要不断调整和修改，直到满足用户需求。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库原理笔记C07 关系数据库理论</title>
    <link href="http://daisine.me/sql07/"/>
    <id>http://daisine.me/sql07/</id>
    <published>2018-06-04T03:45:14.000Z</published>
    <updated>2018-06-08T04:58:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="7-1-关系模式规范化的必要性"><a href="#7-1-关系模式规范化的必要性" class="headerlink" title="7.1 关系模式规范化的必要性"></a>7.1 关系模式规范化的必要性</h2><p>数据冗余一直是影响系统性能的大问题。“分解”是解决冗余的主要办法。<br>(1) 冗余存储<br>(2) 更新异常：重复信息的一个副本修改时，所有副本必须进行同样修改，否则造成不一致。<br>(3) 插入异常：只有当一些信息事先已经存储在数据库中时，另一些信息才能存入到数据库中。<br>(4) 删除异常：在删除某些信息时可能丢失其他信息。<br> <a id="more"></a></p><h2 id="7-2-函数依赖"><a href="#7-2-函数依赖" class="headerlink" title="7.2 函数依赖"></a>7.2 函数依赖</h2><p>关系模式中的各个属性之间相互联系、相互制约的联系称为数据依赖。数据依赖一般分为函数依赖、多值依赖和连接依赖。</p><h3 id="1-函数依赖的定义"><a href="#1-函数依赖的定义" class="headerlink" title="1. 函数依赖的定义"></a>1. 函数依赖的定义</h3><p>设R(U)是属性集U上的关系模式。X，Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称<strong>X函数确定Y</strong>或<strong>Y函数依赖于X</strong>，记作<strong>X → Y</strong>。 </p><h3 id="2-函数依赖的分类P217"><a href="#2-函数依赖的分类P217" class="headerlink" title="2. 函数依赖的分类P217"></a>2. 函数依赖的分类P217</h3><p> ”如果 Y&sube;X&sube;U， 则 X→Y。“称为平凡依赖。否则称为非平凡依赖，若无特别声明，我们总是讨论非平凡依赖。</p><ul><li>完全函数依赖：在关系模式R(U)中，X，Y是U的子集，X’是X的真子集，存在X→Y，但对<strong>每一个</strong>X’都有X’!→Y，则称Y完全函数依赖于X。</li><li>部分函数依赖：在关系模式R(U)中，X，Y是U的子集，存在X→Y，若X’是X的真子集，<strong>存在</strong>X’→Y，则称Y部分函数依赖于X。</li><li>传递函数依赖：在关系模式R(U)中，X，Y，Z是U的子集，存在X→Y(Y∉X)，Y !→X，Y→Z，则有X→Z，称Z传递函数依赖于X。</li></ul><blockquote><p>在此加上条件Y!→X，是因为如果X→Y，Y→X，则X↔Y，实际上就是X直接函数依赖于Z，而不是传递函数依赖。</p></blockquote><h3 id="3-函数依赖和键的联系"><a href="#3-函数依赖和键的联系" class="headerlink" title="3. 函数依赖和键的联系"></a>3. 函数依赖和键的联系</h3><p>函数依赖是键的推广</p><ul><li>设关系模式R的属性集是U，K为U的一个子集。如果K→U在R上成立，则称K为R的一个超键。</li><li>如果K→U在R上成立，但对于K的任一真子集K’都有K’→U不成立，那么称K是R上的一个候选键。</li><li>关系模式R中的属性或属性组X并非R的主键，但X是另外一个关系模式S的主键，则称X是R的外键。</li></ul><h3 id="4-函数依赖的逻辑蕴含"><a href="#4-函数依赖的逻辑蕴含" class="headerlink" title="4. 函数依赖的逻辑蕴含"></a>4. 函数依赖的逻辑蕴含</h3><p>仅仅考虑函数依赖集是不够的，需要考虑模式上成立的锁于函数依赖。对于给定的函数依赖集F，可以推导出其他一些未知的函数依赖，称这些函数依赖被F“逻辑蕴含”。  </p><blockquote><p>设F是在关系模式R上成立的函数依赖的集合，X→Y是一个函数依赖。如果对于R的每个满足F的关系r也满足X→Y(即r中的任意两个元组t，s，若t<sub>1</sub>[X]=t<sub>2</sub>[X]，则t<sub>1</sub>[Y]=t<sub>2</sub>[Y])，则称F逻辑蕴含X→Y。</p></blockquote><h3 id="5-函数依赖的推理规则"><a href="#5-函数依赖的推理规则" class="headerlink" title="5. 函数依赖的推理规则"></a>5. 函数依赖的推理规则</h3><ul><li><p>阿姆斯特朗公理</p><ul><li>自反律/包含规则: 如果 Y&sube;X&sube;U， 则 X→Y。(X→Y 是平凡依赖)</li><li>增广律: 如果 X → Y， 且Z&sube;X，则 XZ → YZ。</li><li>传递率: 如果 X → Y 且 Y → Z, 则 X → Z</li></ul></li><li><p>阿姆斯特朗公理的推理</p><ul><li>合并规则: 如果 X→Y 且 X→Z, 那么 X→YZ.</li><li>分解规则: 如果 X → YZ,且 X → Y 且 X → Z.</li><li>伪传递: 如果 X→Y 且 WY→Z, 那么 XW → Z.</li><li>集合累积规则: 如果 X → YZ 且 Z→W, 那么 X → YZW. </li></ul></li><li>阿姆斯特朗公理是有效的和完备的<ul><li>有效性：在F中根据阿姆斯特朗公理推导出的每一个函数议定为F所逻辑蕴含。</li><li>完备性：F所逻辑蕴含的每一个函数，必定可以可以由F出发根据阿姆斯特朗公理推导出来。</li></ul></li></ul><h3 id="6-函数依赖集的闭包和属性集的闭包-概念，不考怎么计算F的闭包"><a href="#6-函数依赖集的闭包和属性集的闭包-概念，不考怎么计算F的闭包" class="headerlink" title="6. 函数依赖集的闭包和属性集的闭包(概念，不考怎么计算F的闭包)"></a>6. 函数依赖集的闭包和属性集的闭包(概念，不考怎么计算F的闭包)</h3><ul><li>函数依赖集的闭包：F是函数依赖集，F的闭包(closure)是指被F逻辑蕴涵的所有函数依赖的集合，记做F <sup>+</sup> 。</li><li>属性集的闭包：设F为属性集U上的一组函数依赖，X是U的子集，那么属性集X的闭包用X <sup>+</sup> 表示，它是一个从函数依赖集使用FD(函数依赖)推理规则推出的所有满足X→A的属性A的集合：<br>X <sup>+</sup> = { A | X → A 在 F <sup>+</sup> 中} </li></ul><h3 id="7-函数依赖的最小依赖集"><a href="#7-函数依赖的最小依赖集" class="headerlink" title="7. 函数依赖的最小依赖集"></a>7. 函数依赖的最小依赖集</h3><ul><li>如果G <sup>+</sup> = F <sup>+</sup>，就说函数依赖集F覆盖G(F是G的覆盖，G是F的覆盖)，F与G等价。</li><li>如果函数依赖集F满足以下条件，则称F为最小函数依赖集或最小覆盖。<ul><li>F中任一函数依赖的右部仅含一个属性。</li><li>F中不存在这样的函数依赖X → A，使得 F与F -｛X → A｝等价。</li><li>F中不存在这样的函数依赖 X → A，X有真子集 Z 使得 F-｛ X → A｝ ∪ ｛ Z → A｝与 F等价。(左边没有多余)</li></ul></li></ul><blockquote><p>每个依赖都尽可能的小，左边的属性没有多余，右边为单属性，且其中的每个依赖都是必要的。</p></blockquote><h2 id="7-3-关系模式的分解"><a href="#7-3-关系模式的分解" class="headerlink" title="7.3 关系模式的分解"></a>7.3 关系模式的分解</h2><h3 id="模式分解的规则"><a href="#模式分解的规则" class="headerlink" title="模式分解的规则"></a>模式分解的规则</h3><p>设关系模式R(U)，R<sub>1</sub>, R<sub>2</sub>…, R<sub>k</sub>都是R的子集(这里把关系模式看成是属性的集合)，R＝R<sub>1</sub> ∪ R<sub>2</sub> ∪ … ∪ R<sub>k</sub>，关系模式R<sub>1</sub>, R<sub>2</sub>…, R<sub>k</sub>的集合用ρ表示，ρ={R<sub>1</sub>, R<sub>2</sub>…, R<sub>k</sub>}。用ρ代替R的过程称为关系模式的分解。这里称为R的一个分解，也成为数据库模式。</p><h3 id="无损连接分解"><a href="#无损连接分解" class="headerlink" title="无损连接分解"></a>无损连接分解</h3><p>设R是一个关系模式，F是R上的一个函数依赖集合。R的一个分解是一个关系集合ρ={R<sub>1</sub>, R<sub>2</sub>…, R<sub>k</sub>}，如果对R中满足F的每一个关系r，有：r = π<sub>R<sub>1</sub></sub>(r) ⋈ π<sub>R<sub>2</sub></sub>(r) ⋈ … ⋈  π<sub>R<sub>k</sub></sub>(r)，那么称分解ρ相当于F是<code>无损连接分解</code>；否则，称为<code>有损连接分解</code>。</p><blockquote><p>其中 π<sub>R<sub>i</sub></sub>(r) 表示关系 r 在模式 R<sub>i</sub> 属性上的投影。</p></blockquote><p>(考试：给出分解，用定理判断)<br>如果R为一个关系模式，F是R上的函数依赖集。令R<sub>1</sub> 和R<sub>2</sub>为R的分解。该分解为R的无损连接分解的条件是：F<sup>+</sup>中至少存在如下函数依赖中的一个</p><ul><li>R<sub>1</sub> ∩ R<sub>2</sub> → R<sub>1</sub></li><li>R<sub>1</sub> ∩ R<sub>2</sub> → R<sub>2</sub></li></ul><p>即，R<sub>1</sub> 和 R<sub>2</sub> 的公有属性能确定R<sub>1</sub>或R<sub>2</sub>。<br>换句话说，R<sub>1</sub> ∩ R<sub>2</sub>是R<sub>1</sub>或R<sub>2</sub>的<strong>超键</strong>，R上的分解就是无损分解。我们可以用属性闭包的方法来有效的检验<strong>超键</strong>。P225 例7.16</p><h3 id="保持函数依赖的分解"><a href="#保持函数依赖的分解" class="headerlink" title="保持函数依赖的分解"></a>保持函数依赖的分解</h3><p>设R是具有属性U和函数依赖集合F的关系模式，ρ={R<sub>1</sub>, R<sub>2</sub>…, R<sub>k</sub>}为R的一个分解，如果π<sub>R<sub>i</sub></sub>(F)(i = 1, 2, …, k)的并集逻辑蕴含F中的全部函数依赖，则称分解ρ具有函数依赖保持性。</p><p>设关系模式R(A, B, C, D)，函数依赖集F = {A → B, B → C, B → D, C → A}，分解为ρ = { R<sub>1</sub>(AB), R<sub>2</sub>(ACD) }。检验分解的无损连接性和分解的函数依赖保持性。</p><blockquote><p>由于R<sub>1</sub> ∩ R<sub>2</sub> = AB ∩ ABC = A，根据A → B，得到A → AB，即R<sub>1</sub> ∩ R<sub>2</sub> → R<sub>1</sub>，所以分解ρ是无损分解。<br>F<sub>1</sub> = π<sub>R<sub>1</sub></sub>(F) = { A → B, B → A }<br>F<sub>2</sub> = π<sub>R<sub>2</sub></sub>(F) = { A → C, C → A, A → D }<br>F<sub>1</sub> ∪ F<sub>2</sub> = {A → B, B → A, A → C, C → A, A → D } = {A → B, B → C, B → D, C → A} = F，所以分解ρ是保持函数依赖分解。</p></blockquote><p>模式分解的无损分解与保持函数依赖的分解两个特性之间没有必然的联系。</p><h2 id="7-4-关系模式的范式"><a href="#7-4-关系模式的范式" class="headerlink" title="7.4 关系模式的范式"></a>7.4 关系模式的范式</h2><p>范式以函数依赖为基础，有第一范式(1NF)，第二范式(2NF)，第三范式(3NF),BC范式(BCNF)。其他类型范式：4NF和5NF不详述。各范式之间存在下面的关系：<br>1NF &sup; 2NF &sup; 3NF &sup; BCNF &sup; 4NF &sup; 5NF</p><h3 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a>第一范式(1NF)</h3><p>设R是一个关系模式，如果R的每个属性的值域是不可分的(原子的)数据项集合，则称这个关系模式R为第一范式，简称1NF，记作R &in; 1NF。</p><h3 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式(2NF)"></a>第二范式(2NF)</h3><p>若关系模式R &in; 1NF，且每一个非主属性完全函数依赖于键，则R &in; 2NF。[在1NF基础上消除非主属性对键的部分函数依赖]</p><blockquote><p>第二范式（2NF）要求实体的属性完全依赖于(候选)键。所谓完全依赖是指不能存在仅依赖键一部分的属性，如果存在，那么这个属性和键的这一部分应该分离出来形成一个新的实体。</p></blockquote><h3 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式(3NF)"></a>第三范式(3NF)</h3><p>关系模式R &in; 2NF，且它的任何一个非主属性都不传递依赖于任何候选键，则R &in; 3NF。[在2NF基础上消除非主属性对键的传递函数依赖]</p><blockquote><p>即不能存在：非主属性 A 依赖于非主属性 B，非主属性 B 依赖于键的情况。</p></blockquote><p>2NF：非主属性是否<strong>完全依赖</strong>于键，还是依赖于键的一部分。<br>3NF：非主键列是<strong>直接依赖</strong>于键，还是直接依赖于非主属性列。</p><h3 id="BC范式-BCNF"><a href="#BC范式-BCNF" class="headerlink" title="BC范式(BCNF)"></a>BC范式(BCNF)</h3><p>设关系模式R(U, F) &in; 1NF, 如果对于R的每个函数依赖X → Y (Y &notin; X)，X必包含键，则R &in; BCNF，又称修正/扩充的第三范式。[在3NF的基础上消除了主属性之间的函数依赖]</p><ul><li>所有非主属性都完全依赖于每个候选键</li><li>所有主属性都完全函数依赖于每个不包含它的候选键</li><li>没有任何属性完全函数依赖于非键的人和一组属性</li></ul><blockquote><p>只要属性或属性组A能够决定任何一个属性B，则A的子集中必须有候选键。<br>BCNF范式排除了任何属性(不光是非主属性，2NF和3NF所限制的都是非主属性)对候选键的传递依赖与部分依赖。</p></blockquote><h3 id="规范化小结"><a href="#规范化小结" class="headerlink" title="规范化小结"></a>规范化小结</h3><p>关系模式在分解时应该保持“等价”。无损连接分解和保持函数依赖分解没有必然联系。</p><ul><li><code>数据等价</code>用无损连接分解来衡量：能保持关系经过自然连接以后仍能恢复回来</li><li><code>语义等价</code>用保持函数依赖费解来衡量：能保证数据在投影或连接中其语义不会发生变化。</li></ul><p>范式是衡量关系模式优劣的标准，范式表达了模式中数据依赖之间应满足的联系。范式级别越高，其数据冗余和操作异常现象越少。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;7-1-关系模式规范化的必要性&quot;&gt;&lt;a href=&quot;#7-1-关系模式规范化的必要性&quot; class=&quot;headerlink&quot; title=&quot;7.1 关系模式规范化的必要性&quot;&gt;&lt;/a&gt;7.1 关系模式规范化的必要性&lt;/h2&gt;&lt;p&gt;数据冗余一直是影响系统性能的大问题。“分解”是解决冗余的主要办法。&lt;br&gt;(1) 冗余存储&lt;br&gt;(2) 更新异常：重复信息的一个副本修改时，所有副本必须进行同样修改，否则造成不一致。&lt;br&gt;(3) 插入异常：只有当一些信息事先已经存储在数据库中时，另一些信息才能存入到数据库中。&lt;br&gt;(4) 删除异常：在删除某些信息时可能丢失其他信息。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
