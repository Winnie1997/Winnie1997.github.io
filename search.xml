<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hadoop安装hive&amp;配置mysql元数据库</title>
      <link href="/hive/"/>
      <url>/hive/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装Hive"><a href="#1-安装Hive" class="headerlink" title="1. 安装Hive"></a>1. 安装Hive</h2><ul><li>环境：<strong>Dokcer</strong>搭建的Hadoop完全分布式集群 - namenode节点</li><li>安装包：<a href="https://archive.apache.org/dist/hive/hive-1.2.1/" target="_blank" rel="noopener">apache-hive1.2.1-bin.tar.gz</a></li></ul><a id="more"></a><ul><li><p>从本地上传安装包到namenode主机并解压</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp /home/daisine/software/apache-hive-1.2.1-bin.tar.gz root@172.18.0.2:/usr/local/</span><br><span class="line"><span class="meta">#</span> 解压到/usr/local中</span><br><span class="line">sudo tar -zxvf ./apache-hive-1.2.1-bin.tar.gz -C /usr/local   </span><br><span class="line">cd /usr/local/</span><br><span class="line"><span class="meta">#</span> 将文件夹名改为hive</span><br><span class="line">sudo mv apache-hive-1.2.1-bin hive</span><br></pre></td></tr></table></figure></li><li><p>配置hive-env.sh文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HADOOP_HOME=/usr/local/hadoop</span><br><span class="line">export HIVE_CONF_DIR=/usr/local/hive/conf</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-安装MySQL"><a href="#2-安装MySQL" class="headerlink" title="2. 安装MySQL"></a>2. 安装MySQL</h2><ul><li><p>MySQL安装过程</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>添加mysql yum源</span><br><span class="line">rpm -Uvh http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm</span><br><span class="line"><span class="meta">#</span>查看当前可用的MySQL安装资源</span><br><span class="line">yum repolist enabled | grep "mysql.*-community.*"</span><br><span class="line"><span class="meta">#</span>使用yum的方式安装MySQL</span><br><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></table></figure></li><li><p>安装MySQL5.6.44：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>查看mysql安装结果</span><br><span class="line">rpm -qa|grep mysql</span><br><span class="line">mysql-community-release-el7-5.noarch</span><br><span class="line">mysql-community-client-5.6.44-2.el7.x86_64</span><br><span class="line">mysql-community-common-5.6.44-2.el7.x86_64</span><br><span class="line">mysql-community-libs-5.6.44-2.el7.x86_64</span><br><span class="line">mysql-community-server-5.6.44-2.el7.x86_64</span><br></pre></td></tr></table></figure></li><li><p>配置MySQL</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>开机启动</span><br><span class="line">systemctl enable mysqld</span><br><span class="line"><span class="meta">#</span>启动mysql</span><br><span class="line">systemctl start mysqld</span><br><span class="line"><span class="meta">#</span>查看mysql当前状态</span><br><span class="line">systemctl status mysqld</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>重置密码</span><br><span class="line">mysql_secure_installation</span><br><span class="line">Set root password? [Y/n] y        [设置root用户密码]</span><br><span class="line">Remove anonymous users? [Y/n] y            [删除匿名用户]</span><br><span class="line">Disallow root login remotely? [Y/n] n            [禁止root远程登录]</span><br><span class="line">Remove test database and access to it? [Y/n] y       [删除test数据库]</span><br><span class="line">Reload privilege tables now? [Y/n] y        [刷新权限]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>修改访问权限 让其他计算机也能访问</span><br><span class="line">mysql -u root -p</span><br><span class="line">mysql &gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'yourpassword' WITH GRANT OPTION;</span><br><span class="line">mysql &gt; flush privileges;</span><br><span class="line"></span><br><span class="line">mysql &gt; show databases;</span><br><span class="line">mysql &gt; use mysql;</span><br><span class="line">mysql &gt; show tables;</span><br><span class="line">mysql &gt; desc user;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>停止mysql</span><br><span class="line">systemctl stop mysqld</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：不建议安装<code>MySQL 5.7版本</code>或更高，后期配置需要解决很多新问题。</p></li><li><p>使用yum安装的MySQL 5.7版本完全卸载方式方案  <code>不卸载干净再安装MySQL5.6 启动会出问题</code> </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>停止mysql</span><br><span class="line">systemctl stop mysqld</span><br><span class="line"><span class="meta">#</span>卸载MySQL5.7</span><br><span class="line">yum remove  mysql mysql-server mysql-libs mysql-server</span><br><span class="line">cd /var/lib/</span><br><span class="line">rm -rf mysql </span><br><span class="line"></span><br><span class="line">cd /usr/share/</span><br><span class="line">rm -rf mysql/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查询MySQL安装包</span><br><span class="line">rpm -qa |grep mysql</span><br><span class="line"><span class="meta">#</span>将查询到的结果删去</span><br><span class="line">yum remove $(查询到的结果)</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-Hive配置MySQL为元数据库"><a href="#3-Hive配置MySQL为元数据库" class="headerlink" title="3. Hive配置MySQL为元数据库"></a>3. Hive配置MySQL为元数据库</h2><ul><li><p>mysql jdbc 包：<a href="https://dev.mysql.com/downloads/connector/j/" target="_blank" rel="noopener">mysql-connector-java-5.1.47.tar.gz</a>(进入网页后选择<code>Platform Independent</code>)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp /home/daisine/software/mysql-connector-java-5.1.47.tar.gz root@172.18.0.2:/usr/local/</span><br><span class="line">tar -zxvf mysql-connector-java-5.1.47.tar.gz</span><br><span class="line">cd mysql-connector-java-5.1.47</span><br><span class="line">cp mysql-connector-java-5.1.47-bin.jar /usr/local/hive/lib/</span><br></pre></td></tr></table></figure></li><li><p>配置Metastore到MySQL</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/hive/conf</span><br><span class="line">touch hive-site.xml</span><br><span class="line">vi hive-site.xml</span><br></pre></td></tr></table></figure></li><li><p>hive-site.xml 需要根据自己的情况<strong>修改</strong>两处</p><ul><li><strong>ConnectionURL</strong>：<code>jdbc:mysql://$(hostname):3306/metastore</code> </li><li><strong>ConnectionPassword</strong>：<code>&lt;value&gt;$(password)&lt;/value&gt;</code> </li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://hadoop1:3306/metastore?createDatabaseIfNotExist=true&amp;amp;useSSL=false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>JDBC connect string for a JDBC metastore<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Driver class name for a JDBC metastore<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>username to use against metastore database<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>111111<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>password to use against metastore database<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="启动hive"><a href="#启动hive" class="headerlink" title="启动hive"></a>启动hive</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 启动hdfs yarn</span><br><span class="line"><span class="meta">#</span> namenode</span><br><span class="line">sbin/start-dfs.sh</span><br><span class="line"><span class="meta">#</span> resourcemanager</span><br><span class="line">sbin/start-yarn.sh</span><br><span class="line"><span class="meta">#</span> 启动hive</span><br><span class="line">cd /usr/local/hive</span><br><span class="line">bin/hive</span><br><span class="line">Logging initialized using configuration in jar:file:/usr/local/hive/lib/hive-common-1.2.1.jar!/hive-log4j.properties</span><br><span class="line">hive &gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
            <tag> Docker </tag>
            
            <tag> hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下Docker搭建Hadoop完全分布式集群</title>
      <link href="/dockerhadoop/"/>
      <url>/dockerhadoop/</url>
      
        <content type="html"><![CDATA[<h2 id="1-系统环境"><a href="#1-系统环境" class="headerlink" title="1. 系统环境"></a>1. 系统环境</h2><ul><li><p>Mac OS X 10.13</p></li><li><p>Parallels Desktop 虚拟机软件</p></li><li><p>Ubuntu 14.04 虚拟机</p><blockquote><p>Ubuntu 14.04 与Mac OS X共享网络，文件夹。</p></blockquote></li></ul><a id="more"></a><h2 id="2-安装Docker"><a href="#2-安装Docker" class="headerlink" title="2.  安装Docker"></a>2.  安装Docker</h2><ul><li>参考<a href="http://dblab.xmu.edu.cn/blog/1233/" target="_blank" rel="noopener">安装Docker-厦大数据库实验室</a></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -r</span><br><span class="line"><span class="meta">#</span>安装Dokcer: 64位Linux系统，其次内核版本必须大于3.10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>更新apt，安装CA证书，因为访问Docker用的是https协议</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install apt-transport-https ca-certificates</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>添加新的GPG key；</span><br><span class="line">sudo apt-key adv \</span><br><span class="line">               --keyserver hkp://ha.pool.sks-keyservers.net:80 \</span><br><span class="line">               --recv-keys 58118E89F3A912897C070ADBF76221572C52609D</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>Ubuntu系统添加Docker源</span><br><span class="line">echo deb https://apt.dockerproject.org/repo ubuntu-xenial main | sudo tee /etc/apt/sources.list.d/docker.list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>更新apt包索引</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>验证下是否从正确的仓库拉取安装包</span><br><span class="line">apt-cache policy docker-engine</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>安装Docker[出现问题]</span><br><span class="line">sudo apt-get install docker-engine</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>启动Docker</span><br><span class="line">sudo service docker start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>docker默认是只有root才能执行Docker命令，因此需要添加用户权限</span><br><span class="line"><span class="meta">#</span>创建docker用户组</span><br><span class="line">sudo groupadd docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>添加当前用户到Docker用户组 $USER用当前用户名替换</span><br><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><ul><li><p>在最后一步安装Docker指令遇到问题：</p><blockquote><p>Some packages could not be installed. This may mean that you have requested an impossible situation or if you are using the unstable distribution that some required packages have not yet been created or been moved out of Incoming.<br>The following information may help to resolve the situation:<br>The following packages have unmet dependencies:<br>docker-engine : Depends: init-system-helpers (&gt;= 1.18~) but 1.14 is to be installed<br>Depends: lsb-base (&gt;= 4.1+Debian11ubuntu7) but 4.1+Debian11ubuntu6 is to be installed<br>Depends: libdevmapper1.02.1 (&gt;= 2:1.02.99) but 2:1.02.77-6ubuntu2 is to be installed<br>Recommends: aufs-tools but it is not going to be installed<br>Recommends: cgroupfs-mount but it is not installable or cgroup-lite but it is not going to be installed<br>Recommends: git<br>E: Unable to correct problems, you have held broken packages.</p></blockquote></li><li><p>意思是安装Docker对系统有些软件包的版本有要求，而现在系统已有的软件包版本过低不符合Docker安装的依赖关系。</p></li><li><p>解决方法：使用如下指令安装Dokcer  参考<a href="https://github.com/moby/moby/issues/15692" target="_blank" rel="noopener">Github issues Docker安装问题</a></p></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo wget -qO- https://get.docker.com/ | SH</span><br></pre></td></tr></table></figure><h2 id="3-Docker构建Hadoop镜像"><a href="#3-Docker构建Hadoop镜像" class="headerlink" title="3. Docker构建Hadoop镜像"></a>3. Docker构建Hadoop镜像</h2><h3 id="获取CentOS7镜像"><a href="#获取CentOS7镜像" class="headerlink" title="获取CentOS7镜像"></a>获取CentOS7镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>大约70+ MB 速度较慢</span><br><span class="line">docker pull centos</span><br></pre></td></tr></table></figure><blockquote><p>建议使用阿里云Docker镜像加速器，参考<a href="https://blog.csdn.net/weixin_36794678/article/details/81434487" target="_blank" rel="noopener">使用阿里云Docker镜像加速器</a></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>查看镜像列表 可以看到刚才pull的centos的镜像</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><h3 id="在CentOS7的基础上构建CentOS-SSH镜像"><a href="#在CentOS7的基础上构建CentOS-SSH镜像" class="headerlink" title="在CentOS7的基础上构建CentOS-SSH镜像"></a>在CentOS7的基础上构建CentOS-SSH镜像</h3><ul><li><p>使用Dockerfile安装CentOS-SSH镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>最好在一个空文件夹中创建 不要在系统根目录创建</span><br><span class="line">mkdir ~/centos-ssh</span><br><span class="line">cd centos-ssh</span><br><span class="line">vi Dockerfile</span><br></pre></td></tr></table></figure></li><li><p>Dockerfile内容为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">RUN yum install -y openssh-server sudo</span><br><span class="line">RUN sed -i 's/UsePAM yes/UsePAM no/g' /etc/ssh/sshd_config</span><br><span class="line">RUN yum  install -y openssh-clients</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 用户root，密码111111，将此用户添加到sudoers里  </span><br><span class="line">RUN echo "root:111111" | chpasswd</span><br><span class="line">RUN echo "root   ALL=(ALL)       ALL" &gt;&gt; /etc/sudoers</span><br><span class="line">RUN ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key</span><br><span class="line">RUN ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key</span><br><span class="line"></span><br><span class="line">RUN mkdir /var/run/sshd</span><br><span class="line">EXPOSE 22</span><br><span class="line">CMD ["/usr/sbin/sshd", "-D"]</span><br></pre></td></tr></table></figure><blockquote><p>关于Dockerfile更多指令来构建镜像，参考<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile官方文档</a></p></blockquote></li><li><p>构建CentOS-SSH镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t="centos7-ssh" .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查看镜像列表 可以看到刚才build的centos7-ssh的镜像</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure></li></ul><h3 id="在CentOS-SSH的基础上构建Hadoop-JDK镜像"><a href="#在CentOS-SSH的基础上构建Hadoop-JDK镜像" class="headerlink" title="在CentOS-SSH的基础上构建Hadoop+JDK镜像"></a>在CentOS-SSH的基础上构建Hadoop+JDK镜像</h3><ul><li><p>使用Dockerfile安装CentOS-SSH镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>最好在一个空文件夹中创建 不要在系统根目录创建</span><br><span class="line">mkdir ~/hadoop</span><br><span class="line">cd hadoop</span><br><span class="line">vi Dockerfile</span><br></pre></td></tr></table></figure></li><li><p>在~/hadoop文件夹中放入JDK安装包和Hadoop安装包</p><blockquote><p>我使用的是jdk-8u131-linux-x64.tar.gz与hadoop-2.7.2.tar.gz</p><p>不同版本JDK或Hadoop需在Dockerfile中修改</p></blockquote></li><li><p>Dockerfile内容为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos7-ssh</span><br><span class="line">ADD jdk-8u131-linux-x64.tar.gz /usr/local/</span><br><span class="line">RUN mv /usr/local/jdk1.8.0_131 /usr/local/jdk1.8</span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8</span><br><span class="line">ENV PATH $JAVA_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">ADD hadoop-2.7.2.tar.gz /usr/local</span><br><span class="line">RUN mv /usr/local/hadoop-2.7.2 /usr/local/hadoop</span><br><span class="line">ENV HADOOP_HOME /usr/local/hadoop</span><br><span class="line">ENV PATH $HADOOP_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">RUN yum install -y which sudo</span><br></pre></td></tr></table></figure><blockquote><p>关于Dockerfile更多指令来定制镜像，参考<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile官方文档</a></p></blockquote></li><li><p>构建CentOS-SSH镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t="hadoop" .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查看镜像列表 可以看到刚才build的hadoop的镜像</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-Dokcer搭建Hadoop完全分布式集群"><a href="#4-Dokcer搭建Hadoop完全分布式集群" class="headerlink" title="4. Dokcer搭建Hadoop完全分布式集群"></a>4. Dokcer搭建Hadoop完全分布式集群</h2><ul><li><p>两个概念的区别：参考<a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank" rel="noopener">Docker-从入门到实践</a></p><ul><li>Docker镜像(类)</li><li>Docker容器(对象)</li></ul></li><li><p>基本规划：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">172.18.0.2 hadoop1 namenode datanode</span><br><span class="line">172.18.0.3 hadoop2 datanode</span><br><span class="line">172.18.0.4 hadoop3 secondarynamenode datanode</span><br></pre></td></tr></table></figure></li><li><p>由于docker容器重新启动之后ip会发生变化，所以需要设置固定ip</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>创建自定义网络 并且指定网段172.18.0.0/16</span><br><span class="line">docker network create --subnet=172.18.0.0/16 mynetwork</span><br><span class="line"><span class="meta">#</span>查看创建的mynetwork</span><br><span class="line">docker network ls</span><br><span class="line"><span class="meta">#</span>启动三个容器，分别作为hadoop1 hadoop2 hadoop3</span><br><span class="line">docker run --privileged --name hadoop1 --hostname hadoop1 --net mynetwork --ip 172.18.0.2 -d -P -p 50070:50070 -p 8088:8088 -p 9000:9000 -p 50020:50020 hadoop /usr/sbin/init</span><br><span class="line">docker run --name hadoop2 --hostname hadoop2 --net mynetwork --ip 172.18.0.3 -d -P hadoop</span><br><span class="line">docker run --name hadoop3 --hostname hadoop3 --net mynetwork --ip 172.18.0.4 -d -P hadoop</span><br></pre></td></tr></table></figure></li><li><p>关于hadoop1容器的启动方式说明</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 由于CentOS7镜像本身存在的缺陷 无法使用systemctl命令</span><br><span class="line"><span class="meta">#</span> 可以通过启动容器时加参数--privileged和最末加上/usr/sbin/init 使用systemctl命令</span><br><span class="line">docker run --privileged .... /usr/sbin/init</span><br></pre></td></tr></table></figure><ul><li>具体报错：在安装好mysql启动时：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld</span><br><span class="line">Failed to get D-Bus connection: Operation not permitted</span><br></pre></td></tr></table></figure></li></ul><h3 id="SSH免密码登录设置"><a href="#SSH免密码登录设置" class="headerlink" title="SSH免密码登录设置"></a>SSH免密码登录设置</h3><ul><li><p>打开3个容器的终端</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>打开三个终端分别为hadoop1，hadoop2与hadoop3</span><br><span class="line">docker exec -it hadoop1 /bin/bash</span><br><span class="line">docker exec -it hadoop2 /bin/bash</span><br><span class="line">docker exec -it hadoop3 /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>配置主机映射</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>在该文件内加入新的主机映射 内网ip 主机名</span><br><span class="line">vi /etc/hosts</span><br><span class="line">172.18.0.2 hadoop1</span><br><span class="line">172.18.0.3 hadoop2</span><br><span class="line">172.18.0.4 hadoop3</span><br></pre></td></tr></table></figure></li><li><p>SSH免密码登录设置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen  </span><br><span class="line"><span class="meta">#</span>拷贝公钥到需要免密码登录的目标服务器上</span><br><span class="line">ssh-copy-id hadoop01 </span><br><span class="line">ssh-copy-id hadoop02</span><br><span class="line">ssh-copy-id hadoop03</span><br><span class="line"><span class="meta">#</span>使用`ssh 主机名`免密码登录目标服务器</span><br><span class="line">ssh hadoop0x</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-配置Hadoop与JDK的环境变量"><a href="#5-配置Hadoop与JDK的环境变量" class="headerlink" title="5. 配置Hadoop与JDK的环境变量"></a>5. 配置Hadoop与JDK的环境变量</h2><ul><li><p>profile文件中加入环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>#JAVA_HOME</span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_131</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line"><span class="meta">#</span>#HADOOP_HOME</span><br><span class="line">export HADOOP_HOME=/opt/module/hadoop-2.7.2</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>让修改后的profile生效</span><br><span class="line">source  /etc/profile </span><br><span class="line">java -version</span><br><span class="line">hadoop</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-修改Hadoop配置文件"><a href="#6-修改Hadoop配置文件" class="headerlink" title="6. 修改Hadoop配置文件"></a>6. 修改Hadoop配置文件</h2><ul><li><p>相关文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/hadoop/etc/hadoop</span><br><span class="line">vi core-site.xml</span><br><span class="line">vi hdfs-site.xml</span><br><span class="line">vi yarn-site.xml</span><br><span class="line">vi slaves</span><br><span class="line">vi yarn-env.sh</span><br><span class="line">vi mapred-env.sh</span><br></pre></td></tr></table></figure></li><li><p>core-site.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop1:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/hadoop/data/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>hdfs-site.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop3:50090<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.permissions<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>slaves</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop1</span><br><span class="line">hadoop2</span><br><span class="line">hadoop3</span><br></pre></td></tr></table></figure></li><li><p>yarn-env.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/hadoop1.8</span><br></pre></td></tr></table></figure></li><li><p>mapred-env.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/hadoop1.8</span><br></pre></td></tr></table></figure></li><li><p>hadoop-env.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> Hadoop启动报Error: JAVA_HOME is not set and could not be found</span><br><span class="line">export JAVA_HOME=$JAVA_HOME  </span><br><span class="line"><span class="meta">#</span> 修改为绝对路径</span><br><span class="line">export JAVA_HOME=/usr/local/hadoop1.8</span><br></pre></td></tr></table></figure></li><li><p>分发文件到hadoop2与hadoop3</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r /usr/local/hadoop/etc/hadoop hadoop2:/usr/local/hadoop/etc/</span><br><span class="line">scp -r /usr/local/hadoop/etc/hadoop hadoop3:/usr/local/hadoop/etc/</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-Hadoop集群启动"><a href="#7-Hadoop集群启动" class="headerlink" title="7. Hadoop集群启动"></a>7. Hadoop集群启动</h2><ul><li><p>首次启动集群，需要格式化namenode</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/hdfs namenode -format</span><br></pre></td></tr></table></figure></li><li><p>在Hadoop01中启动HDFS</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbin/start-dfs.sh</span><br></pre></td></tr></table></figure></li><li><p>此时可以打开本地ubuntu浏览器输入:localhost:50070看到web管理界面</p></li><li><p>关闭HDFS</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbin/stop-dfs.sh</span><br></pre></td></tr></table></figure></li><li><p>启动与关闭yarn</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbin/start-yarn.sh</span><br><span class="line">sbin/stop-yarn.sh</span><br></pre></td></tr></table></figure></li><li><p>全部启动与关闭</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-all.sh</span><br><span class="line">stop-all.sh</span><br></pre></td></tr></table></figure></li><li><p>备注：由于本地ubuntu使用docker启动容器时，指定的为主机网络。Docker 容器的网络会附属在主机上，两者是互通的。所以使用ssh可以直接连接到三个容器。</p><blockquote><p>如，在容器中运行一个Web服务，监听8080端口，则主机的8080端口就会自动映射到容器中。</p></blockquote></li></ul><h2 id="8-参考资料"><a href="#8-参考资料" class="headerlink" title="8. 参考资料"></a>8. 参考资料</h2><p><a href="https://www.cnblogs.com/liujinhong/p/8795387.html" target="_blank" rel="noopener">使用Docker部署Hadoop环境和Presto</a></p><p><a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank" rel="noopener">Docker — 从入门到实践</a></p><p><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile官方文档</a></p><p><a href="https://www.jianshu.com/p/a6bfe81247b6" target="_blank" rel="noopener">Hadoop启动报Error: JAVA_HOME is not set and could not be found解决办法</a></p><p><a href="http://dblab.xmu.edu.cn/blog/1233/" target="_blank" rel="noopener">安装Docker-厦大数据库实验室</a></p>]]></content>
      
      
      <categories>
          
          <category> 大数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
            <tag> 大数据 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3个阿里云ECS搭建Hadoop完全分布式集群</title>
      <link href="/hadoops/"/>
      <url>/hadoops/</url>
      
        <content type="html"><![CDATA[<h2 id="1-准备阿里云ECS"><a href="#1-准备阿里云ECS" class="headerlink" title="1. 准备阿里云ECS"></a>1. 准备阿里云ECS</h2><ul><li>我使用的是Mac OS X 10.13，在终端中可以进行：<ul><li><code>ssh</code>连接远程服务器，</li><li><code>scp</code>上传/下载远程服务器文件</li></ul></li><li>云服务器ECS * 3  <code>共享基本型</code>  - <code>1vCPU</code>  - <code>1Gib</code></li><li>PS：3个ECS需要在同一个地域，如<code>华东1</code>。因为<strong>不同地域</strong>的实例之间<strong>内网互不相通</strong>。</li></ul><a id="more"></a><ul><li><p>操作系统：CentOS 7.3 <code>64位</code></p></li><li><p>分配公网IPv4地址：理论上只需要1个ECS分配公网IP即可，3个ECS使用内网互通。<code>之后需要进行设置内网互通，免费</code></p><blockquote><p>如果是3个不同账号/跨地域的ECS，也可以搭建</p></blockquote></li><li><p>ESC设置内网互通，参考：<a href="https://help.aliyun.com/document_detail/65861.html?spm=a2c4g.11186623.6.558.491f303e3Lb1M5" target="_blank" rel="noopener">阿里云帮助-同账号同地域VPC和VBR互通</a></p></li></ul><p><img src="/hadoops/ecs.png" width="80%"></p><h2 id="2-SSH免密码登录"><a href="#2-SSH免密码登录" class="headerlink" title="2. SSH免密码登录"></a>2. SSH免密码登录</h2><ul><li><p>关闭防火墙        <code>3个ECS</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>关闭防火墙</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"><span class="meta">#</span>开机禁止启动</span><br><span class="line">systemctl disable firewalld.service</span><br><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure></li><li><p>修改主机名称：此处我将3个ECS的主机名分别修改为<code>hadoop01</code>，<code>hadoop02</code>，<code>hadoop03</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>将该文件中的内容修改为新的主机名</span><br><span class="line">sudo vim /etc/hostname</span><br><span class="line"><span class="meta">#</span>重启服务器生效</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure></li><li><p>配置主机映射：由于内网互通，所以均填写的为ecs的内网IP。</p><blockquote><p>如果内网不互通，则自己主机的IP填写为内网IP，其他主机的IP填写为公网IP。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>在该文件内加入新的主机映射 内网ip 主机名</span><br><span class="line">vi /etc/hosts </span><br><span class="line">172.16.119.x hadoop01</span><br><span class="line">172.16.119.y hadoop02</span><br><span class="line">172.16.238.z hadoop03</span><br></pre></td></tr></table></figure></li><li><p>此时，<code>ECS</code> 之间ping对方的内网IP可以ping通。</p><blockquote><p>事实上我设置了阿里云的ECS内网互通之后就可以ping通内网IP了。</p></blockquote></li><li><p>SSH免密码登录设置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen  #回车完成操作</span><br><span class="line">ssh-copy-id hadoop01 #拷贝公钥到需要免密码登录的目标服务器上</span><br><span class="line">ssh-copy-id hadoop02</span><br><span class="line">ssh-copy-id hadoop03</span><br><span class="line">ssh hadoop0x #使用`ssh 主机名`免密码登录目标服务器</span><br></pre></td></tr></table></figure></li><li><p>~/.ssh/下的文件功能</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ls</span><br><span class="line">authorized_keys  id_rsa  id_rsa.pub  known_hosts</span><br><span class="line"><span class="meta">#</span>~/.ssh的4个文件</span><br><span class="line"><span class="meta">#</span> known_hosts：记录ssh访问过计算机的公钥(public key)</span><br><span class="line"><span class="meta">#</span> id_rsa：生成的私钥</span><br><span class="line"><span class="meta">#</span> id_rsa.pub：生成的公钥</span><br><span class="line"><span class="meta">#</span> authorized_keys：存放授权过得无秘登录服务器公钥</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-安装JDK与Hadoop"><a href="#3-安装JDK与Hadoop" class="headerlink" title="3. 安装JDK与Hadoop"></a>3. 安装JDK与Hadoop</h2><ul><li><p>在root用户下的<code>opt</code>文件夹中创建<code>module</code>、<code>software</code>文件夹</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">mkdir module #安装的JDK与Hadoop的位置</span><br><span class="line">mkdir software #安装包的存储位置</span><br></pre></td></tr></table></figure></li><li><p><strong>way1</strong>：将本地的JDK和Hadoop安装包上传到服务器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>在mac os的本地用户的终端下使用scp上传安装包</span><br><span class="line"><span class="meta">#</span>scp 本地安装包路径 root@公网ip:存放文件夹路径</span><br><span class="line">scp /users/yi/Downloads/jdk-8u131-linux-x64.tar.gz root@123.56.135.146:/opt/software</span><br><span class="line">scp /users/yi/Downloads/hadoop-2.7.2.tar.gz root@123.56.135.146:/opt/software</span><br></pre></td></tr></table></figure></li><li><p><strong>way2</strong>:在ECS用户下使用wget下载安装包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>wget 下载链接</span><br><span class="line"><span class="meta">#</span>我使用的是Hadoop2.7.2 与 Java 1.8.0_131</span><br><span class="line"><span class="meta">#</span>Hadoop2.x 与 Hadoop3.x 有区别</span><br><span class="line">cd /opt/software #下载的安装包的存放位置</span><br><span class="line">wget JDK‘s URL</span><br><span class="line">wget Hadoop‘s URL</span><br></pre></td></tr></table></figure></li><li><p>在<code>/opt/module</code>安装Hadoop与JDK</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/software #安装包的位置</span><br><span class="line"><span class="meta">#</span> tar -zxvf 压缩包名称 -C 解压文件存放位置</span><br><span class="line">tar -zxvf jdk-8u131-linux-x64.tar.gz -C /opt/module/</span><br><span class="line">tar -zxvf hadoop-2.7.2.tar.gz -C /opt/module/</span><br></pre></td></tr></table></figure></li><li><p>配置hadoop中的hadoop-env.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/module/hadoop-2.7.2/etc/hadoop</span><br><span class="line">vi hadoop-env.sh</span><br><span class="line"><span class="meta">#</span>修改JAVA_HOME的值为/opt/module/jdk1.8.0_131</span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_131</span><br></pre></td></tr></table></figure></li><li><p>配置Hadoop与JDK的环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/profile #在profile中加入以下环境变量</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>#JAVA_HOME</span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_131</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line"><span class="meta">#</span>#HADOOP_HOME</span><br><span class="line">export HADOOP_HOME=/opt/module/hadoop-2.7.2</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin</span><br><span class="line"></span><br><span class="line">source  /etc/profile #让修改后的profile生效</span><br><span class="line">java -version#查询Java版本可以正确显示结果</span><br><span class="line">hadoop #显示Hadoop的使用方式</span><br></pre></td></tr></table></figure><blockquote><p>如果不能查询Java版本和Hadoop指令，可以使用<code>reboot</code>重启服务器再进行尝试。</p></blockquote></li></ul><h2 id="4-Hadoop完全分布式集群搭建"><a href="#4-Hadoop完全分布式集群搭建" class="headerlink" title="4. Hadoop完全分布式集群搭建"></a>4. Hadoop完全分布式集群搭建</h2><ul><li><p>修改<code>/opt/module/hadoop-2.7.2/etc/hadoop</code>文件夹中的配置文件</p></li><li><p>core-site.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop01:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定hadoop运行时产生文件的存储目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/module/hadoop-2.7.2/data/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>hdfs-site.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop03:50090<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>slaves</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>删掉了localhost，加入以下内容</span><br><span class="line">hadoop01</span><br><span class="line">hadoop02</span><br><span class="line">hadoop03</span><br></pre></td></tr></table></figure></li><li><p>yarn-env.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 修改JAVA_HOME的值并取消注释#</span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_131</span><br></pre></td></tr></table></figure></li><li><p>yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- reducer获取数据的方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定YARN的ResourceManager的地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop02<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>mapred-env.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 修改JAVA_HOME的值并取消注释#</span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_131</span><br></pre></td></tr></table></figure></li><li><p>mapred-site.xml(原本不存在这个文件)</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定mr运行在yarn上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>分发以上修改的文件到另外2个ECS</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r /opt/module/hadoop-2.7.2/etc/hadoop hadoop02:/opt/module/hadoop-2.7.2/etc/</span><br><span class="line">scp -r /opt/module/hadoop-2.7.2/etc/hadoop hadoop03:/opt/module/hadoop-2.7.2/etc/</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-Hadoop集群启动"><a href="#5-Hadoop集群启动" class="headerlink" title="5. Hadoop集群启动"></a>5. Hadoop集群启动</h2><ul><li><p>首次启动集群，需要格式化namenode</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/hdfs namenode -format</span><br></pre></td></tr></table></figure></li><li><p>在Hadoop01中启动HDFS</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbin/start-dfs.sh</span><br></pre></td></tr></table></figure></li><li><p>使用<code>jps</code>查看Hadoop进程</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 hadoop-2.7.2]# jps</span><br><span class="line">6649 Jps</span><br><span class="line">6316 NameNode</span><br><span class="line">6446 DataNode</span><br><span class="line">[root@hadoop01 hadoop-2.7.2]# ssh hadoop02</span><br><span class="line">[root@hadoop02 ~]# jps</span><br><span class="line">14206 Jps</span><br><span class="line">14111 DataNode</span><br><span class="line">[root@hadoop02 ~]# ssh hadoop 03</span><br><span class="line">[root@hadoop03 ~]# jps</span><br><span class="line">5091 DataNode</span><br><span class="line">5192 SecondaryNameNode</span><br><span class="line">5260 Jps</span><br></pre></td></tr></table></figure></li><li><p>在阿里云ECS控制台中将Hadoop01服务器的安全组规则中开放50070端口</p><blockquote><p>50070为hadoop2.x中namenode的默认web访问端口</p></blockquote></li><li><p>在HDFS启动的时候，访问<code>http://hadoop01&#39;s公网IP:50070</code></p></li></ul><p><img src="/hadoops/h1.png" width="100%"></p><p><img src="/hadoops/h2.png" width="100%"></p><ul><li><p>关闭HDFS</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbin/stop-dfs.sh</span><br></pre></td></tr></table></figure></li><li><p>启动与关闭yarn</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbin/start-yarn.sh</span><br><span class="line">sbin/stop-yarn.sh</span><br></pre></td></tr></table></figure></li><li><p>全部启动与关闭</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-all.sh</span><br><span class="line">stop-all.sh</span><br></pre></td></tr></table></figure></li><li><p>上传文件到集群</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>创建上传的文件所在目录</span><br><span class="line">bin/hdfs dfs -mkdir -p /user/root/tmp/conf</span><br><span class="line"><span class="meta">#</span>上传文件到HDFS</span><br><span class="line">bin/hdfs dfs -put etc/hadoop/*-site.xml /user/root/tmp/conf</span><br><span class="line"><span class="meta">#</span>下载HDFS中的文件</span><br><span class="line">bin/hadoop fs -get /user/root/input/workcount.txt</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理习题</title>
      <link href="/diptimu/"/>
      <url>/diptimu/</url>
      
        <content type="html"><![CDATA[<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ul><li>数字图像处理  - 冈萨雷斯 - 第三版中文版</li><li><p>习题答案为英文版翻译删减版 + 小部分个人理解</p><a id="more"></a></li></ul><h4 id="C2-6-22"><a href="#C2-6-22" class="headerlink" title="C2[6, 22]"></a>C2[6, 22]</h4><ul><li>2.6 某汽车制造商想在一条限量版跑车生产线上将一些零件自动安放在跑车保险杠上，这一部件就是彩色坐标，为选择合适的保险杠零件，机器人需要知道每辆车的颜色。模型有4种颜色：蓝色、绿色、红色、白色。请提出一种基于成像的解决方案。你怎样解决自动确定每辆跑车颜色的问题？记住，在选择零件时价格是最主要的考虑因素。<ul><li>一种可能的解决方案是为单色相机配备机械装置，该装置在镜头前依次放置红色，绿色和蓝色通过滤光器。相机最强的响应决定了颜色。 如果所有三个响应大致相等，则为白色。</li><li>更快的系统将使用三个不同的相机，每个相机配备一个单独的滤光器。 然后，轮询每个摄像机的响应进行分析。 这个系统会贵一点，但会更快，更可靠。 </li><li>请注意，两种解决方案都<strong>假设摄像机的视野是完全由均匀的颜色填充</strong>[即，摄像机聚焦在车辆的一部分上 它的颜色可见。 否则，需要进一步分析以隔离均匀颜色的区域，这是解决该问题所关注的所有问题。</li></ul></li><li>2.22 图像相减通常用于在生产线上检测缺失的元件。方法是存储一幅对应于正确组装的“金”图像；然后，从相同产品的传入图像中减去该图像。理想情况下，如果新产品组装正确，则差值为零。对于缺失元件的产品，在不同于金图像的位置，差值图像将不为零。在实际中，你认为在什么条件下使用这种方式工作才是合适的？<ul><li>有三个基本因素需要严格控制基于差异的检查才能发挥作用：</li><li>（1）<strong>正确组装：</strong>产品会打上特殊标记，用于图像的对齐。如果它相对于金图像移位，则比较它们之间的差值是没有意义的。</li><li>（2）<strong>照明控制：</strong>照明的变化会显着影响差值图像中的值。所以必须保证照明控制，才不会对差值图像的结果产生影响。</li><li>（3）<strong>足够低的噪声水平：</strong>这样才不会对黄金和输入图像之间的比较产生实质性影响。良好的信号强度对降低噪声影响有很大帮助。</li><li>（4）<strong>设定阈值</strong>，使传入的图像与金图像的差值对比足够接近也能接受。</li></ul></li><li>灰度分辨率，结合课后习题。</li></ul><h4 id="C3-5-6-7-14"><a href="#C3-5-6-7-14" class="headerlink" title="C3[5, 6, 7, 14]"></a>C3[5, 6, 7, 14]</h4><ul><li><p>3.5 (a) 通常，如果将低阶比特平面的一半设为零值，对一幅图像的直方图有何影响？</p><ul><li>具有不同灰度值的像素的数量将减少，从而导致直方图中的分量的数量减少。由于像素的数量不会改变，所以这将导致剩下的直方图分量的(幅值)高度增加。通常，灰度值的丰富性降低会导致<strong>对比度下降</strong>。</li></ul></li><li><p>3.5 (b) 如果将高阶比特平面的一半设为零值，对一幅图像的直方图有何影响？</p><ul><li>最明显的效果是<strong>图像显著变暗</strong>。例如，丢弃最高位将会使8位图像中最亮的亮度限制在127.由于像素数保持不变，直方图的某些峰值的高度会增加，总体呈现出更高更窄的直方图。</li></ul></li><li><p>3.6 试解释为什么离散直方图均衡技术一般不能得到平坦的直方图？</p><ul><li>直方图均衡所做的事是在亮度范围上<strong>重新映射</strong>直方图的分量。为了获得平坦的直方图，需要<strong>重新分配像素灰度值</strong>，直方图均衡没有灰度值重新分配的过程。</li></ul></li><li><p>3.7 假设对一幅数字图像进行直方图均衡处理。试证明(对直方图均衡化的图像)进行第二次直方图均衡处理的结果，与第一次直方图均衡处理的结果相同。</p><ul><li><p>令n = MN，像素的总数，n<sub>r<sub>j</sub></sub>是具有灰度值r<sub>j</sub>的输入图像的像素个数。那么直方图均衡处理为：</p><p><img src="/diptimu/371.png" width="35%"></p></li><li><p>因为每个具有灰度值 r<sub>k</sub> 的像素被映射到灰度值 s<sub>k</sub> ，所以n<sub>s<sub>k</sub></sub> = n<sub>r<sub>k </sub></sub> 。第二次直方图均衡处理将产生值v<sub>k</sub></p></li></ul><p><img src="/diptimu/372.png" width="30%"></p><ul><li>由于n<sub>s<sub>k</sub></sub> = n<sub>r<sub>k </sub></sub>  ：</li></ul><p><img src="/diptimu/373.png" width="30%"></p><ul><li>这表明直方图均衡的第二次处理结果与第一次处理相同。(舍入误差忽略不计)</li></ul></li><li><p>3.14 如图所示图像很不相同，但它们的直方图却相同，假设每幅图像都用一个3x3的均值模版来进行模糊处理。</p><p><img src="/diptimu/314.png" width="20%"></p><ul><li><p>模糊后图像的直方图还相同吗？试解释原因。</p><p>右侧图像中<strong>黑色和白色区域之间的边界点数量要多得多</strong>。当进行模糊处理时，边界点将在右侧产生更多数量的不同值，因此模糊处理后的直方图不同。</p></li><li><p>如果你的答案是不相同，画出两个直方图。</p><p>3x3的均值模版，其系数为1/9。假设图片的大小为NxN，用0的边框环绕图像。模糊处理后两张图像的值如下表所示：</p><p><img src="/diptimu/3142.png" width="50%"></p></li></ul></li></ul><ul><li><p>第三章的概念，需要掌握：平滑滤波，中值滤波，直方图等。公式不会考，需要掌握定性的内容如：高频，低频，滤波器，etc</p><h4 id="C11-1-2-8"><a href="#C11-1-2-8" class="headerlink" title="C11[1, 2, 8]"></a>C11[1, 2, 8]</h4></li><li><p>11.1(a) 重新定义链码的一个起始点，以便所得的数字序列形成一个最小整数。请证明该编码与边界的初始起点无关。</p><ul><li>链码中每个元素的值都与其前元素的值相关。 以一致方式（例如，顺时针方向）跟踪的边界的代码是唯一的圆形数字集。 <strong>从该集合中的不同位置开始不会改变循环序列的结构</strong>。 </li><li>选择最小整数作为起始点只是标识序列中的相同点。 即使起点不是唯一的，这种方法仍然会给出一个独特的序列。 例如，序列101010具有三个可能的起始点，但它们都产生相同的最小整数010101。</li></ul></li><li><p>11.1(b) 求编码10176722335422的归一化起始点。</p><ul><li>代码：11076765543322.起点为0，产生序列07676554332211。</li></ul></li><li><p>11.2(a) 证明链码的一次差分会将该链码关于旋转归一化</p><ul><li>一次差分仅计算分隔代码的相邻元素的<strong>方向数</strong>。 因为计数过程与方向无关，所以第一个差异与边界旋转无关。 （这里的假设是旋转不会改变代码本身）。</li></ul></li><li><p>11.2(b)计算编码0110233210332322111的一次差分</p><ul><li>编码：0101030303323232212111</li><li>差分：3131331313031313031300。</li><li>编码被视为循环序列，因此差分的第一个元素是代码的最后一个元素和第一个元素之间的方向变化数，如文中所述。</li></ul></li><li><p>11.8 画出下列图形的中轴：一个圆，一个等边五角形，一个矩形，一个等边三角形</p><p><img src="/diptimu/118.png" width="50%"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理笔记</title>
      <link href="/dip/"/>
      <url>/dip/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数字图像处理概述"><a href="#1-数字图像处理概述" class="headerlink" title="1. 数字图像处理概述"></a>1. 数字图像处理概述</h3><ul><li><p>图像处理的应用</p><ul><li>货车安全状态自动识别系统</li></ul></li><li><p>DIP阶段划分：</p><a id="more"></a></li></ul><p><img src="/dip/dip.png" width="65%"></p><ul><li><p>数字图像处理在各个领域的应用</p><ul><li>伽马射线成像：核医学，天文观测…</li><li>X射线成像：医学诊断，工业成像…</li><li>紫外波段成像：平板印刷术，显微方法，工业检测…</li><li>可见光及红外波段成像：遥感，天气观测与预报，生产产品的自动视觉检测</li><li>微波波段成像(雷达)，无线电波段成像(医学，天文学)</li></ul></li><li><p>数字图像处理关键步骤：</p><p><img src="/dip/keys.png" width="50%"></p><ul><li>图像获取：通常包括图像预处理，如图像缩放。</li><li>图像增强：对一幅图像进行某种操作，使其结果在特定应用中比原始图像更适合进行处理。(主观的)</li><li>图像复原：复原技术倾向于以图像退化的图数学或概率模型为基础。(客观的)</li><li>形态学处理：涉及提取图像成分的工具，这些成分在表示和描述形状方面很有用。(输出图像属性处理)</li><li>分割：将一幅图片划分为其组成部分或目标。分割越准确，识别越成功。</li><li>表示与描述：选择一种合适的表示，如关注外部形状特征&amp;一条边界，内部特效&amp;整个区域。描述又称为特征选择，涉及特征提取。</li><li>目标识别：基于目标的描述给该目标赋予标志的过程。</li></ul></li></ul><h3 id="2-数字图像基础"><a href="#2-数字图像基础" class="headerlink" title="2. 数字图像基础"></a>2. 数字图像基础</h3><h5 id="2-1-采样和量化"><a href="#2-1-采样和量化" class="headerlink" title="2.1 采样和量化"></a>2.1 采样和量化</h5><ul><li><p>为了产生一幅数字图像，我们需要将连续的感知数据转换为数字形式。采集到的图像都需要经过离散化变成数字图像后才能被计算机识别和处理。</p></li><li><p>数字图像始终只是现实世界场景的近似值。</p><p><img src="/dip/采样量化.png" width="30%"></p></li><li><p>采样：对坐标值进行数字化。</p></li><li><p>量化：对幅值数字化。(把采样点上对应的灰度连续变化区间转换为单个特定数码的过程)</p></li></ul><p><img src="/dip/采样.png" width="45%"><img src="/dip/量化.png" width="45%"></p><h5 id="2-2-空间分辨率和灰度分辨率"><a href="#2-2-空间分辨率和灰度分辨率" class="headerlink" title="2.2 空间分辨率和灰度分辨率"></a>2.2 空间分辨率和灰度分辨率</h5><ul><li>空间分辨率是图像中可辨识的最小细节的度量。(像素大小，每英寸点数DPI)</li><li>灰度分辨率是指在灰度级中可分辨的最小变化。<ul><li>灰度分辨率指的是用于量化灰度的比特数。</li><li>灰度分辨率越高，图中可辨识的细节程度越精细。(低细节，中细节，高细节)</li></ul></li></ul><p><img src="/dip/灰度等级.png" width="50%"></p><h3 id="3-灰度变化与空间滤波"><a href="#3-灰度变化与空间滤波" class="headerlink" title="3. 灰度变化与空间滤波"></a>3. 灰度变化与空间滤波</h3><h5 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h5><ul><li>图像增强：对一幅图像进行某种操作，使其结果在特定应用中比原始图像更适合进行处理。</li><li>图像增强的原因：<ul><li>突出显示图像中的有趣细节</li><li>消除图像中的噪点</li><li>使图像更具视觉吸引力</li></ul></li><li><p>图像增强的方法：</p><ul><li>点处理</li><li>直方图处理</li><li>算数/逻辑运算</li><li>邻域操作</li></ul></li><li><p>到目前为止，当我们谈到图像灰度值时，说它们在[0, 255]范围内。其中0为黑色，255为白色，这个范围源于显示技术。而对于本章的许多图像处理操作，假设<strong>灰度级在[0.0, 1.0]</strong>范围。</p></li><li><p>空间域和频率域</p><ul><li><strong>空间域</strong>指图像平面本身，这类图像处理方法直接操作图像中的元素，主要分为灰度变换和空间滤波两类。<strong>灰度变换</strong>对图片的单个像素进行操作，主要以对比度和阈值处理为目的。<strong>空间滤波</strong>设计改善性能的操作，如通过图片中每个像素的邻域处理来锐化图像。</li><li><strong>频率域</strong>的图像处理，如傅立叶变换、小波变换的操作</li></ul></li></ul><h5 id="3-2-点处理"><a href="#3-2-点处理" class="headerlink" title="3.2 点处理"></a>3.2 点处理</h5><ul><li><p>灰度变换是所有图像处理技术中最简单的技术。r和s分别代表处理前后的像素值</p></li><li><p>s = T( r ) T是把像素值r映射到像素值s的一种变换。</p></li><li><p>负像操作/图像反转</p><ul><li>适用于增强嵌入图像暗色区域中的白色或灰色细节，特别是当黑色面积占主导地位时。</li><li>s = L - 1 - r，灰度级范围[0, L-1]</li></ul></li><li><p>阈值处理(二值化) P64图3.2</p><ul><li>阈值转换：将感兴趣的对象与背景隔离的分割。</li></ul></li><li><p>对数变换</p><ul><li>s = c log ( 1 + r )，c为常数，r ≥ 0</li><li>使用对数变换来<strong>扩展</strong>图像中的<strong>暗像素值</strong>，同时<strong>压缩更高灰度级</strong>的值。该变换将输入中范围较窄的低灰度值映射为输出中范围较宽的灰度值，或将输入中范围较宽的高灰度值映射为输出中范围较窄的灰度值。</li><li>应用：傅立叶频谱 P66</li></ul></li><li><p>幂律(伽马)变换</p><ul><li>s = r <sup><em>γ</em></sup>，c和<em>γ</em>为正常数</li><li>与对数变换情况类似，部分<em>γ</em>值的幂律曲线将较窄范围的暗色输入映射为较宽范围的输出值，或将较宽范围的高灰度级输入映射为较窄范围的输出值。<strong>不同的是</strong>，<em>γ</em>&gt;1的值所生成的曲线(<strong>图像变暗</strong>)和 <em>γ</em>&lt;1的值所生成的曲线(<strong>图像变亮</strong>)效果完全相反，当c = <em>γ</em> = 1，为恒等变换。</li><li><strong>伽马校正</strong>：显示设备不能线性响应不同的亮度，所以需要将图像输入到显示设备前进行预处理，使得经过伽马校正过的输入产生外观上接近原图像的输出。</li></ul></li><li><p><strong>分段</strong>线性变换<strong>函数</strong></p><ul><li><p>灰度级分层：突出显示图像中特定灰度范围的亮度。一种方法是将感兴趣范围内所有灰度值显示为一个值(eg白)，其他灰度值显示为另一个值(eg黑)；另一种方法是将感兴趣范围的灰度变亮(/暗)，保持图像中其他灰度级不变。</p><p><img src="/dip/gl.png" width="50%"></p></li><li><p>比特平面分层：像素是由比特组成的数字。如在256级灰度图像中，每个像素的灰度由8比特组成。替代突出灰度级范围，我们可用突出比特来突出整个图像的外观。</p><blockquote><p>比如一幅8比特图像由8个1比特平面组成，其中平面1包含图像中所有像素的低阶比特，而8包含图像中所有像素的最高阶比特。P71</p></blockquote></li></ul></li></ul><h5 id="3-3-直方图处理"><a href="#3-3-直方图处理" class="headerlink" title="3.3 直方图处理"></a>3.3 直方图处理</h5><ul><li><p>灰度范围为[0, L-1]的数字图像的直方图是离散函数 h ( r <sub>k</sub> ) = n <sub>k</sub>，其中 r <sub>k</sub>是第k级灰度值， n <sub>k</sub>是图像中灰度为 r <sub>k</sub>的像素个数。</p><ul><li>归一化：p ( r <sub>k</sub> ) = n <sub>k</sub> / MN， M和N为图像的行数和列数，p ( r <sub>k</sub> )为r <sub>k</sub>在图像中出现的概率估计。</li></ul></li><li><p>直方图的主要性质：</p><ul><li>直方图只能反应图像的灰度分布情况，不能表示灰度所在位置。</li><li>一幅图像对应唯一的灰度直方图，不同图像可对应相同的直方图。</li></ul></li><li><p>图像与其直方图之间的关系 P73：<strong>高对比度图像</strong>具有最均匀间隔的直方图。若一幅图像的像素占有全部可能灰度级范围并且分布均匀，则这幅图像对比度高，灰度色调多变。</p></li><li><p>直方图均衡化 P76</p><ol><li>统计图象中各灰度级像素个数n <sub>k</sub></li><li>计算直方图中应变量的值: p <sub>k</sub> = n <sub>k</sub>/(M×N)</li><li>计算累计直方图中应变量的值: s <sub>k</sub> = Σ p <sub>k</sub></li><li>取整S <sub>k</sub>=int{(L-1)s <sub>k</sub>};</li><li>确定映射对应关系: k → S <sub>k</sub>;</li><li>对图象进行增强变换( k → S <sub>k</sub>).</li></ol><p><img src="/dip/gs.png" width="55%"></p></li></ul><h5 id="3-4-算数-逻辑运算"><a href="#3-4-算数-逻辑运算" class="headerlink" title="3.4 算数/逻辑运算"></a>3.4 算数/逻辑运算</h5><ul><li><p>算术运算：加法，减法，乘法</p></li><li><p>逻辑运算：NOT，AND，OR，XOR</p><p><img src="/dip/logic.png" width="75%"></p></li></ul><h5 id="3-5-空间滤波"><a href="#3-5-空间滤波" class="headerlink" title="3.5 空间滤波"></a>3.5 空间滤波</h5><ul><li><p>空间滤波器由(1)邻域(通常是一个较小的矩形)，(2)对该邻域所包围的图像像素执行的预定义操作组成。</p><ul><li>线性操作 - 线性空间滤波器  eg.平滑空间滤波器<ul><li>非线性操作 - 非线性空间滤波器 eg.中值滤波器</li></ul></li></ul></li><li><p>简单的邻域操作：</p><ul><li>Min：将像素值设置为最小值</li><li>Max：将像素值设置为最大值</li><li>Median：将像素值设置为中值(中位数)。有时候中值比平均值效果更好。</li></ul><p><img src="/dip/滤波.png" width="60%"></p></li><li><p>对原始图像中的每个像素重复上述操作以生成滤波图像。</p></li></ul><h5 id="3-6-平滑空间滤波器"><a href="#3-6-平滑空间滤波器" class="headerlink" title="3.6  平滑空间滤波器"></a>3.6  平滑空间滤波器</h5><ul><li><p>用于模糊处理和降低噪声。模糊处理经常用于预处理任务中，例如在目标提取之前去除图像中一些琐碎细节。</p></li><li><p>平滑线性空间滤波器/均值滤波器：使用滤波器模版确定的邻域内像素的平均灰度值来代替图像中的每个像素的值。</p><p><img src="/dip/均值滤波.png" width="60%"><img src="/dip/加权平滑.png" width="15%"></p></li></ul><ul><li>加权平滑滤波器：通过允许平均函数中邻域中的不同像素具有不同的权重，可以生成更有效的平滑滤波器。更接近中心像素的像素更重要，通常称为加权平均。</li></ul><h5 id="3-7-中值滤波器-统计排序-非线性-滤波器"><a href="#3-7-中值滤波器-统计排序-非线性-滤波器" class="headerlink" title="3.7  中值滤波器 - 统计排序(非线性)滤波器"></a>3.7  中值滤波器 - 统计排序(非线性)滤波器</h5><ul><li>统计排序(非线性)滤波器以滤波器包围的图像区域中所包含的像素排序为基础，使用统计排序结果决定的值代替中心像素的值。</li><li>中值滤波器：对处理脉冲噪声非常有效，这种噪声也称为<strong>椒盐噪声</strong>，因为这种噪声以黑白点的形式叠加在图像上。</li></ul><h5 id="3-8-邻域的边界问题"><a href="#3-8-邻域的边界问题" class="headerlink" title="3.8 邻域的边界问题"></a>3.8 邻域的边界问题</h5><ul><li><p>在图像的边缘，我们缺少像素以形成邻域</p><p><img src="/dip/边界.png" width="25%"></p></li><li><p>处理方法：</p><ul><li>忽略丢失的像素：仅适用于某些滤波器，可以添加额外代码并减缓处理速度</li><li>填充图像：通常使用全白或者全黑像素</li><li>复制边框像素</li><li>允许像素环绕图像</li></ul></li></ul><h5 id="3-9-锐化空间滤波器-拉普拉斯算子"><a href="#3-9-锐化空间滤波器-拉普拉斯算子" class="headerlink" title="3.9 锐化空间滤波器 - 拉普拉斯算子"></a>3.9 锐化空间滤波器 - 拉普拉斯算子</h5><ul><li><p>锐化处理的主要目的是突出<strong>灰度的过渡部分</strong>。锐化处理可由<strong>空间</strong>微分来实现。</p><ul><li>从图像中消除模糊</li><li>高亮显示边缘</li></ul></li><li><p>基于<strong>一阶微分</strong>和<strong>二阶微分</strong>的锐化滤波器</p></li><li><p>使用二阶微分锐化图像 - <strong>拉普拉斯算子 P100</strong></p><ul><li>各向同性滤波器：这种滤波器的响应与滤波器作用的图像的突变方向无关。</li></ul></li></ul><blockquote><p>通常，为了达到令人满意的结果，对给定的任务需要应用多种互补的图像增强技术。 例子P104 增强骨骼扫描</p></blockquote><h3 id="4-频率域滤波"><a href="#4-频率域滤波" class="headerlink" title="4. 频率域滤波"></a>4. 频率域滤波</h3><h5 id="4-1-傅里叶级数和傅里叶变换"><a href="#4-1-傅里叶级数和傅里叶变换" class="headerlink" title="4.1 傅里叶级数和傅里叶变换"></a>4.1 傅里叶级数和傅里叶变换</h5><ul><li><p>傅里叶级数：任何周期函数都可以表示为不同频率的正弦和或余弦之和的形式，每个正弦项和/或余弦项都乘以不同的<strong>系数</strong> - 傅立叶级数</p></li><li><p>逆DFT：值得注意的是傅立叶变换是完全可逆的。</p></li><li><p>二维图像的DFT可以通过显示图像分量频率的频谱来可视化。 P155</p><ul><li>谱对图像平移不敏感，它随着旋转图像以相同的角度旋转</li></ul><p><img src="/dip/dft.png" width="40%"></p></li></ul><h5 id="4-2-频域中的图像处理"><a href="#4-2-频域中的图像处理" class="headerlink" title="4.2 频域中的图像处理"></a>4.2 频域中的图像处理</h5><ul><li><p>频率域滤波是指先修改一幅图像的傅里叶变换，然后计算其反变换，得到处理后的结果。</p><ol><li>计算 F(u, v)，即图像的DFT</li><li>用滤波函数H(u, v) 乘以F(u, v)</li><li>计算结果的<strong>逆DFT</strong></li></ol><p><img src="/dip/dft2.png" width="70%"></p></li></ul><h5 id="4-3-图像平滑"><a href="#4-3-图像平滑" class="headerlink" title="4.3 图像平滑"></a>4.3 图像平滑</h5><ul><li>平滑频域滤波器：通过丢弃高频分量在频域中实现平滑。</li><li><p>过滤的基本模型是：</p><ul><li>G(u, v) = H(u, v) F(u, v)</li><li>其中F(u, v)是被滤波图像的傅里叶变换，H(u, v)是滤波器变换函数</li></ul></li><li><p>低通滤波器：仅通过低频，衰减高频滤波。</p><ul><li>理想低通滤波器(ILPF)：非常急剧</li><li>布特沃斯低通滤波器(BLPF)：阶数值较高，接近于ILPF；阶数值较低，接近于GLPF。可以视为两种”极端”滤波器的过渡。</li><li>高斯低通滤波器(GLPF)：非常平滑</li></ul></li><li><p>理想低通滤波器(ILPF) P169  <strong>[存在振铃现象]</strong></p><ul><li>在以原点为中心，以D<sub>0</sub>为半径的圆内，无衰减地通过所有频率，而在该圆外”阻断”所有频率的二位低通滤波器。 </li><li>对于一个理想低通滤波器横截面，在H(u, v) = 1 和 H(u,v) = 0 之间的过渡点称为<strong>截止频率</strong>。</li><li>D<sub>0</sub>越小，处理后的结果越模糊。D(u, v)是距频率矩形中心的距离。</li></ul><p><img src="/dip/ilpf.png" width="65%"></p></li><li><p>布特沃斯低通滤波器(BLPF)<strong>[振铃现象与阶数有关]</strong></p><ul><li>与ILPGF不同，BLPF函数并没有在通过频率和滤除频率之间给出明显截止的急剧不连续性。对于具有平滑传递函数的滤波器，可在这样一点上定义截止频率：即使得H(u, v) 下降为其最大值的某个百分比的点。</li><li>空间域的<strong>一阶</strong>布特沃斯低通滤波器<strong>没有振铃现象</strong>，<strong>二阶</strong>中振铃现象<strong>很难被察觉</strong>，但更高阶数的滤波器中的振铃现象会很明显。</li></ul><p><img src="/dip/blpf.png" width="65%"></p></li><li><p>高斯低通滤波器(GLPF)<strong>[无振铃现象]</strong></p><p><img src="/dip/glpf.png" width="65%"></p></li><li><p>应用：</p><ul><li>低分辨率文本：使用GLPF对图像滤波后的结果，断开的字符段已被连接到一起。</li><li>用不同D<sub>0</sub>的高斯滤波器处理照片。</li></ul></li></ul><h5 id="4-4-图像锐化"><a href="#4-4-图像锐化" class="headerlink" title="4.4 图像锐化"></a>4.4 图像锐化</h5><ul><li><p>图像中的边缘和精细细节与高频分量相关联</p></li><li><p>高通滤波器：仅通过高频，降低低频滤波。高通滤波器是从给定低通滤波器得到：H<sub>hp</sub>(u, v) = 1 - H<sub>lp</sub>(u ,v)</p><ul><li>理想高通滤波器(IHPF)：非常急剧</li><li>布特沃斯高通滤波器(BHPF)：表现为理想滤波器的锐利性和高斯滤波器的宽阔平滑性间的一种过渡。</li><li>高斯高通滤波器(GHPF)：非常平滑</li></ul><p><img src="/dip/hp.png" width="65%"></p></li><li><p>应用：使用高通滤波法和阈值法增强图像 - 指纹图像P179</p></li><li><p>频率域的拉普拉斯算子</p><ul><li>使用拉普拉斯算子在频率域锐化图像 P180</li></ul></li></ul><h5 id="4-5-快速傅里叶变换"><a href="#4-5-快速傅里叶变换" class="headerlink" title="4.5 快速傅里叶变换"></a>4.5 快速傅里叶变换</h5><ul><li>允许傅里叶变换在合理时间内执行</li><li>将执行傅里叶变换所需的时间缩短100到600倍</li><li>可以在空间域和频率域中完成类似的工作</li><li>可以更容易理解空间域中的过滤</li><li>在频率域中过滤可以更快——特别是对于大图像</li></ul><h3 id="5-图像复原"><a href="#5-图像复原" class="headerlink" title="5. 图像复原"></a>5. 图像复原</h3><h5 id="5-1-图像复原定义"><a href="#5-1-图像复原定义" class="headerlink" title="5.1 图像复原定义"></a>5.1 图像复原定义</h5><ul><li><p>定义</p><ul><li>图像复原技术的主要目的是以预先确定的目标来改善图像。</li><li>类似于图像增强，但更客观。</li><li>图像复原是图利用退化现象的某种先验知识(或后验的)来复原被退化的图像。</li><li>面向退化模型，采用相反的过程进行处理。</li></ul></li><li><p>图像退化：图像在形成、记录、处理和传输过程中，由于成像系统、记录设备、传输介质和处理方法的不完善，导致图像质量的下降的现象。</p><p><img src="/dip/th.png" width="65%"></p></li></ul><h5 id="5-2-噪声与噪声模型"><a href="#5-2-噪声与噪声模型" class="headerlink" title="5.2 噪声与噪声模型"></a>5.2 噪声与噪声模型</h5><ul><li>数字图像中，<strong>噪声</strong>主要来源于图像的获取和/或传输过程。<ul><li>成像传感器的性能受各种因素的影响，如图像获取过程中环境条件和传感元件自身的重量。</li><li>图像在传输中被污染主要是由于传输信道的干扰。</li></ul></li><li><p>将噪声模型建模为：g(x, y) = f(x, y) + η(x, y)</p></li><li><p>其中 f(x, y)是原始图像像素，η(x, y)是噪声项，g(x, y)是得到的噪声像素。</p></li><li><p>图像噪声项η(x, y)有许多不同的模型： <strong>P201 噪声效果</strong></p><ul><li>高斯噪声：最常见的模型</li><li>瑞利噪声</li><li>爱尔兰(伽马)噪声</li><li>指数噪声</li><li>均匀噪声</li><li>脉冲(椒盐)噪音</li></ul><p><img src="/dip/zs.png" width="60%"></p></li></ul><h5 id="5-3-只存在噪声的复原-——-空间滤波"><a href="#5-3-只存在噪声的复原-——-空间滤波" class="headerlink" title="5.3 只存在噪声的复原 —— 空间滤波"></a>5.3 只存在噪声的复原 —— 空间滤波</h5><ul><li>在仅存在加性噪声的情况下，可以选择空间滤波方法。</li><li><p>均值滤波器：</p><ul><li><strong>算数均值</strong>滤波器：作为简单的平滑滤波器实现的，<strong>模糊图像</strong>以消除噪音。</li><li><strong>几何均值</strong>滤波器：实现与算术平均值类似的平滑，但这种处理丢失的图像细节更少。</li><li><strong>谐波均值</strong>滤波器：对于盐粒噪声效果较好，但不适用于胡椒噪声。善于处理像高斯噪声那样的其他噪声。</li><li><strong>逆谐波均值</strong>滤波器P204：Q为滤波器的阶数。这种滤波器适合减少或在实际中消除椒盐噪声的影响。当Q为正，消除胡椒噪声；Q为负，消除盐粒噪声；Q=0，为算数均值滤波器；Q=-1，为谐波均值滤波器。</li></ul></li><li><p>统计排序滤波器：</p><ul><li><strong>中值</strong>滤波器：引起的模糊更小。在存在椒盐噪声的情况下，中值滤波器尤其有效。</li><li><strong>最大值和最小值</strong>滤波器：最大值滤波器发现最亮点，有利于降低胡椒噪音(值低)；最小值滤波器发现最暗点，有利于降低胡椒噪音(值高)。</li><li><strong>中点</strong>滤波器：最大值和最小值中间的点。适用于处理随机分布的噪声，如高斯噪声或均匀噪声。</li><li><strong>修正的阿尔法均值</strong>滤波器P206：d=0，退化为算数均值滤波器；d=mn-1，退化为中值滤波器；d为其他值，在包括多种噪声的情况下很有用，如混合有高斯噪声和椒盐噪声的情况。</li></ul></li></ul><h5 id="自适应中值滤波器"><a href="#自适应中值滤波器" class="headerlink" title="自适应中值滤波器"></a>自适应中值滤波器</h5><ul><li><strong>自适应滤波器</strong>：到目前为止讨论的用于图像处理的滤波器，并未考虑图像中的一点对其他点的特征变化。<ul><li>自适应滤波器的行为根据滤波器区域内的图像的特性而改变。</li></ul></li><li><strong>自适应中值滤波器</strong><ul><li>可以处理具有更大概率的脉冲噪声，传统中值滤波器只要脉冲噪声的空间密度不大，性能就会很好。</li><li>平滑非脉冲噪声时会试图保留细节，这是传统中值滤波器做不到的。</li><li>在进行滤波处理时，会根据图像的特征而改变。</li></ul></li><li>考虑如下符号：自适应滤波器也工作在矩形窗口区域 S <sub>xy</sub>内。<ul><li>Z <sub>min</sub> = S <sub>xy</sub> 中的最小灰度值</li><li>Z <sub>max</sub> =  S <sub>xy</sub>中的最大灰度值</li><li>Z <sub>med</sub> =  S <sub>xy</sub>中灰度值的中值</li><li>Z <sub>xy</sub> = 坐标(x, y)处的灰度值</li><li>S <sub>max</sub> =   S <sub>xy</sub>允许的最大尺寸</li></ul></li><li>自适应中值滤波器算法以两个进程工作，分别表示为进场A和进程B</li><li>进程A：<ul><li>A <sub>1</sub> = Z <sub>med</sub> - Z <sub>min</sub> </li><li>A <sub>2</sub> = Z <sub>med</sub> - Z <sub>max</sub> </li><li>如果 A <sub>1</sub> &gt; 0 且 A <sub>2</sub> &lt; 0，则转到进程B</li><li>否则增大窗口尺寸</li><li>如果窗口尺寸≤ S <sub>max</sub>，则重复进程A</li><li>否则输出Z <sub>med</sub></li></ul></li><li><p>进程B </p><ul><li>B <sub>1</sub> = Z <sub>xy</sub> - Z <sub>min</sub> </li><li>B <sub>2</sub> = Z <sub>xy</sub> - Z <sub>max</sub> </li><li>如过 B <sub>1</sub> &gt; 0 且 B <sub>2</sub> &lt; 0  ，则输出Z <sub>xy</sub></li><li>否则输出Z <sub>med</sub> </li></ul></li><li><p>该算法的三个主要目的：</p><ol><li>去除椒盐噪声</li><li>平滑其他非脉冲噪声</li><li>减少诸如物体边界细化或粗化等失真</li></ol></li></ul><h5 id="5-4-用频率域滤波消除周期噪声"><a href="#5-4-用频率域滤波消除周期噪声" class="headerlink" title="5.4 用频率域滤波消除周期噪声"></a>5.4 用频率域滤波消除周期噪声</h5><ul><li><p><strong>周期噪声</strong>[空间相关噪声]：在图像获取期间由于电力或者机电干扰产生的。周期噪声可以通过频率域滤波中来显著地减少(傅里叶变换)。</p></li><li><p>带阻滤波器：从图像中去除周期性噪声涉及从该图像中去除特定范围的频率</p></li></ul><blockquote><p>图像恢复比增强更客观<br>空间域技术对于消除随机噪声特别有用<br>频域技术对于消除周期性噪声特别有用</p></blockquote><h3 id="6-形态学图像处理"><a href="#6-形态学图像处理" class="headerlink" title="6. 形态学图像处理"></a>6. 形态学图像处理</h3><ul><li>形态学图像处理描述了一系列处理图像中特征形状(或形态)的图像处理技术。</li><li>形态学，是图像处理中应用最为广泛的技术之一，主要用于从图像中提取对表达和描绘区域形状有意义的图像分量，<strong>使后续的识别工作</strong>能够抓住目标对象最为本质〈最具区分能力）的形状特征，如边界和连通区域等。同时像细化、像素化和修剪毛刺等技术也常应用于图像的预处理和后处理中，成为图像增强技术的有力补充。</li></ul><h5 id="6-1-基础知识"><a href="#6-1-基础知识" class="headerlink" title="6.1 基础知识"></a>6.1 基础知识</h5><ul><li><strong>结构元</strong>：设有两幅图像A，S。若A是被处理的对象， 而S是用来处理A的， 则称S为结构元。结构元通常都是一些比较小的图像， A与S的关系类似于滤波中图像和模板的关系。<ul><li>结构元可以是任何尺寸， 形状。</li><li>为简单起见，我们使用矩形构造结构元，其原点位于中间像素。</li></ul></li><li>适合：结构元的所有像素都覆盖图像中的像素。</li><li>击中：结构元的任意一个像素域与图像中的像素重叠。</li></ul><h5 id="6-2-基本形态学操作"><a href="#6-2-基本形态学操作" class="headerlink" title="6.2 基本形态学操作"></a>6.2 基本形态学操作</h5><ul><li><p>腐蚀</p><ul><li><p>结构元 s 对图像 f 的腐蚀定义为： f ㊀ s  。结构元的原点位于(x, y)，新的像素值由以下规则确定：</p><p><img src="/dip/er.png" width="25%"></p></li><li><p>缩小或者细化了二值图像中的物体。</p></li><li>可以分裂连接的物体</li></ul></li><li><p>膨胀</p><ul><li>结构元 s 对图像 f 的膨胀定义为： f ⊕ s  。结构元的原点位于(x, y)，新的像素值由以下规则确定：</li></ul><p><img src="/dip/di.png" width="25%"></p><ul><li>会增长或粗化二值图像中的物体</li><li>可以连接裂缝</li></ul></li></ul><h5 id="6-3-复合操作"><a href="#6-3-复合操作" class="headerlink" title="6.3 复合操作"></a>6.3 复合操作</h5><ul><li><p>开：先腐蚀后膨胀 f 〇 s =  (f ㊀ s)  ⊕ s</p><ul><li>平滑物体的轮廓</li><li>断开较窄的连接，消除较细的突出物</li></ul><p><img src="/dip/2.png" width="45%"></p></li><li><p>闭：先膨胀后腐蚀  f • s = ( f ⊕ s) ㊀ s</p><ul><li>使轮廓变得光滑</li><li>弥合较窄的间断和细长的沟壑</li><li>消除(填充)较小的孔洞，填补轮廓线中的断裂</li></ul><p><img src="/dip/1.png" width="45%"></p></li></ul><h5 id="6-4-形态学算法-P412"><a href="#6-4-形态学算法-P412" class="headerlink" title="6.4 形态学算法 P412"></a>6.4 形态学算法 P412</h5><ul><li><p>边界提取：提取对象的边界(或轮廓)非常有用。</p><ul><li>β(A) = A – (A㊀B)</li></ul><p><img src="/dip/b.png" width="25%"></p></li><li><p>孔洞填充</p><ul><li>X<sub>k</sub> =( X<sub>k-1</sub>⊕ B ) ∩A<sup>c</sup></li></ul><p><img src="/dip/fill.png" width="35%"></p></li><li><p>连通分量的提取</p></li><li><p>凸壳，细化，粗化，骨架，剪裁</p></li></ul><h3 id="7-图像分割"><a href="#7-图像分割" class="headerlink" title="7. 图像分割"></a>7. 图像分割</h3><ul><li>本章的多数分割算法均基于灰度值的两个基本性质之一：<ul><li>不连续性</li><li>相似性</li></ul></li></ul><h5 id="7-1-点、线和边缘检测"><a href="#7-1-点、线和边缘检测" class="headerlink" title="7.1 点、线和边缘检测"></a>7.1 点、线和边缘检测</h5><ul><li><p>点检测(孤立点)</p><p><img src="/dip/point.png" width="15%"></p></li><li><p>线检测</p><p><img src="/dip/line.png" width="55%"></p></li><li><p>边缘检测</p><ul><li>通常，在边缘检测中出现问题，因为存在<strong>太多细节</strong>，这种精致的细节在边缘检测中通常是不符合需要的。克服这个问题的一种方法是在边缘检测之前进行<strong>平滑处理</strong>。</li></ul><p><img src="/dip/edge.png" width="60%"></p><ul><li>拉普拉斯边缘检测：拉普拉斯算子通常不会单独使用，因为它对噪声过于敏感。通常用于边缘检测的拉普拉斯算子与平滑高斯滤波器相结合</li><li>拉普拉斯高斯滤波器：使用高斯去除噪声，使用拉普拉斯算子进行边缘检测。</li></ul></li></ul><h5 id="7-2-阈值"><a href="#7-2-阈值" class="headerlink" title="7.2 阈值"></a>7.2 阈值</h5><ul><li><p>基本的全局阈值处理 P478</p><ul><li>基于图像的直方图。</li><li>当物体和背景的灰度分布十分明显，可以用适用于整个图像的单个阈值。</li><li>在大多数应用中，通常图像之间有较大变化，即使使用全局阈值，对每一幅图像有能力自动估计阈值的算法是必要的。</li></ul><p><img src="/dip/fuc.png" width="80%"></p></li><li><p>用Otsu方法的最佳全局阈值处理</p><ul><li>假定图像包含两类像素（前景像素和背景像素），直方图为双峰直方图，然后计算使得两类像素能分开的最佳阈值（类内方差），或<strong>等价的间类间方差最大</strong>。</li><li>按图像的灰度特性,将图像分成背景和目标两部分，或者说，是寻找一个阈值为K，将图像的颜色分为1,2…..K和K+1…..256两部分。</li><li>自适应的。</li></ul></li></ul><h3 id="8-表示-amp-描述"><a href="#8-表示-amp-描述" class="headerlink" title="8. 表示&amp; 描述"></a>8. 表示&amp; 描述</h3><ul><li><p>边界可用特征对其进行描述：</p><ul><li>长度</li><li>连接端点的直线的方向</li><li>边界上凹陷的数量</li></ul></li><li><p>形状特征 - 外部表示</p></li><li>内部属性，如颜色，纹理 - 内部表示</li></ul><h5 id="8-1-表示"><a href="#8-1-表示" class="headerlink" title="8.1 表示"></a>8.1 表示</h5><ul><li>分割技术会获得原始数据，其形式是沿着边界或包含在区域中的像素。标准做法是使用某种方案将分割后的数据精简为便于描绘子计算的表示，以减小数据的大小。</li></ul><h5 id="1-链码"><a href="#1-链码" class="headerlink" title="1. 链码"></a>1. 链码</h5><ul><li><p>链码被用来以顺次连接的具有指定长度和方向的直线段来表示边界。</p></li><li><p>这种表示基于4连接或者8连接。</p></li><li><p>原链码：沿着顺时针方向追踪一个边界，并对连接酶对像素的线段赋予一个方向的方法产生。</p><ul><li>得到的链码往往太长</li><li>噪声或不完美分割沿边界引起的任何较小干扰都会导致编码的变化</li><li><strong>解决方案</strong>：选取一个较大的网格间距来对边界重取样，编码表示的京都取决于取样网格的间距。</li></ul></li><li><p>归一化链码：原链码具有平移不变性（平移时不改变指向符），但当改变起点S时，会得到不同的链码表示，即不具备唯一性。为此可引入归一化链码，其方法是：</p><ul><li>对于闭合边界，任选一起点S得到原链码，将链码看作由各方向数构成的n位自然数，将该码按一个方向循环，使其构成的n位自然数最小，此时就形成起点唯一的链码，称为归一化链码，也称为规格化链码。</li><li>使用链码的一次差分而非链码本身，来对旋转进行归一化。这个差分时通过计算链码分隔两个相邻像素的方向变化的数得到的。</li></ul><p><img src="/dip/lm.png" width="100%"></p></li></ul><h5 id="2-多边形近似"><a href="#2-多边形近似" class="headerlink" title="2. 多边形近似"></a>2. 多边形近似</h5><ul><li><p>使用最小周长多边形的多边形近似</p><ul><li>将目标边界勘城市一个橡皮筋，将组成边界的像素序列内外边各堪称一堵墙，边界处于内外墙之间，如果将向脾经收缩，则可得到目标的最小周长多边形。</li></ul></li><li><p>聚合技术：</p><ul><li>沿一条边界来聚合一些点，直到拟合这些聚合点的直线的最小均方差超过某个预设的阈值。当这种条件出现时，存储该直线的参数，将误差设为0，并且重复该过程，沿边界聚合新的点，直到误差再次超过预设的阈值。过程结束后，相邻线段的交点就构成多边形的顶点。</li><li>难点：得到的近似顶点不总是对应于原始边界的形变。</li></ul><p><img src="/dip/聚合.png" width="30%"></p></li><li><p>分裂技术</p><ul><li>将线段不断地细分为两部分，直到满足规定的准则。</li></ul><p><img src="/dip/分裂.png" width="30%"></p></li></ul><h5 id="3-标记图"><a href="#3-标记图" class="headerlink" title="3. 标记图"></a>3. 标记图</h5><ul><li><p>将边界表示简化为描述起来可能比原始二维边界更简单的一维函数。</p><ul><li>距离为角度的函数</li></ul><p><img src="/dip/标记.png" width="50%"></p></li></ul><h5 id="4-骨架"><a href="#4-骨架" class="headerlink" title="4. 骨架"></a>4. 骨架</h5><p><img src="/dip/骨架.png" width="50%"></p><ul><li><p>迭代删除一个区域边界点的细化算法：</p><ul><li>不能删除端点</li><li>不能破坏连续性</li><li>不能导致区域的过度腐蚀</li></ul></li><li><p>细化算法步骤 P526-527 (稍微偷了个懒，然后它就考到了？？？ )</p></li></ul><h5 id="8-2-描述"><a href="#8-2-描述" class="headerlink" title="8.2 描述"></a>8.2 描述</h5>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS Code调教笔记 on Mac OS</title>
      <link href="/vscode-macos/"/>
      <url>/vscode-macos/</url>
      
        <content type="html"><![CDATA[<h2 id="Python-OpenCV"><a href="#Python-OpenCV" class="headerlink" title="Python-OpenCV"></a>Python-OpenCV</h2><ol><li><p>在终端使用homebrew 安装 <code>python3</code> 和<code>opencv3</code>。</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">➜  ~ brew install python3</span><br><span class="line">➜  ~ pip3 install opencv-python</span><br></pre></td></tr></table></figure><a id="more"></a></li><li><p>查看python和opencv的版本。(由于OS X系统自带python2，所以后面会出问题)        </p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">➜  ~ python3 --version</span><br><span class="line">Python 3.6.5</span><br><span class="line">➜  ~ python3</span><br><span class="line">Python 3.6.5 (default, Jun 17 2018, 12:15:43) </span><br><span class="line">[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)] on darwin</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> or <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; import cv2</span><br><span class="line">&gt;&gt;&gt; cv2.__version__</span><br><span class="line"><span class="string">'3.4.4'</span></span><br></pre></td></tr></table></figure></li><li><p>在VS Code的扩展中安装<code>Python</code>和<code>Code Runner</code>。<code>Code Runner</code>是一个方便编译运行的一个插件。</p></li><li><p>使用<code>Code Runner</code>右键RunCode，发现输出存在问题。原因是<code>Code Runner</code>不是使用的python3，而是使用 系统自带的python2。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Running] python -u &quot;/Users/yi/Documents/Python-opencv/blur.py&quot;</span><br></pre></td></tr></table></figure><p>解决方法：VS Code  ➜ 首选项 ➜ 设置 ➜ 用户区 / 工作区(按照自己的情况选择) ➜ 扩展 ➜ Run Code configuration  ➜ 找到Executor Map ➜ 在settings.json中编辑。详见<a href="https://github.com/formulahendry/vscode-code-runner#configuration" target="_blank" rel="noopener">Code Runner的说明文档关于configuration描述</a></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"code-runner.executorMap": &#123;</span><br><span class="line">    "python": "/usr/local/bin/python3"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之后运行得到：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">[Running] /usr/<span class="built_in">local</span>/bin/python3 <span class="string">"/Users/yi/Documents/Python-opencv/blur.py"</span></span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>在.py文件中使用cv2的函数：imread, imshow等，会报错。这是由于VS Code中python的语法检查工具pylint无法识别cv2的函数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Module &apos;cv2&apos; has no &apos;imread&apos; member pylint(no-member)</span><br><span class="line">Module &apos;cv2&apos; has no &apos;imshow&apos; member pylint(no-member)</span><br></pre></td></tr></table></figure><p>解决方法：VS Code  ➜ 首选项 ➜ 设置 ➜ 用户区 / 工作区(按照自己的情况选择) ➜ 扩展 ➜ Python  ➜ Python › Linting: Pylint Args ➜ 在settings.json中加入：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"python.linting.pylintArgs": ["--generate-members"]</span><br></pre></td></tr></table></figure></li></ol><h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><ol><li><p>OS X已经安装XCode</p></li><li><p>在VS Code的扩展中安装<code>C/C++</code>和<code>C/C++ Clang Command Adapter</code>。</p></li><li><p>按F5进行调试，需要选择gcc/clang++/…，我使用的是clang++。如果调试没用问题，会在终端显示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">终端将被任务重用，按任意键关闭。</span><br></pre></td></tr></table></figure></li><li><p>使用<code>Code Runner</code>在输出窗口中可以输出C/C++的结果，但是无法进行输入。所以需要进行设置修改：VS Code  ➜ 首选项 ➜ 设置 ➜ 用户区 / 工作区(按照自己的情况选择) ➜ 扩展 ➜ Run Code configuration  ➜  找到Run In Terminal 并勾选。</p></li><li><p>再使用<code>Code Runner</code>会在终端运行，可以进行输入。</p></li><li><p>遇到的问题：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">找不到任务“clang++ build active file”</span><br><span class="line">preLaunchTask“clang++ build active file”已终止，退出代码为 1。</span><br><span class="line">运行 preLaunchTask“clang++ build active file”后存在错误。</span><br></pre></td></tr></table></figure><p>最开始以为是没有配置好环境，查了半天，后来发现是程序写的有问题，没有编译通过，只不过以前用vs没见过这种方式的错误提示。<br>程序写的没问题的话，再次调试就会显示：终端将被任务重用，按任意键关闭。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mac OS X </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试笔记</title>
      <link href="/sftest/"/>
      <url>/sftest/</url>
      
        <content type="html"><![CDATA[<h3 id="1-软件测试概述"><a href="#1-软件测试概述" class="headerlink" title="1 软件测试概述"></a>1 软件测试概述</h3><h4 id="故障、错误-amp-失败"><a href="#故障、错误-amp-失败" class="headerlink" title="故障、错误&amp;失败"></a>故障、错误&amp;失败</h4><ul><li>软件故障(fault)：软件中的一个静态的缺陷。</li><li>软件错误(error)：软件运行中一个不正确的内部状态，这是某个故障的表现。</li><li><p>软件失败(failure)：一个与软件需求或者是预期行为描述不相符的、外在的行为。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CSta</span> <span class="params">(<span class="keyword">int</span> [ ] numbers)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> length = numbers.length; <span class="comment">//(PIE Model - 3: int length = numbers.length-1; )</span></span><br><span class="line">   <span class="keyword">double</span> mean, sum; </span><br><span class="line">   sum = <span class="number">0.0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++)**<span class="comment">//i=0** </span></span><br><span class="line">   &#123;</span><br><span class="line">         sum += numbers [ i ]; </span><br><span class="line">   &#125;</span><br><span class="line">   mean = sum / (<span class="keyword">double</span>) length; </span><br><span class="line">   System.out.println (<span class="string">"mean: "</span> + mean); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>软件错误：Input: [3,4,5]  sum=4+5  ( × )</p></li><li>软件失败：Input: [3,4,5]  sum=4+5 mean=3  ( × )</li></ul><h4 id="PIE模型"><a href="#PIE模型" class="headerlink" title="PIE模型"></a>PIE模型</h4><ul><li>Execution/Reachability 执行/可达性：执行必须通过错误的代码。</li><li>Infection 感染：在执行错误代码的时候必须触发出一个错误的中间状态。</li><li>Propagation 传播：错误的中间状态必须传播到最后输出，使得观测到输出结果与预期结果不一致，即失效。</li></ul><blockquote><ol><li>测试可能无法执行故障的位置。</li><li>一个测试执行到包含错误的代码，不一定会产生错误的中间状态。Test Input: [0,4,5] sum=4+5  mean=3</li><li>产生了错误的中间状态，不一定会失效(failure)。Test Input: [3,5,4] sum=3+5 mean=8/2=4</li></ol></blockquote><p>Q: 是否存在一个fault，任何测试都不会将其测试出来？这样还能称之为fault吗？</p><p>A: 存在这样的fault。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>测试用例(test case)：所有测试用例的基类，它是软件测试中最基本的组成单元。<ul><li>测试输入：测试数据</li><li>测试预期输出(test oracle)：软件中给定输入的预期输出</li><li>其他：环境</li></ul></li><li>测试预言(test oracle)：软件中给定输入的预期输出，测试用例的一部分。自动测试中最难的问题：测试预言的生成。</li><li>测试夹具(test fixture)：一个固定/已知的环境状态以确保测试可重复并且按照预期方式运行</li><li>测试套件(test suite)：一组测试用例。通常这些测试用例具有相似的先决条件和配置，可以按顺序一起运行。用于不同目的的不同测试套件。</li><li>测试脚本(test script)：自动运行一系列测试用例或测试套件的脚本。</li><li>测试驱动程序(test driver)：可以加载测试用例集或测试套件的软件框架，还可以处理预期输出和实际输出之间的配置和比较。</li><li>测试充分性(test adequacy)：用以判断一个软件的一组测试数据的充分性的规则。eg. 语句/分支覆盖率</li><li>Testing vs. Debugging<ul><li>Testing 是通过执行测试和观察失败来发现一个bug。</li><li>Debugging是通过定位、理解和纠正故障( fault)来修复bug。</li></ul></li><li><strong>Verification vs. Validation</strong><ul><li>Verification：确保产品，服务或系统满足客户和其他确定的利益相关者的<strong>需求</strong>。 </li><li>Validation：评估产品，服务或系统是否符合法规、要求、规范或强制条件。 它通常是一个内部过程。</li></ul></li><li><strong>Static Testing vs. Dynamic Testing</strong><ul><li>静态测试：不运行被测程序本身。</li><li>动态测试：运行被测程序。</li></ul></li><li><strong>Black-box Testing vs. White-box Testing</strong><ul><li>黑盒测试：没有源代码。</li><li>白盒测试：有源代码。</li></ul></li><li>V模型：<br><img src="/sftest/vmodel.png" width="50%"></li></ul><h3 id="C2-单元测试"><a href="#C2-单元测试" class="headerlink" title="C2 单元测试"></a>C2 单元测试</h3><ul><li>单元测试：每个模块的测试。</li><li>集成测试：测试模块之间的交互。</li><li>系统测试：开发人员对整个系统进行测试。</li><li>验收测试：根据需求和用户需要来评估软件。没有正式测试用例的客户根据用户要求验证系统。</li></ul><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul><li>测试软件的基本模块：功能，类，组件</li><li>揭示典型问题<ul><li>本地数据结构</li><li>算法</li><li>边界条件</li><li>错误处理</li></ul></li><li>为什么单元测试？<ul><li>分而治之的方法：将系统拆分为单位，单独调试单元。</li><li>缩小可能存在错误的地方，不想追逐其他单元的错误。</li></ul></li><li>如何单元测试？<ul><li>分层构建系统：从不依赖于其他的类开始，继续测试已经测试的类</li><li>好处：避免编写模拟类。当测试一个模块时，它所依赖的模块是可靠的。</li></ul></li><li>单元测试框架<ul><li>xUnit</li><li>JUnit</li></ul></li></ul><h3 id="C3-白盒测试"><a href="#C3-白盒测试" class="headerlink" title="C3 白盒测试"></a>C3 白盒测试</h3><h4 id="1-测试中的图"><a href="#1-测试中的图" class="headerlink" title="1. 测试中的图"></a>1. 测试中的图</h4><ul><li><strong>图G</strong>定义如下：G =（V，E）<ul><li>V：有限的非空顶点集V = {v<sub>1</sub>，v<sub>2</sub>，v<sub>3</sub>，v<sub>4</sub>}</li><li>E：一组边（顶点对）E = {（v<sub>1</sub>，v<sub>2</sub>），（v<sub>1</sub>，v<sub>3</sub>），（v<sub>2</sub>，v<sub>4</sub>），（v<sub>3</sub>，v<sub>4</sub>）}</li><li>V<sub>0</sub>：一组初始节点，V<sub>0</sub> = {v<sub>1</sub>}</li><li>V<sub>f</sub>：一组最终节点，Vf = {v4}</li><li>V<sub>0</sub>和V<sub>f</sub>是V的子集</li><li>图中允许存在多个初始节点，至少要有一个终止节点(或者多个)。</li></ul></li><li>Q：一个顶点是一个图吗？(Yes) E可以是一个无限的集合吗？(No)</li><li><p><strong>路径(Path)</strong>：一个节点序列[v<sub>1</sub>，v<sub>2</sub>，… ，v<sub>n</sub>]</p><ul><li>每对邻近节点(v<sub>i</sub>, v<sub>i+1</sub>)都是一条边(属于边集合E)</li><li>路径的长度：边的数量</li><li>长度为0的路径：单个节点的路径。</li><li>子路径：路径p的子路径是p的一个子序列(也可能是p自己)</li></ul></li><li><p><strong>测试路径</strong>：从初始节点(V<sub>0</sub>中某个节点)开始到最终节点(V<sub>f</sub>中某个节点)结束的路径。</p><ul><li>每个测试用例都只游历图G中的一条测试路径。</li><li>一条测试路径可以对应多个测试用例。(多对一)</li><li>一些测试路径不会被任何测试用例执行。(不可达：图G中的节点从V<sub>0</sub>中任何节点开始都无法在语法上到达，也无法满足覆盖准则)</li></ul></li><li><p><strong>测试和测试路径</strong></p><ul><li><strong>path( t )</strong>：测试 t 执行的测试路径</li><li><strong>path( T )</strong>：由一组测试执行的<strong>测试路径集 T</strong> </li></ul></li></ul><h4 id="2-图覆盖准则"><a href="#2-图覆盖准则" class="headerlink" title="2. 图覆盖准则"></a>2. 图覆盖准则</h4><ul><li><p>可达：从一个初始节点开始所有节点和边都语法可达的图。</p><ul><li>v<sub>1</sub>可达v<sub>2</sub>：存在一条路径开始于v<sub>1</sub>，终止于v<sub>2</sub>。</li><li><p>v<sub>1</sub>可达图G’：存在一条路径开始于v<sub>1</sub>，终止于图G中的某个节点。</p></li><li><p><strong>语法可达</strong>：图G中语法上存在一条路径。</p></li><li><strong>语义可达</strong>：存在测试用例执行该路径。</li></ul></li><li><p><strong>覆盖</strong>：</p><ul><li>测试路径p<strong>覆盖节点</strong>v：v在p中</li><li>测试路径p<strong>覆盖边</strong>e：e在p中</li><li>测试路径p<strong>覆盖子路径</strong>p’：p’在p中</li></ul></li><li><p><strong>图覆盖</strong></p><ul><li>结构图覆盖</li><li>数据流覆盖</li></ul></li><li><p>测试需求集<strong>( TR )</strong>：描述测试路径的属性</p></li><li><p>图覆盖：给定一个<strong>图覆盖准则C</strong>所包含的<strong>测试需求集TR</strong>，当且仅当对于TR中的<strong>每个测试需求tr</strong>，<strong>测试路径集path( T )</strong>中都至少存在一个测试路径p满足tr的时候，测试用例集T满足图G的覆盖准则C。</p></li></ul><h4 id="3-结构化的覆盖准则"><a href="#3-结构化的覆盖准则" class="headerlink" title="3. 结构化的覆盖准则"></a>3. 结构化的覆盖准则</h4><ul><li><p><strong>节点覆盖(VC)</strong></p><ul><li>当且仅当对于 V 中每个语法可达的节点 v，测试用例集T满足path( T )存在路径p使得p覆盖v。即测试用例集T在图G上满足节点覆盖。</li><li>TR包含G中的每个可达的节点。</li></ul></li><li><p><strong>边覆盖(EC)</strong></p></li><li><p>当且仅当对于 E 中的每个语法可达边e，测试用例集T满足path( T )中存在路径p使得p覆盖e。即测试用例集T在图G上满足边覆盖。</p></li><li><p>TR包含G中的每个可达的边。<br><img src="/sftest/vcec.png" width="60%"></p></li><li><p><strong>对边覆盖(EPC)</strong>：TR包含G中每个可达的长度小于等于2的路径。</p></li><li><strong>全路径覆盖(CPC)</strong>：TR中包含G中所有的路径。</li><li><p><strong>n-Path Coverage(nPC)</strong>：TR包含每个可达长度小于等于n的路径。</p></li><li><p><strong>包含(Subsume)关系</strong>：</p><ul><li><p>C1包含C2，表示为C1 ≧  C2</p></li><li><p>对任意测试用例集T，假如T满足C1，则T一定满足C2。</p></li><li>C1≧ C2 does not imply that <em>T1</em> satisfying C1 can detect any fault detected by T2 which satisfies C2.</li><li>C1≧ C2不意味着满足C1的T1可以检测到满足C2的T2检测到的故障。<br><img src="/sftest/sce.png" width="80%"></li></ul></li></ul><h4 id="4-控制流图-CFG-及其覆盖"><a href="#4-控制流图-CFG-及其覆盖" class="headerlink" title="4. 控制流图(CFG)及其覆盖"></a>4. 控制流图(CFG)及其覆盖</h4><ul><li><p>控制流图(CFG)</p><ul><li>使用图表符号表示<strong>在执行期间可能遍历程序的所有路径</strong>的表示。</li><li>边与每条可能的分支对应，节点与一系列的语句对应。</li></ul></li><li><p>基本块</p><ul><li>一段最长的可以被同时执行的程序语句序列。如果这个基本块中的一条语句被执行，那么这个块中所有语句都要被执行。</li><li>一个基本块只有一个起始点和一个终点。<br><img src="/sftest/if.png" width="40%"><img src="/sftest/ifreturn.png" width="36%"><img src="/sftest/while.png" width="40%"><img src="/sftest/do.png" width="36%"><img src="/sftest/for.png" width="45%"><img src="/sftest/switch.png" width="45%"><img src="/sftest/bc.png" width="45%"><img src="/sftest/cfg.png" width="80%"></li></ul></li><li><p>语句覆盖率：SCov = 4 / 5 = 80%</p></li><li>分支覆盖率：BCov = 2 / 4 = 50%</li><li>路径覆盖率：PCov = 1 / 4 = 25%</li></ul><p><img src="/sftest/scov.png" width="21%"><img src="/sftest/bcov.png" width="22%"><img src="/sftest/pcov.png" width="49%"></p><ul><li>如果测试套件达到100%分支覆盖率，则一定达到100%语句覆盖率。</li><li><p>如果测试套件达到100%路径覆盖率，则一定达到100%分支覆盖率。反之未必。</p></li><li><p>路径覆盖 -&gt; 分支覆盖 -&gt; 语句覆盖  (路径覆盖严格包含分支覆盖，分支覆盖严格包含语句覆盖) </p><ul><li>路径覆盖：被测试程序中的每一个语句至少被执行一次。<strong>实际运用中语句覆盖很难发现代码中的问题。</strong></li><li>分支覆盖：被测试程序中的每一个分支都至少执行一次。</li><li>语句覆盖：覆盖程序中所有可能的执行路径。</li></ul></li><li><p>基于CFG的覆盖</p><ul><li><p><strong>有效性：</strong>大约65％的错误可以在单元测试中捕获，单元测试由控制流测试方法主导，语句和分支测试在控制流测试中占主导地位。</p></li><li><p><strong>局限性：</strong>某些方面的100％覆盖率不能保证软件没有错误。</p></li><li><p>Test: assertEquals(1, sum(1,0))</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; </span><br><span class="line"><span class="keyword">return</span> x-y; <span class="comment">//should be x+y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="5-主路径覆盖-Prime-Path-Coverage-PPC"><a href="#5-主路径覆盖-Prime-Path-Coverage-PPC" class="headerlink" title="5. 主路径覆盖(Prime Path Coverage, PPC)"></a>5. 主路径覆盖(Prime Path Coverage, PPC)</h4><ul><li>简单路径<ul><li>从n<sub>i</sub>到n<sub>j</sub>的路径，当且仅当在这条路径中没有任何节点出现超过一次(除了初始节点和终止节点相同的情况)</li><li>简单路径可以是一个自环，但它没有内在的循环。<br><img src="/sftest/简单路径.png" width="55%"><img src="/sftest/主路径.png" width="40%"></li></ul></li><li>主路径：<ul><li>一条简单路径，且它不是任何其他简单路径的子路径。</li><li>最大长度的简单路径。</li></ul></li><li>往返路径：长度非0且初始节点和终止节点相同的主路径。</li><li><strong>主路径覆盖(PPC)</strong><ul><li>TR包含G中每条主路径。</li></ul></li><li><strong>简单往返路径(SRTC)</strong><ul><li>对于G中所有可达的，且可以作为往返路径起点和终点的节点，TR包含至少一条往返路径。</li></ul></li><li><p><strong>完全往返路径(CRTC)</strong></p><ul><li>对于G中所有可达的节点，TR包含所有的往返路径。<br><img src="/sftest/PPC.png" width="54%"></li></ul></li><li><p>主路径覆盖练习：<br><img src="/sftest/主路径覆盖.png" width="54%"></p></li></ul><h4 id="6-基本路径覆盖"><a href="#6-基本路径覆盖" class="headerlink" title="6. 基本路径覆盖"></a>6. 基本路径覆盖</h4><ul><li>独立路径：一条独立路径是指和其他的独立路径相比，至少引入一个新处理语句或一个新判断的程序通路。</li><li><strong>圈复杂度(Cyclomatic Complexity, CC)</strong>：<ul><li>一种为程序逻辑复杂性提供定量测度的软件度量，将该度量用于计算程序的基本的独立路径数目，为确保所有语句至少执行一次的测试数量的上界。</li><li>独立路径必须包含一条在定义之前不曾用到的边。</li><li>计算方法：<strong>CC =  E - V + 2  =  P + 1</strong>，E是边数量，V是节点的数量；P是<strong>判定结点</strong>的数量。</li></ul></li><li><strong>基本路径测试步骤</strong>：<ul><li>生成控制流图</li><li>计算圈复杂度</li><li>选择一组基本路径</li><li>生成基本路径的测试用例</li></ul></li><li>全路径测试 ≥ 基本路径测试 ≥ 分支测试</li></ul><h4 id="7-数据流覆盖"><a href="#7-数据流覆盖" class="headerlink" title="7. 数据流覆盖"></a>7. 数据流覆盖</h4><ul><li><strong>定义(def)</strong>：当一个变量的值被存储于内存时变量所处的位置。(写)</li><li><strong>使用(use)</strong>：当获取一个变量的值时变量所处的位置。(读)</li><li><p>数据流测试准则依据：数据值由定义转向使用。这种转移成为<strong>定义使用对/定义-使用/定义使用关联</strong>。<br><img src="/sftest/defuse.png" width="54%"></p></li><li><p><strong>定义使用对(DU Pair)</strong>：(l <sub>i</sub>,  l<sub>j</sub>) ，变量v在l <sub>i</sub>处定义，并在l <sub>j</sub>处使用。</p></li><li><strong>def(n) def(e)  / use(n) use(e)</strong><ul><li>由<strong>节点n</strong>或边e<strong>定义</strong>的变量集</li><li>由<strong>节点n</strong>或边e<strong>使用</strong>的变量集</li></ul></li><li><strong>无重复定义(Def-clear)</strong><ul><li>存在一条由l <sub>i</sub>到l <sub>j</sub>的路径，对于这条路径上的每个节点n<sub>k</sub>和每条边e<sub>k</sub>，k≠i 且 k≠j，变量v不属于def(n<sub>k</sub>)和def(e<sub>k</sub>)，那么这条路径对于变量v是无重复定义的。</li><li>如果变量v存在一条由l <sub>i</sub>到l <sub>j</sub>的无重复定义的路径，我们说处于l<sub>i</sub>的定义到达处于l<sub>j</sub>的使用。</li></ul></li><li><strong>定义使用路径(du-path)</strong><ul><li>定义使用路径是一条简单路径，并且对于变量v这是一条由节点n<sub>i</sub>到另一个节点n<sub>j</sub>的无重复定义路径，v在n<sub>i</sub>中存在于def(n<sub>i</sub>)而在n<sub>j</sub>中存在于use(n<sub>j</sub>)</li><li><em>du</em> (<em>n<sub>i</sub></em>, <em>n<sub>j</sub></em>, <em>v</em>)：变量v的定义使用路径集合，起始于n<sub>i</sub>，终止于n<sub>j</sub>。</li><li><em>du</em> (<em>n<sub>i</sub></em>, <em>v</em>)：对于变量v，定义路径集合是起始于n<sub>i</sub>的定义使用路径的集合。</li></ul></li><li><p><strong>全定义覆盖(ADC)</strong></p><ul><li>对于每个<strong>定义路径</strong>集合<em>S</em> = <em>du</em> (<em>n<sub>i</sub></em>, <em>v</em>)，TR包含S中至少一条路径d。</li></ul></li><li><p><strong>全使用覆盖(AUC)</strong></p><ul><li>对于每个<strong>定义对</strong>集合<em>S</em> = <em>du</em> (<em>n<sub>i</sub></em>, <em>n<sub>j</sub></em>, <em>v</em>)，TR包含S中至少一条路径d。</li></ul></li><li><p><strong>全定义使用路径覆盖(ADUPC)</strong></p><ul><li>对于每个<strong>定义对</strong>集合<em>S</em> = <em>du</em> (<em>n<sub>i</sub></em>, <em>n<sub>j</sub></em>, <em>v</em>)，TR包含S中每一条路径d。<br><img src="/sftest/dutest.png" width="54%"></li></ul></li><li><p>图覆盖准则之间的包含关系<br><img src="/sftest/包含关系.png" width="34%"></p></li></ul><h4 id="8-事件流覆盖"><a href="#8-事件流覆盖" class="headerlink" title="8. 事件流覆盖"></a>8. 事件流覆盖</h4><ul><li><strong>事件流图(EFG)</strong>是一个三元组M = &lt;V, I, E&gt;：<ul><li>V是一组表示对象所有事件的顶点。</li><li>I ⊆ V是一组初始顶点。</li><li>E ⊆ V × V是顶点之间的一组边，当v<sub>j</sub>可以在v<sub>i</sub>之后立即执行，(v<sub>i</sub>, v<sub>j</sub>) ∈ E。</li></ul></li></ul><p><img src="/sftest/event1.png" width="40%"><img src="/sftest/event2.png" width="40%"></p><p>#####9. 变异测试</p><ul><li>变异测试<ul><li>将错误插入程序以测试测试用例是否接收它们的方法。</li><li>是一种对测试集的充分性进行评估的技术。</li></ul></li><li>操作数变异操作符：将单个操作数替换为另一个操作数或常量。</li><li>表达变异操作符：更换一个操作符或者插入一个新的操作符。</li><li><strong>等价变异体</strong><ul><li>存在没有被杀死的变异体，被称为等价变异体</li><li>虽然变异体语法不同，但通过测试难以发现，需要手动检查。</li></ul></li><li><strong><em>Mutation Score = 100 \</em> K / (T - E)*</strong><ul><li>K：被杀死的变异体数</li><li>T：变异体总数</li><li>E：等价的变异体数</li></ul></li><li><p>主管程序员假设</p><ul><li>被测模块由合格的程序员或设计师编写。 因此，如果模块不正确，则它与正确的模块不同，最多只有几个小故障。</li></ul></li><li><p>耦合效应</p><ul><li>由于仅通过简单故障将所有模块与正确模块区分开来的测试套件非常敏感，它还可以隐式区分更复杂的故障。</li></ul></li></ul><p>#####10. 逻辑覆盖</p><ul><li><strong>语句覆盖(SC)</strong></li><li><strong>判定覆盖(DC)</strong><ul><li>判定的true和false至少各执行一次。</li><li>((x&gt;5) &amp;&amp; (y&gt;0)): <em>true</em> and <em>false</em></li></ul></li><li><strong>条件覆盖(CC)</strong><ul><li>每个条件的true和false至少各被执行一次。</li><li>(x&gt;5) 􏰄 <em>true</em> and <em>false</em></li><li>(y&gt;0) 􏰄<em>true</em> and <em>false</em></li></ul></li><li><strong>条件判定覆盖(C/DC)</strong><ul><li>同时满足DC和CC.</li><li>使得判定中的每个条件取到各种可能的值，并使每个判定取到各种可能的结果。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;(6, 1), (1,1)&#125;--DC</span></span><br><span class="line"><span class="comment">// &#123;(6, 0), (0,1)&#125;--CC </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> z = y;</span><br><span class="line"><span class="keyword">if</span> ((x&gt;<span class="number">5</span>) &amp;&amp; (y&gt;<span class="number">0</span>)) &#123;</span><br><span class="line">z = x; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> x*z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SC&amp;DC&amp;CC的包含关系<ul><li>DC ≥ SC</li><li>CC not ≥ SC</li><li>DC not ≥ CC􏰂 CC not ≥ DC</li><li>C/DC ≥ CC </li><li>C/DC ≥ DC</li></ul></li><li><p>MC/DC ≥ C/DC</p></li><li><p><strong>多条件覆盖(MCC)</strong></p><ul><li>使得每个判定中条件的各种可能组合都至少出现一次。<br><img src="/sftest/MCC.png" width="30%"></li></ul></li><li><p><strong>修正条件判定覆盖(MCDC)</strong></p><ul><li>每个条件都要独立影响判定结果(true和false各一次)<br><img src="/sftest/MCDC.png" width="30%"></li></ul></li><li><p>计数</p><ul><li>DC——2</li><li>CC——2*n</li><li>MC/DC——2*n+1</li><li>MCC——2<sup>n</sup></li></ul></li></ul><h3 id="C4-自动化软件测试"><a href="#C4-自动化软件测试" class="headerlink" title="C4 自动化软件测试"></a>C4 自动化软件测试</h3><ul><li>自动化测试<strong>生成</strong><ul><li>测试用例生成</li><li>测试数据生成</li></ul></li><li>自动化测试<strong>执行</strong></li><li>自动化测试<strong>选择</strong><ul><li>针对修改部分的测试</li><li>针对测试需求的用例集约简</li><li>针对测试需求的用例排序</li></ul></li><li>自动化测试修复<ul><li>测试用例修复</li><li>测试用例演化</li></ul></li><li>自动化测试<strong>扩增</strong></li></ul><h3 id="C5-黑盒测试"><a href="#C5-黑盒测试" class="headerlink" title="C5 黑盒测试"></a>C5 黑盒测试</h3><h4 id="5-1-随机测试"><a href="#5-1-随机测试" class="headerlink" title="5.1 随机测试"></a>5.1 随机测试</h4><ul><li>随机测试<ul><li>测试用例完全随机生成</li><li>必须知道输入域</li><li>在输入域中选择随机点</li><li>自动化</li></ul></li><li>ART算法</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* T = &#123;&#125;  是以前执行的一组测试用例*/</span></span><br><span class="line">随机生成输入t </span><br><span class="line">用t作为测试用例测试程序          </span><br><span class="line">将t添加到T     </span><br><span class="line"><span class="keyword">while</span>（未达到停止条件）           </span><br><span class="line">   随机生成下一个k候选c1，c2，…，ck    </span><br><span class="line">   <span class="keyword">for</span> 每个候选Ci </span><br><span class="line">      计算与T的最小距离di  </span><br><span class="line">   end <span class="keyword">for</span></span><br><span class="line">  选择一个具有最小距离的候选t</span><br><span class="line">  将t添加到T           </span><br><span class="line">  用T作为测试用例测试程序    </span><br><span class="line">end <span class="keyword">while</span></span><br></pre></td></tr></table></figure><h4 id="5-2-等价划分"><a href="#5-2-等价划分" class="headerlink" title="5.2 等价划分"></a>5.2 等价划分</h4><ul><li>等价划分<ul><li>可以同等地应用于多个级别的测试(• 单元  • 整合  • 系统)</li><li>相对容易应用，无需自动化</li><li>易于调整程序以获得更多或更少的测试</li></ul></li><li>输入域<ul><li>程序的输入域包含该程序的所有可能输入</li><li>对于即使是小型程序，输入域也是如此之大，以至于它可能是无限的</li><li>测试一般是从输入域中选择有限的值集</li><li>输入参数定义输入域的范围</li><li>每个输入参数的域被划分为区域</li><li>从每个区域至少选择一个值</li></ul></li><li><p>分区域</p><ul><li>域D</li><li>D的分区方案p</li><li>分区p定义了一组块b<sub>1</sub>，b<sub>2</sub>，… b<sub>n</sub></li><li>分区必须满足两个属性：<strong>1.块必须两两之间不相交（不重叠）2.所有块共同覆盖域D（完整）</strong></li></ul></li><li><p>两种方法</p><ul><li>基于接口的方法：直接根据各个输入参数开发特性，简单应用，在某些情况下可以部分自动化。</li><li>基于功能的方法：从被测程序的行为角度发展特征，更难开发，需要更多的设计工作，可以带来更好的测试，或者更少的测试。</li></ul></li><li><p>基于接口的方法：</p><ul><li>三角形有三个输入：q1=第一个边的输入与0的关系：大于，等于，小于</li></ul></li><li>基于功能的方法：<ul><li>三角形的类型：q1 =“几何分类”  b1=不等边  b2=等腰<strong>但不等边</strong>三角形  b3=正三角形  b4=无效</li><li>几何分区q1的可能值：b1= (4, 5, 6)，b2 = (3, 3, 4) ， b3 = (3, 3, 3)， b4 = (3, 4, 8)</li></ul></li></ul><h4 id="5-3-边界值分析"><a href="#5-3-边界值分析" class="headerlink" title="5.3 边界值分析"></a>5.3 边界值分析</h4><ul><li>示例：<ul><li>两个输入变量x1（a≤x1≤b）和x2（c≤x2≤d）。 测试用例包括：</li><li>&lt;x1nom，x2min&gt;，&lt;x1nom，x2min +&gt;，&lt;x1nom，x2nom&gt;，&lt;x1nom，x2max&gt;，&lt;x1nom，x2max-&gt;，&lt;x1min，x2nom&gt;，<x1min +，x2nom="">，&lt;x1max，x2nom&gt;，&lt;x1max-，x2nom&gt;</x1min></li><li>nomal，min，max</li></ul></li><li>弱边界值分析<ul><li>Min-  Min  Min+</li><li>Nom </li><li>Max-  Max  Max+ </li></ul></li></ul><p><img src="/sftest/弱边界1.png" width="40%"><img src="/sftest/弱边界2.png" width="30%"><img src="/sftest/边界.png" width="30%"></p><ul><li><p>强边界分析</p><p><img src="/sftest/强边界1.png" width="30%"><img src="/sftest/强边界2.png" width="35%"></p></li></ul><p><img src="/sftest/强边界3.png" width="35%"><img src="/sftest/强边界4.png" width="35%"></p><h4 id="5-4-组合测试"><a href="#5-4-组合测试" class="headerlink" title="5.4 组合测试"></a>5.4 组合测试</h4><ul><li>弱等价类测试</li><li>强等价类测试</li></ul><h4 id="5-5-测试中的约束"><a href="#5-5-测试中的约束" class="headerlink" title="5.5 测试中的约束"></a>5.5 测试中的约束</h4><ul><li>合并输入变量</li><li>优化输入域</li><li>修改测试用例</li></ul><h4 id="5-6-决策表"><a href="#5-6-决策表" class="headerlink" title="5.6 决策表"></a>5.6 决策表</h4><ul><li>决策表的优点<ul><li>能够将复杂的问题按照各种可能的情况全部列举出来，简明并避免遗漏。</li><li>利用决策表能够设计出完整的测试用例集合。 </li></ul></li><li>决策表通常由以下4部分组成:<ul><li>条件桩：列出问题的所有条件</li><li>条件项：针对条件桩中条件列出所有可能的取值</li><li>动作桩：列出问题规定的可能采取的操作</li><li>动作项：指出条件项各取值情况下应采取的动作</li></ul></li><li>构造决策表的5个步骤: <ol><li>确定规则的个数 ：有n个条件的决策表有2n个规则(每个条件取真、假值) </li><li>列出所有的条件桩和动作桩 </li><li>填入条件项 </li><li>填入动作项，得到初始决策表 </li><li>简化决策表，合并相似规则 </li></ol></li><li>练习：<ul><li>前一日函数DPreate是NextDate的逆函数，即给定一个月份、日期、年，会返回前一天的日期。</li><li>年的取值在1812年到2017年</li><li>日的取值在1日到31日之间</li><li>月的取值在1到12月之间</li><li>条件项(等价类划分)：<br><img src="/sftest/条件项.png" width="40%"></li></ul></li></ul><h3 id="C7-功能、性能、移动应用测试"><a href="#C7-功能、性能、移动应用测试" class="headerlink" title="C7 功能、性能、移动应用测试"></a>C7 功能、性能、移动应用测试</h3><ul><li>功能测试<ul><li>根据产品特性和设计需求，验证一个产品的特性和行为是否满足设计需求。</li><li>正确性、可靠性、易用性。</li></ul></li><li>性能测试<ul><li>验证产品的性能在特定负载和环境条件下使用是否满足性能指标。</li><li>度量方法：响应时间、并发用户数、吞吐量、性能计数器、负载测试、压力测试</li></ul></li><li><p>移动应用测试</p><ul><li>手机系统、型号</li><li>传感器与屏幕(尺寸？)碎片化</li></ul></li><li><p>软件缺陷的􏰀描述</p><ul><li>软件缺陷的生命周期</li><li>严重性和优先级</li><li>缺陷的其它属性</li><li>完整的缺陷信息</li><li>缺陷描述的基本要求</li><li>缺陷报告的示例</li></ul></li><li><p>软件缺陷的生命周期</p><ul><li>一个软件缺陷被发现、报告到 这个缺陷被修复、验证直至最后关闭的完整过程。</li></ul></li><li><p>基本的缺陷生命周期</p><ul><li>发现-打开:测试人员找到软件缺陷并将软件缺陷􏰁交给开发人员。 </li><li>打开-修复:开发人员再现、修复缺陷，然后提交给测试人员去验证。 </li><li>修复-关闭:测试人员验证修复过的软件，关闭已不存在的缺陷。 </li></ul></li><li><p>严重性(severity)：衡量缺陷对客户满意度的影响程度</p><ul><li>致命的(fatal)、严重的(critical)、一般的(major)、微小的(minor)</li></ul></li><li><p>优先级(Priority)：指缺陷被修复的紧急程度。</p></li><li><p><strong>缺陷􏰀述的基本要求</strong></p><ul><li>单一准确</li><li>可以再现</li><li>完整统一</li><li>短小简练</li><li>特定条件</li><li>补充完善</li><li>不做评价 </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件项目管理</title>
      <link href="/manage/"/>
      <url>/manage/</url>
      
        <content type="html"><![CDATA[<h3 id="C1-软件项目管理概述"><a href="#C1-软件项目管理概述" class="headerlink" title="C1 软件项目管理概述"></a>C1 软件项目管理概述</h3><ul><li><strong>项目管理</strong>是指一定的主体为了实现其目标，利用各种有效的手段，对执行中的项目周期的个阶段工作进行计划、组织、协调、指挥、控制，以取得良好经济效益的各项活动的总和。<a id="more"></a></li><li><strong>软件项目管理</strong>是为了使软件项目能够按照预定的成本，进度，质量顺利完成，而对成本，人员，进度，质量，风险等进行分析和管理的活动。</li><li>日常运作：连续不断、周而复始的活动，通过效率和有效性体现。</li><li>项目：临时性、一次性的活动，以目标为导向。<ul><li><strong>特性</strong>：目标性、相关性、临时性、独特性、资源约束性、不确定性</li></ul></li><li>项目目标实现的制约因素：项目范围、成本、进度计划和客户满意度。</li><li>项目管理包括<strong>启动</strong>过程组、<strong>计划</strong>过程组、<strong>执行</strong>过程组、<strong>控制</strong>过程组、<strong>收尾</strong>过程组等5个过程组。</li><li>项目管理知识体系(PMBOK)10个知识领域：<ul><li>项目<strong>整体</strong>管理，项目<strong>范围</strong>管理，项目<strong>时间</strong>管理，项目<strong>成本</strong>管理，项目<strong>质量</strong>管理，项目<strong>人力资源</strong>管理，项目<strong>沟通</strong>管理，项目<strong>风险</strong>管理，项目<strong>采购</strong>管理，项目<strong>干系人</strong>管理。</li></ul></li></ul><h3 id="C2-项目确立"><a href="#C2-项目确立" class="headerlink" title="C2 项目确立"></a>C2 项目确立</h3><ul><li><p>自造-购买决策</p><ul><li>在立项阶段，产品负责人进行自造-购买决策，确定待开发的产品的哪些部分应当采购、外包开发或者自主研发。除了需要考虑自造或者购买的成本，还需要考虑后续的大量费用（维护费、保险费..）。</li></ul></li><li><p>项目经理的职责：①开发计划   ②组织实施   ③项目控制</p></li><li>在招投标阶段，甲方过程包括招标书定义、供方选择、合同签署，乙方过程包括项目分析、竞标、合同签署。</li></ul><h3 id="C3-生存期模型"><a href="#C3-生存期模型" class="headerlink" title="C3 生存期模型"></a>C3 生存期模型</h3><ul><li>瀑布模型：适用于软件需求很明确的项目。要求项目所有的活动都严格按照顺序进行，一个阶段的输入是下一个阶段的输入。</li><li>V模型：瀑布模型的一个变种。</li><li><strong>快速原型模型</strong>：从核心方面开始设计和实施最初原型，根据用户反馈改进原型直到被接受。</li><li><strong>增量式模型</strong>：首先构造系统的核心功能，然后逐步增加功能和完善性能。</li><li><strong>渐进式阶段模型</strong>(<strong>迭代</strong>)：适用于中型或者大型项目，将大项目分成几个小项目来做。</li></ul><h3 id="C4软件项目范围计划-需求管理"><a href="#C4软件项目范围计划-需求管理" class="headerlink" title="C4软件项目范围计划 - 需求管理"></a>C4软件项目范围计划 - 需求管理</h3><ul><li><p>需求管理包括<strong>需求获取</strong>、<strong>需求分析/建模</strong>、<strong>需求规格编写</strong>、<strong>需求验证</strong>、<strong>需求变更</strong> 5个过程。</p><ul><li>需求获取：软件需求具有模糊性、不确定性、变化性和主观性的特点。</li><li>需求分析(/建模)：任务是借助于当前系统的逻辑模型导出目标系统的逻辑模型。</li><li>需求规格编写：完成的标志是提交一份完整的<strong>软件需求规格说明书(SRS)</strong>。</li><li>需求验证：验证需求的正确性、一致性、完整性、可行性、必要性、可验证性、可跟踪性和最后的签字。</li><li>需求变更：需求变更的主要工作如下<ul><li>建立需求基线</li><li>确定需求变更控制过程</li><li>建立<strong>变更控制委员会(SCCB)</strong></li><li>进行需求变更影响分析</li><li>跟踪所有受需求变更影响的工作产品</li><li>建立需求基准版本和需求控制版本文档</li><li>跟踪每项需求的状态</li></ul></li></ul></li><li><p>需求分析方法：<strong>①结构化分析方法  ②面向对象的用例分析方法   ③功能列表方法</strong></p><ul><li>结构化分析方法：数据流图、数据字典、实体联系图</li><li>面向对象的用例分析方法：用例视图、顺序视图、活动视图etc</li><li>功能列表方法：对项目的功能需求进行详细说明，基于功能特性及层次关系来描述需求的方法</li></ul></li></ul><h3 id="C5-软件项目范围计划-任务分解"><a href="#C5-软件项目范围计划-任务分解" class="headerlink" title="C5 软件项目范围计划 - 任务分解"></a>C5 软件项目范围计划 - 任务分解</h3><ul><li>任务分解的过程：<ul><li>将一个项目分解为更多的工作细目或者子项目， 使项目变得更小、更易管理、更易操作。 </li></ul></li><li><p>任务分解的结果：<strong>WBS(任务分解结构)</strong>。其中，工作包是WBS的最低层次的可交付成果。</p><ul><li>工作包应当由唯一主体负责，另外一位项目经理进行计划和执行，或者通过子项目的方式完成。</li><li>工作包可进一步分解为子项目的WBS或各个活动。</li></ul></li><li><p>任务分解步骤：</p><ol><li>确认并分解项目的组成要素 </li><li>确定分解标准</li><li>确定分解是否详细</li><li>确定项目交付成果 </li><li>验证分解的正确性(建立编号) </li></ol></li><li>WBS类型 <strong>分级的树形结构</strong><ul><li>清单形式</li><li>图表形式</li></ul></li><li><p>任务分解方法：</p><ul><li>模版参照方法</li><li>类比方法：许多项目有相同或者相似的周期。</li><li>自顶向下方法：从项目的大局着手，逐步分解子细目。</li><li>自底向上方法：首先定义项目的一些特定任务，然后将这些任务组织起来。</li></ul></li><li><p>检验分解结果的标准：</p><ul><li>最底层的要素是否是实现目标的充分必要条件</li><li>最底层要素是否有重复的</li><li>每个要素是否清晰完整定义</li><li>最底层要素是否有定义清晰的责任人,是否可以进行成本估算和进度安排 </li></ul></li><li><p>WBS的应用</p><ul><li>OBS(组织分解结构)</li><li>CBS(成本分解结构) </li><li>RBS(风险分解结构) </li><li>OBS(责任矩阵)</li><li>CBS(费用分解矩阵) </li><li>RBS(风险矩阵) </li></ul></li></ul><h3 id="C6-软件项目成本计划"><a href="#C6-软件项目成本计划" class="headerlink" title="C6 软件项目成本计划"></a>C6 软件项目成本计划</h3><ul><li><p>成本管理过程：</p><ul><li>资源计划编制：确定项目需要的资源种类和数量。</li><li>成本估算(中心环节)：编制一个为完成项目各活动所需要的资源成本的近似估算。</li><li>成本预算(项目进度)：将总成本估算分配到各单项工作活动上。</li><li>成本控制(项目跟踪)：控制项目预算的变更。</li></ul></li><li><p><strong>估算</strong>不是很准确的，有误差的。经验(历史)数据非常重要，不要太迷信数学模型。</p></li><li>项目规模的单位：<ul><li>􏰀LOC(Loc of Code)源代码程序长度的测量 </li><li>FP(Function Point)用系统的功能数量来测量 </li><li>人月 􏰀人天 􏰀人年</li></ul></li><li>成本的单位：<ul><li>货币单位：人命币，美元。</li></ul></li><li><strong>软件项目成本</strong>：项目规模是成本的主要因素<ul><li>完成软件规模相应付出的代价。</li><li>待开发的软件项目需要的资金。</li><li>人的劳动的消耗所需要的代价是软件产品的主要成本。</li></ul></li><li>成本估算过程：<ul><li>估算输入：<ul><li>项目需求、 WBS</li><li>历史项目度量</li><li>资源要求(资源编制计划)</li><li>资源消耗率:如人员成本: 100元/小时</li><li>进度规划:项目总进度(一般是合同要求)</li><li>学习曲线</li></ul></li><li>估算处理：<ul><li>直接成本：与具体项目相关的成本。</li><li>间接成本：不能归属于一个具体的项目，是企业的运营成本。</li></ul></li><li>估算输出<ul><li>估算文件：资源、资源的数量、质量标准、估算成本等信息，一般是货币单位。</li><li>估算说明：工作范围、估算的基础和依据、估算的假设、估算的误差变动等。</li></ul></li></ul></li></ul><h4 id="成本估算方法："><a href="#成本估算方法：" class="headerlink" title="成本估算方法："></a>成本估算方法：</h4><ul><li><p>估算的基本方法</p><ul><li>代码行、功能点、对象点、用例点估算法</li><li>类比 (自顶向下)估算法 </li><li>自下而上估算法 </li><li>参数法估算法 </li><li>专家估算法</li></ul></li><li><p><strong>代码行估算法</strong>：从软件程序量的角度定义项目规模。</p><ul><li>要求功能分解足够详细的，有一定的经验数据(类比和经验方法)，<strong>与具体的编程语言有关</strong>。</li><li>缺点：<ul><li>对代码行没有公认的可接受的标准定义，代码行数量依赖于所用的编程语言和个人的编程风格。</li><li>在项目早期,需求不稳定、设计不成熟、实现不确定的情况下很难准确地估算代码量。 </li><li>代码行强调编码的工作量，只是项目实现阶段 的一部分。</li></ul></li></ul></li><li><p><strong>功能点估算法</strong>：用系统的功能数量来测量其规模。</p><ul><li>与实现产品所使用的语言和技术没有关系。</li><li><strong>功能点计算公式</strong>：􏰀FP = UFC * TCF<ul><li>UFC: 未调整功能点计数</li><li>TCF: 技术复杂度因子(调整系数) P105</li></ul></li><li><strong>功能计数项</strong>：外部输入，外部输出，外部查询，外部文件，内部文件。</li></ul></li><li><p>类比 (自顶向下)估算法 </p><ul><li>根据以往的完成类似项目所消耗的总成本(或工作量)，来推算将要开发的软件的总成本(或工作量)，然后按比例将它分配到各个开发任务单元中。</li><li>使用情况<ul><li>有类似的历史项目数据</li><li>信息不足(要求不是非常精确)</li><li>在合同期和市场招标时</li></ul></li><li>特点：简单易行，花费少。有一定的局限性，准确性差,可能导致项目出现困难</li></ul></li><li><p>自下而上估算法：</p><ul><li>利用任务分解结构图，对各个具体工作包进行详细的成本估算，然后将结果累加起来得出项目总成本。</li><li>使用情况<ul><li>项目开始以后，WBS的开发阶段 </li><li>需要进行准确估算的时候</li></ul></li><li>特点：相对较准确，费时，可能发生虚报现象。</li></ul></li><li><p>参数法估算法：</p><ul><li>一种使用项目特性参数建立数据模型来估算成本的方法，是一种统计技术，如回归分析和学习曲线。<strong>一个模型不能适合所有情况。</strong><ul><li>静态单变量模型：面向LOC的估算模型，面向FP的估算模型</li><li>动态多变量模型：把工作量看作软件规模和开发时间这两个变量的函数。</li></ul></li><li>理论导出：不成熟阶段。 经验导出：软件估算常常采用。</li><li>使用情况<ul><li>存在成熟的项目估算模型 </li><li>应该具有良好的数据库数据为基础 </li></ul></li><li>特点：比较简单，准确。如果模型选择不当或者数据不准，也会导致偏差。</li><li>COCOMO模型：<ul><li>COCOMO 81 <strong>3个等级的模型</strong>：基本，中等，高级。</li><li>COCOMO 81模型将<strong>项目的模式</strong>分为有机型、嵌入型和半嵌入型。</li></ul></li></ul></li><li><p>专家估算法：</p><ul><li>由多位专家进行成本估算，一个专家可能会有偏见，最好由多位专家进行估算，取得多个估算值,最后得出综合的估算值。</li><li>组织者发给每位专家一份软件系统的规格说明 和一张记录估算值的表格，请他们估算 专家详细研究软件规格说明后，对该软件提出3 个规模的估算值：<ul><li>最小 ai</li><li>最可能的mi</li><li>最大bi</li></ul></li><li>计算每位专家的 E<sub>i</sub> = ( ai + 4mi + bi ) / 6</li><li>综合结果后，计算期望值: E<sub>i</sub> = E<sub>1</sub> + E<sub>2</sub> + … E<sub>n</sub> / n </li></ul></li></ul><h4 id="估算方法总结"><a href="#估算方法总结" class="headerlink" title="估算方法总结"></a>估算方法总结</h4><ul><li>􏰀初期：类比 专家估算 </li><li>计划阶段 ：自下而上 􏰀 参数模型 </li><li>实施阶段(包括变更发生)： 􏰀 自下而上 􏰀 参数模型 </li></ul><blockquote><p>主要考虑三种模型：类比法，自下而上法，参数法。自下而上法费时费力，参数法比较简单。自下向上法与参数法的估计精度相似。类比法通常用来验证参数法和自下而上法的结果。</p><p>各种方法不是孤立的，应该注意相互的结合使用</p></blockquote><h4 id="成本预算"><a href="#成本预算" class="headerlink" title="成本预算"></a>成本预算</h4><ul><li>成本预算是将项目的总成本按照项目的度分摊到各个工作单元中去。</li><li>成本预算将总的成本安排到各个任务中。</li><li>􏰁 成本预算的目的是产生成本基线 </li><li>分配项目成本预算主要包括3种情况：<ul><li>分配资源成本</li><li>分配固定资源成本</li><li>分配固定成本</li></ul></li></ul><h3 id="C7-项目进度计划"><a href="#C7-项目进度计划" class="headerlink" title="C7 项目进度计划"></a>C7 项目进度计划</h3><ul><li>任务之间的4种关系：<ul><li>结束 -&gt;  开始</li><li>结束 -&gt; 结束</li><li>开始 -&gt; 开始</li><li>开始 -&gt; 结束</li></ul></li><li><p>任务间关系的依据：</p><ul><li>强制性依赖关系：固有，不可违背的逻辑关系</li><li>软逻辑关系：人为，主观，由项目管理人员确定的项目活动之间的关系</li><li>外部依赖关系：项目活动与非项目活动之间的依赖关系。如环境测试依赖于外部提供的环境设备等。</li></ul></li><li><p>进度管理图示：</p><ul><li><strong>网络图</strong>：活动排序的一个输出，展示项目中的各个活动以及活动之间的逻辑关系，可以表达活动的历时。<ul><li>PDM：优先图法 ,节点法 (单代号)网络图。节点表示活动，箭线表示各活动之间的逻辑关系。</li><li>ADM：箭线法 (双代号)网络图。箭线表示活动，结点表示前一个任务的结束，也表示后一个任务的开始。两个代号唯一确定一个任务。 </li><li>ADM - 虚活动：不是一个实际活动，为了表达逻辑关系而引入的。</li></ul></li><li><p>甘特图</p><ul><li>显示基本的任务信息</li><li>可以查看任务的工期、开始时间和结束时间以 及资源的信息。</li><li>只有时标，没有活动的逻辑关系 </li></ul></li><li><p>里程碑图</p><ul><li>显示项目进展中的重大工作完成</li><li>里程碑不同于活动：活动是需要消耗资源的，里程碑仅仅表示事件的标记。</li></ul></li><li><p>资源图</p></li></ul></li></ul><h4 id="任务历时估计"><a href="#任务历时估计" class="headerlink" title="任务历时估计"></a>任务历时估计</h4><ul><li>定额估算法<ul><li>公式：T = Q / ( R * S )<ul><li>T: 活动持续时间。</li><li>Q: 活动的工作量。</li><li>R: 人力或设备的数量。</li><li>S: 效率，以单位时间完成的工作量表示。</li></ul></li><li>方法比较的简单，容易计算。适合对某个任务的历时估算或者规模比较小的项目。</li><li>局限性：没有考虑任务之间的关系。</li></ul></li><li>经验导出模型<ul><li>公式：D = a * E<sup>b</sup><ul><li>D: 月进度 </li><li>E: 人月工作量 </li><li>a: 2~4之间的参数</li><li>b: 1/3左右的参数，依赖于项目的自然属性。</li></ul></li></ul></li><li>工程评价技术(PERT)<ul><li>利用网络顺序图逻辑关系和加权历时估算来计算项目历时的技术。当估算项目中某项单独的活动，存在很大的不确定性时采用。</li><li>公式：期望值 E = ( O + 4m + P ) / 6<ul><li>O是最小估算值，M是最大可能估算值， P是最大估算值。</li></ul></li></ul></li><li>基于进度表的估算：①可能的最短进度表   ②有效进度表   ③普通进度表</li><li>基于承诺的进度估算：从需求出发去安排进度，不进行中间的工作量(规模)估计。</li><li>Jones的一阶估算准则：<strong>取得功能点的总和</strong>，从幂次表中选择合适的幂次将它升幂。</li><li>其他方法：专家估计方法、类推估计方法、模拟估计方法</li></ul><h4 id="进度计划编排"><a href="#进度计划编排" class="headerlink" title="进度计划编排"></a>进度计划编排</h4><h4 id="关键路径法：-正推法，逆推法-P143"><a href="#关键路径法：-正推法，逆推法-P143" class="headerlink" title="关键路径法： 正推法，逆推法 P143"></a>关键路径法： 正推法，逆推法 P143</h4><ul><li><p>步骤</p><ul><li>根据指定的网络图逻辑关系和单一的历时估算， 计算每一个活动的单一的、确定的最早和最迟 开始和完成日期。 </li><li>计算浮动时间。 </li><li>计算网络图中最长的路径。 </li><li>确定项目完成时间 </li></ul></li><li><p>概念：</p><ul><li><p>ES：最早开始时间   EF：最早完成时间  LS：最晚开始时间  LF：最晚完成时间</p></li><li><p>TF：<strong>总浮动   TF = LS - ES  = LF -EF</strong></p></li><li><p>FF：<strong>自由浮动   FF = ES(S) - EF - lag</strong>  即某任务的自由浮动等于它的<strong>(S)</strong>后置任务的ES减去它的EF，再减去它的lag。</p><blockquote><p>TF(总浮动)：在不影响项目最早完成时间，本任务可以延迟的时间</p><p>FF(自由浮动)：在不影响后置任务最早开始时间，本任务可以延迟的时间。</p></blockquote></li><li><p>lead：超前  lag：滞后   Duration：任务历时</p></li><li><p>关键任务：一个任务的最早时间和最迟时间相同。</p></li><li><p>关键路径：一系列不同任务链条上的关键任务链接成为项目的关键路径。关键路径在网络图中浮动为0，是网络图中的最长路径。</p></li></ul></li><li><p>正推法</p><ul><li>首先建立项目的开始时间 </li><li>项目的开始时间是网络图中第一个活动的最早开始时间 </li><li>从左到右，从上到下进行任务编排 </li><li>当一个任务有多个前置时，选择其中最大的EF作为其后置任务的最早开始日期 </li><li>ES + Duration = EF</li><li>EF + Lag = ES(s) 后置任务的最早开始时间</li></ul></li><li><p>逆推法</p><ul><li>首先建立项目的结束时间 </li><li>项目的结束时间是网络图中最后一个活动的最晚结束时间 </li><li>从右到左，从上到下进行计算 </li><li>当一个前置任务有多个后置任务时，选择其中最小的LF作为其前置任务的最晚完成日期 </li><li>LF - Duration = LS </li><li>LS - Lag = LF(p) </li></ul></li></ul><h4 id="时间压缩法：应急法-赶工，平行作业-快速跟进法"><a href="#时间压缩法：应急法-赶工，平行作业-快速跟进法" class="headerlink" title="时间压缩法：应急法/赶工，平行作业/快速跟进法"></a>时间压缩法：应急法/赶工，平行作业/快速跟进法</h4><ul><li><p>应急法 P146</p><ul><li>在不改变活动的前提下，通过压缩某一个或者多个活动的时间来达到缩短整个项目工期的目的。</li><li>在最小相关成本增加的条件下，压缩关键路经上的关键活动历时的方法。</li><li>进度压缩单位成本 = ( 压缩成本 - 正常成本 ) / ( 正常进度 - 压缩进度 )</li></ul></li><li><p>平行作业法</p></li></ul><h3 id="C8-软件项目质量管理计划"><a href="#C8-软件项目质量管理计划" class="headerlink" title="C8 软件项目质量管理计划"></a>C8 软件项目质量管理计划</h3><ul><li><p><strong>质量</strong>是产品或者服务满足明确和隐含需要能力的性能特性的总体。<strong>等级</strong>是对具有相同功能的实体按照不同技术特征进行分类或者分级。无论等级高低，都可以实现自己等级内的高质量。</p></li><li><p><strong>质量管理</strong>是确定质量方针、目标和职责，并在质量体系中通过诸如质量计划、质量控制、质量保障和质量改进使质量得以实现的全部管理活动。 </p></li><li><strong>质量方针</strong>是由组织的最高管理者正式发布的一个组织总的质量宗旨和质量方向，是质量管理的核心和出发点。 </li><li><strong>质量体系</strong>是为实施质量管理所需的组织结构、程序、过程和资源的总称。 </li><li><strong>质量计划</strong>是确定质量的目标和要求， 以及确定采用质量体系要素的目标和要求的活动的过程。</li><li><strong>质量控制</strong>是为达到质量要求所采取的作业技术与活动。 其内容包括 ：确定控制对象、规定控制标准、制定控制方法、 选用检验技术、 处理事故(失控)等等。</li><li><strong>质量保障</strong>是为了保障实体能够满足质量要求 , 并􏰃供足够的证明以表明实体保障能够满足质量要求，而在质量体系中实施，并根据需要进行证实的、全部有计划和有系统的活动。 </li><li><strong>质量改进</strong>是为向本组织及其顾客􏰃供更多的收益，在整个组织内所采取的旨在􏰃高活动和过程的效益和效率的各种措施。</li><li>质量模型：<ul><li>Boehm质量模型：软件产品的质量从3方面考虑— 软件的可用性、可维护性、可移植性。</li><li>McCall质量模型：通过定义的评价准则对反映质量特征的软件属性进行分级，依此来估计软件质量特征的值。</li><li>ISO/IEC 9126质量模型：”质量特征—质量子特征—度量因子”的三层结构模型</li></ul></li><li>质量控制的7种工具<ul><li>旧7种工具：统计分析法、数据分层法、散布图、 帕累托图、 􏰂 因果分析图、 􏰂 直方图、 控制图。 </li><li>新7种工具：关联图法、系统图法、 矩阵图法、 数据矩阵分析法、 网络图法、 PDPC( 过程决策程序图 ) 法、KJ(喜田二郎 ) 法。 </li></ul></li></ul><h4 id="PDCA循环"><a href="#PDCA循环" class="headerlink" title="PDCA循环"></a>PDCA循环</h4><ul><li>PDCA 循环的概念最早是由美国质量管理专家戴明􏰃出来的，所以又称 “ 戴明环 ”</li><li>P(plan)    —  计划  </li><li>D(do)       — 执行 </li><li>C(check)  — 检查 </li><li>A(action) — 处理</li></ul><h3 id="C9-软件配置管理计划"><a href="#C9-软件配置管理计划" class="headerlink" title="C9 软件配置管理计划"></a>C9 软件配置管理计划</h3><ul><li>配置管理：记录软件产品的演化过程，确保软件开发者在软件生命周期中的各个阶段都能得到精确的产品配置。最终保证软件产品的<strong>完整性、一致性、追朔性、可控性</strong>。<ul><li>主要功能：版本管理，变更管理。</li></ul></li><li><strong>软件配置项</strong>是项目需定义其受控于软件配置管理的项。每个项目的配置项也许会不同，配置项也有不同的版本。<ul><li>eg. 系统规格说明书，软件需求规格说明书，设计规格说明书，源代码，测试规格说明书</li></ul></li><li><strong>基线</strong>提供了软件生存期中各个开发阶段的一个特定点，一个(些)配置项形成并通过审核，即形成基线。<ul><li>基线标志开发过程一个阶段的结束和里程碑。</li><li>基线修改只能通过正式的变化控制过程改变。</li></ul></li><li><p><strong>配置控制委员会</strong>(SCCB)具体责任如下：</p><ul><li>评估变更</li><li>批准变更申请</li><li>在生存期内规范变更申请流程</li><li>对变更进行反馈</li><li>与项目管理层沟通</li></ul></li><li><p>配置管理的基本过程</p><ul><li>配置项标识、跟踪</li><li>配置管理环境建立</li><li>基线变更管理：变更请求，变更评估，变更批准/拒绝，变更实现</li><li>基线审核</li><li>配置状态统计</li><li>配置管理计划</li></ul></li><li>配置管理工具<ul><li>好的配置管理工具应该具备的功能：并行开发支持，履历管理，版本控制，过程控制，产品发布管理。</li><li>常见的配置管理软件<ul><li>Rational ClearCase</li><li>Hansky Firefly</li><li>CVS</li><li>SVN</li><li>Microsoft VSS</li></ul></li></ul></li></ul><h3 id="C10-软件项目人员与沟通计划"><a href="#C10-软件项目人员与沟通计划" class="headerlink" title="C10 软件项目人员与沟通计划"></a>C10 软件项目人员与沟通计划</h3><ul><li><p>项目组织结构</p><ul><li>特点：临时性，目标性</li><li>类型：职能型，项目型，矩阵型</li></ul></li><li><p><strong>职能型</strong>：项目是以部门为主体来承担项目的，一个项目由一个或者多个部门承担。</p><ul><li><p>优点：</p><p>1.可以充分发挥职能部门的资源集中优势</p><p>2.部门的专家可以同时为部门内不同项目使用</p><p>3.便于相互交流， 相互支援</p><p>4.可以随时增派人员</p><p>5.可以将项目和本部门的职能工作融为一体</p></li><li><p>缺点：</p><p>1.项目和部门利益发生冲突，职能部门更重视本部门的目标,会忽视项目目标</p><p>2.资源平衡会出现问题</p><p>3.权利分割不利于各个职能部门的交流和团结协作</p><p>4.行政隶属关系使得项目经理没有充分的权利</p></li></ul></li><li><p><strong>项目型</strong>：部门完全按照项目设置，每个项目以项目经理为首，项目工作会运用到大部分的组织资源。</p><ul><li><p>优点：</p><p>1.项目经理对项目可以负全责</p><p>2.项目目标单一，可以以项目为中心,有利于项目顺利进行</p><p>3.避免多重领导</p><p>4.组织结构简单，交流简单,快速</p></li><li><p>缺点：</p><p>1.资源不能共享</p><p>2.各个独立的项目处于相对封闭状态,不利于公司政策的贯彻</p><p>3.对项目组织的成员缺少一种事业上的连续性和安全感</p><p>4.项目组织之间处于分割状态,缺少信息交流</p></li></ul></li><li><p><strong>矩阵型</strong>：从不同的部门中选择合适的项目人员组成一个临时项目组，项目结束后买这个项目组也解体了。</p><ul><li><p>优点：</p><p>1.专职的项目经理负责整个项目 , 以项目为中心,</p><p>2.公司的多个项目可以共享各个职能部门的资源</p><p>3.即利于项目目标的实现,又利于公司目标方针的贯彻</p><p>4.项目成员的顾虑减少了</p></li><li><p>缺点：</p><p>1.容易引起职能经理和项目经理权力的冲突</p><p>2.资源共享也能引起项目之间的冲突</p><p>3.项目成员有多位领导</p></li></ul></li><li><p><strong>沟通渠道</strong>：N ( N - 1 ) / 2 ，其中N为人员总数。</p></li></ul><h3 id="C11-项目风险计划"><a href="#C11-项目风险计划" class="headerlink" title="C11 项目风险计划"></a>C11 项目风险计划</h3><ul><li><p><strong>风险的定义</strong>：损失发生的不确定性；对潜在的，未来可能发生损害的一种度量。</p></li><li><p>项目风险的三要素：一个事件，事件发生的概率，事件的影响。</p></li><li><p>风险类型：</p><ul><li>预测角度：已知风险，可预测风险，不可预测风险。</li><li>范围角度：商业风险，技术风险，管理风险，人员风险，开发环境风险，客户风险，产品风险，过程风险。</li></ul></li><li><p><strong>风险识别</strong>的方法：</p><ul><li>德尔菲方法</li><li>头脑风暴法</li><li>情景分析法</li><li>风险条目检查表</li><li>面谈法，SWOT分析</li></ul></li><li><p><strong>风险评估</strong>：确定风险发生概率的估计和评价，项目风险后果严重程度的估计和评价，项目风险影响范围的分析和评价，以及对于项目风险发生时间的估计和评价。</p><p>风险R是该风险发生的概率 P 和影响程度 I 的函数，即R = F ( P , I )。</p><ul><li>定性风险评估<ul><li>风险概率：概率值(0~1)，风险概率度量(极高、高、中、低、极低)</li><li>风险后果：风险影响项目目标的严重程度(无影响~无穷大)，风险后果度量(极高、高、中、低、极低)</li></ul></li><li>定量风险评估：在定性评估的逻辑基础上，给出各个风险源的量化指标及其发生概率<ul><li>访谈：确定概率分布模型， 领域专家访谈，信息采集。</li><li>盈亏平衡分析 </li><li>决策树分析 </li></ul></li></ul></li><li><p>风险规划的主要策略：回避风险，转移风险，损失控制，自留风险。</p></li></ul><h4 id="决策树分析"><a href="#决策树分析" class="headerlink" title="决策树分析"></a>决策树分析</h4><ul><li>决策树分析是一种图表分析方法，提供项目所有可供选择的行动方案，行动方案之间的关系，行动方案的后果以及发生的概率，提供选择一个最佳的方案的依据。</li><li><strong>损益期望值(EMV)</strong>是决策树的一种计算值，根据风险发生的概率计算出一种期望的损益<ul><li>EMV = P(概率) * outcome(收益)</li></ul></li><li>利用决策树风险分析技术来分析如下两种情况，并选择其中一种方案：<ul><li>随机投掷硬币两次，如果两次投掷的结果都是硬币正面朝上，你将获得10元；投掷的结果背面每朝上一次你需要付出1.5元。 </li><li>随机投掷硬币两次，你需要付出2元； 如果两次投掷的结果都是硬币正面朝上，你将获得10元。 </li></ul></li></ul><h3 id="C13-项目集成计划"><a href="#C13-项目集成计划" class="headerlink" title="C13 项目集成计划"></a>C13 项目集成计划</h3><ul><li>软件项目管理4要素：C = F(S , Q , T)<ul><li>范围(S)  质量(Q)  进度(T)  成本(C)</li><li>S  与 C  成一定正比关系</li><li>Q 与 C  成一定正比关系</li><li>T  与 C  成一定反比关系</li></ul></li><li>项目集成计划的内容<ul><li>确定项目概貌、团队</li><li>明确项目团队内、外的协作沟通</li><li>规划开发环境和规范，项目范围说明，编制项目进度计划，项目成本计划，项目质量计划，项目沟通计划，风险计划，项目合同计划，配置管理计划，制定其他辅助计划。</li></ul></li></ul><h3 id="C15-项目核心计划执行控制"><a href="#C15-项目核心计划执行控制" class="headerlink" title="C15 项目核心计划执行控制"></a>C15 项目核心计划执行控制</h3><ul><li><p>进度、成本、资源控制：输入计划与实际的进度成本资源，输出进度成本资源的修改决定。</p><ul><li>图解控制法</li><li>挣值分析法</li></ul></li><li><p>图解控制法：</p><ul><li><p>进度：<strong>甘特图</strong></p></li><li><p>成本：<strong>累计费用曲线图</strong></p></li><li><p>人力物力资源：<strong>资源载荷图</strong></p><ul><li><p>优点：可以一目了然地确定项目情况</p></li><li><p>缺点：只能提供视觉印象，但本身不能提供其他重要的量化信息。</p></li></ul></li></ul></li></ul><h4 id="挣值分析法-已获取价值分析"><a href="#挣值分析法-已获取价值分析" class="headerlink" title="挣值分析法 / 已获取价值分析"></a>挣值分析法 / 已获取价值分析</h4><ul><li><p>挣值分析法：对项目实施的进度、成本状态进行绩效评估的有效方法。是计算实际花在一个项目上的工作量，以及预计该项目所需成本和完成该项目的日期的一种方法。</p></li><li><p>输入：</p><ul><li>BCWS：到目前为止的总预算成本。</li><li>ACWP：到目前为止所完成工作的实际成本。</li><li>BCWP：已完成工作的预算成本。</li><li>BAC：预计总成本，项目计划中的成本估算结果。</li><li>TAC：预计总耗时，项目计划中完成时间的估算结构</li></ul></li><li>输出：<ul><li><strong>进度差异 SV = BCWP - BCWS</strong> <ul><li>=0:  按照进度进行  &lt;0:  落后于进度  &gt;0:  超前于进度</li></ul></li><li><strong>进度效能指标 SPI = BCWP / BCWS * 100%</strong><ul><li>已完成工作百分比</li><li>=1:  按照进度进行    &gt;1:  超前于进度  &lt;1:  落后于进度 </li></ul></li><li><strong>费用差异 CV = BCWP - ACWP</strong><ul><li>=0:  按照预算进行  &gt;0:  低于于预算  &lt;0:  超出于预算</li></ul></li><li><strong>成本效能指标 CPI =  BCWP / ACWP * 100%</strong><ul><li>费用的支出速度</li><li>=1:  按照预算进行   &gt;1:  低于预算     &lt;1:  超出预算</li></ul></li><li>项目完成的预测成本：EAC = BAC / CPI</li><li>项目完成的成本差异：VAC = BAC - EAC</li><li>项目完成的预测时间：SAC = TAC / SPI</li><li>未完工的成本效能指标：TCPI = ( BAC - BCWP ) / (Goal - ACWP) = 剩余工作 / 剩余成本 <ul><li>Goal是项目希望花费的数目</li></ul></li></ul></li><li>BCWP的计算<ul><li>Way1：自下而上 — 很麻烦</li><li>Way2：规则计算<ul><li><strong>50/50规则:</strong> 当一项工作开始时，假定已经获得一半的价值。 </li><li><strong>0/100规则:</strong> 当一项工作开始时，没有产生价值，直到结束获得全部的价值。 </li></ul></li><li>Way3：经验加加权法</li></ul></li></ul><h4 id="质量计划控制执行"><a href="#质量计划控制执行" class="headerlink" title="质量计划控制执行"></a>质量计划控制执行</h4><ul><li><p>质量保证的管理</p><ul><li>3个要点：在项目进展过程中，定期对项目各方面的表现进行评价，通过评价来推测项目最后是否能够达到相关的质量标准，通过质量评价来帮助项目相关的人建立对项目质量的信心。</li><li>主要活动<ul><li>产品审计：根据质量保证计划对项目过程中的工作产品进行质量审查的过程。</li><li>执行过程审计：对项目质量管理活动的结构性复查。</li></ul></li></ul></li><li><p>质量控制的管理</p><ul><li>3个要点：检查控制对象是项目工作结果，进行跟踪检查的依据是相关质量标准，对于不满意的质量问题进一步分析原因并确定采取何种措施来消除这些问题。</li><li>方法：技术评审，代码走查，测试，返工</li><li>策略手段：趋势分析，抽样统计，缺陷追踪</li></ul></li><li>质量保证与质量控制的关系：<ul><li>质量保证着重于过程和产品提交之后的质量监管。— 管理职能<ul><li>针对一般的、具有普遍性的问题</li><li>从总体上提供质量信心</li></ul></li><li>质量控制着重于产品推出前的质量把关。— 检查职能<ul><li>针对具体产品或者具体活动的质量管理</li><li>从具体环节上提高产品的质量</li></ul></li></ul></li></ul><h3 id="C16-团队人员计划的执行控制"><a href="#C16-团队人员计划的执行控制" class="headerlink" title="C16 团队人员计划的执行控制"></a>C16 团队人员计划的执行控制</h3><ul><li>项目团队建设：组建阶段、磨合阶段、规范阶段和执行阶段。</li><li>项目成员的激励：<ul><li>马斯洛的需求层次理论：生理，安全，社会归属，自尊，自我实现。</li><li>海兹伯格的激励理论<ul><li>激励因素（内在因素）：成就感，责任感，晋升，被赏识、认可</li><li>保健因素（外在因素）：工作环境，薪金，工作关系，安全等</li></ul></li><li>麦克勒格的 X理论：用马斯洛的底层需求（生理和安全）进行激励 </li><li>麦克勒格的Y 理论 ：用马斯洛的高层需求（自尊和自我实现）进行激励</li><li>期望理论：相信他们的努力很可能会产生成功的结果，他们也相信自己会因为成功得到相应的回报</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件需求笔记</title>
      <link href="/require/"/>
      <url>/require/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基本的软件需求"><a href="#1-基本的软件需求" class="headerlink" title="1. 基本的软件需求"></a>1. 基本的软件需求</h2><h3 id="1-1-软件需求"><a href="#1-1-软件需求" class="headerlink" title="1.1 软件需求"></a>1.1 软件需求</h3><ul><li>要解决的问题是：<ul><li>什么是软件需求？</li><li>为什么要实现软件需求？</li><li>哪些人应参与软件需求<a id="more"></a></li></ul></li><li><strong>需求分析模型：</strong><br><img src="/require/需求分析模型.png" width="40%"><img src="/require/需求分析模型2.png" width="40%"></li><li>软件需求活动 <ul><li>需求诱导 → 需求分析 → 需求传递 → 需求确认 → 需求演化  </li></ul></li><li>IEEE软件工程标准词汇表中定义<strong>软件需求</strong>为：<br>（1）<strong>用户</strong>为解决某个问题或达到目标而需具备的条件或能力。<br>（2）<strong>系统</strong>或系统部件为满足合同、标准、规范或其它正式文档而必须满足的条件或能力。<br>（3）上述（1）或（2）中定义的条件或能力的<strong>文档表达</strong>。 </li><li>需求分析：<ul><li>分析软件用户的需求，细致的进行、调查，把用户“做什么”的要求，最终转换为一个完全的、精细的软件逻辑模型。</li><li>并写出软件的需求规格说明。</li><li>准确地表达用户的要求。</li></ul></li><li><strong>需求的层次</strong><ul><li><strong>业务需求</strong>：表示组织或客户高层次的目标。描述了组织为什么要开发一个系统，即目标。可以用前景和范围文档表述。</li><li><strong>用户需求</strong>：描述的是用户的目标，或用户要求系统必须能完成的任务，即用户能使用系统来做些什么。可以用用例、场景描述和时间-响应表表述。</li><li><strong>功能需求</strong>：规定开发人员必须在产品中实现的软件功能，用户利用这些功能来完成任务，满足业务需求，即开发人员需要实现什么。<br><img src="/require/产物.png" width="50%"></li></ul></li><li>需求不应该包括：<ul><li>设计和实现的细节</li><li>项目计划信息</li><li>测试信息</li></ul></li></ul><h3 id="1-2-需求工程"><a href="#1-2-需求工程" class="headerlink" title="1.2 需求工程"></a>1.2 需求工程</h3><h5 id="1-需求开发"><a href="#1-需求开发" class="headerlink" title="1. 需求开发"></a>1. 需求开发</h5><ul><li>需求开发的过程：<ul><li><strong>诱导 → 分析 → 规范化 → 确认</strong></li></ul></li></ul><h5 id="2-需求管理"><a href="#2-需求管理" class="headerlink" title="2. 需求管理"></a>2. 需求管理</h5><ul><li><strong>需求管理的4个主要内容</strong>：<ol><li><strong>变更控制</strong>：建议变更；分析影响；作出决策；交流；合并；测量需求的稳定性。</li><li><strong>版本控制</strong>：确定需求文档版本；确定单个需求文档版本。</li><li><strong>需求跟踪</strong>：定义对其它需求的连接链；定义对其它系统元素的连接。</li><li><strong>需求跟踪状态</strong>：定义需求状态；跟踪需求每一个状态。</li></ol></li><li>需求开发与需求管理的分界<br><img src="/require/界限.png" width="30%"></li></ul><h5 id="需求的好坏"><a href="#需求的好坏" class="headerlink" title="需求的好坏"></a>需求的好坏</h5><ul><li><strong>糟糕的需求</strong><ul><li>用户参与不足</li><li>用户需求扩展</li><li>有歧义的需求</li><li>镀金问题</li><li>过于抽象的需求</li><li>忽略了某类用户</li><li>不准确的计划</li></ul></li><li><strong>理想情况下需求的性质</strong><ul><li>完整的</li><li>正确的</li><li>可行的</li><li>必须的</li><li>优先化的 / 有优先次序的</li><li>清楚的 / 无歧义的</li><li>可检验的 / 可验证性</li></ul></li><li><strong>需求规格说明的特点</strong><ul><li>完整性</li><li>一致性</li><li>可修改性</li><li>可跟踪性</li></ul></li></ul><h2 id="2-客户眼中的需求"><a href="#2-客户眼中的需求" class="headerlink" title="2. 客户眼中的需求"></a>2. 客户眼中的需求</h2><h5 id="用户：是一种泛称"><a href="#用户：是一种泛称" class="headerlink" title="用户：是一种泛称"></a>用户：是一种泛称</h5><ul><li>掏钱买软件的用户称为<strong>客户</strong></li><li>真正操作软件的用户叫<strong>最终用户</strong></li><li><strong>间接用户</strong>既不掏钱买该软件产品，也不使用该软件，但是它可能对软件产品有很大的影响。<ul><li>eg. 财务软件 -&gt; <strong>国家财政局</strong>审核</li><li>客户与最终用户可能是同一个人也可能不是同一个人</li></ul></li></ul><h5 id="涉众"><a href="#涉众" class="headerlink" title="涉众"></a>涉众</h5><ul><li><strong>涉众</strong>：在软件开发项目中主要是<strong>指和这个项目有密切相关利益的人</strong>，他们共同感兴趣的就是需求分析阶段。</li><li>这些涉众包括客户、用户、业务或需求分析员、开发人员、测试人员、用户文档编写者、项目管理者和客户管理者。 <ul><li>需求分析员：负责收集客户需求并编写文档，以及负责客户与开发机构之间联系沟通的人</li></ul></li></ul><h5 id="软件客户的权利"><a href="#软件客户的权利" class="headerlink" title="软件客户的权利(!!!)"></a>软件客户的权利(!!!)</h5><ol><li>要求需求分析员<strong>使用客户的语言</strong></li><li>要求需求分析员<strong>熟悉客户的业务，了解客户对系统的目标</strong></li><li>要求需求分析员<strong>把需求收集过程中客户提供的信息组织成书面的<code>软件需求规格说明</code></strong></li><li>要求需求分析员<strong>解释需求过程生成的所有工作结果</strong></li><li>要求需求分析员和开发人员尊重客户，始终以合作和专业的态度与客户进行互动</li><li>要求需求分析员和开发人员为需求和产品实现提供思路和备用方案</li><li>要求开发人员实现能让产品使用起来更容易、更有趣的特性</li><li><strong>调整需求</strong>，便于重用已有的软件组件</li><li>在提<strong>出需求变更时，获得对变更的成本</strong>、影响及二者权衡关系的真实评估</li><li>获得满足功能和质量要求的系统，这些要求必须事先告知开发人员征得其同意</li></ol><h5 id="软件客户的义务"><a href="#软件客户的义务" class="headerlink" title="软件客户的义务"></a>软件客户的义务</h5><ol><li>为需求分析员和开发人员<strong>讲解业务</strong>并<strong>定义业务术语</strong></li><li>提供需求，阐明需求，通过与开发人员的交互将<strong>需求充实完善</strong></li><li>对系统需求的<strong>描述</strong>必须<strong>详细、准确</strong></li><li>需要时，及时对需求做出决断</li><li><strong>尊重</strong>开发人员对需求<strong>成本和可行性的评估</strong></li><li>与开发人员<strong>协作</strong>，为功能需求、系统特性和用例<strong>设置优先级</strong></li><li><strong>审阅</strong>需求文档，评估原型</li><li>发现需要变更需求时，<strong>及时</strong>与开发人员<strong>沟通</strong></li><li>按照开发组织的变更控制过程<strong>提出需求变更</strong></li><li>尊重需求分析员在需求工程中使用的过程</li></ol><h2 id="3-需求工程的推荐方法"><a href="#3-需求工程的推荐方法" class="headerlink" title="3. 需求工程的推荐方法"></a>3. 需求工程的推荐方法</h2><ul><li><strong>需求工程的推荐方法：</strong><ul><li>知识技能</li><li>需求管理 </li><li>项目管理 </li></ul></li><li><strong>需求开发：</strong><ul><li>获取 </li><li>分析 </li><li>编写规格说明书 </li><li>验证  </li></ul></li></ul><h2 id="4-需求分析员"><a href="#4-需求分析员" class="headerlink" title="4. 需求分析员"></a>4. 需求分析员</h2><ul><li><strong>需求分析员</strong>：<ul><li>是<strong>对软件项目设计的需求进行收集、分析、记录和验证等工作的主要承担者。</strong></li><li>是用户群体和软件开发团队之间进行需求沟通的桥梁。</li><li>是收集和传播的中心角色。</li><li>需求分析员是一种项目角色，而不是职务头衔。</li><li>需求分析员称职与否关系到项目的成败。</li></ul></li><li><strong>需求分析员的任务</strong> <strong>深刻了解</strong><ul><li>定义业务需求</li><li>确定项目涉众和用户类别</li><li>获取需求</li><li>分析需求</li><li>编写需求规格说明</li><li>为需求建模</li><li>主持对需求的验证</li><li>引导对需求的优先级划分</li><li>管理需求</li></ul></li><li><strong>需求分析员的来源</strong>：<ul><li>从<strong>用户</strong>转为分析员</li><li>从<strong>开发人员</strong>转为分析员</li><li>应用领域专家 / 主题专家</li></ul></li></ul><h2 id="5-确定产品前景与项目范围"><a href="#5-确定产品前景与项目范围" class="headerlink" title="5. 确定产品前景与项目范围"></a>5. 确定产品前景与项目范围</h2><ul><li>项目视图：描述了产品所涉及的各个方面和最终所具有的功能。 </li><li>项目范围：<ul><li>描述了产品应包括的部分和不应包括的部分。</li><li>说明了在包括的部分与不包括的部分之间的界线。</li></ul></li></ul><h5 id="前景与范围文档"><a href="#前景与范围文档" class="headerlink" title="前景与范围文档"></a>前景与范围文档</h5><ul><li><strong>业务需求</strong><ul><li>包括<strong>背景、业务机遇、业务目标与成功标准、客户与市场需求、业务风险</strong></li></ul></li><li>解决方案的前景<ul><li>包括前景声明、主要特征、假设与依赖</li></ul></li><li>范围与限制<ul><li>包括第一个版本的范围、各后续版本的范围、限制与排除</li></ul></li><li>业务背景<ul><li>包括涉及简介、项目优先级、操作环境</li></ul></li></ul><h5 id="DFD图"><a href="#DFD图" class="headerlink" title="DFD图"></a>DFD图</h5><ul><li>关联图（0层DFD） ：<ul><li>确定了通过某一接口与系统相连的<strong>外部实体</strong>。有时，称为“端点”。</li><li>以及，外部实体和系统之间的数据流和物流</li><li>我们把<strong>关联图</strong>，作为结构化分析方法，形成<strong>数据流图</strong>的<strong>最高抽象层</strong>。 </li></ul></li></ul><h2 id="6-获取客户的需求"><a href="#6-获取客户的需求" class="headerlink" title="6. 获取客户的需求"></a>6. 获取客户的需求</h2><ul><li><strong>需求的来源</strong><ol><li>与潜在的用户进行交谈和讨论</li></ol><ul><li>描述现有产品或竞争产品的文档</li><li>系统需求规格说明</li><li>现有系统的问题报告和改进要求</li><li>市场调查和用户问卷调查</li><li>观察用户如何工作</li><li>用户工作的情景分析</li><li>时间和响应</li></ul></li><li><strong>用户代言人</strong><ul><li>用户代言人本身就是实际用户</li><li><strong>外部的用户代言人</strong></li><li>对用户代言人的要求：计划、需求、确认和验证、用户辅助、变更控制</li><li>设置多位用户代言人</li><li>设置用户代言人会出现和应避免的问题 P72</li></ul></li><li><strong>步骤</strong><ul><li><strong>准备调查</strong>：首先，需求分析员应当起草需求调查问题表，将调查重点锁定在该问题表内，否则调查工作将变得漫无边际。其次，需求分析员应当确定需求调查的方式。最后需求分析员与被调查者建立联系，确定调查的时间、地点、人员等。</li><li><strong>执行调查</strong>：按照计划执行调查。在调查过程中随时记录（或存储）需求信息。需求分析员与用户面谈时应守时，先去了解用户的身份、背景。</li></ul></li><li>为了征求客户的意见，必须采取以下几步：<ul><li>明确项目用户需求的来源。</li><li>明确使用该产品的不同类型的用户。</li><li>与产品不同用户类的代表进行沟通。</li><li>遵从项目的最终决策者的意见。</li></ul></li></ul><h2 id="7-聆听客户的需求"><a href="#7-聆听客户的需求" class="headerlink" title="7. 聆听客户的需求"></a>7. 聆听客户的需求</h2><h5 id="需求获取"><a href="#需求获取" class="headerlink" title="需求获取"></a>需求获取</h5><ul><li>需求获取是最困难、最关键、最容易出错和最需要沟通的环节</li><li>需求获取的方式：面谈、小组讨论、解决冲突等</li><li>多问“为什么”</li><li>获得业务问题或总体特性</li><li>设身处地</li><li>对现有系统最感到烦恼的事情是什么？</li><li>工作流程—流程图和判定树</li><li>编写文档及评审</li></ul><h5 id="需求获取讨论会"><a href="#需求获取讨论会" class="headerlink" title="需求获取讨论会"></a>需求获取讨论会</h5><ul><li>建立基本规则</li><li>不超出范围（项目范围）</li><li>使用活动挂图来捕获以后再考虑的一些条目</li><li>时间盒讨论</li><li>保持较小的团队规模并找到合适的参与者（人多误事）</li><li>确保每个人都积极地参与讨论</li></ul><h5 id="将客户的意见归类"><a href="#将客户的意见归类" class="headerlink" title="将客户的意见归类"></a>将客户的意见归类</h5><ul><li>业务需求</li><li>用例或场景</li><li>业务规则</li><li>功能性需求</li><li>质量属性</li><li>外部接口需求</li><li>约束</li><li>数据定义</li><li>解决思路</li></ul><h2 id="8-理解用户需求"><a href="#8-理解用户需求" class="headerlink" title="8. 理解用户需求"></a>8. 理解用户需求</h2><ul><li>需要了解 使用用例获取方法  </li><li><strong>使用用例产生的成果：数据字典</strong><br><img src="/require/使用用例.png" width="50%"></li></ul><h5 id="使用用例的好处"><a href="#使用用例的好处" class="headerlink" title="使用用例的好处"></a>使用用例的好处</h5><ul><li>使用户更清楚地认识到新系统允许他们做什么</li><li>防止“孤立”的功能</li><li>揭示对象以及它们之间的责任</li></ul><h5 id="使用用例时应避免的问题"><a href="#使用用例时应避免的问题" class="headerlink" title="使用用例时应避免的问题"></a>使用用例时应避免的问题</h5><ol><li><strong>太多</strong>的使用用例 </li><li>使用用例的<strong>冗余</strong> </li><li>使用用例中的<strong>用户界面的设计</strong> </li><li>使用用例中<strong>包括数据定义</strong> </li><li>试图把每一个需求与一个使用实例相联系</li></ol><h5 id="需求整理和分析的过程"><a href="#需求整理和分析的过程" class="headerlink" title="需求整理和分析的过程"></a>需求整理和分析的过程</h5><ul><li>需求收集 -&gt; 解释原始数据 -&gt; 整理需求 -&gt; 设置权重 -&gt; 概念选择</li><li>整理单项需求：黄纸贴</li><li>头脑风暴</li></ul><h5 id="单项需求重要性定义（BSA）"><a href="#单项需求重要性定义（BSA）" class="headerlink" title="单项需求重要性定义（BSA）"></a>单项需求重要性定义（BSA）</h5><ul><li>B（Basic）：基本需求</li><li>S（Satisfied）：让客户更满意的需求 </li><li>A（Attractive）：更有吸引力的需求</li></ul><h2 id="9-遵守规则"><a href="#9-遵守规则" class="headerlink" title="9. 遵守规则"></a>9. 遵守规则</h2><ul><li>遵守业务规则（从讨论会来）</li><li>业务规则：是对业务的某个方面进行定义或约束的语句<ul><li>eg. 政策性法规</li></ul></li><li>业务规则的<strong>分类</strong>：<ul><li>事件</li><li>约束</li><li>动作触发规则</li><li>计算</li><li>推论</li></ul></li></ul><h2 id="10-编写需求文档"><a href="#10-编写需求文档" class="headerlink" title="10. 编写需求文档"></a>10. 编写需求文档</h2><ul><li><strong>软件需求规格说明</strong><ul><li>精确地阐述了一个软件系统必须提供的功能和性能，以及所要考虑的限制条件。</li><li>是一个软件系统成功的基础</li></ul></li><li>编写软件需求规格说明的<strong>三种方法</strong>：<ul><li><strong>用好的结构化和自然语言编写文本型文档</strong></li><li><strong>建立图形化模型方法：</strong>模型可以描绘转换过程、系统状态和它们之间的变化、数据关系、逻辑流或对象类和它们的关系。</li><li><strong>编写形式化规格说明：</strong>这可以通过使用数学上精确的形式化逻辑语言来定义需求。</li></ul></li><li>高质量需求文档，所具有的特征：<ul><li>完整性</li><li>一致性</li><li>必要性</li><li>明确性</li><li>可验证性</li><li>可更改性</li><li>可跟踪性</li></ul></li><li>注意事项：(最后的分析题可以用到)<ul><li>对节、小节和单个需求的号码编排，必须一致。</li><li>正确使用各种可视化强调标志 —— 例如，黑体、下划线、斜体等</li><li>创建目录表和索引表，有助于读者寻找所需的信息。</li><li>对所有图和表，指定号码和标识号，并且可按号码进行查阅。</li><li>使用字处理程序中，交叉引用的功能，来查阅文档中其它项或位置。</li></ul></li><li>优秀的需求文档应该考虑： <ul><li>保持语句和段落的简短。</li><li>采用主动语态的表达方式。</li><li>编写具有正确的语法、拼写和标点的完整句子。</li><li>使用的术语与词汇表中所定义的应该一致。</li><li>需求陈述应该具有一致的样式。</li><li>为了减少不确定性，避免模糊的、主观的术语。</li><li>避免使用比较性的词汇</li></ul></li><li>编号：<ol><li>序列号   如：UR-9、SRS-43</li><li>层次化编码 如：3.2.1</li><li>层次化文本标签  </li></ol></li><li>数据字典<ul><li>数据字典是一个共享存储库，用于定义应用程序中使用的所有数据元素或属性的含义、数据类型、长度、格式、需要的精度以及数据允许的取值范围或数据值的列表。</li><li>数据字典与数据流图配合，能清楚地表达数据处理的要求</li></ul></li></ul><h2 id="11-需求的图形化分析"><a href="#11-需求的图形化分析" class="headerlink" title="11. 需求的图形化分析"></a>11. 需求的图形化分析</h2><ul><li><strong>软件系统从三个方面来表达</strong><ul><li><strong>过程</strong>：数据流图 </li><li><strong>数据</strong>：实体-关系图 </li><li><strong>状态</strong>：状态转换图，对话图，判定表和树。</li></ul></li><li><strong>数据流图</strong>：一个数据流图可以标识系统的转换过程、系统所操纵的数据或物质集合（存储），以及过程、存储和外部世界之间的数据流或物质流。<ul><li><strong>过程</strong>：用<strong>圆圈</strong>表示</li><li><strong>端点</strong>：用<strong>矩形框</strong>表示</li><li><strong>数据流</strong>：用<strong>箭头</strong>表示</li><li><strong>数据存储区</strong>：用<strong>一对平行线</strong>表示</li></ul></li><li><strong>实体-关系图</strong>：描绘了系统的数据关系<ul><li><strong>实体</strong>用单名词来命名。用<strong>矩形</strong>框表示。</li><li>每个实体要用几个<strong>属性</strong>来描述，每个实体的单个实例具有不同的属性值。</li><li><strong>关系</strong>用能描述关系的本质来命名，它确定了一对实体之间在逻辑上和数量上的连接。用<strong>菱形框</strong>表示。</li></ul></li><li><strong>状态转换图</strong>：表示处理结果可能的状态转换。<ul><li><strong>系统状态</strong>，用<strong>矩形框</strong>表示。</li><li><strong>状态改变</strong>，用<strong>箭头连接一对矩形框</strong>表示。</li><li><strong>事件或条件</strong>，在每个迁移箭头上用<strong>文本标签</strong>来表示。</li></ul></li><li>对话图：在<strong>较高的抽象层次上</strong>表示用户界面的设计，它展示了系统的对话元素及这些元素之间的导航连接，但<strong>没有展示</strong>详细的屏幕设计。一种状态转换图<ul><li>每个<strong>对话元素</strong>表示为一个状态，用<strong>矩形框</strong>表示</li><li>将每个允许的<strong>导航选项</strong>表示为一个<strong>转换</strong>，用<strong>箭头</strong>表示。</li><li>触发用户界面导航的<strong>条件</strong>表示为<strong>转换箭头上的文本标签</strong>。</li></ul></li><li>决策表：应用表格的形式进行需求表达。<ul><li>可列出影响系统行为的所有因素的各种取值，并表明对这些因素的每一种组合所期望的系统响应动作。</li></ul></li><li>决策树：采用一种树形结构表达需求。用树形结构表示动作的各种分支。</li></ul><h2 id="12-软件质量属性"><a href="#12-软件质量属性" class="headerlink" title="12. 软件质量属性"></a>12. 软件质量属性</h2><ul><li>质量属性难以挖掘</li><li><strong>软件质量属性</strong>是系统非功能性需求的一部分。<ul><li>非功能需求：描述系统<strong>展现给用户的行为和执行的操作</strong>等。</li></ul></li><li><strong>主要对用户重要的属性</strong> <strong>一定了解</strong> <ul><li><strong>可用性</strong>：系统能够正常运行的时间比例。</li><li><strong>有效性</strong>：系统如何优化处理器、磁盘空间或通信带宽的。</li><li><strong>灵活性</strong>：在产品中，增加新功能时，所需工作量的大小。</li><li><strong>完整性</strong></li><li><strong>互操作性</strong>：表明了产品与其它系统交换数据和服务的难易程度。</li><li><strong>可靠性</strong>：软件无故障执行一段时间的概率。</li><li><strong>健壮性</strong>：是指当系统或其组成部分遇到非法输入数据、相关软件或硬件组成部分的缺陷或异常的操作情况时，能继续正确运行功能的程度。</li><li><strong>易用性</strong>：对于新用户或不常使用产品的用户在学习使用产品时的难易程度。</li></ul></li><li><strong>主要对开发人员重要的属性：</strong> <strong><code>一定了解</code></strong> <ul><li><strong>可维护性</strong>：在软件中纠正一个缺陷或做一次更改的难易程度。</li><li><strong>可移植性</strong>：把一个软件从一种运行环境转移到另一种运行环境中所花费的工作量。对于工程的成功是不重要的。</li><li><strong>可重用性</strong>：除了在最初开发的系统中使用之外，还可以在其它应用程序中使用的程度。</li><li><strong>可测试性</strong>：测试软件组件或集成产品时查找缺陷的难易程度。</li></ul></li></ul><h2 id="13-通过原型法减少项目风险"><a href="#13-通过原型法减少项目风险" class="headerlink" title="13. 通过原型法减少项目风险"></a>13. 通过原型法减少项目风险</h2><ul><li>一个软件原型：<strong>是所提出的新产品的部分实现</strong></li><li><strong>使用软件原型的3个目的：</strong><ul><li>明确并完善需求</li><li>研究设计选择方案</li><li>发展为最终产品</li></ul></li></ul><h5 id="原型的分类"><a href="#原型的分类" class="headerlink" title="原型的分类"></a>原型的分类</h5><ul><li><strong>水平原型</strong>（行为原型或演示性模型）主要描绘用户界面的一部分，<strong>不深入</strong>到体系结构的所有层次。</li><li><strong>垂直原型</strong>（结构化原型或概念模型）主要在技术服务层次上实现应用程序用户界面的一部分功能，它触及到了系统实现的<strong>所有层次。</strong></li><li><strong>进化型原型</strong>是螺旋式软件开发生命周期模型和某些面向对象软件开发过程的一个组成部分。</li><li><strong>废弃型原型</strong>是指达到预期目的后，原型本身被抛弃。<ul><li>用途：解决需求不确定性、二义性、不完整性、含糊性等。</li></ul></li><li><strong>书面原型</strong>和电子原型：用<strong>平面工具</strong>把系统是如何实现的呈现在用户面前。<ul><li>是一种廉价、快速，并且不涉及高技术的方法</li><li>它可以把一个系统某部分，是如何实现的呈现在用户面前。  </li></ul></li><li><strong>使用原型法的若干可能的方法</strong><br><img src="/require/原型.png" width="40%"></li><li><strong>原型法的好处</strong><ol><li>提供了一套强有力的技术</li></ol><ul><li>可以缩短开发进度</li><li>增加用户的满意程度</li><li>生产出高质量的产品</li><li>可以减少需求错误和用户界面的缺陷。 </li></ul></li></ul><h2 id="14-设定需求优先级"><a href="#14-设定需求优先级" class="headerlink" title="14. 设定需求优先级"></a>14. 设定需求优先级</h2><h5 id="为什么要划分优先级"><a href="#为什么要划分优先级" class="headerlink" title="为什么要划分优先级"></a>为什么要划分优先级</h5><ul><li><strong>设定优先级的好处</strong>:<ul><li>有助于项目经理解决冲突、安排阶段性交付，并且，做出必要的取舍。</li><li>尽早确定出所交付的产品应具备的最重要的功能</li><li>权衡合理的项目范围和进度安排、预算以及质量目标的约束</li></ul></li><li>设定优先级的一般方法是<ul><li>把需求分成三类：高、中、低</li></ul></li><li>每一个需求的优先级，必须写入软件需求规格说明或使用实例的说明中。</li></ul><h5 id="基于价值、费用和风险的优先级设定"><a href="#基于价值、费用和风险的优先级设定" class="headerlink" title="基于价值、费用和风险的优先级设定"></a>基于价值、费用和风险的优先级设定</h5><ol><li>列出要设定优先级的所有需求、特性或使用实例；</li></ol><ul><li>估计每一个特性提供给客户或业务的相关利益。</li><li>估计出如果没有把应该实现的特性包括到产品中，将会给客户或业务上带来的损失。</li><li>总价值栏是相对利润和相对损失的总和。<ul><li>总价值 = 相对利益 <em> 利益权值 + 相对损失 </em> 损失权值</li></ul></li><li>估计实现每个特性的相对费用。</li><li>估计出与每个特性相关的技术或风险相对程度。</li><li>一旦把所有的估算写入平面表，就可以利用如下公式计算出每一特性的优先级：<ul><li>优先级 =  价值% / (费用% <em> 费用权值+ 风险% </em> 风险权值)</li></ul></li><li>按计算出的优先级的降序排列表中的特性。   </li></ul><h2 id="15-需求确认"><a href="#15-需求确认" class="headerlink" title="15. 需求确认"></a>15. 需求确认</h2><ul><li>需求确认：是指开发方和客户方共同对《产品需求规格说明书》进行<strong>评审</strong>，双方对需求达成共识后作出<strong>承诺</strong>。</li><li>需求确认包含两个重要工作：<ol><li><strong>需求评审</strong></li><li><strong>需求承诺</strong></li></ol></li><li>评审过程要干些什么 看每一个步骤大概要点<br><img src="/require/审查.png" width="40%"></li><li>需求评审的参与者(5-9人)<ol><li>产品的开发者及其可能的同组成员</li></ol><ul><li>先前产品的开发者或正在评审的项目的SRS编写者</li><li>要根据正在审查的文档来开展工作的人</li></ul></li></ul><h2 id="18-需求管理的原则与实现"><a href="#18-需求管理的原则与实现" class="headerlink" title="18. 需求管理的原则与实现"></a>18. 需求管理的原则与实现</h2><ul><li><strong>需求管理</strong>的4个部分，每部分大概需要做什么。<br><img src="/require/管理.png" width="40%"></li><li><strong>需求基线</strong>-是团队成员已经承诺将在某一特定产品版本中实现的功能性和配功能性需求的一组集合。</li></ul><h2 id="19-变更管理"><a href="#19-变更管理" class="headerlink" title="19. 变更管理"></a>19. 变更管理</h2><ul><li>注意事项：<ol><li>应仔细评估已建议的变更</li><li>挑选合适的人选对变更做出决定</li><li>变更应及时通知所有涉及的人员</li><li>项目要按一定的程序来采纳需求变更</li></ol></li><li>变更控制策略<ol><li>所有需求变更必须遵循一个过程，按照此过程，如果一个变更需求未被采纳，则其后过程不再予以考虑。</li><li>对于未获批准的的变更，除可行性论证之外，不应再做其他设计和实现工作。</li><li>简单请求一个变更不能保证能实现变更，要由项目CCB决定实现哪些变更。</li><li>项目风险承担者应该能够了解变更数据库的内容。</li><li>绝不能从数据库中删除或修改变更请求的原始文档。</li><li>每一个集成的需求变更必须能跟踪到一个经核准的变更请求。</li></ol></li></ul><h4 id="考点：对整个需求过程比较关键的环节的概念比较重要。"><a href="#考点：对整个需求过程比较关键的环节的概念比较重要。" class="headerlink" title="考点：对整个需求过程比较关键的环节的概念比较重要。"></a>考点：对整个需求过程比较关键的环节的概念比较重要。</h4><ul><li>做需求需要哪几个典型阶段</li><li>每个阶段需要哪些参与者</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多媒体技术笔记</title>
      <link href="/media/"/>
      <url>/media/</url>
      
        <content type="html"><![CDATA[<h2 id="1-引论"><a href="#1-引论" class="headerlink" title="1. 引论"></a>1. 引论</h2><h4 id="媒体的分类"><a href="#媒体的分类" class="headerlink" title="媒体的分类"></a>媒体的分类</h4><ul><li><code>感觉媒体</code>: 能直接作用于人的感官，使人直接产生感觉的一类媒体<strong>（作用于人）</strong>。如人类的语言、音乐、自然界的各种声音、图形、图像。</li><li><code>表示媒体</code>: 计算机对信息的表示方法的描述。是<strong>为了加工、处理和传输感觉媒体</strong>而人为研究、构造出来的一种媒体<strong>（作用于计算机)</strong>。具体体现为：编码<a id="more"></a></li><li><code>表现媒体</code>: <strong>感觉媒体和用于通信的电信号之间转换</strong>用的一类媒体，分为输入表现媒体和输出表现媒体。如打印机、音箱、MIDI键盘，扫描仪、键盘、鼠标。除此之外，还有耳麦、轨迹球、绘图仪等<strong>（用于人与计算机交互）</strong></li><li><code>存储媒体</code>: 用于计算机存放<strong>表示媒体</strong>，以便计算机随时处理、加工和调用信息编码。常用的有光盘、硬盘、磁带、活动硬盘、优盘等</li><li><code>传输媒体</code>: 用于传输<strong>表示媒体</strong>，将表示媒体从一处传送到另一处的物理载体。如双绞线、同轴电缆、光纤等</li></ul><h4 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h4><ul><li><strong><code>多媒体</code></strong>是指信息<strong>表示媒体</strong>的多样化，包括文本、图形、图像、声音、音乐、动画、视频等，即多媒体<strong>主要研究表示媒体</strong>。</li><li>性质：<ul><li>多媒体是多种信息载体的<strong>表现</strong>形式、<strong>存储</strong>和<strong>传输</strong>方式的有机集合</li><li>多媒体系统具有<strong>多样性</strong>、<strong>集成性</strong>、<strong>实时性</strong>和<strong>交互性</strong></li></ul></li></ul><h4 id="多媒体系统的体系结构"><a href="#多媒体系统的体系结构" class="headerlink" title="多媒体系统的体系结构"></a>多媒体系统的体系结构</h4><p><img src="/media/体系结构.png" width="30%"></p><ul><li><strong>多媒体应用系统</strong> / 多媒体应用软件：利用多媒体工具软件，针对某一主题<strong>设计开发的具体多媒体应用系统</strong>。</li><li><strong>多媒体创作系统</strong> / 多媒体应用系统开发软件：集成文本、图形、声音、图像、视频和动画等多种媒体信息的编辑和著作工具，是开发多媒体应用系统的平台或环境，可以用于<strong>生成各种多媒体应用系统</strong>。</li><li><strong>媒体制作平台与工具</strong> / 多媒体素材创作软件：利用本层提供的工具及接口可以完成多媒体数据的采集、制作及编辑。</li><li><strong>多媒体核心系统</strong> / 多媒体系统软件：提供硬件层上的基础服务，拥有一系列的服务软件，包括对多种硬件设备的连接、控制，对用户使用的语言环境的支持和解释。其核心是<strong>多媒体操作系统</strong>，还包括<strong>设备驱动程序</strong></li><li><strong>多媒体计算机硬件系统</strong>：包括多媒体计算机<strong>主机系统</strong>（MPC）及各种外围设备的<strong>接口部件</strong>。</li><li><strong>多媒体外围设备</strong>：包括音频、视频等多种媒体的<strong>输入/输出设备和装置</strong>，通信（网络）<strong>传输设备及装置</strong></li></ul><h2 id="2-图形图像技术"><a href="#2-图形图像技术" class="headerlink" title="2. 图形图像技术"></a>2. 图形图像技术</h2><h4 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h4><ul><li>图形（矢量图）是用一系列计算机指令来表示一幅图，如画点、画线、画曲线、画圆、画矩形等。例如，一条直线可以用Line (1,1 5,5)表示（计算机中描述方式？）</li><li>优点<ul><li>存储和传输时数据量较小</li><li>缩放、旋转、移动图形不会失真，能保证质量（可无级缩放）</li><li>适合管理图形的每一部分</li><li>编辑方便</li><li>图块可重用</li></ul></li><li>缺点<ul><li>图形重生成花费时间较长 </li><li>不适合描述彩色图像</li></ul></li></ul><h4 id="图像-位图"><a href="#图像-位图" class="headerlink" title="图像 / 位图"></a>图像 / 位图</h4><ul><li>将一幅图像在<strong>空间</strong>上<strong>离散化</strong>为多个<strong>像素</strong>，每个像素用若干个二进制位来描述其<strong>颜色、亮度和属性</strong></li><li>位图的获取通常使用扫描仪、数码相机、数码摄像机</li><li>优点<ul><li>显示速度快</li><li>表现力强，可适于任何自然图像，细腻、层次多、细节丰富</li></ul></li><li>缺点<ul><li>存储和传输时数据量比较大</li><li>缩放、旋转时算法复杂且容易失真</li><li>矢量图和位图之间可以进行转换</li><li>由矢量图转换成位图采用光栅化技术，转换也相对容易</li><li>由位图转换成矢量图用跟踪技术</li></ul></li></ul><h4 id="采样与量化"><a href="#采样与量化" class="headerlink" title="采样与量化"></a>采样与量化</h4><ul><li>在用计算机进行处理时，需要<strong>对连续信号离散化</strong>。包括空间、时间、幅值上的离散化</li><li>其中<strong>空间/时间</strong>离散称为<strong>采样</strong>，<strong>幅值离散</strong>称为<strong>量化</strong></li><li><p>离散化后的连续信号还需要进行<strong>编码</strong>，以便计算机存储、处理和传输</p></li><li><p>对量化后的数据编码、压缩，生成不同多媒体信息的表示媒体，可以采用多种方案。思考：什么是编码？编码是否等同于压缩？</p><ul><li>对于数据编码不一定压缩数据，但压缩数据的结果一定是一种编码，即编码可以分为非压缩编码和压缩编码</li><li>压缩可以在编码前进行，也可以在编码后针对编码结果进行压缩得到另一种编码</li></ul></li><li><p>输入矢量图时是否需要采样、量化和编码？为什么？</p><ul><li>矢量图在表示方式上采用数学描述，因此在输入时不需要采样和量化，但在计算机内部有其自身的编码方式</li></ul></li></ul><h4 id="颜色模型"><a href="#颜色模型" class="headerlink" title="颜色模型"></a>颜色模型</h4><ul><li><strong><code>RGB</code></strong>：R，G，B分别代表红、绿、蓝三色，<strong>相加混色模型</strong>。用于显示设备。(从黑色开始加)</li><li><strong><code>CMYK</code></strong>：印刷四分色模式，<strong>相减混色模型</strong>。用于打印设备。（从白色开始减）</li><li><strong><code>HSL</code></strong>：H(色调)、S(饱和度)、I(光强度)这3个分量来表示一种颜色。用于人眼。</li><li><strong><code>Lab</code></strong>：颜色-对立空间，带有维度L表示亮度，a和b表示颜色对立维度，<strong>所生成的颜色与所使用的设备无关</strong>。用途：Lab模式可以用作为在不同颜色模式之间转换时使用的中间颜色模式。</li><li><strong><code>Index</code></strong>：索引色彩模式用<strong>8bit</strong>描述，最多可以使用<strong>256种颜色</strong>，采用调色板方式实现。用于减小图片文件的大小，同时基本上不影响视觉效果。(不是真的彩色)</li><li><strong><code>Grayscale</code></strong>：灰度模式用<strong>8bit</strong>描述，最多使用<strong>256级灰度</strong>来表现图像，图像中的每个像素有一个0（黑色）到255（白色）之间的亮度值。主要用于医学、图像识别领域。</li><li><strong><code>Binary</code></strong>：二值图像是每个像素只有两个可能值的数字图像(黑、白)。主要用于数字图像处理研究。</li></ul><blockquote><p>索引色彩模式和灰度模式中，每个像素值都占用一个字节，为什么一种为彩色？一种不为彩色？<br>索引彩色有调色板，灰度模式没有，且灰度模式的索引8bit就是灰度值本身灰度模式和索引色彩模式归为同一类。</p></blockquote><h4 id="位图图像基本属性"><a href="#位图图像基本属性" class="headerlink" title="位图图像基本属性"></a>位图图像基本属性</h4><ul><li><strong>分辨率</strong><ul><li>图像分辨率：构成图像的像素总数，以水平和垂直的像素表示。</li><li>显示分辨率：在某种显示方式下，在屏幕上最大的显示区域中，可显示的像素总数。</li></ul></li><li><strong>颜色深度：</strong>图像每个像素所占用的存储位数。它决定了彩色图像中最多能使用的颜色数，或者灰度图像中最多能有的灰度级数</li><li><strong>调色板：</strong><ul><li>一个彩色图像假如只包含24位真彩色空间中的16个离散的点（16色图），则可以建立一个颜色查找表，表中的每一行记录一组RGB值。</li><li>实际像素的值用来指定该点颜色在查找表中的索引值，这样就可以大大缩小存储量。这个颜色查找表就叫做调色板</li></ul></li><li><strong>真彩色、伪彩色与直接色</strong> (不考)<ul><li>真彩色：在组成一幅彩色图像的每个像素值中，有R，G，B三个基色分量，每个基色分量直接决定显示设备的基色强度。</li><li>伪彩色：把像素值当作彩色查找表(调色板)的表项入口地址，去查找一个显示图像时使用的R，G，B强度值，用查找出的R，G，B强度值产生的彩色。</li><li>直接色：每个像素值分成R，G，B分量，每个分量作为单独的索引值对它做变换。也就是通过相应的彩色变换表找出基色强度，用变换后得到的R，G，B强度值产生的彩色称为直接色</li></ul></li><li><strong>位图图像数据量</strong><ul><li>位图图像数据量计算公式B = (h <em> w </em> c ) / 8 (Byte)</li><li>其中，h:垂直分辨率，w:水平分辨率，c:颜色深度</li><li>例：一副大小为640X480，256色彩色图像，其数据量为：B =（ 640 × 480 × 8 ) / 8 = 307, 200字节</li></ul></li></ul><h4 id="BMP图像文件格式"><a href="#BMP图像文件格式" class="headerlink" title="BMP图像文件格式"></a>BMP图像文件格式</h4><ul><li>BMP图像文件格式：<ul><li>采用位映射存储格式</li><li>图像颜色深度可选lbit、4bit、8bit及24bit</li><li>不采用其他任何压缩（？）</li><li>包含的图像信息较丰富</li><li>占用磁盘空间过大，不利于网络传输</li><li>存储数据时，图像的扫描方式是按<strong>从左到右、从下到上</strong>的顺序</li></ul></li><li><p>BMP文件由4个部分组成：</p><ol><li>位图文件头</li><li>位图信息头</li><li>颜色表</li><li>图像数据阵列字节</li></ol></li><li><p>有哪些不同类型的图形/图像文件？为什么有这些不同的类型？各自有何特点？</p></li></ul><h2 id="3-音频技术"><a href="#3-音频技术" class="headerlink" title="3. 音频技术"></a>3. 音频技术</h2><ul><li>声音、语音、音乐的区别和联系？<ul><li>声音是统称，或专指除语音、音乐之外的其它声音。</li><li>语音是声音的一种特殊类型，因为人类语音的频率范围小于声音的频率范围，且具有独特的发音特点。</li><li>音乐也是声音的一种特殊类型，主要是指MIDI音乐。</li></ul></li></ul><h4 id="声音的听觉心理特性"><a href="#声音的听觉心理特性" class="headerlink" title="声音的听觉心理特性"></a>声音的听觉心理特性</h4><ul><li>音调：声音的高低。由声音的(基)频率决定</li><li>音强（响度）：表示人们所感觉到的声音能量的强弱，主要取决于声波振幅的大小。可听声音的强度范围是0-120dB</li><li>响度的特性：响度与人耳的可闻程度有关<ul><li>人耳的可听频率范围外，声音的响度再大，人耳也无法察觉</li><li>人耳的可听频域范围内，当声音弱或强到一定程度，人耳都无法听到</li></ul></li><li>等响曲线：人类感受不同频率声音时，其所感知的相同响度对应的声音能量是不同的，由此构成了等响曲线。</li><li>听阈：人能听到的最低声压级</li><li>痛阈：当声压级增大到一定强度时，人耳会感到不适或疼痛。</li></ul><h4 id="掩蔽效应："><a href="#掩蔽效应：" class="headerlink" title="掩蔽效应："></a>掩蔽效应：</h4><ul><li>一种频率的声音阻碍听觉系统感受另一种频率的声音的现象。人的耳朵只对最明显的声音反应敏感，而对于不明显的声音，反应则较不敏感</li><li>前者称为掩蔽声音，后者称为被掩蔽声音</li><li>应用此原理，人们发明了mp3等<strong>压缩的数字音乐格式</strong>，在这些格式的文件里，只突出记录了人耳朵较为敏感的中频段声音，而对于较高和较低的频率的声音则简略记录，从而大大压缩了所需的存储空间<ul><li>频域掩蔽：指一个<strong>强纯音</strong>会掩蔽在其附近同时发声的弱纯音。</li><li>时域掩蔽：指在<strong>时间上相邻的声音之间</strong>也有掩蔽现象。</li></ul></li></ul><h4 id="声音信号数字化"><a href="#声音信号数字化" class="headerlink" title="声音信号数字化"></a>声音信号数字化</h4><ul><li>声音如何数字化？  <ul><li>与模拟图像数字化相似，声音数字化包括<strong>采样、量化和编码</strong></li></ul></li><li><strong>采样</strong>：将声音信号<strong>在时间上离散化</strong>，即每隔相等的一段时间抽取一个信号样本</li><li><strong>量化</strong>：将连续的信号<strong>幅度离散化</strong>。<ul><li>如果幅度的划分是等间隔的，称为线性量化/均匀量化。</li><li>否则为非线性量化/非均匀量化。</li></ul></li><li><strong>编码</strong>：按<strong>一定的格式</strong>将离散的数字信号记录下来，并在数据的前、后加上同步、纠错等控制信号</li></ul><h4 id="影响数字音频质量的技术参数"><a href="#影响数字音频质量的技术参数" class="headerlink" title="影响数字音频质量的技术参数"></a>影响数字音频质量的技术参数</h4><ul><li>数字音频的质量取决于：<strong>采样频率、采样精度/量化位数和声道数</strong></li></ul><h4 id="采样数据量-考试不用计算，考算式"><a href="#采样数据量-考试不用计算，考算式" class="headerlink" title="采样数据量(考试不用计算，考算式)"></a>采样数据量(考试不用计算，考算式)</h4><ul><li><strong>声音采样数据量 (字节) = 采样频率 × 采样精度 / 8 × 声道数 × 采样时间</strong></li><li>为了减少数据量，采样且量化后的数据常要进行压缩编码（将在第5章介绍）</li><li>eg. <strong>1分钟</strong>的<strong>双声道声音</strong>，采用不同采样频率和精度所需的存储容量例如，采用<strong>44.1kHz采样频率</strong>和<strong>16位采样精度</strong>时，数字化后需要的存贮容量为：<strong>44.1 × 16 / 8 × 2 × 60 = 10584(字节)</strong></li></ul><h4 id="语音"><a href="#语音" class="headerlink" title="语音"></a>语音</h4><ul><li>以语音的基本特性为基础，主要针对语音的成分进行相应处理，包括语音<strong>采样、识别、模拟、合成</strong>等技术</li><li><strong>语音识别和语音合成</strong>技术是实现人机语音通信的两项关键技术</li></ul><h4 id="MIDI音乐"><a href="#MIDI音乐" class="headerlink" title="MIDI音乐"></a>MIDI音乐</h4><ul><li>数字音乐是一种音乐语言；数字音乐编码。</li><li>MIDI：电子乐器数字接口</li><li><strong>MIDI音乐是一种数字音乐</strong>，MIDI音乐通常被称为<strong>电子音乐或合成音</strong>乐，它也是声音的一种，但是这种声音与流行的乐器有关，例如，钢琴、提琴、长号、鼓等乐器。</li><li>优点：<ul><li>生成的文件比较小，一个六分多钟、有16个乐器的文件只有80多KB（为什么？）</li><li>容易编辑</li><li>可以作背景音乐</li></ul></li></ul><ul><li>缺点：<ul><li>播放效果因软、硬件而异。好的播放效果必须支持波表功能</li><li>录制较复杂，需要学习一些使用MIDI创作并改编作品的专业知识，还须有专门工具，如键盘合成器</li></ul></li></ul><h4 id="音频文件的格式"><a href="#音频文件的格式" class="headerlink" title="音频文件的格式"></a>音频文件的格式</h4><ul><li>WAV</li><li>MIDI：MIDI文件储存着MIDI资料和命令。</li><li>MP3：利用了<strong>知觉音频编码技术</strong>，削减了音乐中人耳所听不到的成分，尽可能保持原有的音质。</li><li>MP3PRO：降低压缩比</li><li>ra(RealAudio) &amp; rm(RealMedia)：网络流媒体文件格式</li><li>Windows Media</li></ul><h2 id="4-动画视频技术"><a href="#4-动画视频技术" class="headerlink" title="4. 动画视频技术"></a>4. 动画视频技术</h2><ul><li>动态图像：由多幅连续的图像构成的序列称为动态图像</li><li>原理：它利用了人眼的视觉暂留性</li></ul><h4 id="动态图像的特点"><a href="#动态图像的特点" class="headerlink" title="动态图像的特点"></a>动态图像的特点</h4><ul><li><strong>时间连续性</strong>：动态图像具有时间连续性</li><li><strong>数据量大</strong>：数据量更大</li><li><strong>相关性强</strong>：动态图像的帧与帧之间具有很强的相关性。据研究，相邻帧之间有10%以下的像素有亮度变化，1%以下的像素有色度变化(注：该性质在动态图像压缩中具有重要作用。为什么？)@<strong>“为什么”考试</strong></li><li><strong>实时性高</strong>：动态图像对实时性要求高，必须在规定的时间内完成更换画面播放的过程</li></ul><h4 id="动画文件的格式"><a href="#动画文件的格式" class="headerlink" title="动画文件的格式"></a>动画文件的格式</h4><ul><li>GIF</li><li>SWF</li><li>FLI/FLC</li></ul><h4 id="视频文件格式"><a href="#视频文件格式" class="headerlink" title="视频文件格式"></a>视频文件格式</h4><ul><li>微软的AVI </li><li>苹果公司的MOV</li><li>MPEG</li><li>RealNetwork公司的RM</li><li>ASF、 WMV</li></ul><h2 id="5-多媒体数据压缩技术"><a href="#5-多媒体数据压缩技术" class="headerlink" title="5. 多媒体数据压缩技术"></a>5. 多媒体数据压缩技术</h2><h3 id="5-1-数据压缩的基本原理和方法"><a href="#5-1-数据压缩的基本原理和方法" class="headerlink" title="5.1 数据压缩的基本原理和方法"></a>5.1 数据压缩的基本原理和方法</h3><h4 id="多媒体数据压缩的必要性和可能性"><a href="#多媒体数据压缩的必要性和可能性" class="headerlink" title="多媒体数据压缩的必要性和可能性"></a>多媒体数据压缩的必要性和可能性</h4><ul><li>必要性<ul><li>数字化后的图像、视频和音频等媒体信息的海量性</li><li>计算机存储资源和网络带宽难以满足需要</li><li>导致多媒体数据存储和传输的困难</li><li>结论：多媒体数据需要压缩</li></ul></li><li>可能性<ul><li>多媒体数据冗余：统计冗余（空间冗余、时间冗余）、结构冗余、知识冗余、感知冗余（视觉冗余、听觉冗余）</li><li>信息表达冗余：信息熵冗余</li></ul></li></ul><h4 id="数据冗余"><a href="#数据冗余" class="headerlink" title="数据冗余"></a>数据冗余</h4><ul><li><strong>统计冗余</strong> <ul><li>时间冗余: 一段视频的前后相邻的2帧中会有大量的区域有相同或相近的数据，形成帧间的数据冗余。</li><li>空间冗余: 在同一个静态图像或画面中，有部分区域数据值一样或相差不大，形成空间冗余。</li></ul></li><li>结构冗余：有些图像存在着明显的分布模式</li><li>知识冗余：许多图像的理解与某些基础知识有相当大的相关性。如人脸的图像有固定的结构。 </li><li><strong>感知冗余</strong><ul><li>视觉冗余</li><li>听觉冗余</li></ul></li><li><strong>信息熵冗余</strong>：信息的表达存在冗余。<ul><li>信息熵：一组数据所携带的<strong>平均信息量</strong>（不确定性的度量）</li><li>平均信息量乘以数据的个数，就是整个一组数据的信息量</li></ul></li></ul><blockquote><ul><li>存在数据冗余，才可能进行数据压缩</li><li>某些数据冗余是多媒体数据所特有的</li><li>针对不同数据冗余，设计不同数据压缩方法</li></ul></blockquote><h4 id="信源符号，码元，码字"><a href="#信源符号，码元，码字" class="headerlink" title="信源符号，码元，码字"></a>信源符号，码元，码字</h4><ul><li>对于<strong>消息集</strong>中的<strong>信源符号</strong>使用<strong>符号集</strong>中的<strong>码元</strong>进行编码，得到<strong>输出集（码书）</strong>中的与信源符号<strong>一一对应</strong>的<strong>码字</strong></li><li>信源符号，码元，码字（要求信源符号和码字一一对应）<ul><li>英文字母，0和1，ASCII码</li><li>数字，0和1，ASCII码</li><li>汉字，0和1，GB2312码</li></ul></li><li><strong>压缩目标：</strong>用尽量短的码字表达信源符号，且一一对应</li><li>按照单个英文字母或单个汉字，与按照单词或词组，<strong>信源符号的个数不同</strong></li><li>不同环境下的信源符号、码元、码字，<strong>同一符号可能分别为信源符号或码元</strong></li></ul><h4 id="感知冗余"><a href="#感知冗余" class="headerlink" title="感知冗余"></a>感知冗余</h4><ul><li>视觉冗余（是否知道有哪些？）<ul><li><strong>亮度和色度的差别</strong>：人眼<strong>对亮度的敏感性比色度要强</strong>，所以在色度成分上，可以不要保留太多细节，这样可以使色度成分中出现更多的冗余。</li><li><strong>高亮度区和非高亮度区差别</strong>：在高亮度区，人眼的敏感度会下降。灰度值的量化可以更粗糙些，<strong>人类视觉系统一般分辨能力约为2<sup>6</sup>灰度等级，而一般图像量化采用2<sup>8</sup>灰度等级</strong>。</li><li><strong>边缘和非边缘区别</strong>:人眼对急剧色彩和亮度变化的<strong>物体边缘</strong>的敏感度比非边缘区域强<br>听觉冗余（在“音频数据压缩技术”中介绍）</li></ul></li></ul><h4 id="数据压缩方法分类"><a href="#数据压缩方法分类" class="headerlink" title="数据压缩方法分类"></a>数据压缩方法分类</h4><ul><li>根据解码（解压缩）后数据与原始数据是否完全一致，数据压缩方法分为两类<ul><li><strong>可逆编码</strong>(无失真编码，无损编码）：解码数据与原始数据（数字而非模拟）严格相同  </li><li><strong>不可逆编码(</strong>有失真编码，有损编码）： 解码数据与原始数据存在一定的误差，但感知效果一般可以接受。常用的有<strong>变换编码和预测编码</strong>等。</li></ul></li><li>根据数据压缩的原理可以分为<ul><li><strong>统计编码</strong>（<strong>针对信息熵冗余</strong>，即信息表达冗余）</li><li><strong>预测编码</strong>（<strong>针对统计冗余</strong>，即多媒体信号的相关性）</li><li><strong>变换编码</strong>（<strong>针对感知冗余</strong>，即多媒体信号的人类感知冗余）</li><li><strong>其他编码</strong></li></ul></li><li><strong>通用无损数据压缩</strong><ul><li>研究中发现，大多数信息表达都存在着一定的冗余度，通过采用一定的模型和编码方法，可以降低这种冗余度。</li><li><strong>eg.</strong> Huffman编码，算术编码，词典式编码，LZ78，LZW，ZIP格式。</li></ul></li><li><strong>(专用)多媒体数据压缩</strong><ul><li>采用成熟的通用数据压缩技术进行压缩</li><li>根据<strong>媒体信息的特性</strong>设计新的压缩方法</li><li><strong>eg.</strong> RLE编码(游程编码，适合压缩具有面积重复的颜色块的图像)，预测编码，变换编码</li></ul></li><li>数据压缩方法评价<ul><li><strong>压缩比</strong>（压缩效果：要求压缩比高</li><li><strong>算法复杂性和运算速度</strong>（压缩效率）：要求算法简单，压缩和解压缩速度快，最好能实时解压</li><li><strong>失真度</strong>（压缩质量）：要求恢复效果好</li><li>三个指标相互制约</li></ul></li></ul><h3 id="5-2-统计编码"><a href="#5-2-统计编码" class="headerlink" title="5.2 统计编码"></a>5.2 统计编码</h3><h4 id="统计编码的基本原理"><a href="#统计编码的基本原理" class="headerlink" title="统计编码的基本原理"></a>统计编码的基本原理</h4><ul><li>数据压缩技术的理论基础是<strong>信息论</strong>，根据信息论的原理，<strong>数据压缩的理论极限是信息熵</strong></li></ul><ul><li>如果要求编码过程中不<strong>丢失信息量（无损编码）</strong>，即要求保存信息熵，这种信息保持编码叫<strong>熵编码（统计编码）</strong></li><li>信息论认为信源中存在的冗余度来自于<strong>信源本身的相关性</strong>和<strong>信源概率分布的不均匀性</strong></li><li>熵编码（统计编码）要解决的问题是，如何利用信息熵理论<strong>减少数据在存储和传输中的冗余度</strong>。也就是要找到<strong>去除信源的相关性和概率分布的不均匀性</strong>的方法</li><li>无损压缩编码</li><li>根据信源符号出现概率的分布特性进行编码<ul><li><strong>概率大</strong>的信源符号用<strong>短码字</strong>表示</li><li><strong>概率小</strong>的信源符号用<strong>长码字</strong>表示</li><li>从而去除数据之间的冗余而达到压缩的目的</li></ul></li><li>统计编码需要在信源符号和码字之间确定严格的一一对应关系，以便准确无误地再现原来信源，同时使平均码长尽量小</li><li>如果所有的信源符号出现的概率相同，则说明平均信息量最大，也就不存在信源的冗余<ul><li>游程（RLE）编码</li><li>Huffman编码</li><li>算术编码</li></ul></li></ul><h4 id="游程（RLE）编码"><a href="#游程（RLE）编码" class="headerlink" title="游程（RLE）编码"></a>游程（RLE）编码</h4><ul><li>不需要存储每一个像素的颜色值，而仅仅存储一个像素的颜色值，以及具有相同颜色的连续像素数目</li><li>即，将颜色值相同的相邻像素用一个计数值和那些像素的颜色值来代替<ul><li>例如:aaabccccccddeee，则可用3a1b6c2d3e来代替</li></ul></li></ul><ul><li><strong>游程长度</strong>：具有相同颜色并且是连续的像素数目</li><li>对于拥有大面积，相同颜色区域的图像，用RLE压缩方法非常有效</li><li>无损压缩编码</li></ul><ul><li><strong>RLE压缩编码特点</strong><ul><li>直观，经济</li><li><strong>压缩比的大小，主要取决于图像本身的特点。</strong>如果图像中具有相同颜色的图像块越大，图像块数目越少，获得的压缩比就越高。反之，压缩比就越小</li><li><strong>适用于计算机生成的图像</strong>，但对颜色丰富的自然图像不仅不能压缩图像数据，反而可能使原来的图像数据变得更大。</li></ul></li></ul><h4 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h4><ul><li>统计编码，针对信息熵冗余，无损压缩编码</li><li>1952年为文本文件建立</li><li>编码方法简单且有效，得到广泛应用，现在已经派生出很多变体。</li><li><strong>基本原理</strong>：<ul><li>使用<strong>变长编码</strong>，对出现概率大的<strong>信源符号</strong>赋于短码字，而对于出现概率小的<strong>信源符号</strong>赋于长码字</li><li>如果码字长度严格按照所对应符号出现概率大小逆序排列，则编码结果平均码字长度一定小于任何其它排列方式。</li></ul></li><li><strong>步骤</strong>：<ol><li>将信源符号按概率递减顺序排列；</li><li>把二个最小概率相加作为新符号的概率, 并按(1)重排；</li><li>重复 (1)、(2)，直到概率为1；</li><li>在每次合并信源时,将合并的信源分别赋“0”和“1”(例如概率大的赋“0”,概率小的赋“1”)；</li><li>寻找从每一信源符号到概率为1处的路径，记录下路径上的“1”和“0”；</li><li>写出每一符号的“1”、“0”序列(从树根到信源符号节点)。<br><img src="/media/huf.png" width="50%"></li></ol></li><li>特点<ul><li>Huffman编码是最佳变长码，其优点是<strong>编码效率高</strong></li><li>Huffman编码<strong>依赖于信源的统计特性</strong></li></ul></li><li>Huffman编码是否只能得到唯一编码结果？<ul><li>由于“0”和“1”的指定可以是任意的，所以Huffman编码所得到的编码不是唯一的。</li><li>各次累加时对于信源符号可以任意指定0或1，并非一定要所有大概率信源符号使用相同编码，所有小概率信源符号使用相同编码。因为最终是以查表的方式查找信源符号的码字。</li></ul></li><li>Huffman编码结果是否需要考虑如何区分不同字符的编码？<ul><li>Huffman编码不需要附加同步代码，任何一个字符的编码，都不是另一个字符编码的前缀</li></ul></li><li>Huffman编码如何解码？特别是对于自适应概率模型解码？<ul><li>查表。因此在<strong>解码时需要有编码时采用的Huffman表</strong>，才能正确解码、</li><li>如果信源符号数（例如，汉字？）很大，需要存储的码表（码书）也需很大，从而会影响存储量、编码以及解码速度等各个方面的性能。</li></ul></li><li>根据Huffman编码得到的消息编码序列，是否可以从中间开始解码？<ul><li>Huffman编码是可变长度码，很难随意查找或调用压缩文件中间的内容</li></ul></li><li>Huffman编码没有错误保护功能，会出现错误传播</li><li>总结<ul><li>信源符号的概率统计模型 → Huffman表</li><li>编码：消息（由信源符号组成） → 根据Huffman表对于消息中的信源符号逐个编码  →  消息编码</li><li>解码：消息编码 → 根据Huffman表对于消息编码逐个解码 → 信源符号 → 消息</li></ul></li></ul><h4 id="算术编码"><a href="#算术编码" class="headerlink" title="算术编码"></a>算术编码</h4><ul><li>统计编码，针对信息熵冗余，无损压缩编码。</li><li>常用于图像数据压缩标准(如JPEG，JBIG)中</li><li><strong>基本原理</strong>：将出现概率较多的<strong>“消息”</strong>(可以是字符或字符串) (Huffman编码针对信源符号) ，用尽可能少的位或字节来表示。</li><li>算术编码是一种变长码，主要针对出现概率高的消息序列标识的信息进行压缩。<ul><li>信源符号是表达消息的符号</li></ul></li><li>算术编码用到的两个基本的参数是<strong>符号的概率</strong>和它的<strong>编码间隔</strong>。<ul><li>信源符号的概率决定压缩编码的效率，也决定编码过程中信源符号的间隔。</li><li>间隔则决定了符号压缩后的输出</li></ul></li><li>算术编码区别于Huffman编码的是，它是<strong>根据信源符号估计出各个元素的概率</strong>，然后进行<strong>迭代计算</strong>。而不像Huffman编码必须预先得知信源的出现概率。</li><li>将编码的消息表示成实数0和1之间的一个间隔，<strong>消息越长，编码表示它的间隔就越小，表示这一间隔所需的二进制位就越多</strong>。</li><li><strong>步骤</strong><ul><li>两个基本的参数：符号的概率和编码间隔(在0到1之间)。令概率为p<sub>1</sub>,p<sub>2</sub>,…p<sub>n</sub>（其和为1），则编码间隔为［0,p<sub>1</sub>) 、[p<sub>1</sub>，p<sub>1</sub>+p<sub>2</sub>）…[p<sub>1</sub>+p<sub>2</sub>+…p<sub>n-1</sub>，1）</li><li>令high为间隔的高端，low为低端，range为间隔的长度，rangelow为编码字符分配的间隔低端，rangehigh为编码字符分配的间隔高端。</li><li>初始<strong>high=1，low=0，range = high-low</strong></li><li>计算一个字符编码后新的low和high：<br><strong>low = low + range×rangelow</strong><br><strong>high = low + range×rangehigh</strong><br><img src="/media/算数编码.jpg" width="100%"></li></ul></li><li><strong>特点：</strong><ul><li>算术编码的精度在64位以内，对于运算中的溢出问题，可使用比例缩放方法解决</li><li>在解码器中<strong>需要添加一个专门的终止符</strong>，当解码器看到终止符时就停止解码，否则可以无穷尽地解码。</li><li>算术编码器对整个消息只产生一个码字，这个码字是在间隔[0，1）中的<strong>一个实数</strong>，解码器在接受到表示这个实数的所有位之前不能进行解码</li><li>算术编码也是一种<strong>对错误很敏感的编码方法</strong></li><li>算术编码可以<strong>是静态的或者自适应</strong>的。在静态算术编码中，信源符号的概率是固定的。但事先很难知道精确的信源概率。最有效的方法是在编码过程中估算概率，这就是自适应算术编码，信源符号的概率根据编码时符号出现的频繁程度动态地进行修改，也就是在编码期间估算信源符号概率建模。</li><li><strong>信源符号概率接近时，建议使用算术编码</strong>，这种情况下其效率高于Huffman编码(约5%) 。</li></ul></li></ul><h3 id="5-3-词典编码"><a href="#5-3-词典编码" class="headerlink" title="5.3 词典编码"></a>5.3 词典编码</h3><ul><li>词典编码：在不知数据统计特性的前提下的通用编码算法<ol><li>用已经出现过的字符串替代重复的部分，输出仅仅是指向早期出现过的字符串的“指针”。eg. <strong>LZ77算法</strong></li><li>创建一个“短语词典”。编码中遇到已在词典中出现的“短语”时，输出词典中的短语的“索引号” 。eg. <strong>LZ78算法</strong>，改进后为LZW压缩编码。</li></ol></li></ul><h4 id="LZW压缩编码算法"><a href="#LZW压缩编码算法" class="headerlink" title="LZW压缩编码算法"></a>LZW压缩编码算法</h4><ul><li>查找冗余字符和用较短的符号标记替代冗余字符</li><li>压缩效率较高（思考：为什么？）</li><li>无损压缩编码<ul><li>LZ77  →  LZ78  →  LZW</li></ul></li><li><strong>特点：</strong><ul><li>处理过程比其他压缩过程复杂，但过程完全可逆</li><li>对于简单图像和平滑且噪音小的信号源具有较高的压缩比，并且有<strong>较高的压缩和解压缩速度</strong>。对机器硬件条件要求不高</li><li>可压缩<strong>任何类型和格式的数据</strong>。</li><li>有错误传播（虽然是定长编码，但在解码过程中需要生成词典。如果存在错误，可能导致生成词典出错，甚至无法生成词典）</li></ul></li></ul><h4 id="各种编码方式的比较"><a href="#各种编码方式的比较" class="headerlink" title="各种编码方式的比较"></a>各种编码方式的比较</h4><p><img src="/media/编码.png" width="80%"></p><h3 id="预测编码-amp-变换编码"><a href="#预测编码-amp-变换编码" class="headerlink" title="预测编码 &amp; 变换编码"></a>预测编码 &amp; 变换编码</h3><ul><li>预测编码：根据离散信号之间存在一定的<strong>相关性</strong>的特点，利用前面的一个或多个信号对下一个信号进行<strong>预测</strong>，然后对实际值和预测值的<strong>差值</strong>进行<strong>编码</strong>。<ul><li>针对<strong>统计冗余</strong></li><li>有损压缩编码</li><li>适合于声音和图像数据的压缩</li></ul></li><li>变换编码：对欲编码的原始数据所在的时间或空间域<strong>进行某种数学变</strong>换，从一种信号空间变换到另一种信号空间，产生一批<strong>变换系数</strong>，使得通过变换后<strong>能够突出原始数据中的重要部分</strong>，以便重点处理。然后再对这些系数进行编码处理。<ul><li>数据变换的方式有：傅立叶变换、沃尔什变换、正弦变换、余弦变换、斜变换、哈尔变换、K-L变换等</li><li>针对<strong>感知冗余</strong></li><li>有损压缩编码</li><li>常用于音频信号压缩编码和图像/视频信号压缩编码</li></ul></li></ul><h3 id="5-4-音频信号压缩技术"><a href="#5-4-音频信号压缩技术" class="headerlink" title="5.4 音频信号压缩技术"></a>5.4 音频信号压缩技术</h3><ul><li>音频编译码器的分类<ul><li><strong>波形编译码器</strong>：不利用生成话音的信号的任何知识，将话音视为一种普通的声音，直接对波形信号进行采样和量化。 <strong>eg.PCM、DPCM、ADPCM等</strong></li><li>音源编译码器 / 参数编译码器 / 声码器：它从话音波形信号中提取话音生成模型的参数，使用这些参数通过话音生成模型重构出话音。</li><li><strong>混合编译码器</strong>：综合使用上述两种技术。使用的激励信号波形尽可能接近于原始话音信号的波形。<strong>eg. CELP， MPEGⅠ中的音频部分是一种混合编码</strong></li></ul></li></ul><h4 id="两类压缩"><a href="#两类压缩" class="headerlink" title="两类压缩"></a>两类压缩</h4><ul><li><strong>模拟信号转换为数字信号</strong><ul><li>降低采样频率，减少量化位数</li><li>音频信号编码，PCM、DM、DPCM</li></ul></li><li><strong>针对数字信号</strong><ul><li>统计编码，词典编码。无损。通用压缩编码</li><li>预测编码，变换编码。有损。多媒体数据专用压缩编码</li></ul></li></ul><h2 id="6-多媒体数据压缩标准"><a href="#6-多媒体数据压缩标准" class="headerlink" title="6. 多媒体数据压缩标准"></a>6. 多媒体数据压缩标准</h2><h3 id="6-1-图像数据压缩标准"><a href="#6-1-图像数据压缩标准" class="headerlink" title="6.1 图像数据压缩标准"></a>6.1 图像数据压缩标准</h3><h4 id="JPEG算法特点"><a href="#JPEG算法特点" class="headerlink" title="JPEG算法特点"></a>JPEG算法特点</h4><ul><li>JPEG是一个适用范围很广的静态图像数据压缩标准，既可用于<strong>灰度图像</strong>又可用于<strong>彩色图像</strong>（为什么？） <ul><li><strong>JPEG算法与色彩空间无关</strong>，因此“RGB到YUV变换”和“YUV到RGB变换”不包含在JPEG算法中。JPEG算法处理的彩色图像是单独的彩色分量图像，因此<strong>它可以压缩来自不同彩色空间的数据</strong>，如RGB, YCbCr和CMYK</li></ul></li><li>通常使用YUV模式（为什么？）<ul><li>JPEG不仅适于<strong>静止图像</strong>的压缩，<strong>电视图像的帧内图像的压缩编码</strong>，也常采用此算法（作为动态图像压缩的一个组成部分）</li></ul></li><li>JPEG标准还可以大范围地<strong>调节</strong>图像压缩比及其保真度（如何调节？）<ul><li>JPEG中的有损压缩利用了人的视觉系统的特性，使用<strong>变换编码+量化</strong>和<strong>无损压缩编码</strong>相结合来去掉<strong>视觉的冗余信息和数据本身的冗余信息</strong></li></ul></li></ul><h4 id="JPEG压缩编码算法的主要步骤"><a href="#JPEG压缩编码算法的主要步骤" class="headerlink" title="JPEG压缩编码算法的主要步骤"></a>JPEG压缩编码算法的主要步骤</h4><ol><li>图像分块<ul><li>分为8x8图像块；相关性强，标准化，计算量的考虑。</li></ul></li><li><strong>正向离散余弦变换(FDCT)</strong><ul><li>区分重要信息和次要信息 </li></ul></li></ol><ul><li>量化<ul><li>减小非“0”系数的幅度以及<strong>增加“0”值系数的数目</strong>。</li><li>重要系数和次要系数采用不同的量化步长。分别处理，量化表可以不同，可调节压缩比和压缩质量。</li><li>不能使用一个值作为所有系数的量化系数，需要体现相对于感知冗余的不同系数的不同重要性。</li></ul></li><li>Z字形编排<ul><li>增加0值系数的长度</li></ul></li><li>使用差<strong>分脉冲编码调制(DPCM)</strong>对直流系数(DC)进行编码<ul><li>直流DC系数特点：相关性预测编码</li><li>进一步压缩：预测编码，DPCM</li></ul></li><li>使用<strong>游程长度编码(RLE)</strong>对交流系数(AC)进行编码<ul><li>交流AC系数特点：0值系数较多</li><li>进一步压缩：RLE游程编码 </li></ul></li><li><strong>熵编码</strong></li><li>组成位数据流</li><li><strong>各种压缩技术的组合</strong></li></ul><h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><ol start="2"><li>为什么不使用整个图像而使用分块图像？<ul><li>局部图像的相关性比整体图像的相关性更强</li><li>算法标准化</li><li>计算量的考虑</li></ul></li></ol><ul><li>采样精度为P位(二进制)，把[0，2<sup>P-1</sup>]范围的无符号数变换成[-2<sup>P-1</sup>，2<sup>P-1</sup>-1]范围的有符号数（为什么？），作为正向离散余弦变换的输入，通过DCT变换，把能量集中在少数几个系数上。<ul><li>使得变换后的系数分布于[-2<sup>P-1</sup>，2<sup>P-1</sup>-1]</li></ul></li><li>对经过FDCT变换后的系数进行量化（为什么？）<ul><li>目的是减小非“0”系数的幅度以及增加“0”值系数的数目</li><li>量化是图像质量下降的最主要原因 </li></ul></li><li>对经过FDCT变换后的系数进行量化（为什么？）<ul><li>目的是减小非“0”系数的幅度以及增加“0”值系数的数目</li><li>量化是图像质量下降的最主要原因 </li></ul></li><li>量化后的系数按Z字形编排（为什么？）<ul><li>目的是为了增加连续的“0”系数的个数，就是“0”的游程长度</li></ul></li><li>变换编码提到通过正交变换减少相关性，为什么这里还有相关性存在并可以加以利用？<ul><li>DCT变换减少的是8×8块内部各像素之间的相关性，但各8×8块之间的相关性依然存在</li></ul></li><li>DC、AC系数表达的特点？如何进一步压缩？<ul><li>信息表达的冗余</li><li>熵编码，先转化为中间符号</li></ul></li></ul><h4 id="JPEG图像文件格式-amp-JPEG2000"><a href="#JPEG图像文件格式-amp-JPEG2000" class="headerlink" title="JPEG图像文件格式 &amp;  JPEG2000"></a>JPEG图像文件格式 &amp;  JPEG2000</h4><ul><li>JEPG文件大体上可以分成两个部分：<strong>标记码</strong>（tag）和<strong>压缩数据</strong><ul><li><strong>标记码部分给出了JPEG图像的所有信息</strong>，如图像的宽、高、Huffman表、量化表等等</li></ul></li><li>JPEG2000主要特点<ul><li><strong>高压缩率</strong>。在具有和传统JPEG类似质量的前提下，JPEG2000的<strong>压缩率比JPEG高30%左右</strong>。</li><li><strong>同时支持有损和无损压缩</strong></li><li><strong>渐进传输。</strong>即先传输图像的轮廓，然后逐步传输数据，不断提高图像质量，让图像由朦胧到清晰显示，以满足用户的需要。从而节约、充分利用有限的带宽。</li><li><strong>感兴趣区域压缩</strong>。即可以指定感兴趣区域，在这些区域，可以在压缩时指定特定的压缩质量，或在恢复时指定特定的解压缩要求。</li></ul></li></ul><h3 id="6-2-动态图像压缩标准MPEG"><a href="#6-2-动态图像压缩标准MPEG" class="headerlink" title="6.2 动态图像压缩标准MPEG"></a>6.2 动态图像压缩标准MPEG</h3><h4 id="MPEG-Video压缩技术基本方法"><a href="#MPEG-Video压缩技术基本方法" class="headerlink" title="MPEG-Video压缩技术基本方法"></a>MPEG-Video压缩技术基本方法</h4><ul><li>如何分别实现图像空间方向压缩和运动图像时间方向压缩？<ul><li>在<strong>空间方向</strong>上，图像数据压缩采用<strong>JPEG压缩算法</strong>来去掉冗余信息</li><li>在<strong>时间方向</strong>上，图像数据压缩采用<strong>运动补偿算法</strong>来去掉冗余信息</li></ul></li></ul><h4 id="MPEG定义的三种图"><a href="#MPEG定义的三种图" class="headerlink" title="MPEG定义的三种图"></a>MPEG定义的三种图</h4><ul><li><strong>I图像（帧内图）</strong><ul><li>采用帧内编码方式，即只利用了单帧图像内的空间相关性，而没有利用时间相关性</li><li>与JPEG压缩算法大致相同</li><li>压缩后每个像素为1～2bit</li><li><strong>一个内帧是一个随机访问点</strong></li><li><strong>可作为其它图像的参考帧</strong></li></ul></li><li><strong>P图像（预测图）</strong><ul><li>用最近的前一个I图像(或P图像)预测编码得到</li><li>只采用前向时间预测</li></ul><ul><li>可以提高<strong>压缩比和图像质量</strong></li><li><strong>可作为其它图像的参考帧</strong></li></ul></li><li><strong>B图像（插补图，即双向预测图）</strong><ul><li>B图像在预测时, 既可使用前一个图像作参照, 也可使用后一个图像做参照或同时使用前后两个图像作为参照图像(双向预测)</li><li>采用双向时间预测可以大大提高压缩比</li><li><strong>不可作为其它图像的参考帧</strong></li></ul></li><li>P图像和B图像采用帧间编码方式，即同时利用了空间和时间上的相关性</li></ul><h2 id="7-多媒体应用系统创作技术"><a href="#7-多媒体应用系统创作技术" class="headerlink" title="7. 多媒体应用系统创作技术"></a>7. 多媒体应用系统创作技术</h2><h4 id="多媒体应用系统设计基本过程"><a href="#多媒体应用系统设计基本过程" class="headerlink" title="多媒体应用系统设计基本过程"></a>多媒体应用系统设计基本过程</h4><ul><li>多媒体应用系统适用于各个领域，多媒体软件融图、文、声、像于一体，它的创作是一项系统工程，涉及到多种因素。</li><li>主要涉及到制作人员、制作环境和制作步骤三个方面</li><li>包含<strong>系统目标确定、编写系统脚本、进行脚本分析、脚本制作、脚本测试、系统评价</strong>等</li></ul><h4 id="多媒体系统创作工具"><a href="#多媒体系统创作工具" class="headerlink" title="多媒体系统创作工具"></a>多媒体系统创作工具</h4><ul><li>基于<strong>多媒体著作工具的多媒体系统创作</strong></li><li>包括：<ul><li>Hypercard</li><li>ToolBook</li><li>Authorware Professional</li><li>IconAuthor</li><li>Action</li><li>Director</li><li>PowerPoint</li><li>Animation Works Interactive</li><li>Storyboard</li><li>方正奥思多媒体创作工具</li><li>洪图多媒体编著系统</li></ul></li></ul><h4 id="多媒体程序设计基础"><a href="#多媒体程序设计基础" class="headerlink" title="多媒体程序设计基础"></a>多媒体程序设计基础</h4><ul><li>在Windows系统中，对多媒体设备进行控制主要有<strong>三种方法</strong>：<ul><li><strong>使用Microsoft提供的多媒体控制接口MCI</strong>，MCI是多媒体设备和多媒体应用软件之间进行设备无关的沟通的桥梁</li><li><strong>通过调用Windows的应用程序接口API多媒体相关函数</strong>实现媒体控制</li><li><strong>使用对象链接与嵌入OLE</strong>为不同软件之间共享数据和资源提供了有效的手段</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记</title>
      <link href="/ml/"/>
      <url>/ml/</url>
      
        <content type="html"><![CDATA[<h2 id="0-机器学习概述"><a href="#0-机器学习概述" class="headerlink" title="0. 机器学习概述"></a>0. 机器学习概述</h2><h4 id="机器学习基本任务"><a href="#机器学习基本任务" class="headerlink" title="机器学习基本任务:"></a>机器学习基本任务:</h4><ul><li><strong>回归</strong>：<ul><li>能解决分类、预测问题。</li><li>eg. 年龄估计、表情分析<a id="more"></a></li></ul></li><li><strong>分类</strong>：<ul><li>分类、识别、检测</li></ul></li><li><strong>聚类</strong>：<ul><li>分割(图像、视频)、背景建模</li><li>数据挖掘、数据恢复</li><li>字典学习(视觉信息，文本)</li></ul></li><li><strong>表征</strong>：<ul><li>特征提取(便于前三个任务解决)</li><li>数据重构</li><li>信息检索</li></ul></li></ul><h4 id="方法分类-根据学习形式"><a href="#方法分类-根据学习形式" class="headerlink" title="方法分类(根据学习形式)"></a>方法分类(根据学习形式)</h4><ul><li><strong>有监督学习</strong><ul><li>数据都有明确的标签，根据机器学习产生的模型可以将新数据分到一个明确的类或得到一个预测值。</li><li>eg. 支持向量机、贝叶斯分类器、决策树、线性判别分析…….</li></ul></li><li><strong>无监督学习</strong><ul><li>数据没有标签，机器学习出的模型是从数据中提取出来的模式(提取决定性特征或者聚类等)</li><li>eg. K均值、Meanshift、主成分分析、典型相关分析</li></ul></li><li><strong>半监督学习</strong><ul><li>部分数据有明确的标签，根据机器学习产生的模型可以将新数据分到一个明确的类或得到一个预测值。</li><li>eg. 图直推学习、超图直推学习……</li></ul></li></ul><h4 id="数据划分"><a href="#数据划分" class="headerlink" title="数据划分"></a>数据划分</h4><ul><li>训练集：用来训练模型或确定模型参数。</li><li>测试集：测试已经训练好的模型的推广能力。</li><li>验证集(可选)：用来做模型选择，即做模型的最终优化及确定的。</li></ul><h4 id="误差与精度"><a href="#误差与精度" class="headerlink" title="误差与精度"></a>误差与精度</h4><ul><li>误差：学习器的实际预测输出与 样本的真实输出之间的差异。</li><li>错误率：被错误分类的样本在总样本中的比例。</li><li>精度：被正确分类的样本在总样本中的比例，即1 – error rate。</li><li>训练误差：学习器在训练集上的误差。</li><li>经验误差：即训练误差</li><li>泛化误差：在新样本的误差，实际误差!</li><li>测试误差：学习器在测试集上的误差，用来近似泛化误差。</li></ul><h4 id="过拟合与欠拟合"><a href="#过拟合与欠拟合" class="headerlink" title="过拟合与欠拟合"></a>过拟合与欠拟合</h4><ul><li>过拟合(Overfitting): 为了得到一致假设而使假设变得<strong>过度严格</strong>。</li><li>欠拟合(Underfitting): 模型没有很好地捕捉到数据特征，<strong>不能够很好地</strong>拟合数据</li></ul><h4 id="数据集划分策略"><a href="#数据集划分策略" class="headerlink" title="数据集划分策略"></a>数据集划分策略</h4><ul><li>数据集划分策略：利用测试集或验证集评估学习器的泛化 误差，进而进行模型优化与选择，避免 过拟合。</li><li>常见划分策略:<ul><li>留出法</li><li>交叉验证法</li><li>自助法</li></ul></li><li>数据集划分各子集之间<strong>不能有重合</strong>。</li><li><strong><code>留出法</code></strong><ul><li>直接将数据集D划分为两个互斥的集合，分别为训练集S与测试集T，即 D = S T， S T =  。</li><li>训练/测试集划分尽量保持数据一致性。</li><li>采用合理的采样，合理控制训练集与测试集比例。</li><li>多次使用留出法，重复进行试验评估，求均值，减少数据分布差异造成的偏差。</li></ul></li><li><strong><code>交叉验证法</code></strong><ul><li>n-折交叉验证法：数据集等 分为n份相互不重叠的子集，每次以其中1份子集作为 测试集，其余n-1份子集作为训练集，重复n次，<strong>直至所有子集都作为测试集进行过一次实验评估</strong>，最后返 回n次实验评估的平均结果。常见n取值2、5、10、20。</li><li>交叉验证是最常见数据集划分方法。</li></ul></li><li><strong><code>留一法</code></strong><ul><li>特殊的交叉验证法，每个被划分的子集只有一个样本。</li><li>优点：训练集比例高，训练出来模型与用所有数据进行训练的模型<strong>相似度高</strong>。</li><li>缺点：评估开销大；测试集比例太低，模型调参不便。 </li></ul></li><li><strong><code>自助法</code></strong><ul><li>假设一个由m个样本组成数据集D，对其进行m次<strong>随机采样</strong>构造一个由m个样本组成新数据集D’, 由于m次随机采样可能会对D中部分样本重复采样，所以D’中有部分样本是完全相同，而D中 有部分样本是没有被采样到数据集D’中。因此我们可以把D中这部分<strong>没有被采样到样本D\D’构造测试集， 而D’作为训练集。</strong></li><li>这种没被采样到样本在数据集D中比例一般占 25%~36.8%之间。</li><li>自助法通常用于<strong>数据集较小或难以有效划分训练/测试集情况。</strong></li></ul></li></ul><h4 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h4><ul><li>真正例TP 真反例TN 假正例FP 假反例FN<ul><li>(TP+FN)+(TN+FP) = P + N = 样本总数</li></ul></li><li><strong>均方误差</strong>：多用于度量学习器解决<strong>回归任务</strong>的性能。</li><li><strong>错误率与精度</strong>：多用于评估分类任务的性能。</li><li><strong>查准率、查全率与F1</strong> ：<ul><li>查准率：被正确分类的正例样本在被学习器分类为正例样本中所占的比例。</li><li>查全率：被正确分类的正例样本在正例样本中的比例。</li><li>查全率与查准率是一对相互矛盾的度量。</li></ul></li><li><strong>ROC与AUC</strong><ul><li>二分类问题的性能度量：根据置信度对样本进行降序排序… </li><li>受试者工作特征(ROC)曲线</li><li>AUC：ROC曲线下的面积</li></ul></li></ul><h2 id="1-线性回归"><a href="#1-线性回归" class="headerlink" title="1. 线性回归"></a>1. 线性回归</h2><ul><li>损失函数<ul><li>平方损失函数</li><li>绝对损失函数</li><li>平均损失函数</li></ul></li><li><strong><code>单变量回归模型</code></strong><br><img src="/ml/线性1.png" width="50%"><img src="/ml/线性3.png" width="50%"></li><li><strong><code>多元线性回归</code></strong><br><img src="/ml/线性2.png" width="50%"><br><img src="/ml/线性4.png" width="50%"><img src="/ml/线性5.png" width="50%"></li><li>概率解释<ul><li>似然函数</li><li><strong>极大似然法</strong>：令每个样本x<sub>i</sub>输出为y<sub>i</sub>的概率越大越好。</li></ul></li><li>回归任务的思想：分析变量之间的关系</li><li>定义了损失函数来评估线性回归模型的好坏：平方损失函数、极大似然函数。</li><li>线性回归函数中两个参数的显示表达：最小二乘法(向量与矩阵形式)</li><li>线性回归算法可以对数据进行分析、预测。</li><li>线性回归的概率解释：极大似然法</li></ul><h2 id="2-逻辑回归"><a href="#2-逻辑回归" class="headerlink" title="2. 逻辑回归"></a>2. 逻辑回归</h2><ul><li>逻辑回归与线性回归的区别与联系：<ul><li>逻辑回归是用于解决二分类问题的机器学习方法。</li><li>线性回归要求因变量是连续性数值变量，逻辑回归要求因变量是分类型变量。</li></ul></li><li>逻辑回归的损失函数：<strong>分类损失函数</strong> </li><li><strong>求解无约束优化问题</strong>：<ul><li>数值方法I：<strong>牛顿法</strong> -&gt; 方程求根问题 / 最小化问题</li><li>数值方法II：<strong>梯度下降法</strong> y<sub>n</sub>是第n步下降时选取的步长，也称学习旅率。</li></ul></li><li>掌握梯度下降法、牛顿法的基本原理与迭代公式：<br><img src="/ml/牛顿.png" width="50%">  </li></ul><h2 id="3-决策树"><a href="#3-决策树" class="headerlink" title="3. 决策树"></a>3. 决策树</h2><ul><li>决策树：构建一个基于属性的<strong>树形分类器</strong>。<ul><li>每个非叶节点表示一个特征属性上的测试(分割)。</li><li>每个分支代表这个特征属性在某个值域上的输出。</li><li>每个叶节点存放一个类别。</li></ul></li><li>使用决策树进行决策的过程：<ul><li>从根节点开始，测试待分类项中相应的特征属性，并按照其值选择输出分支，直到到达叶子节点，将叶子节点存放的类别作为决策结果。</li></ul></li><li>决策树构建：<strong>分治法思想(递归)</strong></li><li>对于当前结点<strong>返回递归条件</strong> / <strong>递归结束条件</strong>:<ul><li>当前结点样本均属于同一类别，无需划分。</li><li>当前属性集为空。</li><li>所有样本在当前属性集上取值相同，无法划分。 </li><li>当前结点包含的样本集合为空，不能划分。</li></ul></li></ul><h4 id="决策树的核心"><a href="#决策树的核心" class="headerlink" title="决策树的核心"></a>决策树的核心</h4><ul><li>定义最佳划分属性:<ul><li>经过属性划分后，不同类样本被更好的分离。</li><li>理想情况:划分后样本被完美分类。即每个分支的样本都属于同一类。</li><li>实际情况:不可能完美划分。尽量使得每个分支某一类样本比例尽量高，即尽量提高划分后子集的纯度(purity)。</li></ul></li><li>最佳划分属性目标: <ul><li>提升划分后子集的纯度</li><li>降低划分后子集的不纯度</li></ul></li></ul><h4 id="ID3决策树算法"><a href="#ID3决策树算法" class="headerlink" title="ID3决策树算法"></a>ID3决策树算法</h4><ul><li>我们希望决策树的分支节点所包含的样本尽可能属于同一类别，即结点的“纯度”越来越高。</li><li>纯度 ↑ = 确定性 ↑ = 信息量 ↓ </li><li><strong><code>信息熵</code></strong>：<strong>度量样本集合纯度</strong>最常用的一种指标。<ul><li>假定当前样本集合D中第k类样本所占的比例为p<sub>k</sub>(k = 1, 2, …, |y|)，则D的信息熵为：<br><img src="/ml/信息熵.png" width="30%"></li><li>信息熵用来度量信息量，<strong>信息熵值越小，说明样本集的纯度越高。</strong></li></ul></li><li><strong><code>信息增益</code></strong>：<br><img src="/ml/信息增益.png" width="50%"></li><li>ID3决策树算法：<strong>利用</strong>划分后的<strong>信息增量来判断</strong>属性划分的优劣性。<ul><li><strong>信息增益越大，说明当前划分效果越好。</strong></li><li>信息增量准则对可取值数目较多的属性有所偏好。 eg. 每个学号因为只有一个样本，纯度都很高。</li></ul></li></ul><h4 id="C4-5决策树算法"><a href="#C4-5决策树算法" class="headerlink" title="C4.5决策树算法"></a>C4.5决策树算法</h4><ul><li><strong><code>增益率</code></strong>：越大越好<br><img src="/ml/增益率.png" width="50%"></li><li>采用此新准则的方法称为C4.5决策树算法。</li></ul><h4 id="CART决策树算法"><a href="#CART决策树算法" class="headerlink" title="CART决策树算法"></a>CART决策树算法</h4><ul><li><strong><code>基尼指数</code></strong>：越小 -&gt; 纯度越高 -&gt; 越好<br><img src="/ml/gini.png" width="40%"></li></ul><h4 id="决策树的裁剪"><a href="#决策树的裁剪" class="headerlink" title="决策树的裁剪"></a>决策树的裁剪</h4><ul><li>剪枝处理：避免训练<strong>过拟合</strong>。 </li><li><strong><code>预剪枝</code></strong>：指<strong>在决策树生成过程中</strong>，对每个结点在划分前后进行估计，若当前结点划分不能提升决策树泛化性能，则进行裁剪，把结点标记为叶结点。<ul><li>优点: 减少属性划分与测试时间开销。 </li><li>缺点: 可能造成欠拟合。</li></ul></li><li><strong><code>后剪枝</code></strong>：在<strong>生成一颗完整的决策树后</strong>，<strong>自底向上</strong>地对非叶结点进行考察，若将该结点对应的子树被替换为叶节点能提升决策树泛化能力，则进行裁剪。<ul><li>优点: 减少欠拟合风险。 </li><li>缺点: 时间开销大。</li></ul></li></ul><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul><li>决策树ID3算法能不能进一步优化? <ul><li>𝐺𝑎𝑖𝑛𝐷,𝑎 = 𝑬𝒏𝒕𝑫 − 𝐸𝑛𝑡𝐷,𝑎 减少开销</li></ul></li><li>如何设计自己决策树算法?<ul><li>设计自己的划分属性优劣性目标函数。</li></ul></li><li>现有决策树框架的分类是否是全局最优? <ul><li>决策树采用<strong>贪心法则</strong>，只得<strong>局部最优</strong>。</li></ul></li><li>如何提升决策树算法框架的性能?<ul><li>融入随机性，提升泛化能力，Eg.<strong>随机森林</strong>。</li></ul></li><li>划分属性优劣度量(重点) <ul><li>ID3算法：信息增益</li><li>C4.5算法：增益率 </li><li>CART算法：基尼指数</li></ul></li></ul><h2 id="4-感知机"><a href="#4-感知机" class="headerlink" title="4. 感知机"></a>4. 感知机</h2><h4 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h4><ul><li>感知机由两层神经元组成，输入层接受外界输入信号后传递给输出层，输出层是M-<br>本质上, M-P神经元 = <strong>线性二分类</strong>器</li><li>感知机能容易地实现逻辑与、或、非运算。 <strong>P99</strong>(感知机<strong>不能解决异或</strong>这样的非线性可分问题)</li><li>感知机只有输出神经元进行激活函数处理，即只拥有一层功能神经元。<ul><li>只能解决线性可分问题：存在一个线性超平面将他们分开，感知机的学习过程收敛。</li><li>否则感知机学习过程会发生振荡。</li></ul></li></ul><h4 id="多层神经网络"><a href="#多层神经网络" class="headerlink" title="多层神经网络"></a>多层神经网络</h4><ul><li>非线性可分问题：多层功能神经元。</li><li>多层网络的<strong>权重优化法则</strong>：<strong>误差逆传播(简称BP)算法</strong>。</li></ul><h4 id="BP算法-P101"><a href="#BP算法-P101" class="headerlink" title="BP算法 P101"></a>BP算法 P101</h4><ul><li>基于梯度下降策略，是一个迭代学习算法。</li><li>核心思想：利用前向传播，计算第 𝑛 层输出值。</li><li>优化目标：输出值和实际值的残差。(最小化训练集D上的累积误差)</li><li>计算方法：将残差按影响逐步传递回第 𝑛 −1, 𝑛 − 2, ⋯ , 2层，以修正各层参数。(即所谓的误差逆传播)</li><li>主要工具：链式法则(复合函数求偏导)。</li><li>BP算法局限性<ul><li>容易过拟合 -&gt; 早停、正则化</li><li>容易陷入局部最优 -&gt; 选取多次初值、随机梯度下降法</li><li>难以设置隐层个数 -&gt; 试错法</li></ul></li></ul><h2 id="5-神经网络"><a href="#5-神经网络" class="headerlink" title="5. 神经网络"></a>5. 神经网络</h2><ul><li>神经网络: 神经网络是由具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实世界物体所做的交互反应。<br><img src="/ml/神经元.png" width="60%"><ul><li>Sigmoid函数 ≠ Logistic函数</li><li>Logistic函数 ⊂ Sigmoid函数</li></ul></li></ul><h2 id="6-支持向量机-SVM模型"><a href="#6-支持向量机-SVM模型" class="headerlink" title="6. 支持向量机(SVM模型)"></a>6. 支持向量机(SVM模型)</h2><h4 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h4><ul><li>离分类边界远的样本的置信度高，而离分类边界近的样本置信度低。</li><li>SVM是一个凸的带不等式约束的凸二次规划问题</li><li><strong>基本思想：</strong>寻找两类样本之间最中间的直线。</li><li><strong>目的：</strong>使划分平面对于样本的扰动容忍性好。</li><li>对比：<ul><li>逻辑回归算法是基于全部样本的二分类器：考虑<strong>全部样本的平均似然性</strong>。</li><li>支持向量机算法是基于部分样本的二分类器：考虑<strong>部分靠近边界</strong>的支持向量。</li></ul></li></ul><h4 id="拉格朗日乘子法"><a href="#拉格朗日乘子法" class="headerlink" title="拉格朗日乘子法"></a>拉格朗日乘子法</h4><ul><li>拉格朗日乘子法：求解约束优化问题常用的方法之一。</li><li>基本思想：<strong>求解与之等价的无约束对偶问题</strong>。</li><li>较之原问题来说，对偶问题可能更方便求解。</li><li>较之原问题来说，对偶问题也可能更有意义。</li><li>原问题和对偶问题等价的充分必要条件被称作KKT条件</li></ul><h4 id="SVM对偶模型"><a href="#SVM对偶模型" class="headerlink" title="SVM对偶模型"></a>SVM对偶模型</h4><ul><li>可以利用拉格朗日乘子法得到SVM的对偶模型。</li><li>对偶模型更能反映该问题的特点，只有支持向量才对优化问题起作用。</li><li>求解对偶模型的比求解原问题简单，计算复杂度更低。</li></ul><h4 id="软间隔SVM"><a href="#软间隔SVM" class="headerlink" title="软间隔SVM"></a>软间隔SVM</h4><ul><li>前面的讨论一直假定训练样本在样本空间或者特征空间中是线性可分的，即存在一个超平面能将不同的类的样本完全划分开。</li><li>在现实任务重很难确定合适的核函数使得训练集在特征空间中线性可分。<ul><li>缓解该问题的一个办法是允许支持向量机在一些样本上出错。</li><li>硬间隔：要求所有样本均满足约束。</li><li>软间隔：允许某些样本不满足约束。在最大化间隔的同时，不满足约束的样本应该尽可能少。</li></ul></li><li>软间隔SVM三种常见的替代损失函数：<ul><li>hinge损失</li><li>指数损失</li><li>对率损失</li></ul></li><li>软间隔SVM可以对有outlier的数据分类。<ul><li>软间隔SVM对偶模型与SVM对偶模型非常相似，可以用相同算法求解。</li><li>软间隔SVM模型可以看作是最小化hinge损失函数的正则化模型。</li><li>当参数C趋向无穷大时，软间隔SVM退化成普通的SVM。</li></ul></li></ul><h4 id="SMO算法"><a href="#SMO算法" class="headerlink" title="SMO算法"></a>SMO算法</h4><ul><li>SMO的两个部分:<ul><li>解析地求解两个变量二次规化问题。</li><li>启发式地选择变量。</li></ul></li><li>SMO小结<ul><li>序列极小化优化算法(SMO)是求解SVM模型最高效的算法。</li><li>SMO每次迭代解两个变量的二次优化问题，其最优解可以显式表达。</li><li>SMO利用了启发式算法根据数据点违反KKT条件的大小选取需要迭代的变量。</li></ul></li></ul><h4 id="非线性SVM-核化SVM-P126"><a href="#非线性SVM-核化SVM-P126" class="headerlink" title="非线性SVM / 核化SVM P126"></a>非线性SVM / 核化SVM P126</h4><ul><li>核技巧是处理非线性分布数据处理问题最常见的方法之一。</li><li>核技巧最早出线在SVM模型中，随后在许多机器学习领域都有应用。。</li><li>核化SVM的效果主要取决于核函数的选取。</li></ul><h4 id="支持向量回归SVR-P133"><a href="#支持向量回归SVR-P133" class="headerlink" title="支持向量回归SVR P133"></a>支持向量回归SVR P133</h4><ul><li>线性回归问题<ul><li>寻找最佳直线(超平面)，使得预测值𝒇(𝒙𝒊 )和真实标签的均方误差尽量小。</li></ul></li><li>支持向量机思想<ul><li>寻找最佳直线(超平面)，使得数据点到直线的间隔尽可能的大。</li></ul></li></ul><h2 id="7-K-均值-聚类"><a href="#7-K-均值-聚类" class="headerlink" title="7. K-均值(聚类)"></a>7. K-均值(聚类)</h2><h4 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h4><ul><li>聚类：根据某种<strong>相似性</strong>，把一组数据<strong>划分</strong>成<strong>若干个簇</strong>的过程。<ul><li>难点一:相似性很难精准定义! <strong>各种距离，度量学习</strong>。 </li><li>难点二:可能存在的划分太多! <strong>避免穷举，优化算法</strong>。 </li><li>难点三: 若干个簇 = ? <strong>预先给定，算法自适应</strong>。</li></ul></li></ul><h4 id="K-means-K均值算法"><a href="#K-means-K均值算法" class="headerlink" title="K-means / K均值算法"></a>K-means / K均值算法</h4><ul><li>聚类问题可以通过为每个簇簇的中心寻找合适的中心来实现。</li><li>假设每个簇的中心已经找到， 可以把所有数据点分配到距离它最近的中心所在的簇。</li><li>K-means模型可能的划分数：<strong>非凸组合优化问题</strong>，NP-难</li><li>求解非凸组合优化问题的两种常见方法:<ul><li><strong>启发式方法</strong>: 一个基于直 观或经验构造的算法，在可接受的时间内下 给出待解决组合优化问题每一个实例的一个 可行解，该可行解与最优解的偏离程度一般不能被预计。</li><li><strong>松弛方法</strong>: 对组合优化问题进行适当的松弛，将其转化为多项式时间内可解的优化问题，松弛后问题的解不是原组合优化问题的解，需要适当的后处理。</li></ul></li></ul><h4 id="K-means模型的矩阵形式"><a href="#K-means模型的矩阵形式" class="headerlink" title="K-means模型的矩阵形式"></a>K-means模型的矩阵形式</h4><ul><li>对于任意一种划分都对应一个<strong>标准化示性矩阵 H</strong>(或<strong>均一化邻接矩阵 W</strong> )。</li><li>反之，任意一个标准化示性矩阵 H (或均一化邻接矩阵 W )都对应着<strong>一种划分</strong>。</li><li>本质上说，标准化示性矩阵 H(或均一化邻接矩阵 W ) 的引入并没有简化聚类问题的难度，但是<strong>为求解方法提供了更多的参考和选择</strong>。</li></ul><h4 id="Lloyd算法"><a href="#Lloyd算法" class="headerlink" title="Lloyd算法"></a>Lloyd算法</h4><p> <img src="/ml/lloyd.png" width="50%"><img src="/ml/lloyd2.png" width="50%"></p><ul><li>优势：<ul><li>Lloyd 算法属于EM算法(期望最大化)，可以保证收敛到K-means问题的局部最优解。</li><li>Lloyd 算法的速度快，计算复杂度为O(nk)。</li><li>Lloyd 算法思想简单，容易实现，可拓展性强。</li></ul></li><li>劣势:<ul><li>簇的个数k需要预先给定。</li><li>聚类结果依赖于初值的选取。</li></ul></li></ul><h2 id="8-谱聚类-聚类"><a href="#8-谱聚类-聚类" class="headerlink" title="8. 谱聚类(聚类)"></a>8. 谱聚类(聚类)</h2><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><ul><li>输入: 数据矩阵 X，簇个数 k。<ul><li>构建邻接矩阵W。</li><li>计算<strong>拉普拉斯矩阵L</strong>。 </li><li>计算L最小k个特征值对应的特征向量U。</li><li>对U进行<strong>K-means</strong>聚类。</li></ul></li><li>输出: k 个簇。</li></ul><h4 id="谱聚类和K-means的关系"><a href="#谱聚类和K-means的关系" class="headerlink" title="谱聚类和K-means的关系"></a>谱聚类和K-means的关系</h4><ol><li>相比直接进行K-means聚类，谱聚类有什么不同?<ul><li>相当于<strong>先做了一次特征提取</strong>，再聚类。</li></ul></li><li>谱聚类背后的机理是什么? <ul><li>图论中的<strong>切割图问题。</strong></li></ul></li></ol><h2 id="9-降维"><a href="#9-降维" class="headerlink" title="9. 降维"></a>9. 降维</h2><h4 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h4><ul><li>为什么要降维?<ul><li>去除不相关的特征(去噪、特征提取) </li><li>储存与计算</li><li>可视化</li><li>数据本身具有低维特点</li></ul></li><li>线性降维方法:<ul><li>PCA </li><li>LDA </li><li>SVD </li><li>NMF</li></ul></li><li>非线性降维方法:<ul><li>Kernel PCA </li><li>Isomap</li><li>MDS</li></ul></li></ul><h4 id="主成分分析-PCA"><a href="#主成分分析-PCA" class="headerlink" title="主成分分析 PCA"></a>主成分分析 PCA</h4><blockquote><p><strong>思想</strong>: 假设降维的目的是解决维度灾难，在低维空间进行分类。那么我们希望降维后的样本保持<br>一定的可分性，即经过投影之后，同类样本的投 影点尽可能接近，异类样本的投影点尽可能远离。</p><blockquote><p><strong>解决方案</strong>: 让投影后的<strong>类中心之间的距离尽可能大</strong>，从而增强样本的可分性。</p></blockquote></blockquote><ul><li>PCA: 最大可分性<br><img src="/ml/pca.png" width="50%"><img src="/ml/pca2.png" width="36%"></li><li>PCA在考虑数据降维时候希望在新空间的信息越多 越好，即低维嵌入的方差(协方差矩阵的迹)越大。</li><li>PCA是一个<strong>无监督降维方法</strong>，并没有运用任何有监督信息，这也是PCA算法一个弊端。</li><li>对于一个分类问题，保留信息越多分类效果一定 会更好么?<ul><li>不一定，分类效果完全取决样本在新的子空间下的<strong>可区分度</strong>。</li></ul></li></ul><h4 id="线性判别分析-LDA"><a href="#线性判别分析-LDA" class="headerlink" title="线性判别分析 LDA"></a>线性判别分析 LDA</h4><ul><li>对于二维数据来说，线性判别分析(Linear Discriminant Analysis)同时最大化类间散度矩阵，最小化类内散度矩阵。</li><li><strong>目标函数</strong>通常被成为<strong>广义瑞利商</strong>，最优解为广义特征值问题。<ul><li>可以构建拉格朗日函数 -&gt; 𝓛对变量𝒘求偏导 -&gt; 对偶问题</li></ul></li><li>此模型的<strong>最优解有无穷多个</strong>(对最优解w进行任意缩放)。<ul><li>如何<strong>定义聚合程度和扩散程度</strong>?   方差<strong>(协方差矩阵)</strong></li><li>如何保证样本点尽量聚合？  所有点接近<strong>中心点</strong>。</li><li>如何便于分类? <strong>同类样本应具有较好的聚合度，而类别之间应该具有较好的扩散度。</strong></li></ul></li><li>LDA算法流程：<br><img src="/ml/lda.png" width="36%"> </li></ul><h4 id="LDA-vs-PCA"><a href="#LDA-vs-PCA" class="headerlink" title="LDA vs PCA"></a>LDA vs PCA</h4><ul><li>相同点:<ul><li>都属于降维方法。</li><li>都转化为求解特征值问题。 </li><li>都可以使用核化技巧。</li></ul></li><li>不同点:<ul><li>PCA是非监督降维，LDA是监督降维。</li><li>PCA效率比LDA更高</li><li>PCA旨在寻找一组子坐标系(定义一个子空间)<strong>使得样本点的方差最大</strong>，即信息量保留越多。LDA旨在寻找一组子坐标系(定义一个子空间)<strong>使得样本点类内散度越小</strong>，类间散度越大。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学笔记及练习</title>
      <link href="/CG/"/>
      <url>/CG/</url>
      
        <content type="html"><![CDATA[<h2 id="1-计算机图形学概述"><a href="#1-计算机图形学概述" class="headerlink" title="1. 计算机图形学概述"></a>1. 计算机图形学概述</h2><h3 id="1-1-研究内容"><a href="#1-1-研究内容" class="headerlink" title="1.1 研究内容"></a>1.1 研究内容</h3><ul><li><code>图形</code>含有几何属性，或者说更强调场景的集合表示，是由场景的几何模型和警务的物理属性共同组成。（矢量/参数）</li><li><code>图像</code>是指计算机内以位图形式存在的灰度信息。（位图）</li><li><code>计算机图形学</code>：利用计算机研究一系列原理、方法与技术的学科。<a id="more"></a> <ul><li>图形的表示和生成：如何对数据建模，并将数据转换为图像？</li><li>图形的处理和显示：如何在专门的显示设备上显示图形？</li></ul></li><li>一个完整的图形处理过程包括：<ul><li>图形的输入</li><li>图形的处理</li><li>图形的输出</li></ul></li></ul><h3 id="1-2-计算机图形学的发展历史"><a href="#1-2-计算机图形学的发展历史" class="headerlink" title="1.2 计算机图形学的发展历史"></a>1.2 计算机图形学的发展历史</h3><ul><li>50年代，CTR的出现为计算机生成和显示图形提供了可能。</li><li>50年代末期，MIT的林肯实验室在“旋风”计算机上开发SAGE空中防御体系，通过光笔在屏幕上指点与系统交互，<strong>标志着交互式图形技术的诞生。</strong></li><li>60年代<ul><li>MIT林肯实验室的<strong>I. E. Sutherland</strong>发表了一片题为“<strong>Sketchpad：一个人机交互通信的图形系统</strong>”的博士论文，确定了交互图形学作为一个学科分支。</li><li>法国雷诺汽车公司的工程师Pierre Bezier提出 Bezier曲线、曲面的理论，而称为计算机辅助几何设计(CAGD)的先驱。</li><li>MIT的教书 Steven A. Coons提出了超限插值的新思想，通过插值四条任意便捷的曲线来构造曲面，</li></ul></li><li>70年代<ul><li>光栅图形学迅速发展</li><li>图形软件标准化：ISO发布CGI、CGM、GKS、PHIGS</li><li>真实感图形学和实体造型技术：(1970)Bouknight提出第一个光反射模型；(1971)Gourand提出“漫反射模型 + 插值”的思想，被称为Gourand明暗处理；(1975)Phong提出著名的简单光照模型-Phong模型。</li></ul></li></ul><h3 id="1-3-图形软件发展及软件标准的形成"><a href="#1-3-图形软件发展及软件标准的形成" class="headerlink" title="1.3 图形软件发展及软件标准的形成"></a>1.3 图形软件发展及软件标准的形成</h3><ul><li>近二十年，国际标准化组织ISO已经批准和正在讨论的与计算机图形有关的标准有：<ul><li>GKS、GKS-3D、PHIGS、CGM、CGI、IGES、STEP</li></ul></li><li>事实标准<ul><li>SGI的OpenGL，微软的Direct X，Adobe的Postscript等。  </li></ul></li></ul><h3 id="1-4-当前研究热点"><a href="#1-4-当前研究热点" class="headerlink" title="1.4 当前研究热点"></a>1.4 当前研究热点</h3><ul><li>造型技术</li><li>真实感图形绘制技术</li><li>人机交互技术</li><li>与计算机网络技术的紧密结合<ul><li>远程导航与维修</li><li>远程教育</li></ul></li><li>图像生成技术与图像处理的结合</li><li>虚拟现实技术</li></ul><h3 id="1-5-图形系统"><a href="#1-5-图形系统" class="headerlink" title="1.5 图形系统"></a>1.5 图形系统</h3><p>一个图形系统通常由：图形处理器、图形输入设备和图形输出设备构成。</p><h5 id="图形输入设备"><a href="#图形输入设备" class="headerlink" title="图形输入设备"></a>图形输入设备</h5><ul><li>鼠标</li><li>键盘：输入控制命令，利用光标指示对象与位置。</li><li>光笔：一种检测光的装置。P13 <strong>考核原理，判断正误</strong></li><li>数字化仪：数控板/手写板</li><li>扫描仪：直接把图形和图像扫描到计算机中以像素信息进行存储的设备。 <ul><li>光学信号 -&gt; 模拟信号 -&gt; 数字信号</li></ul></li><li>触摸屏，3D图形输入设备</li></ul><h5 id="图形处理器-显卡"><a href="#图形处理器-显卡" class="headerlink" title="图形处理器(显卡)"></a>图形处理器(显卡)</h5><ul><li>显示主芯片是显卡的核心，俗称GPU</li><li>显存用于存储将要现实的图形信息及保存图形运算的中间数据。</li></ul><h5 id="图形显示设备"><a href="#图形显示设备" class="headerlink" title="图形显示设备"></a>图形显示设备</h5><ul><li>图形输出包括图形的显示和图形的绘制<ul><li><code>图形显示</code>指的是在屏幕上输出图形。</li><li><code>图形绘制</code>通常指把图形画在纸上(硬拷贝)，如打印机和绘图仪</li></ul></li><li>显示器分类：<ul><li>CRT显示器</li><li>平板显示器</li></ul></li></ul><h5 id="阴极射线管-CRT-P9"><a href="#阴极射线管-CRT-P9" class="headerlink" title="阴极射线管(CRT) P9"></a>阴极射线管(CRT) P9</h5><ul><li>CRT显示器分类<ul><li>视觉属性：单色CRT，彩色CRT</li><li>偏转系统：偏转电场式，偏转磁场式</li><li>扫描方式：随机扫描，光栅扫描  </li></ul></li><li>组成：<ul><li>电子枪</li><li>聚焦系统</li><li>加速电极</li><li>偏转系统</li><li>荧光屏</li></ul></li><li>工作原理<ul><li>电子枪发射电子束</li><li>经过聚焦系统、加速电极、偏转系统，轰击到荧光屏的不同部位，被其表面的荧光物质吸收，发光产生可见的图形。</li><li>为要保持一幅稳定的画面，必须不断地发射电子束(<strong>不断刷新</strong>)，以抵消亮度的衰减。 </li></ul></li><li>电子枪 <ul><li>阴极：电流通过，灯丝加热，发出电子束。</li><li>控制栅：通过调节负电压来控制电子数量，即控制荧光屏上相应点的亮度。</li></ul></li><li>聚焦系统：通过电场和磁场控制电子束变细，保证亮点足够小，提高分辨率。</li><li>加速电极：加正的高电压(几万伏)，使电子达到轰击激发荧光屏应有的速度</li><li>偏转系统<ul><li>控制静电场或磁场，使电子束偏转。</li><li>最大的偏转角是系统性能的最重要的指标，显示器长短与此有关。</li><li>CRT显示器屏幕越大，整个显像管就越长。</li></ul></li><li>荧光屏<ul><li>荧光物质：吸收电子束而发光</li><li>余辉时间：持续发光时间。电子束离开某点后，该点的亮度值衰减到初始值。</li><li>刷新：为了让荧光物质保持在一个稳定的亮度值。</li><li>刷新频率：每秒重绘屏幕次数，显示器更新图像的速率。  </li><li>光点：电子束打在荧光屏上，显示器能显示的最小的发光点。</li><li>像素：构成屏幕的最小元素。</li><li>图形显示在屏幕上时，按当前的图形显示分辨率所能提供的最小元素点。像素点可看做光点的集合，其最小尺寸等于光点。</li><li>屏幕分辨率/光栅分辨率：是物理分辨率，CRT在水平或者竖直方向单位长度上能识别的最大像素个数，单位通常为dip。</li><li>显示分辨率：计算机显示控制器所提供的显示模式分辨率。</li></ul></li></ul><blockquote><p>P9 <strong>考点</strong> 假设荧光物质的持续发光时间为40ms 则，CRT产生稳定图像所需要的<strong>最小刷新频率 = 1秒/荧光物质的持续发光时间= 1000/40ms = 25 Hz</strong><br>只有刷新频率高达一定值后，图像才能稳定显示，约为每秒60帧(60Hz)。一般必须要有85Hz以上的刷新频率。</p></blockquote><h5 id="彩色阴极射线管"><a href="#彩色阴极射线管" class="headerlink" title="彩色阴极射线管"></a>彩色阴极射线管</h5><ul><li>彩色CRT：通过将能发不同颜色的光的荧光物质进行组合而产生彩色。<ul><li><strong>渗透性 - 射线穿透法</strong>：常用于随机扫描显示器。</li><li><strong>多枪型 - 影孔板法</strong>：常用于光栅扫描显示器。</li></ul></li></ul><h5 id="射线穿透法"><a href="#射线穿透法" class="headerlink" title="射线穿透法"></a>射线穿透法</h5><ul><li>屏幕内表面涂有两层荧光涂层。红色光和绿色光两种发光物质，不同速度电子束穿透荧光层的深浅，决定所产生的颜色。</li><li>应用：主要用于画线显示器</li><li>优点：成本低</li><li>缺点：只能产生有限几种颜色</li></ul><h5 id="影孔板法-P10"><a href="#影孔板法-P10" class="headerlink" title="影孔板法 P10"></a>影孔板法 P10</h5><ul><li>影孔板被安装在荧光屏的内表面，用于精确定位像素的位置。</li><li>分类： <ul><li><strong>点阵式</strong>：球面显像管。</li><li><strong>栅线式</strong>：柱面显像管，如日本索尼公司的特丽珑管，三菱公司的钻石龙管。</li><li><strong>栅格式/沟槽式</strong>：LG的未来窗显像管。</li></ul></li><li>工作原理：<ul><li>三基色(红绿蓝)，三色荧光点，三只电子枪。</li><li>电子枪、影孔板中的一个小孔和对应的荧光点呈一直线。</li><li>每个小孔与一个像素（即三个荧光点）对应。</li><li>调节各电子枪发生的电子束中所含电子的数目，即可控制各色光点亮度。<br><img src="/CG/影孔板.png" width="30%"></li></ul></li><li>显示器能同时显示的颜色个数：如果每支电子枪发出的电子束的强度有256个等级，则显示 器能同时显示<code>256*256*256=16M</code>种颜色，称为真彩系统。</li></ul><h5 id="栅线式-vs-点阵式"><a href="#栅线式-vs-点阵式" class="headerlink" title="栅线式 vs 点阵式"></a>栅线式 vs 点阵式</h5><ul><li>原理的区别：光线的选择方式和荧光点的排列不同</li><li>点阵式的缺点：<ul><li>用于球面荧光屏，几何失真大。</li><li>三角形的荧光点排列，即使很密很细也不会特别清晰。</li></ul></li><li>栅线式的优点：<ul><li>亮度更高，色彩也更鲜艳。</li><li>用于高分辨率的柱面和平面显示器。</li><li>电子束通过率有很大的提高。 </li></ul></li></ul><h5 id="荫罩式显示器的固有缺陷"><a href="#荫罩式显示器的固有缺陷" class="headerlink" title="荫罩式显示器的固有缺陷"></a>荫罩式显示器的固有缺陷</h5><ul><li>由合金钢板制成的荫罩<strong>易磁化</strong></li><li>受热受冲击时<strong>易变形</strong><ul><li>显像管内射向荧光屏的电子束中有75% 以上被荫罩阻挡，转变成热量浪费了</li></ul></li><li>屏幕尺寸越大或清晰度越高，就越难制造， <strong>生产成本高</strong>，成品率偏低，价格过高</li><li>制约彩色显像管<strong>清晰度</strong>提高的技术<strong>瓶颈</strong>是彩色显像管中的荫罩</li></ul><h5 id="随机扫描显示系统特点"><a href="#随机扫描显示系统特点" class="headerlink" title="随机扫描显示系统特点"></a>随机扫描显示系统特点</h5><ul><li>数据表示：矢量表示，只有端点信息，无线段中间点</li><li>扫描方式：电子束像一支快速移动的画笔，在任意方向上自由移动，<br>按照显示命令用画线的方式绘出图形</li><li>显示图形：几何属性为主，线框图形</li><li>别称：矢量扫描显示器，画线显示器</li><li>优点：扫描速度快，分辨率高，线条质量好，易修改，交互性好，<br>动态性能好</li><li>缺点：价格贵，只能显示线框图形，应用于军事、CAD领域</li></ul><h5 id="光栅扫描的显示系统特点"><a href="#光栅扫描的显示系统特点" class="headerlink" title="光栅扫描的显示系统特点"></a>光栅扫描的显示系统特点</h5><ul><li>数据表示：像素矩阵，像素数组</li><li>扫描方式：从上到下，从左到右，与电视工作原理类似</li><li>显示图形：几何属性＋视觉属性(Visual attribute) , 真实<br>感图形</li></ul><h5 id="光栅图形显示系统"><a href="#光栅图形显示系统" class="headerlink" title="光栅图形显示系统"></a>光栅图形显示系统</h5><ul><li>显示处理器：主要任务是将应用程序定义为一组像素强度值，存放在帧缓冲存储器中。</li><li>帧缓冲存储器：俗称<strong>显存</strong>，保存了对应屏幕所有亮点的亮度值。</li><li>视频控制器：建立帧缓存与屏幕像素之间一一对应，负责刷新。</li><li>CRT显示器</li></ul><p><img src="/CG/光栅图形.png" width="50%"></p><h5 id="帧缓存与显示器分辨率的关系"><a href="#帧缓存与显示器分辨率的关系" class="headerlink" title="帧缓存与显示器分辨率的关系"></a>帧缓存与显示器分辨率的关系</h5><ul><li>帧缓存的大小 =  显示器分辨率的大小 * 帧缓存的位平面数 / 8</li><li>eg. 分辨率为640x480、1280x1024、1024x1024的显示器各需要多少字节位平面数为24的帧缓存？ans: 分辨率*24/8</li></ul><h5 id="显存问题"><a href="#显存问题" class="headerlink" title="显存问题"></a>显存问题</h5><ul><li>高分辨率和真彩要求有大的显存：1024x1024真彩模式需要3M字节显存。</li><li>解决办法：<ul><li>采用<strong>查色表</strong>或者称彩色表机制。</li><li>采用<strong>隔行扫描</strong>的方法。</li></ul></li></ul><h5 id="带宽问题"><a href="#带宽问题" class="headerlink" title="带宽问题"></a>带宽问题</h5><ul><li>带宽T与分辨率(M<em>N)、帧频(刷新频率)F的关系：`T &gt;= M </em> N * F`</li><li>高分辨率和高刷新频率要求高带宽</li><li>解决办法：<ul><li>隔行扫描(现在一般用逐行扫描)</li><li>对Z缓冲期内容进行压缩和快速清除。</li></ul></li></ul><h5 id="光栅显示系统的特点"><a href="#光栅显示系统的特点" class="headerlink" title="光栅显示系统的特点"></a>光栅显示系统的特点</h5><ul><li>优点<ul><li>成本低</li><li>易于绘制填充图形</li><li>色彩丰富</li><li>刷新频率一定，与图形的复杂度无关</li><li>易于修改图形</li></ul></li><li>缺点<ul><li>需要扫描转换</li><li>扫描转换速度偏低，交互操作响应慢</li><li>分辨率偏低，有阶梯效应，会产生走样  </li></ul></li></ul><h5 id="LCD显示器"><a href="#LCD显示器" class="headerlink" title="LCD显示器"></a>LCD显示器</h5><ul><li>优点<ul><li>外观小巧精致，厚度只有6.5-Bcm左右</li><li>响应速度快、无闪烁、无干扰</li><li>工作电压低，功耗小，省电</li><li>没有电磁辐射，对人体健康没有任何影响</li></ul></li><li>缺点<ul><li>成品率偏低导致成本偏高，冷阴极荧光灯的使用寿命井不算太长，可<br>视角度有限</li></ul></li></ul><h3 id="1-6-计算机图形学的应用及研究前沿"><a href="#1-6-计算机图形学的应用及研究前沿" class="headerlink" title="1.6 计算机图形学的应用及研究前沿"></a>1.6 计算机图形学的应用及研究前沿</h3><ul><li>计算机辅助设计与制造</li><li>可视化</li><li>真实感图形实时绘制与自然景物仿真 </li><li>计算机动画</li><li>用户接口</li><li>计算机艺术</li></ul><h2 id="2-基本图形的生成算法"><a href="#2-基本图形的生成算法" class="headerlink" title="2.基本图形的生成算法"></a>2.基本图形的生成算法</h2><p><img src="/CG/基本图形.png" width="60%"></p><h3 id="2-1-直线绘制算法"><a href="#2-1-直线绘制算法" class="headerlink" title="2.1 直线绘制算法"></a>2.1 直线绘制算法</h3><ul><li>光栅平面的显示图形<ul><li>在光栅显示平面上，我们只能用二维光栅网格上<strong>尽可能靠近</strong>这条直线的象素集合来表示它。</li><li>每个象素具有一定的尺寸，是显示平面上可被访问的最小单位，</li><li>它的<strong>坐标x和y只能是整数</strong>，也就是说相邻象素的坐标值是阶跃的而不是连续的。</li></ul></li></ul><h5 id="直线段的扫描转换"><a href="#直线段的扫描转换" class="headerlink" title="直线段的扫描转换"></a>直线段的扫描转换</h5><ul><li>两点确定一条直线</li><li>通过直线的两个点的坐标计算出斜率和截距，确定直线方程。</li><li>通过x值确定每一个y的值，并舍入y的值。</li></ul><h5 id="数值微分-DDA-算法"><a href="#数值微分-DDA-算法" class="headerlink" title="数值微分(DDA)算法"></a>数值微分(DDA)算法</h5><ul><li>基本思想： <ul><li>假设直线段的宽度为1,直线段的斜率: |k| ≤ 1</li><li>已知过端点P<sub>0</sub>(x<sub>0</sub>, y<sub>0</sub>), P<sub>1</sub>(x<sub>1</sub>, y<sub>1</sub>)的直线L：y = kx + b。</li><li>直线斜率 k = (y<sub>1</sub> - y<sub>0</sub>) / (x<sub>0</sub> - x<sub>0</sub>)</li><li>当x的增量D<sub>x</sub> = 1， y<sub>i+1</sub> = y<sub>i</sub> + k</li></ul></li><li>当x每递增1，y递增k(即直线斜率)；取象素点(x, round(y))作为当前点的坐标。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DDALine(x0,y0,x1,y1,color) </span><br><span class="line"><span class="keyword">int</span> x0,y0,x1,y1,color;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x</span><br><span class="line"><span class="keyword">float</span> dx,dy,k,y</span><br><span class="line">dx=x1-x0; dy=y1-y0; </span><br><span class="line">k=dy/dx;</span><br><span class="line">y=y0;</span><br><span class="line"><span class="keyword">for</span>(x=x0;x&lt;=x1;x++)</span><br><span class="line">&#123;</span><br><span class="line">drawpixel(x,<span class="keyword">int</span>(y+<span class="number">0.5</span>),color); </span><br><span class="line">y=y+k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：<ul><li>当|k| ≤ 1时，x每增加1，y最多变化1。</li><li>当|k| &gt; 1时，必须把x与y的地位互换。</li></ul></li><li><strong>DDA算法的特点</strong> 以|k| ≤ 1为例<ul><li>y与k必须用浮点数表示</li><li>每一步都要对y进行四舍五入后取整</li><li>不利于硬件实现</li></ul></li></ul><h5 id="中点算法"><a href="#中点算法" class="headerlink" title="中点算法"></a>中点算法</h5><ul><li>基本原理<ul><li>通过在每列(行)象素中确定与理想直线最接近的象素来进行扫描转换</li><li>考虑直线斜率k在0~1之间</li><li>当前象素点为P（x<sub>p</sub>,y<sub>p</sub>），则下一个象素点有两种可选择点<br>P<sub>1</sub>（x<sub>p</sub>+1,y<sub>p</sub>）, P<sub>2</sub>（x<sub>p</sub>+1,y<sub>p+1</sub>）</li><li>P1与P2的中点（x<sub>p</sub>+1,y<sub>p</sub>+0.5）称为M</li><li>Q为理想直线与x = x<sub>p</sub>+1垂线的交点<br>当M在Q的下方时，则取P<sub>2</sub>应为下一个象素点<br>当M在Q的上方时，则取P<sub>1</sub>为下一个象素点<br><img src="/CG/中点算法.png" width="40%"> </li></ul></li><li>算法实现<ul><li>过点(x<sub>0</sub>,y<sub>0</sub>)、(x<sub>1</sub>, y<sub>1</sub>)的直线段L的方程式为：F(x, y)=ax+by+c=0</li><li><strong>其中，a = y<sub>0</sub> - y<sub>1</sub>, b = x<sub>1</sub> - x<sub>0</sub>, c = x<sub>0</sub>y<sub>1</sub> - x<sub>1</sub>y<sub>0</sub></strong></li><li>欲判断中点M在交点Q点的上方还是下方，只要把M代入F（x，y），并判断它的符号即可</li><li>构造判别式：d=F(M)=F(x<sub>p</sub>+1, yp+0.5)=a(x<sub>p</sub>+1)+b(y<sub>p</sub>+0.5)+c    </li><li>当d&lt;0时，M在L(Q点)下方，取P2为下一个象素        </li><li>当d&gt;0时，M在L(Q点)上方，取P1为下一个象素      </li><li>当d=0时，选P1或P2均可，约定取P1为下一个象素  </li></ul></li></ul><h5 id="增量法改进："><a href="#增量法改进：" class="headerlink" title="增量法改进："></a>增量法改进：</h5><ul><li>注意到d是x<sub>p</sub>, y<sub>p</sub>的线性函数，可采用增量计算，提高运算效率 <ul><li>d = F(M)=F(x<sub>p</sub>+1, y<sub>p</sub>+0.5) = a(x<sub>p</sub>+1)+b(y<sub>p</sub>+0.5)+c </li></ul></li><li>若当前象素（P的下一个像素）处于d≥0情况，则取P的正右方象素P1(x<sub>p</sub>+1, y<sub>p</sub>)，再下一个象素位置的判别式：<ul><li>d<sub>1</sub> = F(x<sub>p</sub>+2, y<sub>p</sub>+0.5) = a(x<sub>p</sub>+2)+b(y<sub>p</sub>+0.5)+c = d+a</li><li><strong>增量为a</strong></li></ul></li><li>若当前象素（P的下一个像素） d&lt;0时，则取右上方象素P2(x<sub>p</sub>+1, y<sub>p</sub>+1)，再下一个像素位置的判别式：<ul><li>d<sub>2</sub> = F(x<sub>p</sub>+2, y<sub>p</sub>+1.5) = a(x<sub>p</sub>+2)+b(y<sub>p</sub>+1.5)+c = d+a+b</li><li><strong>增量为a＋b</strong></li></ul></li><li><strong>初值计算</strong><ul><li>画线从(x<sub>0</sub>, y<sub>0</sub>)开始， F(x<sub>0</sub>, y<sub>0</sub>) = 0</li><li>d的初值：起始点(x0, y0) 下一个像素的判别式：</li><li>d<sub>0</sub> = F(x<sub>0</sub>+1, y<sub>0</sub>+0.5)+c = F(x<sub>0</sub>, y<sub>0</sub>)+a+0.5b = 0 + a+0.5b = a+0.5b</li></ul></li><li><strong>摆脱小数计算</strong><ul><li>我们使用的只是d的符号</li><li>d的增量都是整数，只是初始值包含小数</li><li>可以用2d代替d来摆脱小数</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> Midpoint <span class="title">Line</span> <span class="params">(<span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> x1, <span class="keyword">int</span> y1,<span class="keyword">int</span> color)</span></span>&#123; </span><br><span class="line"><span class="keyword">int</span> a, b, d1, d2, d, x, y;a=y0-y1； b=x1-x0；d=<span class="number">2</span>*a+b; <span class="comment">//初值</span>d1=<span class="number">2</span>*a； d2=<span class="number">2</span>* (a+b);x=x0；y=y0;drawpixel(x, y, color);<span class="keyword">while</span> (x&lt;x1)&#123; </span><br><span class="line"><span class="keyword">if</span> (d&lt;<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">x++;</span><br><span class="line">y++；;</span><br><span class="line">d+=d2; </span><br><span class="line">&#125;<span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">x++;</span><br><span class="line">d+=d1;</span><br><span class="line">&#125;drawpixel (x, y, color);&#125; &#125;</span><br></pre></td></tr></table></figure><h5 id="Bresenham算法"><a href="#Bresenham算法" class="headerlink" title="Bresenham算法"></a>Bresenham算法</h5><ul><li>基本思想：<ul><li>过各行各列象素中心构造一组虚拟网格线</li><li>按直线从起点到终点的顺序计算直线与各垂直网格线的<strong>交点</strong></li><li>然后根据<strong>误差项的符号</strong>确定该列象素中与此交点最近的象素</li><li>采用<strong>增量计算</strong>，使得对于每一列，只要检查一个误差项的<strong>符号</strong>，就<br>可以确定该列的所求象素<br><img src="/CG/Bresenham.png" width="30%"></li></ul></li><li>算法实现<ul><li>先考虑斜率k=dy/dx≤1的直线，直线方程可以表示为</li><li>假设当前像素的x坐标已经确定为x<sub>i</sub>，其y坐标为y<sub>i</sub></li><li>由于坐标(x<sub>i</sub>, y<sub>i</sub>)只能取整数，下一个像素的x坐标为</li><li>而y<sub>i</sub>＋1的坐标有两种可能：保持不变，即y<sub>i</sub>＋1＝y<sub>i</sub>；y坐标递增1，即y<sub>i</sub>＋1＝y<sub>i</sub>＋1<br><img src="/CG/Bresenham1.png" width="20%"></li><li>设A为CD边的中点，若B点在A点上方，选择D点； 否则，选C点。</li></ul></li><li>具体实现<ul><li>如果直线的<strong>起始点在象素中心</strong>，所以误差项d的初值<strong>d<sub>0</sub>＝0</strong>。</li><li>x下标每增加1，d的值相应递增直线的斜率值k，<strong>即d＝d＋k</strong>。</li><li>一旦d≥1，就把它减去1，这样<strong>保证d在0与1之间</strong>。<br>①当d≥0.5时，最接近于当前象素的右上方象素（x<sub>i</sub>+1, y<sub>i</sub>+1）<br>②当d&lt;0.5时，更接近于右下方象素（x<sub>i</sub>+1, y<sub>i</sub>）</li><li>为方便计算，<strong>令e＝d-0.5</strong></li><li>e的初值为-0.5 (d0 = 0)，增量为k<br>①当e≥0时，最接近于当前象素的右上方象素（x<sub>i</sub>+1, y<sub>i</sub>+1）<br>②当e&lt;0时，更接近于右方象素（x<sub>i</sub>+1, y<sub>i</sub>）</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bresenhamline</span> <span class="params">(<span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> x1, <span class="keyword">int</span> y1,<span class="keyword">int</span> color)</span></span>&#123;<span class="keyword">int</span> x, y, dx, dy;<span class="keyword">float</span> k, e;dx = x1-x0, dy = y1- y0, k=dy/dx;e=<span class="number">-0.5</span>, x=x0, y=y0;<span class="keyword">for</span> (i=<span class="number">0</span>; i≤dx; i++)&#123;drawpixel (x, y, color);x=x+<span class="number">1</span>, e=e+k;<span class="keyword">if</span> (e≥<span class="number">0</span>)&#123; </span><br><span class="line">y++, e=e<span class="number">-1</span>;</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Bresenham画线算法优点</strong>：<ul><li>快速增量算法</li><li>仅使用整数计算</li><li>效率高，易于用硬件实现</li></ul></li><li>与DDA算法相比，DDA算法的问题：<ul><li>误差的累积会使直线远离真实的结果</li><li>四舍五入运算和浮点运算耗时</li></ul></li></ul><h5 id="改进的Bresenham算法"><a href="#改进的Bresenham算法" class="headerlink" title="改进的Bresenham算法"></a>改进的Bresenham算法</h5><ul><li>可以改用整数以避免除法。由于算法中只用到误差项的符号，因此可作如下替换：<ul><li>e’ = 2 <em> e </em> dx 即用2 <em> dx </em> e代替原有的e。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InterBresenhamline</span> <span class="params">(<span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> x1, <span class="keyword">int</span> y1,<span class="keyword">int</span> color)</span></span>&#123;dx = x1-x0, dy = y1- y0；e=-dx; x=x0; y=y0;<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;dx; i++)&#123;drawpixel (x, y, color）x++； e=e+<span class="number">2</span>*dy;<span class="keyword">if</span> (e&gt;=<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"> y++; </span><br><span class="line"> e=e<span class="number">-2</span>*dx;</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-圆的生成"><a href="#2-2-圆的生成" class="headerlink" title="2.2 圆的生成"></a>2.2 圆的生成</h3><ul><li>八等分圆：可以同时绘制八分对称的点。<br><img src="/CG/八等分.png" width="30%"> <ul><li>八分对称性同时解决了“绘制点稀疏”的问题。</li><li>只需绘制右上八分之一的圆弧。</li><li>①切线斜率|dy/dx| ≤ 1 ②y的变化慢于x ③x每递增1，y最多最多改变一个像素单位 ④不会产生像素空隙 ⑤会有更多的像素拟合圆弧 ⑥使圆弧拟合更精确。</li></ul></li></ul><h5 id="中点画圆法"><a href="#中点画圆法" class="headerlink" title="中点画圆法"></a>中点画圆法</h5><ul><li>构造判别式(圆方程)：F(x, y) = x<sup>2</sup> + y<sup>2</sup> - R<sup>2</sup></li><li>判断点在圆内(F &lt; 0)、圆上(F = 0)、圆外(F &gt; 0)</li><li>M(x<sub>p</sub> + 1,y<sub>p</sub> - 0.5)是P1和P2的中点</li><li>d = F(M) = F(x<sub>p</sub> + 1,y<sub>p</sub> - 0.5) = (x<sub>p</sub> + 1)<sup>2</sup> + (y<sub>p</sub> - 0.5)<sup>2</sup> - R<sup>2</sup><br><img src="/CG/中点画圆.png" width="30%"> <ul><li>八分之一圆弧（如半径R=20），初始象素坐标(0, R)</li><li>下一个像素的绘制位置(1, R) 或(1, R-1)</li><li>得到中点坐标(1, R-0.5)</li><li>构造判别式d<sub>0</sub> = F(M) -&gt; d<sub>1</sub>, d<sub>2</sub>…</li></ul></li></ul><h5 id="增量算法避免重复计算"><a href="#增量算法避免重复计算" class="headerlink" title="增量算法避免重复计算"></a>增量算法避免重复计算</h5><p><img src="/CG/中点画圆增量.png" width="60%"> </p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MidPointCircle(<span class="keyword">int</span> R <span class="keyword">int</span> color)&#123;<span class="keyword">int</span> x,y;<span class="keyword">float</span> d;x=<span class="number">0</span>; y=R; d=<span class="number">1.25</span>-R;CirclePoints (x,y,color); <span class="comment">//显示圆弧上的八个对称点</span><span class="keyword">while</span>(x&lt;=y)&#123;<span class="keyword">if</span>(d&lt;<span class="number">0</span>) </span><br><span class="line">d+=<span class="number">2</span>*x+<span class="number">3</span>;<span class="keyword">else</span> </span><br><span class="line">&#123; </span><br><span class="line">d+=<span class="number">2</span>*(x-y)+<span class="number">5</span>; </span><br><span class="line">y--; </span><br><span class="line">&#125;x++;CirclePoints(x,y,color); <span class="comment">//显示圆弧上的八个对称点</span>&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>为了进一步提高算法的效率，可以将上面的算法中的浮点数改写成整数，将乘法运算改成加法运算，即仅用整数实现中点画<br>圆法。</li><li>初始化运算使用 Q:为什么可以去掉0.25？<ul><li>d’= d - 0.25 = 1.25 – R – 0.25 = 1 – R 代替 d = 1.25 - R</li></ul></li></ul><h5 id="中点算法小结"><a href="#中点算法小结" class="headerlink" title="中点算法小结"></a>中点算法小结</h5><ul><li>圆弧各点切线斜率绝对值<1 -=""> 从x扫描至x+1，y的备选绘制点为y, y-1</1></li><li>适当利用对称性提高效率<ul><li>利用圆的八分对称性 -&gt; 只需绘制圆右上八分之一圆弧</li></ul></li><li>利用中点判别法选择绘制点<ul><li>联合圆方程 + 每一步的两个备选绘图点的中点 -&gt; 构造判别式</li></ul></li><li>设计增量算法 -&gt; 避免重复计算</li><li>符号判别 -&gt; 简化浮点运算为整数运算</li></ul><h5 id="生成圆弧的Bresenham法"><a href="#生成圆弧的Bresenham法" class="headerlink" title="生成圆弧的Bresenham法"></a>生成圆弧的Bresenham法</h5><ul><li>以点(0, R) 为起点按顺时针方向生成圆，则在第一象限内（四分之一圆弧）y是x的单调递减函的单调递减函。</li><li>假设圆心和起点均精确地落在像素中心上。如果已经知道圆弧上的一点 (x<sub>i</sub>,y<sub>i</sub> )，下一像素的选取有三种可能：<br>①正右方像素H ②右下角像素D ③正下方像素V<br><img src="/CG/圆弧.png" width="20%"></li><li>构造函数：F(x<sub>p</sub> + 1,y<sub>p</sub> - 0.5) = (x<sub>p</sub> + 1)<sup>2</sup> + (y<sub>p</sub> - 0.5)<sup>2</sup> - R<sup>2</sup>  </li><li>这三个像素的偏差的平方为：<br><img src="/CG/偏差.png" width="20%"><br><img src="/CG/偏差2.png" width="50%"><img src="/CG/偏差3.png" width="50%"><br><img src="/CG/偏差4.png" width="55%"></li></ul><h3 id="2-3-椭圆的生成"><a href="#2-3-椭圆的生成" class="headerlink" title="2.3 椭圆的生成"></a>2.3 椭圆的生成</h3><ul><li>F(x,y) = b<sup>2</sup>x<sup>2</sup>+a<sup>2</sup>y<sup>2</sup>-a<sup>2</sup>b<sup>2</sup>=0</li><li>椭圆的对称性：<ul><li>只考虑第一象限椭圆弧生成 只考虑第一象限椭圆弧生成 ，分上下两部分</li><li><strong>以切线斜率为-1的点作为分界的点。</strong></li></ul></li><li>椭圆上一点处的法向量：N(x,y) = (F)’ x i+(F)’ y j = 2b<sup>2</sup>x i+2a<sup>2</sup>y j<ul><li>在上部分，法向量的y向分量较大，斜率K满足 |k|&lt; 1,|△x| ＞|△y| ，所以 x方向为主位移方向。</li><li>在下部分，法向量的x向分量较大，斜率K满足 |k|&gt; 1,|△y| ＞|△x| ，所以 y方向为主位移方向。</li></ul></li><li>与圆弧中点算法类似：确定一个象素后，接着在两个候选象素的中点计算一个判别式的值，由判别式的符号确定更近的点。</li><li>先讨论椭圆弧的上部分：<ul><li>(x<sub>p</sub>, y<sub>p</sub>)的中点(x<sub>p</sub> + 1, y<sub>p</sub> - 0.5)</li><li>d<sub>1</sub> = F(x<sub>p</sub> + 1, y<sub>p</sub> - 0.5)<br><img src="/CG/椭圆.png" width="75%"><br><img src="/CG/椭圆2.png" width="60%"><br><img src="/CG/椭圆3.png" width="50%"><br><img src="/CG/椭圆4.png" width="50%"> <img src="/CG/椭圆5.png" width="50%"> </li></ul></li><li>算法步骤：<ol><li>输入椭圆的长半轴 a 和短半轴 b。</li><li>计算初始值 d=b<sup>2</sup>+a<sup>2</sup>(-b+ 0.25 )，x= 0，y=b 。</li><li>绘制点 (x, y )及其在四分象限上的另外三个对称点。</li><li>判断 d 的符号。若d≤ 0，则先将d更新为d+b<sup>2</sup>(2x + 3)，再将 ( x, y)更新为 (x+ 1,y)；否则先将d更新为 d+b<sup>2</sup>(2x + 3) + a<sup>2</sup>(-2y + 2)，再将 ( x, y )更新为 (x + 1, y - 1)。</li><li>当b<sup>2</sup>(x+1) &lt; a<sup>2</sup>(y - 0.5)时，重复步骤 3 和 4 。否则转到步骤 6 。</li><li>用上半部分计算的最后点 ( x, y )来计算下半部分中d的初值：d = b<sup>2</sup>(x + 0.5)<sup>2</sup> + a<sup>2</sup> (y - 1)<sup>2</sup> - a<sup>2</sup> b<sup>2</sup></li></ol></li></ul><h3 id="2-4-多边形的扫描转换"><a href="#2-4-多边形的扫描转换" class="headerlink" title="2.4 多边形的扫描转换"></a>2.4 多边形的扫描转换</h3><h5 id="1-实区域填充算法"><a href="#1-实区域填充算法" class="headerlink" title="1. 实区域填充算法"></a>1. 实区域填充算法</h5><ul><li>点在多边形内的包含性检验<ul><li><strong>检验夹角之和</strong>：若夹角和为0，则点p在多边形外；若夹角和为360°，则点p在多边形内。</li><li><strong>射线法检验交点数</strong>：交点数 = 偶数(包括0) -&gt; 点在多边形之外；交点数 = 奇数 -&gt; 点在多边形之内</li></ul></li><li>逐点测试：效率低不实用。 <ul><li>解决办法：<strong>包围盒法</strong>。</li></ul></li><li>分类<ul><li>扫描线填充算法：按扫描线顺序，测试点的连贯性</li><li>种子填充算法：从内部一个种子点出发，测试点的连贯性。</li></ul></li></ul><h5 id="2-多边形种类"><a href="#2-多边形种类" class="headerlink" title="2. 多边形种类"></a>2. 多边形种类</h5><ul><li>多边形 :由一系列首尾相连的直线段构成的图形称为多边形。 <ul><li><strong>凸多边形</strong>是指任意两顶点间的连线均在多边形内;</li><li><strong>凹多边形</strong>是指任意两顶点间的连线有不在多边形内的部分;</li><li><strong>含内环的多边形</strong>则是指多边形内再套有多边形，多边形内的多边形也叫内环，内环之间不能相交。</li></ul></li></ul><h5 id="3-如何表示多边形"><a href="#3-如何表示多边形" class="headerlink" title="3. 如何表示多边形"></a>3. 如何表示多边形</h5><ul><li><strong>顶点表示</strong>是用多边形的顶点序列来表示多边形。<ul><li>表示直观、几何意义强、占内存少，易于进行几何变换，被广泛用于各种几何造型系统中;</li></ul></li><li><strong>点阵表示</strong>是用位于多边形内的象素集合来刻画多边形。<ul><li>丢失了许多几何信息(如边界、顶点)，但它是光栅显示图形所需要的表示形式。</li></ul></li><li><strong>多边形的扫描转换处理对象</strong>：非自交多边形 (边与边之间除了顶点外无其它交点)</li></ul><h5 id="4-多边形的扫描转换-扫描线算法-多边形的有序边表法"><a href="#4-多边形的扫描转换-扫描线算法-多边形的有序边表法" class="headerlink" title="4. 多边形的扫描转换 / 扫描线算法 / 多边形的有序边表法"></a>4. 多边形的扫描转换 / 扫描线算法 / 多边形的有序边表法</h5><ul><li>4个基本步骤：<ul><li><strong>求交</strong>：计算扫描线与多边形各边的交点</li><li><strong>排序</strong>：把所有交点按x值递增顺序排序</li><li><strong>配对</strong>：将第一个与第二个、第三个与第四个等交点配对，每对交点代表扫描线与多边形的一个相交区间。</li><li><strong>填色</strong>：把相交区间内的像素置成多边形的颜色，相交区间外的颜色置成背景色。</li></ul></li><li><strong>顶点交点的计数问题：</strong><ul><li>思路1: 局部最高点和局部最低点：计偶数次交点</li><li>思路2: 检查交于该顶点的两条边的另外两个端点的y坐标值：大于该顶点y坐标值的个数</li></ul></li><li><strong>填充扩大化问题</strong> <ul><li>取中心扫描线 y+0.5<br>– 检查交点右方像素的中心是否落在区间内：x<sub>l</sub> ≤ x + 0.5 ≤ x<sub>r</sub></li></ul></li><li><strong>效率问题：</strong><ul><li>影响算法效率的因素：<strong>求交和交点排序</strong></li><li>把多边形所有边放在一个表中，按顺序取出，分别计算与当前扫描线求交点。</li><li>为了减少和简化求交点计算，对每条扫描线，建立一个<strong>活性边表</strong>：把所有与当前扫描线有交点的边放到一个表中存储。(活性边：仅与当前扫描线有交点的边)</li></ul></li><li><strong>活性边表 AET</strong>：<ul><li>结点信息：<br>① x:当前扫描线与边的交点<br>②△x:从当前扫描线到下一条扫描线之间的x增量<br>③ymax:边所交的最高扫描线号</li><li>活性边表的更新：<br>①结点信息的更新  <strong>x’ = x + △ x</strong><br>②旧边的删除<br>③新边的插入 </li></ul></li><li><strong>新边表 NET</strong><ul><li>为解决新边插入的问题，对每条扫描线建立一个新边表。</li><li>扫描线与边的交点应为扫描线与边的初始交点</li><li>结点信息<br>①x<sub>0</sub>:扫描线与边的初始交点。（若采用中心扫描线，则需将活性边的较低端点的x坐标值加上0.5△x作为x0）<br>②△x:从当前扫描线到下一条扫描线之间的x增量<br>③ymax:边所交的最高扫描线号<br><img src="/CG/扫描线.png" width="70%"></li></ul></li><li>优点: <ul><li>对每个像素只访问一次 </li><li>与设备无关</li></ul></li><li>缺点:<ul><li>数据结构复杂，表的维护、排序开销大</li><li>只适合软件实现</li></ul></li></ul><h5 id="扫描线算法步骤"><a href="#扫描线算法步骤" class="headerlink" title="扫描线算法步骤"></a>扫描线算法步骤</h5><ol><li>根据给出的多边形顶点坐标，建立NET表;<br>求出顶点坐标中最大y值ymax和最小y值ymin。</li><li>初始化AET表指针，使它为空。</li><li>执行下列步骤直至NET和AET都为空.<ol><li>如NET中的第y类非空，则将其中的所有边取出并插入AET中;</li><li>如果有新边插入AET，则对AET中各边排序;</li><li>对AET中的边两两配对，(1和2为一对，3和4为一对，…)，将每对边中x坐标按规则取整，获得有效的填充区段，再填充.</li><li>当前扫描线纵坐标y值递值1;</li><li>如果AET表中某记录的ymax=yj，则删除该记录(因为每条边被看作下闭上开的);</li><li>对AET中剩下的每一条边的x递增1/k，即x = x+ 1/k .</li></ol></li></ol><h5 id="边填充算法"><a href="#边填充算法" class="headerlink" title="边填充算法"></a>边填充算法</h5><ul><li>无需复杂的链表结构</li><li>涉及到屏幕像素的异或写操作<ul><li>第一次异或写操作，像素被置为前景色</li><li>第二次异或写操作，像素被置为背景色</li></ul></li><li>边填充算法的基本思想<ul><li>对每一条与多边形相交的中心扫描线</li><li>将像素中心位于交点右方的全部像素取补 (异或写)</li></ul></li><li>分类：<ul><li>算法1：<strong>以扫描线为中心</strong>的边缘填充算法</li><li>算法2：<strong>以边为中心</strong>的边缘填充算法</li></ul></li><li>边填充算法的优点:<ul><li>最适合于有帧缓存的显示器</li><li>可按任意顺序处理多边形的边</li><li>仅访问与该边有交点的扫描线上右方的像素，算法简单</li></ul></li><li>缺点: <ul><li>对复杂图形，每一像素可能被访问多次，输入/输出量大</li><li><strong>图形输出不能与扫描同步进行</strong>，只有全部画完才能打印</li></ul></li></ul><h5 id="边界标志法-P27"><a href="#边界标志法-P27" class="headerlink" title="边界标志法 P27"></a>边界标志法 P27</h5><ul><li>在帧缓冲器中对多边形的每条边进行<strong>直线扫描转换</strong>，亦即对多边形边界所经过的象素打上标志。</li><li>对每条与多边形相交的扫描线依从左到右的顺序，逐个访问该扫描线上的象素。</li><li>使用一个<strong>布尔量inside</strong>来指示当前点是否在多边形内的状态。<ul><li>Inside的初值为假，每当当前访问的象素为被打上边标志的点，就把inside取反。 </li><li>对未打标志的象素，inside不变。</li><li>若访问当前象素时，inside为真，说明该象素在多边形内，则把该象素置为填充颜色。</li></ul></li><li>用软件实现时，有序边表算法(扫描线算法)与边界标志算法的执行速度几乎相同。</li><li>但由于边界标志算法<strong>不必建立维护边表以及对它进行排序，所以边界标志算法更适合硬件实现</strong>，这时它的执行速度比有序边表算法快一至两个数量级。</li></ul><h3 id="2-5-区域-种子-填充算法"><a href="#2-5-区域-种子-填充算法" class="headerlink" title="2.5  区域(种子)填充算法"></a>2.5  区域(种子)填充算法</h3><h5 id="区域填充"><a href="#区域填充" class="headerlink" title="区域填充"></a>区域填充</h5><ul><li><strong>区域</strong>：指已经表示成<strong>点阵形式</strong>的填充图形，它是象素的集合。</li><li>表示方法: 内点表示、边界表示</li><li><strong>内点表示</strong><ul><li>枚举处区域内部的所有像素</li><li>内部的所有像素着同一个颜色</li><li>边界像素着与内部像素不同的颜色</li></ul></li><li><strong>边界表示</strong><ul><li>枚举出边界上所有的像素</li><li>边界上的所有像素着同一颜色</li><li>内部像素着与边界像素不同的颜色</li></ul></li><li>种子填充算法的另外一种思路: <ul><li>假设多边形区域内至少有一个像素已知 </li><li>由该像素出发找出区域内部的所有像素</li></ul></li><li><strong>区域连通方式</strong><ul><li>4连通区域(4个方向运动：上下左右)</li><li>8连通区域(8个方向运动)</li></ul></li></ul><h5 id="种子填充的一种非递归-栈-算法"><a href="#种子填充的一种非递归-栈-算法" class="headerlink" title="种子填充的一种非递归(栈)算法"></a>种子填充的一种非递归(栈)算法</h5><ul><li>以4连通边界为例</li><li>种子像素入栈</li><li>当栈非空时，重复以下步骤: <ul><li>栈顶像素出栈</li><li>将出栈象素置成填充色</li><li>按左、上、右、下顺序检查与出栈象素相邻的四象素，若其中某象素不在边界上且未被置成填充色，则将其入栈</li></ul></li><li>特点: 每个像素都需要压栈，耗内存，费时间<br><img src="/CG/种子.png" width="40%"></li></ul><h5 id="种子填充的扫描线算法"><a href="#种子填充的扫描线算法" class="headerlink" title="种子填充的扫描线算法"></a>种子填充的扫描线算法</h5><ul><li>基本思想:<ul><li>利用扫描线的连贯性，每次<strong>填充一行像素</strong></li><li>减少压入堆栈的像素数目</li></ul></li><li>种子像素入栈</li><li>当栈非空时，重复以下步骤:<ul><li>栈顶像素出栈</li><li>沿扫描线对出栈像素的左右像素进行填充，直到遇到边界像素为止</li><li>将上述区间内最左、最右像素记为x<sub>l</sub>,和x<sub>r</sub></li><li>在区间[x<sub>l</sub>,x<sub>r</sub>]中检查与当前扫描线相邻的上下两条扫描线是否全为边界像素、或已填充的像素，若为非边界、未填充的像素，则<strong>把每一区间的最右像素取为种子像素入栈</strong>。(后进先出)</li></ul></li><li><strong>扫描线种子填充算法的特点</strong><ul><li>适用于边界定义的区域</li><li>四连通边界定义的区域既可以是凸的，也可以是凹的，还可以是有孔的。</li><li>算法减少了每个像素的访问次数</li><li>所需堆栈深度较浅</li><li>每次递归填充一行像素，因而速度较快</li></ul></li></ul><h5 id="多边形扫描转换-A-与区域填充方法-B-比较"><a href="#多边形扫描转换-A-与区域填充方法-B-比较" class="headerlink" title="多边形扫描转换(A)与区域填充方法(B)比较"></a>多边形扫描转换(A)与区域填充方法(B)比较</h5><ul><li>都是光栅图形面着色， 用千真实感图形显示。</li><li>可相互转换。</li><li>不同点：</li></ul><ol><li>基本思想不同；<ul><li>A用于将顶点表示转换成点阵表示；</li><li>B只改变区域内填充颜色，没有改变表示方法。</li></ul></li><li>对边界的要求不同<ul><li>A：只要求扫描线与多边形边界交点个数为偶数。</li><li>B：区域封闭，防止递归填充跨界。</li></ul></li><li>基本的条件不同<ul><li>A：从边界顶点信息出发。</li><li>B：区域内种子点。</li></ul></li></ol><h3 id="2-6-字符"><a href="#2-6-字符" class="headerlink" title="2.6 字符"></a>2.6 字符</h3><h5 id="字符的表示和输出"><a href="#字符的表示和输出" class="headerlink" title="字符的表示和输出"></a>字符的表示和输出</h5><ul><li><strong>字符</strong>：数字、字母、汉字， 计算机中字符由一个数字编码唯一标识。</li><li><strong>字符集</strong>：<ul><li>ASCII码：美国信息交换标准代码。</li><li>ISO 8859：是国际标准化组织(ISO)及国际电工委员会(IEC)联合制定的一系列8位字符集的标准， 现时定义了15个字符集。增加、加192个字母及符号， 附加符号的拉丁字母语言</li><li>GB2312/GBK, 这就是汉字的国标码， 专门用来表示汉字， 是双字节编码，</li><li>Unicode可以用来表示所有语言的字符， 而且是定长双字节（也有四字节的）编码， 包括英文字母在内。</li><li>UTF可以用来表示所有语言的字符， utf编码是不定长编码， 每一个字符的长度从1-6个字节不等。另外， utf编码自带简单的校验功能。一般来讲， 英文字母都是用一个字节<br>表示， 而汉字使用三个字节。</li></ul></li><li><strong>字库</strong>：字库中存储了每个字符的形状信息，字库分为<strong>矢量和点阵型</strong>两种。</li><li><strong>点阵字符</strong>：<ul><li>在点阵表示中，每一个字符由一个点阵位图来表示。点阵字符的存储是<strong>按行或者按列进行编码</strong>。</li><li>显示时，形成字符的像素图案。</li></ul></li><li>矢量字符<ul><li>采用直线和曲线段来描述字符形状，矢量字符库中记录的是笔划信息(存的是<strong>顶点的位置信息</strong>)。</li><li>显示时，解释字符的每个笔划信息</li></ul></li></ul><h3 id="2-7-反走样"><a href="#2-7-反走样" class="headerlink" title="2.7 反走样"></a>2.7 反走样</h3><ul><li>什么是反走样?<ul><li>把<strong>由离散量表示连续量引起的失真</strong>称为走样;</li><li>把减少或克服走样效果的技术称为反走样技术，简称反走样。 </li></ul></li><li>光栅图形的走样有如下几种:<ul><li>产生阶梯或锯齿形;</li><li>狭小图形遗失;细节失真</li><li>实时动画忽隐忽现、闪烁跳跃。 </li></ul></li><li><strong>常用的反走样的主要方法</strong> <strong>P41</strong><ul><li>提高分辨率方法(硬件技术)</li><li>非加权区域采样：改变直线段的模型，由此产生算法。将直线段看作具有一定宽度的狭长矩形。<strong>缺点</strong>是直线离像素中心点越近，贡献越大。</li><li>加权区域采样：使相交区域对象亮度的贡献依赖于该区域与像素中心的距离。</li></ul></li></ul><h2 id="3-三维图形的剪裁"><a href="#3-三维图形的剪裁" class="headerlink" title="3. 三维图形的剪裁"></a>3. 三维图形的剪裁</h2><ul><li>场景由世界坐标中指定的对象集合组成</li><li>当我们显示场景时，仅显示特定窗口中的那些对象</li><li>因为将内容绘制到显示器需要时间，我们会剪切窗口外的所有内容</li><li>设窗口的边界为wx<sub>min</sub>, wy<sub>min</sub>, wx<sub>max</sub>, wy<sub>max</sub><ul><li>当一个点(x, y)满足：wx<sub>min</sub> &lt; x &lt; wx<sub>max</sub> &amp;&amp; wy<sub>min</sub> &lt; y &lt; wy<sub>max</sub> 则不需要被剪裁</li><li>否则被剪裁。</li></ul></li></ul><h3 id="3-1-直线段裁剪"><a href="#3-1-直线段裁剪" class="headerlink" title="3.1 直线段裁剪"></a>3.1 直线段裁剪</h3><h5 id="Cohen-Sutherland算法"><a href="#Cohen-Sutherland算法" class="headerlink" title="Cohen-Sutherland算法"></a>Cohen-Sutherland算法</h5><ul><li>优点：减少了必须计算的线与窗口的交点的数量。</li><li>世界空间根据窗口边界划分为区域：<ul><li>每个区域具有唯一的四位区域码。</li><li>区域码表<strong>示区域相对于窗口的位置</strong>。<br>&lt;img src = “区域码.png” width =50%”&gt;</li></ul></li><li>判别方法：设线段的两个端点为P1(x1，y1)和P2(x2，y2)， 根据上述规则，可以求出P1和P2所在区域的分区代码C1和C2。<ul><li>C1 = C2 = 0，表明两端点全在窗口内，因而整个线段也在窗内，应予保留。</li><li>C1 And C2 ≠ 0(两端点代码<strong>按位作逻辑乘</strong>不为0)，即C1和C2至少有某一位同时为1，表明两端点必定处于某一边界的同一外侧，因而整个线段全在窗外，应予舍弃。</li><li>不属于上面两种情况，均需要求交点。</li></ul></li><li>注意：求的交点可能是<strong>延长线上的交点</strong>。</li><li>求交点：<ul><li>使用直线的方程计算与窗口边界的交点</li><li>假设一条直线具有端点(x1, y1), (x2, y2)</li><li>与垂直窗口边界的交点坐标为 y = y<sub>1</sub> + m(x<sub>边界</sub> - x<sub>1</sub>), x<sub>边界</sub>可以为x<sub>min</sub>或者x<sub>max</sub></li><li>与水平窗口边界的交点坐标 x = x<sub>1</sub> + (y<sub>边界</sub> - x<sub>1</sub>) / m</li><li>m = (y<sub>2</sub> - y<sub>1</sub>) / (x<sub>2</sub> - x<sub>1</sub>)</li></ul></li></ul><h5 id="中点分割剪裁算法"><a href="#中点分割剪裁算法" class="headerlink" title="中点分割剪裁算法"></a>中点分割剪裁算法</h5><ul><li>注意：求的交点是<strong>真实的交点</strong>。</li><li><strong>基本思想</strong>：<ul><li>P( (x<sub>1</sub> + x<sub>2</sub>) / 2 , (y<sub>1</sub> + y<sub>2</sub>) / 2 )</li><li>如果P1与P同侧，移动P1点。即可能的交点只能出现在PP2段 <code>if((C1&amp;C)!=0) P1=P</code>;</li><li>如果P1与P不同侧，移动P2点。即可能的交点只能出现在P1P段 <code>if((C1&amp;C)= =0) P2=P</code>;<br>&lt;img src = “中点分割.png” width =22%”&gt;</li></ul></li><li><strong>算法步骤</strong>：<ul><li><strong>将直线的两端点P1、P2编码得：C1、C2。</strong></li><li><strong>根据C1和C2的具体值，可以有三种情况：</strong><br>①C1=C2=0，表明两端点全在窗口内，因而整个线段也在窗内，应予保留。<br>②C1&amp;C2≠0，表明两端点必定处于某一边界的同一外侧，因而整个线段全在窗外，应予舍弃。<br>③不属于上面两种情况，均需要求交点。</li><li><strong>求交点</strong><br>①令窗外端点为P1，如果窗外点不是P1，则P1和P2交换端点。保留窗内端点P2到暂存器里。<br>②对P1编码为C1，用中点公式求出中点 ，并编码得C。按照中点算法的求交规则：<br>若P1和P同侧，移动P1点<code>if((C1&amp;C)!=0) P1=P</code>; 否则，移动P2点 <code>else P2=P</code><br>③流程转②，直到P1和P2相差一个单位时:令交点为P2，取出暂存器的端点赋给P1，然后转向流程①</li></ul></li><li><strong>算法特点</strong>：<ul><li>求交点的次数(n)与线段长度(L)有关，其关系为: <strong>L = 2<sup>n</sup></strong> 例如：线段长度为256，则求交点的次数为8。</li><li>中点分割法求出的交点是<strong>边界上的有效交点</strong>，而不是边界及其延长线上的交点。而Cohen-Sutherland直线裁剪算法求出的则是<strong>边界上或者边界的延长线上的交点</strong>。</li></ul></li></ul><h3 id="3-2-多边形裁剪"><a href="#3-2-多边形裁剪" class="headerlink" title="3.2 多边形裁剪"></a>3.2 多边形裁剪</h3><h5 id="Sutlerland-Hodgman算法-逐边裁剪算法"><a href="#Sutlerland-Hodgman算法-逐边裁剪算法" class="headerlink" title="Sutlerland-Hodgman算法 / 逐边裁剪算法"></a>Sutlerland-Hodgman算法 / 逐边裁剪算法</h5><ul><li>窗口的一条边以及延长线构成的裁剪线该线把平面分成两个部分：可见一侧；不可见一侧。</li><li>简单地通过依次将多边形与每个边界进行比较来修剪多边形。</li><li>多边形的各条边的两端点S、P。它们与裁剪线的位置关系只有四种：<ul><li>S，P均在可见一侧 → 输出P</li><li>S，P均在不可见一侧 → 无输出</li><li>S可见，P不可见 → 输出SP与裁剪线的交点I</li><li>S不可见，P可见  → 输出SP与裁剪的交点I和P<br><img src="/CG/裁剪.jpeg" width="45%"></li></ul></li><li><strong>特点：</strong><ul><li>裁剪算法采用流水线方式， <strong>适合硬件实现。</strong></li><li>可推广到<strong>任意凸多边形裁剪窗口</strong></li></ul></li></ul><h5 id="Weiler-Atherton算法"><a href="#Weiler-Atherton算法" class="headerlink" title="Weiler-Atherton算法"></a>Weiler-Atherton算法</h5><ul><li><strong>特点：</strong><ul><li>裁剪窗口为<strong>任意多边形(凸、凹、带内环)</strong>的情况:</li></ul></li><li>内裁减与外裁剪：<ul><li>内裁剪: 即通常意义上的裁剪，取图元位于窗口之内的部分</li><li>外裁剪: 取图元位于窗口之外的部分。</li></ul></li><li>如果主多边形与裁剪多边形有交点，则<strong>交点成对出现</strong>。它们被分为如下两类:<ul><li>一类称“入”点。即被裁剪多边形由此点进入裁剪窗口，如图中a、c、e。</li><li>一类称“出”点。即被裁剪多边形由此点离开裁剪窗口，如图中b、d、f。</li></ul></li><li>Weiler-Atherton算法步骤<ol><li>建顶点表 </li><li>求交点</li><li>裁剪<br><img src="/CG/wa.png" width="75%"></li></ol></li><li><strong>详细步骤</strong><ol><li><strong>顺时针</strong>输入被裁剪多边形顶点序列 I 放入数组1中。</li><li><strong>顺时针</strong>输入裁剪窗口顶点序列II放入数组2中。</li><li>求出被裁剪多边形和裁剪窗口相交的所有交点，并给每个交点打上 “入”、“出”标记。 然后将交点按顺序插入序列I得到新的顶点序列 III ，并放入数组3中;同样也将交点按顺序插入序列II得到新的顶点序列 IV ，放入数组4中; </li><li>初始化输出数组Q，令数组Q为空。接着从数组3中寻找“入”点。如果“入”点没找到，程序结束。 </li><li>如果找到“入”点，则将“入”点放入S中暂存。</li><li>将“入”点录入到输出数组Q中。并从数组 3 中将该“入”点的“入” 点标记删去。 </li><li>沿数组 3 顺序取顶点: 如果顶点是“出点”，则将顶点录入到输出数组Q中，流程转第7步。否则，流程转第8步。</li><li>沿数组4顺序取顶点:如果顶点是“入点”，则将顶点录入到输出数组Q中，流程转第8步。 否则，流程转第9步。</li><li><strong>如果顶点不等于起始点S，流程转第6步，继续跟踪数组3</strong>。 否则，将数组Q输出。</li><li>流程转第4步，寻找可能存在的分裂多边形。 算法在第4步：满足“入”点没找到的条件时，算法结束。</li></ol></li><li><strong>交点的奇异情况处理</strong><ul><li>与裁剪多边形边重合的主多边形的边不参与求交点;</li><li>对于顶点落在裁剪多边形的边上的主多边形的边，如果落在该裁<br>剪边的内侧，将该顶点算作交点;而如果这条边落在该裁剪边<br>的外侧，将该顶点不看作交点。<br><img src="/CG/奇异.png" width="60%"></li></ul></li></ul><h3 id="3-3-字符裁剪"><a href="#3-3-字符裁剪" class="headerlink" title="3.3 字符裁剪"></a>3.3 字符裁剪</h3><ul><li><strong>基于字符串</strong>：将包围字符串的外接矩形对窗口作裁剪。当字符串外接矩形整个在 窗口内时予以显示，否则不显示。</li><li><strong>基于字符</strong>：将包围字符的外接矩形对窗口作<br>裁剪，如某个字符外接矩形整个落<br>在窗口内予以显示，否则不显示。</li><li><strong>基于构成字符的最小元素 / 像素</strong>：点阵字符：点裁剪 ；矢量字符：线裁剪<br><img src="/CG/字符.png" width="80%"></li></ul><h2 id="4-图形的变换"><a href="#4-图形的变换" class="headerlink" title="4. 图形的变换"></a>4. 图形的变换</h2><h3 id="4-1-图形变换的数学基础"><a href="#4-1-图形变换的数学基础" class="headerlink" title="4.1 图形变换的数学基础"></a>4.1 图形变换的数学基础</h3><ul><li><strong>图形几何变换</strong>：几何图形按照某种法则或规律变换成另一种几何图形的过程。</li><li>矩阵及其运算 P203</li></ul><h3 id="4-2-二维几何变换"><a href="#4-2-二维几何变换" class="headerlink" title="4.2 二维几何变换"></a>4.2 二维几何变换</h3><h5 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h5><ul><li>齐次坐标：所谓齐次坐标, 就是将一个原本是n维的向量用一个n+1 维向量来表示。<ul><li>例如, 向量(x<sub>1</sub>, x<sub>2</sub>, …, x<sub>n</sub>)的齐次坐标表示为<br>(H<sub>x<sub>1</sub></sub>, H<sub>x<sub>2</sub></sub>, …, H<sub>x<sub>n</sub></sub>, H), 其中H是一个不为0的实数。</li></ul></li><li>由点或向量的齐次坐标(H<sub>x<sub>1</sub></sub>, H<sub>x<sub>2</sub></sub>, …, H<sub>x<sub>n</sub></sub>, H)求它的<strong>规范化齐次坐标</strong>, 可根据如下公式求得：<ul><li>x<sub>1</sub> = H<sub>x<sub>1</sub></sub> / H, x<sub>2</sub> = H<sub>x<sub>2</sub></sub> / H, …, x<sub>n</sub> = H<sub>x<sub>n</sub></sub> / H</li></ul></li><li>齐次坐标表示不是唯一的，通常<strong>当h=1时</strong>，称为<strong>规格化齐次坐标</strong>， 在计算机图形学里面，我们常用的是规格化齐次坐标。</li><li>为什么需要引入齐次坐标？<ul><li>多个变换作用于多个目标</li><li>引入齐次坐标，变换的表示法统一</li></ul></li><li>图形变换具有统一表示形式的优点：<ul><li>便于变换合成 </li><li>便于硬件实现  </li></ul></li></ul><h5 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h5><ul><li><strong>平移、旋转、缩放变换</strong><br><img src="/CG/几何变换.jpg" width="100%"></li><li><strong>对称变换</strong>：<br><img src="/CG/对称.jpg" width="100%"></li><li><p><strong>错切变换</strong>： </p><ul><li>也称为剪切、错位变换，用于产生弹性物体的变形处理。</li><li>错切的变换矩阵<br><img src="/CG/错切.jpg" width="100%"></li><li>(a) 错切角 (b) 沿x方向错切 (c) 沿y方向错切<br><img src="/CG/错切3.png" width="50%"></li></ul></li><li><p><strong>仿射变换</strong></p><ul><li>变换的坐标x’和y’都是原始坐标x和y的线性函数。</li><li>仿射变换具有平行线转换成平行线和有限点映射到有限点的一般特性。</li><li><strong>平移、比例、旋转、对称和错切变换是二维仿射变换的特例</strong>，任何常用的二维仿射变换总可表示为这五种变换的组合。 </li></ul></li></ul><h5 id="复杂变换"><a href="#复杂变换" class="headerlink" title="复杂变换"></a>复杂变换</h5><ul><li>复合变换是指对图形进行一次以上的变换，变换的结果是 每次的变换矩阵相乘。</li><li>任何一组变换都可以表示成一个复合变换矩阵，只需要计算每一个单独<strong>变换矩阵</strong>，并求解出乘积。</li><li>从另一个方面讲，任何一个复杂的几何变换都可以看作基本几何变换的组合形式，也叫复合变换。</li></ul><h3 id="4-3-窗口到视区的变换"><a href="#4-3-窗口到视区的变换" class="headerlink" title="4.3 窗口到视区的变换"></a>4.3 窗口到视区的变换</h3><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ul><li><strong>坐标系</strong>：建立了图形与数之间的对应联系<ul><li><strong>世界坐标系</strong>：用户需要在图形独享所在的控件定义一个坐标系</li><li><strong>用户坐标系</strong>：用户按照自己习惯建立世界坐标系，所以世界坐标系有时也称用户坐标系。</li><li><strong>局部坐标系</strong>：简化图形对象的描述，相对于图形定义</li><li><strong>屏幕坐标系</strong>：屏幕上或绘图纸上定义一个二维直角坐标系，也称为设备坐标系。</li></ul></li><li><strong>窗口</strong>：在计算机图形学中，将在用户坐标系中需要进行观察和处理的一个坐标区域。</li><li><strong>视区</strong>：将窗口映射到显示设备上的坐标区域。 <ul><li>改变视区的位置，可以在输出设备的不同位置显示图形对象。</li><li>改变视区的大小和比例可以改变显示对象的大小和比例。 </li></ul></li><li><strong>裁剪在扫描转换之前</strong><br><img src="/CG/显示.png" width="60%"></li></ul><h5 id="窗口到视区变换"><a href="#窗口到视区变换" class="headerlink" title="窗口到视区变换"></a>窗口到视区变换</h5><ul><li>变换步骤：<ul><li>将窗口左下角点<strong>移至用户系统系的坐标原点</strong></li><li>针对原点进行<strong>比例变换</strong></li><li>进行<strong>反平移</strong></li></ul></li><li>两种情况：<ol><li>窗口区的边与坐标轴平行</li><li>窗口区的边与坐标轴不平行：将窗口左下角点<strong>移至用户系统系的坐标原点</strong>后需要旋转到与坐标轴平行。</li></ol></li></ul><h3 id="4-4-三维几何变换"><a href="#4-4-三维几何变换" class="headerlink" title="4.4 三维几何变换"></a>4.4 三维几何变换</h3><h5 id="三维齐次坐标"><a href="#三维齐次坐标" class="headerlink" title="三维齐次坐标"></a>三维齐次坐标</h5><ul><li>(x, y, z)对应的齐次坐标为(x<sub>h</sub>, y<sub>h</sub>, z<sub>h</sub>, h)<ul><li>标准齐次坐标(x,y,z,1) ==〉用来表示三维空间点(x, y, z)。</li></ul></li><li>使用<strong>右手坐标系</strong>(z轴正方向向外) </li></ul><h5 id="三维几何变换"><a href="#三维几何变换" class="headerlink" title="三维几何变换"></a>三维几何变换</h5><ul><li>三维平移变换、放缩变换</li><li>三维旋转变换<ul><li>是指给定的三维立体绕三维空间某个指定的坐标轴旋转θ角度。 </li><li>旋转后, 立体的空间位置将发生变化, 但形状不变。 </li><li><strong>θ角的正负按右手规则确定</strong>, 右手大姆指指向旋转轴的正向, 其余四个手指指向旋转角的正向。</li></ul></li></ul><p><img src="/CG/3d.jpg" width="100%"></p><ul><li>三维错切变换：是指三维立体在空间沿x、 y、 z三个方向实现错切变形, 三维错切是二维错切变换的一个扩充。</li><li>三维对称变换<br><img src="/CG/3d2.jpg" width="60%"></li></ul><h2 id="5-投影"><a href="#5-投影" class="headerlink" title="5. 投影"></a>5. 投影</h2><h3 id="5-1-三维图形显示的基本问题"><a href="#5-1-三维图形显示的基本问题" class="headerlink" title="5.1 三维图形显示的基本问题"></a>5.1 三维图形显示的基本问题</h3><ol><li><strong>在二维屏幕上如何显示三维物体?</strong><ul><li>显示器屏幕、绘图纸等是二维的，显示对象是三维的</li><li>解决方法：投影</li></ul></li><li><strong>如何表示三维物体?</strong><ul><li>二维形体的表示：直线段, 折线, 曲线段, 多边形区域</li><li>二维形体的输入：<strong>简单</strong>(图形显示设备与形体的维数一致)</li><li>三维形体的表示：空间直线段、折线、曲线段、多边形、曲面片 </li><li>三维形体的输入、运算、有效性保证<strong>(困难)</strong></li><li>解决方法：<strong>各种用于形体表示的理论、模型、方法</strong></li></ul></li><li><strong>如何反映遮挡关系?</strong><ul><li>物体之间或物体的不同部分之间存在相互遮挡关系</li><li>遮挡关系是空间位置关系的重要组成部分</li><li>解决方法：<strong>消除隐藏面与隐藏线</strong></li></ul></li><li><strong>如何产生真实感图形?</strong><ul><li>人们观察现实世界产生的真实感来源于<br>• 空间位置关系：近大远小的透视关系和遮挡关系<br>• 光线传播引起的物体表面颜色的自然分布</li><li>解决方法：<strong>建立光照明模型、开发真实感图形绘制方法</strong></li></ul></li></ol><h5 id="三维图形显示的基本研究内容"><a href="#三维图形显示的基本研究内容" class="headerlink" title="三维图形显示的基本研究内容"></a>三维图形显示的基本研究内容</h5><ul><li>投影</li><li>三维形体的表示</li><li>消除隐藏面与隐藏线</li><li>建立光照明模型、开发真实感图形绘制方法</li></ul><h3 id="5-2-平面几何投影"><a href="#5-2-平面几何投影" class="headerlink" title="5.2 平面几何投影"></a>5.2 平面几何投影</h3><ul><li>投影 — 照相机模型<ul><li>选定投影类型 → <strong>透视投影</strong>与<strong>平行投影</strong></li><li>设置投影参数 → 拍摄方向、距离等</li><li>三维裁剪 → 取景</li><li>投影和显示 → 成像</li></ul></li><li><strong>简单的三维图形显示流程图</strong><br><img src="/CG/3d流程.png" width="40%"> </li><li><strong>投影</strong>：将n维的点变换成小于n维的点。比如将3维的点变换成小于3维的点</li><li><strong>投影中心</strong>(COP: Center of Projection)<ul><li>eg. 视觉系统—观察点、视点; 电影放映机—光源</li></ul></li><li><strong>投影面</strong>：不经过投影中心的面<ul><li>eg. 平面–照相机底片; 曲面—球幕电影,视网膜</li></ul></li><li><strong>投影线：</strong>从投影中心向物体上各点发出的射线<ul><li>eg. 直线—光线; 曲线—喷绘</li></ul></li><li><strong>平面几何投影</strong>：投影面是平面，投影线为直线</li><li><strong>投影变换</strong>：投影过程，投影的数学表示</li><li>平面几何投影的分类<br><img src="/CG/投影.png" width="40%"> </li></ul><h5 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h5><ul><li>投影中心与投影平面之间的距离为有限</li><li>参数：投影中心、投影方向</li><li>eg. 室内白炽灯的投影，视觉系统</li><li><strong>灭点</strong>：不平行于投影平面的平行线，经过透视投影之后收敛于一点，称为灭点。</li><li><strong>主灭点</strong>：坐标轴方向的平行线在投影面上 形成的灭点称作主灭点。<ul><li>一点透视：表现范围广，纵深感强，适合表现庄重、严肃的室内空间或建筑物。比较呆板，与真实效果有一定的距离</li><li>两点透视为：构图画面增加动感，使画面结构丰富。</li><li>三点透视：一般用于超高层建筑俯瞰图或仰视图。<br><img src="/CG/透视.png" width="40%"> </li></ul></li><li><strong>特点</strong>：产生近大远小的视觉效果，由它产生的图形深度强，看起来更加真实。</li></ul><h5 id="平行投影"><a href="#平行投影" class="headerlink" title="平行投影"></a>平行投影</h5><ul><li>投影中心与投影平面之间的距离为无限</li><li>是透视投影的极限状态</li><li>分类:<ul><li>根据投影射线与投影平面的关系，平行投影可分为<strong>正投影和斜投影</strong>。<br><img src="/CG/平行投影.png" width="40%"> </li></ul></li><li>正投影：<ul><li>根据投影面和坐标轴的夹角可分为两类:三视图和正轴测图</li><li>当<strong>投影面与某一坐标轴垂直</strong>时，得到的投影为三视图，这时投影方向和这个坐标轴的方向一致。否则，得到的投影为正轴测图。<br><img src="/CG/正投影.png" width="40%"> </li></ul></li><li><strong>三视图</strong>: 包括<strong>主视图、侧视图和俯视图</strong>三种，投影面分别与X轴、Y轴和Z轴垂直</li><li>正轴侧：当投影平面与三个坐标轴都不垂直时。<ul><li>正轴侧又分为等轴侧、正二侧和正三侧。</li><li>当投影面与<strong>三个</strong>坐标轴之间的<strong>夹角都相等</strong>时为等轴测。</li><li>当投影面与<strong>两个</strong>坐标轴之间的<strong>夹角相等</strong>时为正二测。</li><li>当投影面与<strong>三个</strong>坐标轴之间的<strong>夹角都不相等</strong>时为正三测。</li></ul></li></ul><h5 id="斜投影"><a href="#斜投影" class="headerlink" title="斜投影"></a>斜投影</h5><ul><li><strong>投影方向不垂直于投影面</strong></li><li>分类：<ul><li>斜等侧投影:投影方向和投影面夹角α成45° </li><li>斜二侧投影:投影方向和投影面夹角α=arctan(2)</li></ul></li></ul><h5 id="投影总结"><a href="#投影总结" class="headerlink" title="投影总结"></a>投影总结</h5><ul><li>平行投影:投影中心与投影面间距离为无穷远。</li><li>正平行投影:投影方向和投影面垂直。</li><li>三视图:三个投影面和坐标轴相互垂直。</li><li>正轴侧:投影面和坐标轴呈一定的关系。 </li><li>斜平行投影:投影方向和投影面不垂直。</li><li>透视投影:投影中心与投影面间距离为有限。</li></ul><h3 id="5-3-投影变换-amp-投影举例"><a href="#5-3-投影变换-amp-投影举例" class="headerlink" title="5.3 投影变换 &amp; 投影举例"></a>5.3 投影变换 &amp; 投影举例</h3><ul><li><strong>三维观察变换</strong>所起的作用是完成从用户空间选取的一部分物体描述变换到 显示屏上指定的视窗中的图形描述。<ul><li>简单的三维观察流水线：<br><img src="/CG/流水线.png" width="40%"> </li></ul></li><li><strong>取景变换</strong>:完成从用户坐标系中的描述 -&gt; 观察坐标系中的描述的坐标变换。</li><li><strong>观察坐标系(VRC)</strong>:照相机所在的坐标系</li></ul><h5 id="建立观察坐标系"><a href="#建立观察坐标系" class="headerlink" title="建立观察坐标系"></a>建立观察坐标系</h5><ul><li>挑选一个用户坐标点称为观察参考点VRP(View Reference Point)， 即该点为观察坐标系的原点;</li><li>通过给定观察平面法向量来选择观察坐标系的 Zv轴和观察平面方向;</li><li>指定一观察向上向量，通过该向量来建立 观察坐标系的Yv轴;</li><li>确定观察点又称为投影中心(若为透视投影时) 或确定投影方向(若为平行投影时)</li></ul><h5 id="用户坐标到观察坐标的变换"><a href="#用户坐标到观察坐标的变换" class="headerlink" title="用户坐标到观察坐标的变换"></a>用户坐标到观察坐标的变换</h5><ul><li>在物体描述投影到观察平面之前，必须将其转换成观察坐标。该变换顺序是:    <ul><li>平移观察参考点VRP(x0,y0,z0)到用户坐标系原点; </li><li>进行旋转分别让Xv,Yv和Zv轴对应到用户坐标系的x、y、和z轴。 一旦景物中物体的用户坐标描述转换到观察坐标后，我们就可以将三维<br>物体投影到二维观察平面上。<br><img src="/CG/观察坐标.png" width="50%"> </li></ul></li><li>为使剪取处理简单和规范化(即单位化)，需要利用坐标变换将<strong>视见体规范化</strong>。</li></ul><h5 id="视见体-View-Port"><a href="#视见体-View-Port" class="headerlink" title="视见体(View Port)"></a>视见体(View Port)</h5><ul><li>视见体是三维裁剪窗口。</li><li>建立步骤：<ul><li>定义窗口 → 发出射线 → 形成观察空间 → 前后剪裁面 → 形成视见体</li></ul></li><li>需注意，对于透视投影，<strong>前截面必须在投影中心和后截面之间。</strong></li><li>投影参考点(PRP: Projection Reference Point)<br><img src="/CG/视见体.png" width="50%"> <ul><li>透视投影: COP==PRP;</li><li>平行投影: 投影方向DOP= CW-PRP</li><li>透视投影: 观察空间为四棱锥</li><li>平行投影: 观察空间为四棱柱</li></ul></li></ul><h5 id="透视投影变换"><a href="#透视投影变换" class="headerlink" title="透视投影变换"></a>透视投影变换</h5><ul><li>问题：在uvn中，投影平面为n=0，投影中心为(0，0，d)， 待投影点为P(u<sub>p</sub>，v<sub>p</sub>，n<sub>p</sub>)，求投影点Q (u<sub>Q</sub>，v<sub>Q</sub>，n<sub>Q</sub>)<br><img src="/CG/透视投影变换.png" width="25%"><br><img src="/CG/透视投影变换2.png" width="25%"></li><li>透视投影变换矩阵:作用就是将三维物体变换成二维透视投影。</li></ul><h5 id="斜平行投影"><a href="#斜平行投影" class="headerlink" title="斜平行投影"></a>斜平行投影</h5><ul><li>投影方向不垂直于投影平面的平行投影被称为斜平行投影。</li></ul><h5 id="从世界坐标系到观察坐标系的变换"><a href="#从世界坐标系到观察坐标系的变换" class="headerlink" title="从世界坐标系到观察坐标系的变换"></a>从世界坐标系到观察坐标系的变换</h5><p><img src="/CG/变换.png" width="25%"></p><h3 id="5-4-规范视见体变换-规范裁剪空间"><a href="#5-4-规范视见体变换-规范裁剪空间" class="headerlink" title="5.4 规范视见体变换 / 规范裁剪空间"></a>5.4 规范视见体变换 / 规范裁剪空间</h3><ul><li>为什么引入规范视见体?<ul><li>使裁剪算法非常容易、直观</li><li>有助于隐藏线和隐藏面的消除。</li></ul></li><li>规范化变换：将任意视见体变换成规范视见体的变换</li><li>三维图形的显示流程图<br><img src="/CG/2.png" width="45%"></li><li>采用视见体变换的三维图形显示流程图<br><img src="/CG/1.png" width="45%"><ul><li>观察变换：从世界坐标系到观察坐标系的变换</li></ul></li></ul><h5 id="何时裁剪"><a href="#何时裁剪" class="headerlink" title="何时裁剪"></a>何时裁剪</h5><ul><li><strong>投影之前裁剪 三维裁剪</strong><ul><li>优点：只对可见的物体进行投影变换</li><li>缺点：三维裁剪相对复杂</li></ul></li><li><strong>投影之后裁剪 二维裁剪</strong><ul><li>优点：二维裁剪相对容易</li><li>缺点：需要对所有的物体进行投影变换</li></ul></li><li>采用投影后裁剪的三维图形显示流程图<br><img src="/CG/3.png" width="45%"></li><li>在投影之前裁剪的理由<ul><li>三维物体的表面通常被离散表示成多边形或折线，而对这类简单图元，三维裁剪同样比较简单。</li><li>三维图形<strong>在显示过程中需要被消隐</strong>，做这个工作要有图形的深度信息，所以必须在投影之前完成。 消隐很费时，如果在此之前裁剪 (或部分裁剪)掉不可见的图形，可使需要消隐的图形减至最小。</li></ul></li></ul><h2 id="6-隐藏面的消除"><a href="#6-隐藏面的消除" class="headerlink" title="6. 隐藏面的消除"></a>6. 隐藏面的消除</h2><h3 id="6-1-基本概念"><a href="#6-1-基本概念" class="headerlink" title="6.1 基本概念"></a>6.1 基本概念</h3><ul><li>要画出确定的、立体感很强的三维图形，就必须将那些被不透明的面<br>(或物体)所遮挡的线段(或面)移去，这就是隐藏线或隐藏面的消隐处理。</li><li><strong>按消隐对象</strong>将三维物体消隐分为两类: <ul><li><strong><code>线消隐</code></strong>：其消隐对象是物体上的边, 消除的是<strong>物体上不可见的边</strong>，用于线框图。</li><li><strong><code>面消隐</code></strong>：其消隐对象是物体上的面, 消除的是<strong>物体上不可见的面</strong>，用于填色图。</li></ul></li><li><strong>根据消隐空间</strong>的不同，将消隐算法分为3类：<ul><li>物体空间的消隐算法：将场景中每一个面与其它每个面比较, 求出所有点、边、面的遮挡关系。算法精度较高。如<strong>光线投射</strong>等。</li><li>图像空间的消隐算法：对屏幕上每个像素进行判断, 决定哪个多边形在该像素可见。 如：<strong>Z-buffer、扫描线</strong>等。</li><li>物体空间和图像控件的消隐算法：在物体空间中预先计算面的可见性优先级, 再在图像空间中生成 消隐图。如：<strong>画家算法</strong>等。</li></ul></li></ul><h3 id="6-2-提高消隐算法效率的常见方法"><a href="#6-2-提高消隐算法效率的常见方法" class="headerlink" title="6.2 提高消隐算法效率的常见方法"></a>6.2 提高消隐算法效率的常见方法</h3><ol><li>利用连贯性<ul><li>物体的连贯性</li><li>面的连贯性</li><li>区域的连贯性 </li><li>扫描线的连贯性</li></ul></li><li>将透视投影转换成平行投影 <ul><li>消隐与投影方式有关 (消隐必须在投影之前完成)</li></ul></li></ol><ul><li>包围盒技术：包围目标的简单形体</li><li>背面剔除</li><li>空间分割技术</li><li>物体分层表示  </li></ul><h5 id="包含消隐的三维图形显示流程图："><a href="#包含消隐的三维图形显示流程图：" class="headerlink" title="包含消隐的三维图形显示流程图："></a>包含消隐的三维图形显示流程图：</h5><p><img src="/CG/4.png" width="45%"></p><h5 id="消隐的基本-核心-问题-排序"><a href="#消隐的基本-核心-问题-排序" class="headerlink" title="消隐的基本(核心)问题:排序"></a>消隐的基本(核心)问题:排序</h5><ul><li>整体排序: 画家算法</li><li>点排序: Z-Buffer算法、光线投射算法 </li><li>区间排序: 扫描线算法</li><li>区域排序: 区域子分算法</li></ul><h3 id="6-3-画家算法"><a href="#6-3-画家算法" class="headerlink" title="6.3 画家算法"></a>6.3 画家算法</h3><ul><li>基本思想 <ul><li>先将场景中的物体按其距观察点的远近进行排序，结果放在一张线性表中;</li><li>线性表构造:距观察点远的称优先级低，放在表头;距观察点近的称优先级高， 放在表尾。该表称为深度优先级表</li><li>然后按照从表头到表尾的顺序逐个绘制物体。</li></ul></li><li>基本步骤<ul><li>对场景中的多边形按深度进行排序，</li><li>形成深度优先级表;</li><li>按从远到近的顺序显示多边形;</li></ul></li><li>画家算法不能处理的情况<ul><li>多边形循环遮挡</li><li>多边形相互穿透</li></ul></li><li>解决办法: 沿多边形所在平面之间的交线循环地分割这些多边形，直至最终可建立确定的优先级表。</li></ul><h3 id="6-4-Z缓冲器算法"><a href="#6-4-Z缓冲器算法" class="headerlink" title="6.4 Z缓冲器算法"></a>6.4 Z缓冲器算法</h3><ul><li>基本思想<ul><li>先将Z缓冲器中个单元的初始值置为-1 (规范视见体的最小n值)。</li><li>当要改变某个像素的颜色值时，首先检查当前<strong>多边形的深度值</strong>是否大于该像素<br>原来的深度值(保存在该像素所对应的Z缓冲器的单元中);</li><li><strong>如果大于，说明当前多边形更靠近观察点</strong>，用它的颜色替换像素原来的颜色;</li><li>否则说明在当前像素处，当前多边形被前面所绘制的多边形遮挡了，是不可见的，像素的颜色值不改变。</li></ul></li><li><strong>优点</strong><ul><li>算法简单、稳定</li><li>便于硬件加速</li><li>不需要整个场景的几何数据</li></ul></li><li><strong>缺点</strong><ul><li>需要Z缓冲器 <strong>改进: 扫描线Z缓冲器算法</strong> </li><li>计算复杂度大 <strong>改进:区域子分算法</strong></li></ul></li></ul><blockquote><p> 需要计算的像素深度值次数 = 多边形个数 * 多边形平均占据的像素个数</p></blockquote><h3 id="6-5-扫描线Z缓冲器算法"><a href="#6-5-扫描线Z缓冲器算法" class="headerlink" title="6.5 扫描线Z缓冲器算法"></a>6.5 扫描线Z缓冲器算法</h3><ul><li>改进一: 将窗口分割成扫描线<ul><li>缺点：在每一个被多边形覆盖像素处需要计算深度值；被多个多边形覆盖的像素需要多次计算深度值</li></ul></li><li>改进二：利用扫描线的连贯性计算深度 (增量法)</li><li>改进三：采用多边形分类表(PT)、活化多边形表 (APT)<strong>避免多边形与扫描线的盲目求交</strong></li><li>改进四：利用边、边的分类表(ET)、边对、活化边对表(AEPT)<strong>避免边与扫描线的盲目求交</strong></li></ul><h3 id="6-6-区间扫描线算法"><a href="#6-6-区间扫描线算法" class="headerlink" title="6.6 区间扫描线算法"></a>6.6 区间扫描线算法</h3><ul><li><strong>要求多边形不能相互贯穿</strong></li><li>该算法可以看作是边相关扫描线填充算法的延伸。</li><li>不同的是在消隐算法中处理的是多个面片，而多边形填充中是对单个多边形面进行填充。</li><li>它是把当前扫描线与各多边形在投影平面的投影的交点进行排序后，使扫描线分为若干子区间。因此，只要在区间任一点处找出在该 处z值最大的一个面，这个区间上的每一个象素就用这个面的颜色来显示。</li><li>改进：<ul><li>在一条扫描线上，以区间为单位确定多边形的可见性</li><li>不需要Z-Buffer</li></ul></li></ul><h3 id="6-7-区域子分割算法"><a href="#6-7-区域子分割算法" class="headerlink" title="6.7 区域子分割算法"></a>6.7 区域子分割算法</h3><ul><li>首先将场景中的多边形投影到绘图窗口内(假设它为边长为k的正方形)</li><li>判断窗口是否足够简单，若是则算法结束;</li><li>否则将窗口进一步分为四块(左上，右上，左下，右下)。</li><li>对此四个小窗口重复上述过程，直到窗口仅为一个像素大小。</li><li>此时可能有多个多边形覆盖了该像素，计算它们的深度值，以最近的颜色 显示该像素即可。</li></ul><h3 id="6-8-光线投射算法"><a href="#6-8-光线投射算法" class="headerlink" title="6.8 光线投射算法"></a>6.8 光线投射算法</h3><ul><li>考察<strong>由视点出发穿过观察屏幕</strong>的一像素而射入场景的一条射线,则可确定出场景中与该射线相交的物体。 </li><li>在计算出光线与物体表面的交点之后, 离像素最近的交点的所在面片的颜色为该像素的颜色; 如果没有交点, 说明没有多边形的投影覆盖此像素, 用背景色显示它即可。</li></ul><h2 id="7-真实感图形的生成"><a href="#7-真实感图形的生成" class="headerlink" title="7. 真实感图形的生成"></a>7. 真实感图形的生成</h2><ul><li>当光照射到物体表面时，光线可能被<strong>吸收</strong>、<strong>反射</strong>和<strong>透射</strong>。被物体吸收的部分转化为热，反射、透射的光进入 人的视觉系统，使我们能看见物体。</li><li>为模拟这一现象，我们建立一些数学模型来替代复杂的物理模型，这些模型就称为明暗效应模型或者光照明模型。三维形体的图形经过消隐后，再进行明暗效应的处 理，可以进一步提高图形的真实感。</li></ul><h3 id="7-1-简单光照明模型"><a href="#7-1-简单光照明模型" class="headerlink" title="7.1 简单光照明模型"></a>7.1 简单光照明模型</h3><ul><li>光照射到物体表面，主要发生:<ul><li>反射 </li><li>透射(对透明物体) </li><li>部分被吸收成热能 </li></ul></li><li>反射光和透射光的<strong>光谱分布</strong>——决定景物表面的<strong>颜色</strong></li><li>反射光和透射光的<strong>强弱</strong>——决定景物表面的<strong>明暗程度</strong></li><li><strong>环境光</strong>：在空间中近似均匀分布，即在任何位置、任何方向<br>上强度一样</li><li><strong>点光源</strong>:几何形状为一个点，位于空间中的某个位置，向周围所有的方向上辐射等强度的光。<ul><li>在物体的不同部分其亮度也不同，亮度的大小依赖于物体的朝向及它与点光源之间的距离。</li></ul></li><li><strong>漫反射</strong>：粗糙、无光泽物体(如粉笔，墙面)表面对光的反射<ul><li>各点反射光的强度只与①点光源强度、入射角 ②物体表面的反射系数  ③物体各表面的朝向 有关</li><li><strong>与观察者的观察方向无关</strong></li></ul></li><li><strong>镜面反射</strong>: 光滑物体(如金属或塑料)表面对光的反射<ul><li>n为镜面反射(高光)指数，n越大，则Is(镜面反射光强)随α的增大衰减的越快  </li><li><strong>n的取值与表面粗糙程度有关</strong><br>①n越大，表面越平滑(散射现象少，稍一偏离，明暗亮度急剧下降)<br>②n越小，表面越毛糙(散射现象严重)</li></ul></li><li>高光: 入射光在光滑物体表面形成的特别亮的区域</li></ul><h5 id="Phong光照明模型"><a href="#Phong光照明模型" class="headerlink" title="Phong光照明模型"></a>Phong光照明模型</h5><ul><li>由物体表面上一点P反射到视点的光强 I 为<strong>环境光的反射光强</strong> I<sub>e</sub>， <strong>理想漫反射光强</strong> I<sub>d</sub>，和<strong>镜面反射光</strong>I<sub>s</sub>的总和。</li><li>Phong光照明模型是真实感图形学中提出的第一个有影响的光照明模型</li><li>经验模型，Phong模型存在不足:<ul><li>显示出的物体象塑料，<strong>无质感变化</strong></li><li><strong>没有考虑物体间相互反射光</strong></li><li>镜面反射颜色与材质无关</li><li>镜面反射大入射角失真现象</li></ul></li></ul><h3 id="7-2-多边形表示的明暗处理"><a href="#7-2-多边形表示的明暗处理" class="headerlink" title="7.2 多边形表示的明暗处理"></a>7.2 多边形表示的明暗处理</h3><h5 id="Gouraud明暗处理-双线性光强插值"><a href="#Gouraud明暗处理-双线性光强插值" class="headerlink" title="Gouraud明暗处理(双线性光强插值)"></a>Gouraud明暗处理(双线性光强插值)</h5><ul><li>先计算物体表面多边形各顶点的光强, 然后用双线性插值, 求出多边形内部区域中各点的光强。</li><li><strong>基本算法描述</strong>:<ol><li>计算多边形顶点的平均法向;</li><li>计算顶点的平均光强;</li><li>插值计算离散边上的各点光强;</li><li>插值计算多边形内域中各点的光强。</li></ol></li><li><strong>优点</strong><ul><li>简单易行，计算量小</li><li>只需已知顶点的法向量 </li></ul></li><li><strong>缺点</strong><ul><li>只适用于简单的漫反射光照模型，不能正确模 拟镜面反射高光形状</li><li>用于动态显示物体时，物体表面明暗以不规则方式进行变化，高光显示问题</li><li>光亮度变化不连续的边界处出现过亮或过暗的条纹</li><li>公共顶点处颜色不连续，顶点方向不具代表性</li></ul></li><li><strong>在Gouraud提出明暗处理方法时，Phong模型还没有出现</strong></li></ul><h5 id="Phong明暗处理-双线性法向插值"><a href="#Phong明暗处理-双线性法向插值" class="headerlink" title="Phong明暗处理 (双线性法向插值)"></a>Phong明暗处理 (双线性法向插值)</h5><ul><li>与双线性光强插值相比, 该方法有如下特点:<ul><li>保留双线性插值, 对多边形边上的点和内域各点, 采用增量法。</li><li>对顶点的法向量进行插值, 而顶点的法向量, 用相邻的多边形的法向作平均。</li><li>由插值得到的法向, 计算每个像素的光亮度。</li><li>假定光源与视点均在无穷远处, 光强只是法向量的函数。</li></ul></li><li>优点<ul><li>Phong方法绘制的图形比Gouraud方法更真实</li></ul></li><li>缺点<ul><li>计算量远大于Gouraud方法</li></ul></li></ul><h5 id="阴影的生成"><a href="#阴影的生成" class="headerlink" title="阴影的生成"></a>阴影的生成</h5><ul><li>阴影<ul><li>光源不能直接照射的区域</li><li>对光源来说，不可见的面(隐藏面)</li></ul></li></ul><h3 id="7-3-透明"><a href="#7-3-透明" class="headerlink" title="7.3 透明"></a>7.3 透明</h3><ul><li>现实世界中有许多透明物体，如玻璃等。透过透明物体，可以观察到其后面的景物。</li><li>产生简单透明效果的方法<ul><li>插值透明方法</li><li>过滤透明方法</li></ul></li></ul><h5 id="Whitted光透射模型"><a href="#Whitted光透射模型" class="headerlink" title="Whitted光透射模型"></a>Whitted光透射模型</h5><ul><li>基于经验、理论，不是严格的物理模型。</li></ul><h5 id="Hall光透射模型"><a href="#Hall光透射模型" class="headerlink" title="Hall光透射模型"></a>Hall光透射模型</h5><ul><li>在Whitted光透射模型的基础上推广而来。<ul><li>加入光源引起的规则透射分量。</li><li>可以处理理想的漫透射。</li></ul></li></ul><h3 id="7-4-整体光照明模型"><a href="#7-4-整体光照明模型" class="headerlink" title="7.4 整体光照明模型"></a>7.4 整体光照明模型</h3><ul><li><strong>五个组成部分：</strong><ul><li></li></ul></li><li>简单光照模型是一种局部光照模型，不考虑周围环境对当前 景物表面的光照明影响，<strong>忽略了光在环境景物之间的传递</strong>，很难表现自然界复杂场景的高质量真实感图形。</li><li>基于简单光照明模型的<strong>光透射模型</strong>，虽然可以模拟光的折射，但是这种折射的计算范围很小，不能很好的模拟多个透明 体之间的复杂光照明现象。</li><li>对于上述的这些问题，就必须要有一个更精确的光照明模型。<strong>整体光照明模型</strong>就是这样的一种模型，它是相对于局部光照明模型而言的。</li></ul><h3 id="7-5-光线跟踪算法-P149"><a href="#7-5-光线跟踪算法-P149" class="headerlink" title="7.5 光线跟踪算法 P149"></a>7.5 光线跟踪算法 P149</h3><ul><li><strong>四种光线</strong><ul><li>视线：由视点与象素(x，y)发出的射线</li><li>阴影测试线：物体表面上点与光源的连线</li><li>反射光线 </li><li>折射光线</li></ul></li><li>无论是Gouraud还是Phong明暗绘制算法，都只能模拟局部光照明效果。</li><li>如果场景中存在<strong>光亮的镜面物体和透明物体，则光线会在物体之间反射和折射</strong>，这些都是上述算法所无法模拟的。还不能产生阴影效果。如果必须模拟这些效果，则我们可以采用光线跟踪算法或辐射度算法。</li><li><strong>自然界中光线的传播过程</strong>：光源 -&gt; 物体表面 -&gt; 物体表面 -&gt; 人眼</li><li><p>光线跟踪过程：<strong>光线传播的逆过程(视线跟踪)</strong></p><ul><li>光源发出光线，经反射与折射，只有很少部分可以进入人的眼睛。因此直接从光源出发，沿光的传播方向进行光 线跟踪是不现实的，也是不必要的。</li><li>实际上，<strong>光线跟踪算法的跟踪方向与光传播的方向是相反的，是视线跟踪</strong>。<br><img src="/CG/光线.png" width="45%"></li></ul></li><li><p><strong>优点</strong>: 能够方便的产生阴影，模拟镜面反射与折射现象。 </p></li><li><strong>缺点</strong>: 计算量大，每一条光线都要与场景中的物体进行求交、计算光照模型等。</li></ul><h5 id="递归终止条件"><a href="#递归终止条件" class="headerlink" title="递归终止条件"></a>递归终止条件</h5><ol><li>该光线未碰到任何物体。</li><li>该光线碰到了背景。</li><li>光线在经过许多次反射和折射以后，就会产生衰减，光线对于视点的光强贡献很小(小于某个设定值)。</li><li>光线反射或折射次数即跟踪深度大于一定值。</li></ol><h3 id="7-6-纹理"><a href="#7-6-纹理" class="headerlink" title="7.6 纹理"></a>7.6 纹理</h3><ul><li><strong>颜色纹理</strong>：光滑表面的花纹、图案。</li><li><strong>几何纹理</strong>：粗糙的表面(如桔子表面的皱纹), 是基于物体表面的微观几何形状的表面纹理。</li><li>两种方法来定义纹理:<ul><li>图像纹理</li><li>函数纹理</li></ul></li></ul><ol><li>分辨率为1024x1024的显示器各需要多少字节位平面<br>数为24的帧缓存？<br>A) 512KB ; B) 1 MB ; C) 2MB ; D) 3MB  </li><li>哪一个不是国际标准化组织(ISO)批准的图形标准？<br>A) GKS ; B) PHIGS ; C) CGM ; D) DXF</li><li>在计算机图形学的发展历史上，是谁确立了计算机图形学作为一门新学科的地位，他的哪些技术直到今天还在使用？</li><li>计算机图形系统的硬件设备有哪些？</li><li>光栅扫描显示器中，屏幕图形是依靠帧缓存进行刷新的，帧缓存里存放的是什么？</li><li>简述随机扫描显示器和光栅扫描显示器的简单工作原理和各自的特点。</li><li>用中点画线方法扫描转换连接两点P0（0,0）和P1（5,2）的直线段。<br>a = y0 - y1 = -2<br>b = x1 - x0 = 5<br>d0 = 2 <em> a + b = 1<br>d1 = 2 </em> a = -4<br>d2 = 2 * (a+b) = 6<br><img src="/CG/中点.png" width="45%"></li></ol><h2 id="图形学题目"><a href="#图形学题目" class="headerlink" title="图形学题目"></a>图形学题目</h2><ol><li>Breenham算法：<br><img src="/CG/bre.png" width="20%">  <img src="/CG/bre1.png" width="20%"></li><li>中点画圆算法<br><img src="/CG/中点画圆1.png" width="70%"></li><li><p>用边相关扫描线填充算法将顶点为P1 (2，2)，P2 (5，1)， P3(10，3)， P4(8，8)，P5(5，5)，P6(2，7)的多边形填充。请说明如何建立新边表NET和活动边表AET并写出该多边形填充的新边表NET和活动边表AET。<br><img src="/CG/扫描.png" width="60%"> </p></li><li><p>用数值微分DDA算法、中点算法和Bresenham算法扫描转换直线段(1,1)–(5,3)，<br>写出扫描转换的结果:写出每一步递推过程的x，y坐标及判别式d的值，图示计<br>算结果。</p></li><li>图中有两条圆弧A和B，假定当前取点为(xi，yi)，那么下一点只能是正<br>右方的 E(xi+1，yi)或右下方的SE(xi+1，yi-1)两者之一。 假设M是E和SE的中点，即，利用中点画圆算法，回答下列问题:<ul><li>当F(M) &lt; 0时，下一点应取哪个点? <strong>E点</strong> </li><li>当F(M) &gt; 0时，下一点应取哪个点? <strong>SE点</strong></li><li>当F(M) = 0时，下一点应取哪个点?  <strong>在E与SE之中随便取一个 即可，我们约定取SE点。</strong><br><img src="/CG/选点.png" width="30%"> </li></ul></li><li>裁剪的实质是什么?<ul><li>ans：裁剪的实质就是决定图形中哪些点、线段、文字、以及多边形在窗口之内。 </li></ul></li><li>已知窗口左下角坐标(50，50)，右上角坐标(400，400) 直线的端点坐标P1(40，100)和P2(500，420)， 试用Cohen-Sutherland直线编码裁剪算法，结合编码图示， 求出P1和P2所在区域的分区代码C1和C2。<ul><li>C1为0001; C2为1010 。 </li></ul></li><li>当线段与窗口边界有交点时，如果线段的长度为1024， 用中点分割算法求交点的次数是多少?<ul><li>10次。</li></ul></li><li>用Weiler-Atherton算法完成内裁剪和外裁剪。DCBA为裁剪窗口，dcba为要裁剪的多边形。<br><img src="/CG/wa题.png" width="50%"> </li><li>一个由顶点(10，20)，(20，20)和(15，30)所定义的三角形，让它相对于点Q(5，25)正向旋转30°，求其变换后的三角形。<br><img src="/CG/几何1.png" width="60%"> </li><li>推导以直线ax+by+c=0为对称轴的二维对称变换矩阵。<br><img src="/CG/几何2.png" width="70%"> </li><li>在坐标系oxyz中，求一个变换将P(1,1,1)Q(2,2,2)变换到z 轴上:P在坐标原点，Q在z轴正半轴。<br><img src="/CG/3dt.png" width="70%"> </li><li>如图所示三角形ABC，将其关于A点逆时针旋转90度，写 出其变换矩阵和变换后图形各点的规范化齐次坐标。<br><img src="/CG/3dti.png" width="40%"> </li><li>下列有关平面几何投影的叙述，错误的是( )<br>A)透视投影又可分为一点透视、二点透视、三点透视;<br>B)斜投影又可分为斜等测、斜二测;<br>C)正轴测又可分为正一测、正二测、正三测;<br>D)三视图又可分为正视图、侧视图、俯视图。</li><li>下列有关平面几何投影的叙述语句中，正确的论述为( )<br>A)在平面几何投影中，若投影中心移到距离投影面无穷远 处，则成为平行投影;<br>B)透视投影与平行投影相比，视觉效果更有真实感，而且 能真实地反映物体的精确的尺寸和形状;<br>C)透视投影变换中，一组平行线投影在与之平行的投影面 上，可以产生灭点;<br>D)在三维空间中的物体进行透视投影变换，可能产生三个 或者更多的主灭点。  </li><li>用下列二维图形变换矩阵:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;0&nbsp;1&nbsp;<br>T&nbsp;=&nbsp;0&nbsp;1&nbsp;1&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    0&nbsp;0&nbsp;1  &nbsp;<br>将产生变换的结果为( )<br>A) 图形放大2倍;<br>B) 图形放大2倍，同时沿X、Y坐标轴方向各移动1个绘图单位;<br>C) 沿X坐标轴方向各移动2个绘图单位;<br>D) 沿X坐标轴方向放大2倍，同时沿X、Y坐标轴方向各平移1个 绘图单位。</li><li>下列有关透视投影的叙述，错误的是( )<br>A)投影线从视点出发;<br>B)投影线不平行;<br>C)任何一束不平行于投影面的平行线的透视投影将汇成一点;<br>D)主灭点有无数个。  </li><li>请解释平面几何投影的含义。</li><li>何为“透视投影”?并说明“灭点”和“主灭点”是如何产生的?</li><li>什么是观察坐标系?为什么要建立观察坐标系?</li><li>已知投影面为xoy坐标平面，投影中心在z轴的正向、z=d的 位置上，求透视投影变换矩阵。</li><li>描述Z缓存器消隐算法的基本原理和算法实现;</li><li>光线跟踪算法的跟踪方向与光传播的方向是相同的，是视线 跟踪。( )</li><li>双线性法向插值算法先计算出曲面在各多边形顶点处的光强 ，然后再采用双线性插值方法确定在扫描线上每个像素处的 光强值，得到多边形的光滑颜色分布。( )</li><li>非理想镜面反射中，镜面反射指数n模拟镜面反射光在空间 中的汇聚程度，n越大，表面越粗糙( )。</li><li>粗糙的物体表面能够将反射光向各个方向散射， 称为( )。</li><li>比较Gouraud明暗处理算法和Phong明暗处理算法的优缺点。</li><li>何谓“光线跟踪算法”?请简要叙述光线跟踪算法的基本思想。</li></ol><ul><li>CRT的原理简单了解</li><li>光栅图形显示系统：4部分 每一部分具体是做什么用的 </li><li>中点算法增量法的改进 为什么可以摆脱小数计算</li><li>扫面线算法 四个步骤，交点的计数问题</li><li>字符的两种类型 和存储的信息分别是什么</li><li>Cyrus Beck Line Clipping 梁八子算法不作要求</li><li>消隐算法的分类 要能判断。画家算法 Z-Buffer及它的改进 要能描述清楚，其余的了解基本思想和优缺点</li><li>物体对光产生<strong>反射、投射</strong>和部分<strong>吸收</strong>成热能，填空</li><li>两种投影类型 正轴测投影的分类，透视投影变换要会推导</li><li>三维图像的显示流程（剪裁和投影的前后关系）</li><li>光线跟踪算法的递归终止条件 简答题</li><li>为什么引入齐次坐标 ？把加法变成乘法；统一的表达方式；无穷？？</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML</title>
      <link href="/uml/"/>
      <url>/uml/</url>
      
        <content type="html"><![CDATA[<h2 id="1-面向对象技术概述"><a href="#1-面向对象技术概述" class="headerlink" title="1. 面向对象技术概述"></a>1. 面向对象技术概述</h2><h5 id="1-1-软件危机及软件工程"><a href="#1-1-软件危机及软件工程" class="headerlink" title="1.1 软件危机及软件工程　"></a>1.1 软件危机及软件工程　</h5><ul><li><strong>软件危机，软件工程</strong>的提出<ul><li>软件危机是指落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。<a id="more"></a></li><li>软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。</li></ul></li><li><strong>软件工程的目的</strong>就是在规定的时间、规定的开发费用内开发出满足用户需求的高质量的软件系统。<ul><li>高质量不只是指错误率低，还包括好用、易用、可移植、易维护等。</li></ul></li></ul><h5 id="1-2-对软件开发的基本认识"><a href="#1-2-对软件开发的基本认识" class="headerlink" title="1.2 对软件开发的基本认识　"></a>1.2 对软件开发的基本认识　</h5><ul><li><strong>软件是一个逻辑部件</strong>，而不是一个物理部件，所以软件具有与硬件不同的特点：<ul><li>表现形式不同</li><li>生产方式不同</li><li>产品要求不同</li><li>维护方式不同</li></ul></li></ul><h5 id="1-3-软件的固有复杂性"><a href="#1-3-软件的固有复杂性" class="headerlink" title="1.3 软件的固有复杂性　"></a>1.3 软件的固有复杂性　</h5><ul><li>著名的计算机专家、被称之为IBM 360系列计算机之父的F. Brooks认为软件的复杂性是固有的，软件可能是人类所能制造出来的最复杂的实体。 </li><li>软件固有复杂性使得开发成员之间的通讯变得困难，开发费用超支、开发时间延期等；也导致产品有缺陷、不易理解、不可靠、难以使用、功能难以扩充等。</li><li><strong>软件的复杂性是固有的</strong>，即不能采用某种方法彻底消除软件的复杂性，因此软件危机只能是通过控制复杂性的方法解决。</li></ul><h5 id="1-4-控制软件复杂性的基本方法"><a href="#1-4-控制软件复杂性的基本方法" class="headerlink" title="1.4 控制软件复杂性的基本方法"></a>1.4 控制软件复杂性的基本方法</h5><ul><li><strong>分解</strong><ul><li>对复杂系统采用“各个击破”的策略</li></ul></li><li><strong>抽象</strong><ul><li>抽取系统中的基本特性而忽略非基本的部分</li></ul></li><li><strong>模块化</strong><ul><li>高内聚（cohesion），低耦合（coupling）</li><li>高内聚指的是在一个模块中应尽量多地汇集逻辑上相关的计算资源；低耦合指的是模块之间的相互作用应尽量少。</li></ul></li><li><strong>信息隐蔽</strong><ul><li>也称封装</li><li>模块内部的实现细节与外界隔离</li></ul></li></ul><h5 id="1-5-面向对象技术"><a href="#1-5-面向对象技术" class="headerlink" title="1.5 面向对象技术"></a>1.5 面向对象技术</h5><ul><li>对象（object）  行动或思考时作为目标的人或事物对象。</li><li>对象是系统中用来描述客观事物的一个实体，它是构成系统的一个基本单位。</li><li>一个对象由<strong>一组属性（特性）和对这组属性进行操作的一组操作（方法）</strong>组成。属性和操作合起来被称为特征（feature）</li><li><strong><code>类</code></strong>是具有相同属性和方法的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，其内部包括属性和方法两个主要部分。</li><li>对象是一个类（种类）的实例。类是用来创建对象的模板。</li></ul><h5 id="1-6-面向对象领域中的基本概念"><a href="#1-6-面向对象领域中的基本概念" class="headerlink" title="1.6 面向对象领域中的基本概念"></a>1.6 面向对象领域中的基本概念</h5><ul><li><strong>继承(子类，超类)</strong><ul><li>特殊类的对象拥有其一般类的全部属性与方法，称作特殊类对一般类的继承。</li><li>一般类/特殊类；父类/子类；超类/子类；基类/派生类等是相同的概念。</li><li>子类都继承了父类的特征。</li></ul></li><li><strong>多态性</strong><ul><li>在面向对象技术中，多态指的是使一个实体在不同的上下文条件下具有不同意义或用法的能力。</li><li>不同的类中可以有同名的操作，每个类中发生的操作各不相同。</li></ul></li><li><strong>封装 / 信息隐藏</strong><ul><li>把对象的属性和方法结合成一个独立的系统单位，并尽可能隐蔽对象的内部细节。</li></ul></li><li><strong>接口</strong></li><li><strong>消息传递</strong><ul><li><code>消息</code>：就是向对象发出的服务请求，它包含下述信息：提供服务的对象标识、服务（方法）标识、输入信息和回答信息。</li><li>对象之间的协作是通过相互发送消息。</li><li>一个对象发送一个操作消息（或请求）给另一个对象，接受消息的对象就执行这个操作。</li></ul></li><li><strong>关联</strong><ul><li>对象之间通常以某种方式发生关联。</li><li>对象之间有时能以多种方式发生关联</li><li>一个类可以和多个类关联。</li><li>多重性：用于说明在关联中一个类的对象可以对应另一个类的多少对象。</li></ul></li><li><strong>聚集</strong><ul><li>聚集的一种形式是聚集对象和它的组成对象之间具有强关联。<br>一个典型的计算机系统就是聚集的一个例子——它由许多不同类型的对象组合而成。</li><li>组成的关键特征是部分对象<strong>只能</strong>存在于组成对象之中。在组成体中，部分对象有时可能先于组成体消亡。<br>树叶可能先于树而消亡。衬衫是衬衫主体、衣领、衣袖、纽扣..的组成体。</li></ul></li></ul><h5 id="1-7-小结-P29"><a href="#1-7-小结-P29" class="headerlink" title="1.7 小结 P29"></a>1.7 小结 P29</h5><ul><li>面向对象是一种依赖于几个基本原则的思维方法。对象是类的实例。类是具有相同属性和操作的一类对象集。当你创建了一个对象后，对象的属性和操作数目由你所处理的问题域确定。</li><li><strong>继承</strong>是面向对象中的一个重要方面。对象继承了所属类的属性和操作。类同样也可以继承其它类的属性和操作。</li><li><strong>多态性</strong>是另一个重要的方面，它是指不同的类中可以有相同名字的操作，并且这个操作在每个类中都能以各自不同的方式执行。</li><li>对象对其他对象和外部世界隐藏了其操作的执行过程。每个对象都要提供一个让其他对象（和人）用来执行该对象中操作的接口。</li><li>对象通过相互之间的消息传递协同工作。消息是执行操作的请求。</li><li>对象通常要和其他对象发生关联。关联可以具有多种形式。一个类的对象可能和多个其他类的对象同时发生关联。</li><li><strong>聚集是关联的一种</strong>，聚集对象由部分构成。<strong>组成又是一种特殊的聚集</strong>。在一个组成对象中，部分对象只能作为组成对象的一部分与组成对象同时存在。</li></ul><h2 id="2-UML概述"><a href="#2-UML概述" class="headerlink" title="2. UML概述"></a>2. UML概述</h2><h5 id="2-1-为什么要学习UML？"><a href="#2-1-为什么要学习UML？" class="headerlink" title="2.1 为什么要学习UML？"></a>2.1 为什么要学习UML？</h5><ul><li>什么是UML？<ul><li>UML是Unified Modeling Language（统一建模语言）的简称。</li><li>UML是对软件密集型系统中的制品（软件开发过程中产生的各种各样的产物，如模型、源代码、测试用例等）进行可视化、详述、构造和文档化的语言。</li></ul></li><li>模型<ul><li>模型是用文字、图表、符号、关系式以及实体模样等描述所认识到的客观对象的一种简化表示形式。它是人们为了研究和解决客观世界中存在的各种问题而对客观现实经过思维抽象后得到的。简单地说，模型就是所描述客观对象的抽象表示。</li><li>一般来讲，模型都包含一个完整的概念集合、一套相应的表示方法以及必要的规则约束，它们为人们抽象地表达客观对象提供了一个参考性的框架环境。</li></ul></li><li>建立模型的优点<ul><li>使用模型可以更好地理解问题 </li><li>使用模型可以加强人员之间的沟通 </li><li>使用模型可以更早地发现错误或疏漏的地方 </li><li>使用模型可以获取设计结果 </li><li>模型为最后的代码生成提供依据 </li></ul></li></ul><h5 id="2-2-UML的历史"><a href="#2-2-UML的历史" class="headerlink" title="2.2 UML的历史"></a>2.2 UML的历史</h5><ul><li>UML是由世界著名的面向对象技术专家G. Booch, J. Rumbaugh 和 I. Jacobson发起，在Booch方法，OMT方法和OOSE方法的基础上，广泛征求意见，集众家之长，几经修改而完成的。</li><li>为什么UML能得到广泛的应用<ul><li>图形化的建模语言</li><li>开发者用来为面向对象系统建立模型</li><li>具有灵活性与可扩展性</li></ul></li><li>由Object Management Group (OMG)推荐成为国际标准。目前最新的UML规范说明是2003年3月发布的1.5版本（<a href="http://uml.org）" target="_blank" rel="noopener">http://uml.org）</a></li></ul><h5 id="2-3-UML的特点"><a href="#2-3-UML的特点" class="headerlink" title="2.3 UML的特点"></a>2.3 UML的特点</h5><ul><li>UML的主要特点： <ul><li>统一的标准：UML已被OMG接受为标准的建模语言</li><li>面向对象</li><li>可视化、表示能力强大</li><li>独立于过程</li><li>概念明确，建模表示法简洁，图形结构清晰，容易掌握使用</li></ul></li><li>UML和程序设计语言的关系<ul><li>用Java，C++ 等 programming language是用编码实现一个系统</li><li>用UML是对一个系统建立模型</li><li>一些软件工具可以根据 UML所建立的系统模型来产生Java, C++ 或其它程序设计语言代码框架。</li></ul></li></ul><h5 id="2-4-UML的构成"><a href="#2-4-UML的构成" class="headerlink" title="2.4 UML的构成"></a>2.4 UML的构成</h5><ul><li><strong><code>类图</code></strong></li><li>对象图</li><li><strong><code>用例图</code></strong></li><li><strong><code>顺序图</code></strong></li><li>协作图</li><li>状态图</li><li><strong><code>活动图</code></strong></li><li>构件图</li><li>配置图</li></ul><p><img src="/uml/图关系.png" width="60%"><img src="/uml/4+1.png" width="40%">  </p><h5 id="2-5-UML中的视图"><a href="#2-5-UML中的视图" class="headerlink" title="2.5 UML中的视图"></a>2.5 UML中的视图</h5><ul><li>UML中的视图包括：（这5个视图被称为“4+1”视图）<ul><li>用例视图</li><li>逻辑视图：用于表示系统的概念设计和子系统结构等。</li><li>实现视图：用于说明代码的结构。</li><li>进程视图：用于说明系统中并发执行和同步的情况。</li><li>部署视图：用于定义硬件节点的物理结构。</li></ul></li></ul><h5 id="2-6-UML在系统开发各阶段的应用"><a href="#2-6-UML在系统开发各阶段的应用" class="headerlink" title="2.6 UML在系统开发各阶段的应用"></a>2.6 UML在系统开发各阶段的应用</h5><ul><li>在<strong>分析阶段</strong>，用户的需求用UML模型来描述。</li><li>在<strong>设计阶段</strong>，引入定义软件系统中技术细节的类（如处理用户接口、数据库、通信和并行性等问题的类）。</li><li>在<strong>实现阶段</strong>，用面向对象程序设计语言将来自设计阶段的类转换成实际的代码。</li><li>UML模型还是<strong>测试阶段</strong>的依据<ul><li>单元测试使用类图和类规格说明。</li><li>集成测试使用构件图和协作图。</li><li>系统测试使用用例图来验证系统的行为。</li></ul></li></ul><h2 id="3-UML各种图简介"><a href="#3-UML各种图简介" class="headerlink" title="3. UML各种图简介"></a>3. UML各种图简介</h2><h5 id="3-1-类图与对象图"><a href="#3-1-类图与对象图" class="headerlink" title="3.1 类图与对象图"></a>3.1 类图与对象图</h5><ul><li>类是一类或者一组具有类似属性和共同行为的事物。</li><li>UML类图的特点：<ul><li>矩形方框</li><li>被分为三个区域：类名、类的属性、类的操作</li><li>类名由多个单词组成；每个单词的首字母要大写，单词之间不用空格</li><li>属性名和操作名也类似，但首字母不用大写 </li><li>每个操作名的后面都有一对括号<br><img src="/uml/类图标.png" width="22%">  <img src="/uml/对象图标.png" width="65%"> </li></ul></li><li>对象是一个类的实例，是具有具体属性值的一个具体事物。<ul><li>矩形方框</li><li>对象名首字母为小写，对象名下面要带下划线</li><li>冒号左边为实例名，冒号右边为类名；对象也可以是匿名</li></ul></li></ul><h5 id="3-2-用例图"><a href="#3-2-用例图" class="headerlink" title="3.2 用例图"></a>3.2 用例图</h5><ul><li>用例是从用户的观点对系统行为的一个描述；它是用来从用户的观察角度收集系统需求的主要技术。</li><li>用例图的特点：<ul><li>直立小人被称为参与者（actor）；参与者可以是一个人，也可以是另一个系统.</li><li>椭圆形代表用例。</li><li>矩形代表系统。<br><img src="/uml/用例图.png" width="35%">   <img src="/uml/状态图.png" width="20%"></li></ul></li></ul><h5 id="3-3-状态图"><a href="#3-3-状态图" class="headerlink" title="3.3 状态图"></a>3.3 状态图</h5><ul><li>在任一给定的时刻，一个对象总是处于某一特定的<strong>状态</strong>。</li><li>UML状态图的特点：<ul><li>圆角矩形</li><li>最顶端的符号（实心圆）代表起始状态，而最底端的符号（眼形圆）表示终止状态</li></ul></li></ul><h5 id="3-4-顺序图"><a href="#3-4-顺序图" class="headerlink" title="3.4 顺序图"></a>3.4 顺序图</h5><ul><li>顺序：类图和对象图表达的是系统的静态结构。在一个运行的系统中，对象之间要发生交互，并且这些交互要经历一定的时间。UML顺序图所表达的正是这种<strong>基于时间的动态交互</strong>。</li><li>顺序图的特点：<ul><li>横坐标为系统中的对象</li><li>每个对象都有一个或多个操作</li><li>对象间通过相互传递消息来协同工作</li><li>纵坐标为时间序列<br><img src="/uml/顺序图2.png" width="50%">  </li></ul></li></ul><h5 id="3-5-活动图"><a href="#3-5-活动图" class="headerlink" title="3.5 活动图"></a>3.5 活动图</h5><ul><li>活动即工作步骤。</li><li>活动图的特点：<ul><li>和流程图很接近</li><li>圆角矩形（比状态图更窄，更接近与椭圆）</li><li>箭头表示活动的转移 </li><li>实心圆代表起点，眼形圆代表终点<br><img src="/uml/活动图.png" width="35%">   <img src="/uml/协作图.png" width="50%"> </li></ul></li></ul><h5 id="3-6-协作图"><a href="#3-6-协作图" class="headerlink" title="3.6 协作图"></a>3.6 协作图</h5><ul><li>协作图用于展示对象之间的交互关系。<ul><li>对象图展示出对象之间的静态关系。协作图是对对象图的扩展。协作图除了展示对象之间的关联，还显示出对象之间的消息传递。</li></ul></li><li>协作图的特点：<ul><li>关联线附近的箭头线表示对象之间传递的消息，箭头指向消息接收对象</li><li>消息名称和消息序号附在箭头线附近</li><li>顺序图和协作图之间可以相互转换  </li></ul></li></ul><h5 id="3-7-构件图"><a href="#3-7-构件图" class="headerlink" title="3.7 构件图"></a>3.7 构件图</h5><ul><li>软件构件是软件系统的一个物理单元。在UML中，数据文件、表格、可执行文件、文档和动态链接库等都被定义为构件。</li><li>构件图和部署图与整个计算机系统密切相关。</li><li>构件图的特点：<ul><li>一个左侧附有两个小矩形的大矩形框。</li><li>也可以用一个顶部带关键字 &lt;<component>&gt;的矩形表示。<br><img src="/uml/构件图1.png" width="40%"> <img src="/uml/构件图2.png" width="30%"> </component></li></ul></li></ul><h5 id="3-8-部署图"><a href="#3-8-部署图" class="headerlink" title="3.8 部署图"></a>3.8 部署图</h5><ul><li>部署图的用途：UML部署图显示了基于计算机系统的物理体系结构。</li><li>部署图的特点：<ul><li>立方体图标</li><li>立方体之间的连线表示体系之间的关系<br><img src="/uml/部署图.png" width="40%"></li></ul></li></ul><h5 id="3-9-其他特征"><a href="#3-9-其他特征" class="headerlink" title="3.9 其他特征"></a>3.9 其他特征</h5><ul><li>注释：通过附加注释来做解释说明。</li><li>符号特征：<ul><li>带折角的矩形，矩形中是解释性文字。</li><li>注释和被注释的图元素之间用一条虚线连接。</li></ul></li><li>构造型（版型）<ul><li>版型是建模人员在已有的构造块上派生出的新构造块，这些新构造块是和特定问题相关的。</li><li>版型可以应用于所有类型的模型元素，包括类、节点、构件、注解、关系、包、操作等。</li></ul></li><li>关键字<ul><li>版型用两对尖括号括起来的一个名称来表示，这个括号叫做双尖括号（guillemots）。这个被括起来的名称叫做关键字。</li><li>如<code>&lt;&lt;Interface&gt;&gt;，&lt;&lt;entity&gt;&gt;</code></li></ul></li></ul><h5 id="3-10-为什么需要这么多种图"><a href="#3-10-为什么需要这么多种图" class="headerlink" title="3.10 为什么需要这么多种图"></a>3.10 为什么需要这么多种图</h5><ul><li>每一种UML图都提供一种组成特殊视图的方式。采用多视角的目标是为了能够和每一类风险承担人良好地沟通。</li><li>UML是一套表示法系统。</li><li>UML由一组图组成，它使得系统分析员可以利用这一标准来建立能够和客户、程序员以及任何参与程序开发的人员理解的多视角的系统蓝图。不同的风险承担人通常使用不同类型的图相互交流。</li><li>UML模型<strong>只说明一个系统应该做什么</strong>，并没有告诉我们系统应该怎么做。</li></ul><h2 id="4-关系"><a href="#4-关系" class="headerlink" title="4. 关系"></a>4. 关系</h2><h5 id="4-1-关联"><a href="#4-1-关联" class="headerlink" title="4.1 关联"></a>4.1 关联</h5><ul><li><strong>关联</strong>：当类之间在概念上有连接关系时，类之间的连接叫做关联。<ul><li>用一条线连接两个类，并把关联的名字放在这个连线上</li><li>关联的方向用一<strong>个实心三角形箭头</strong>来指明<br><img src="/uml/关联.png" width="50%">  <img src="/uml/关联1.png" width="35%"> <img src="/uml/关联.png" width="50%">  </li></ul></li><li><strong>关系上的约束</strong>：两个类之间的一个关联随后就有一个规则，可以通过关联线附近加注一个约束来说明这个规则。<ul><li>花括号、虚线（或关系）</li></ul></li><li><strong>关联类</strong>：和类一样，关联也可以有自己的属性和操作，称为关联类。<ul><li>用虚线将关联类和对应的关联线连接起来。</li></ul></li><li><strong>链</strong>：关联类的实例叫做链。（类的实例是对象）<ul><li>用一条线连接两个对象，并把链的名字放在这个连线上。</li><li>链的名字也要加下划线。<br><img src="/uml/约束.png" width="35%"> <img src="/uml/链.png" width="50%"><br><img src="/uml/关联类.png" width="50%"></li></ul></li></ul><h5 id="4-2-多重性"><a href="#4-2-多重性" class="headerlink" title="4.2 多重性"></a>4.2 多重性</h5><ul><li>多重性：某个类有多个对象可以和另一个类的多个对象关联。<ul><li>符号特征：在参与关联的类附近的关联线上注明多重性数值。UML使用 <code>*</code> 来代表许多；<code>1..*</code> 代表一个或多个；<code>,</code> 代表”或”关系<br><img src="/uml/多重性.png" width="50%"></li></ul></li></ul><h5 id="4-3-限定关联"><a href="#4-3-限定关联" class="headerlink" title="4.3 限定关联"></a>4.3 限定关联</h5><ul><li>在UML中，标识符ID（identification）信息叫做限定符。<ul><li>符号特征：一个小矩形框<br><img src="/uml/限定关联.png" width="50%"></li></ul></li></ul><h5 id="4-4-自身关联"><a href="#4-4-自身关联" class="headerlink" title="4.4 自身关联"></a>4.4 自身关联</h5><ul><li>一个类可能与它自己发生关联，这样的关联被称为自身关联。<br><img src="/uml/自身关联.png" width="50%"></li></ul><h5 id="4-5-继承与泛化"><a href="#4-5-继承与泛化" class="headerlink" title="4.5 继承与泛化"></a>4.5 继承与泛化</h5><ul><li><p>继承：如果你知道某物所属的种类，你自然就会知道同类的其他事物也具有该事物的一些特征。在面向对象术语中，这种关系被称为继承。<strong>在UML中，则被称为泛化</strong>。  </p><blockquote><p>基类或根类 —— 叶类<br>单继承 —— 多继承   </p></blockquote><ul><li>符号特征： <strong>指向父类一端</strong>带有一个空心三角箭头<br><img src="/uml/泛化.png" width="35%"></li></ul></li><li>抽象类：不提供实例对象的类被称为抽象类。 <ul><li>符号特征：类名<strong>用斜体书写</strong></li></ul></li></ul><h5 id="4-6-依赖"><a href="#4-6-依赖" class="headerlink" title="4.6 依赖"></a>4.6 依赖</h5><ul><li>依赖：如果一个类使用了另一个类，这种关系称之为依赖。<ul><li>符号特征：在有依赖关系的类之间画上一条带箭头的虚线<br><img src="/uml/依赖.png" width="45%"></li></ul></li></ul><h5 id="4-7-类图和对象图"><a href="#4-7-类图和对象图" class="headerlink" title="4.7 类图和对象图"></a>4.7 类图和对象图</h5><ul><li><p>类图给出的是多个类以及类之间的关系，它描述的是一般性的、定义性的信息</p><ul><li>类图包括类以及类之间的关联；</li><li>类图用来表现系统的静态构成；</li><li>一个系统的静态构成可以由<strong>多张类图</strong>来共同描述，不同的类图描述了系统的不同层面、角度及范围。</li></ul></li><li><p>对象图则在某个特定时刻多个具体实例以及它们如何联系起来的信息。<br><img src="/uml/类图.png" width="45%"> <img src="/uml/对象图.png" width="45%"> </p></li></ul><h2 id="5-聚集、组成、接口和实现"><a href="#5-聚集、组成、接口和实现" class="headerlink" title="5. 聚集、组成、接口和实现"></a>5. 聚集、组成、接口和实现</h2><h5 id="5-1-聚集"><a href="#5-1-聚集" class="headerlink" title="5.1 聚集"></a>5.1 聚集</h5><ul><li>聚集：一个类有时是由几个部分类构成，这种特殊类型的关系被称为聚集。部分类和由它们组成的类之间是一种整体－部分（part-whole）关联。<ul><li>符号特征：关联线上有一个<strong>空心菱形箭头</strong>，箭头的方向是从部分指向整体。<br><img src="/uml/聚集.png" width="55%"> </li></ul></li><li>聚集上的约束：可以在聚集上施加一个“or”约束，它表示某个整体包含一个或另一个部分。<br><img src="/uml/聚集约束.png" width="55%"> </li></ul><h5 id="5-2-组成"><a href="#5-2-组成" class="headerlink" title="5.2 组成"></a>5.2 组成</h5><ul><li>组成：组成是强类型的聚集。聚集中每个部分体只能属于一个整体。<ul><li>符号特征：关联线上有一个实心菱形箭头，箭头的方向是从部分指向整体。<br><img src="/uml/组成.png" width="55%"> </li></ul></li></ul><h5 id="5-3-组成结构图"><a href="#5-3-组成结构图" class="headerlink" title="5.3 组成结构图"></a>5.3 组成结构图</h5><ul><li>组成是展示一个类的构件的一种方式。通过组成结构图可以展示<strong>类的内部结构</strong>。<br><img src="/uml/组成结构图.png" width="50%"></li></ul><h5 id="5-4-接口和实现"><a href="#5-4-接口和实现" class="headerlink" title="5.4 接口和实现"></a>5.4 接口和实现</h5><ul><li><strong>接口</strong>是描述类的部分行为的一组操作，它也是一个类提供给另一个类的一组操作。<ul><li>符号特征：和类相似，都是用一个矩形图标来代表。接口只是一组操作，没有属性。</li></ul></li><li><strong>实现</strong>：一个类和它的接口之间的关系叫做实现。<ul><li>符号特征：和继承符号相似，但它是一个带空心三角形的箭头的虚线表示，箭头的方向指向接口。省略表示法是将接口表示为一个小圆圈，并和实现它的类用一条线连起来</li></ul></li></ul><p><img src="/uml/接口1.png" width="55%">  <img src="/uml/接口2.png" width="30%"><br><img src="/uml/接口3.png" width="50%">  <img src="/uml/接口4.png" width="40%"> </p><h5 id="5-5-接口和端口"><a href="#5-5-接口和端口" class="headerlink" title="5.5 接口和端口"></a>5.5 接口和端口</h5><ul><li>端口<ul><li>符号特征：位于类符号边缘上的一个小方格，这个小方格连接到接口<br><img src="/uml/端口.png" width="40%"> </li></ul></li></ul><h5 id="5-6-可见性"><a href="#5-6-可见性" class="headerlink" title="5.6 可见性"></a>5.6 可见性</h5><ul><li><strong>可见性</strong>可应用于属性或操作，它说明在给定类的属性和操作（或者接口的操作）的情况下，其他类可以访问到的属性和操作的范围。</li><li><strong>可见性有三个层次</strong>（级别）：<ul><li>公有层次上，其他类可以直接访问这个层次中的属性和操作。</li><li>受保护层次上，只有继承类这些属性和操作的子类可以访问最初类的属性和操作。</li><li>私有层次上，只有最初的类才能访问这些属性和操作。</li></ul></li><li>符号特征<ul><li><code>+</code> 表示该操作或属性是公有的（其它类可访问）</li><li><code>#</code> 表示该操作或属性是受保护的（子类才可访问）</li><li><code>-</code> 表示该操作或属性是私有的（最初类才可访问）</li></ul></li></ul><h5 id="5-7-作用域"><a href="#5-7-作用域" class="headerlink" title="5.7 作用域"></a>5.7 作用域</h5><ul><li>作用域是与属性和操作相关的又一个重要概念。存在两种可能的作用域：<ul><li>实例作用域：类的每个实例对象都有自己的属性值和操作。</li><li>分类符作用域：一个类的所有实例只存在一个属性值和操作。</li></ul></li></ul><h2 id="6-用例图"><a href="#6-用例图" class="headerlink" title="6. 用例图"></a>6. 用例图</h2><h5 id="6-1-什么是用例"><a href="#6-1-什么是用例" class="headerlink" title="6.1 什么是用例"></a>6.1 什么是用例</h5><ul><li>用例的定义：<ul><li>用例是系统的一组使用场景。每个场景描述了一个事件的序列。每个序列是由一个人、另一个系统、一台硬件设备或者某段时间的流逝所发起。</li><li>这些发起事件序列的实体叫做<strong>参与者</strong>。</li><li>用例是对一个<strong>参与者</strong>使用系统的一项功能时所进行的交互过程的一个文字描述序列。<br><img src="/uml/用例图1.png" width="40%"> </li></ul></li></ul><h5 id="6-2-用例模型的表示法"><a href="#6-2-用例模型的表示法" class="headerlink" title="6.2 用例模型的表示法"></a>6.2 用例模型的表示法</h5><ul><li>用例模型（use case model）<ul><li>用户知道的比他们清楚表达出来的要多，用例能帮助用户解决表达问题。</li><li>用例是由参与者发起的，参与者（或许是发起者，但不是必须的）能够从用例的执行中获得有价值的事物。</li><li>参与者、用例和互连线共同组成了用例模型。</li></ul></li><li>每个用例是一组场景的组合，而每个场景又是一个步骤序列。</li><li><p>用例描述的主要内容：</p><ul><li>用例的目标</li><li>用例是怎样启动的</li><li>参与者和用例之间的消息是如何传递的</li><li>用例中除了主路径外，其它路径是什么</li><li>用例结束后的系统状态</li><li>其它需要描述的内容</li></ul></li><li><p>符号特征：</p><ul><li>用例用一个椭圆形表示。</li><li>参与者用直立人形图标表示。</li><li>用例的发起参与者在用例图的左侧，接收参与者在用例图的右侧。</li><li>关联线连接参与者和用例并且表示参与者与用例之间有通信关系；关联线是实线。</li></ul><p><img src="/uml/用例图2.png" width="40%">  </p></li></ul><h5 id="6-3-用例之间关系的可视化表示"><a href="#6-3-用例之间关系的可视化表示" class="headerlink" title="6.3 用例之间关系的可视化表示"></a>6.3 用例之间关系的可视化表示</h5><ul><li><strong><code>包含</code></strong>：在一个用例中重用另一个用例中的步骤<ul><li>符号特征：虚线箭头，箭头指向被包含的用例，在虚线上加关键字<code>&lt;&lt;include&gt;&gt;</code><br><img src="/uml/用例包含.png" width="40%"> </li></ul></li><li><strong><code>扩展</code></strong>：通过对已有用例增加步骤创建一个新的用例<ul><li>基用例：新用例扩展了原来的用例，因为它在原来的用例上增加了新的步骤序列，因此原用例被称作基用例。</li><li>扩展点：扩展只能发生在基用例的序列中某个具体指定点上，这个点叫做扩展点。</li><li>符号特征：虚线箭头，箭头指向基用例，在虚线上加关键字<code>&lt;&lt;extend&gt;&gt;</code>，在基用例中注明扩展点的发生位置。<br><img src="/uml/用例扩展包含.png" width="40%"> </li></ul></li><li><strong><code>泛化</code></strong>：子用例可以继承父用例的行为和含义，还可以增加自己的行为。任何父用例出现的地方子用例也可以出现。</li><li><p><strong><code>分组</code></strong>：当一个系统包含很多子系统时。最直接的办法就是把相关的用例<strong>放在一个包中</strong>组织起来。</p><ul><li>符号特征：包用一个一边突起的文件夹形的矩形框表示，一组用例可以出现在一个文件夹框中。</li></ul><p><img src="/uml/泛化1.png" width="40%">  <img src="/uml/泛化2.png" width="40%"> </p></li></ul><h5 id="6-4-运用用例模型的实例-P75"><a href="#6-4-运用用例模型的实例-P75" class="headerlink" title="6.4 运用用例模型的实例 P75"></a>6.4 运用用例模型的实例 P75</h5><ul><li>《银行系统的分析与设计》中的用例图<br><img src="/uml/银行用例.png" width="40%"></li></ul><h5 id="6-5-用例的一些特点"><a href="#6-5-用例的一些特点" class="headerlink" title="6.5 用例的一些特点"></a>6.5 用例的一些特点</h5><ul><li>Use case从使用系统的角度描述系统中的信息，即站在系统外部察看系统功能，并不考虑系统内部对该功能的具体实现方式。</li><li>使用use case可以促进与用户沟通，理解正确的需求，同时也可以用来划分系统与外部实体的界限，是OO系统设计的起点，是类、对象、操作的来源。</li><li>用例描述了用户提出的一些可见的需求；用例可大可小；用例对应一个具体的用户目标</li><li>理论上可以把一个软件系统的所有Use Case画出来，但实际运用时只需把重要的、交互过程复杂的那些画出来。</li></ul><h2 id="7-顺序图"><a href="#7-顺序图" class="headerlink" title="7. 顺序图"></a>7. 顺序图</h2><h5 id="7-1-什么是顺序图"><a href="#7-1-什么是顺序图" class="headerlink" title="7.1 什么是顺序图"></a>7.1 什么是顺序图</h5><ul><li>关键思想<ul><li>对象之间的交互是<strong>按照特定的顺序发生</strong>的，这些按特定顺序发生的交互序列从开始到结束需要一定的时间。</li><li>当建立一个系统时，必须要指明这种交互序列，顺序图就是用来完成这项工作的UML组件。</li></ul></li><li>符号特征<ul><li><strong>对象</strong>用矩形表示，其中是带下划线的对象名。</li><li><strong>时间</strong>用垂直虚线表示。</li><li><strong>消息</strong>用带箭头的直线表示。</li><li><strong>激活</strong>用窄矩形条表示。<br><img src="/uml/顺序图.png" width="30%">   <img src="/uml/顺序图对象.png" width="30%"> </li></ul></li><li>建立顺序图的步骤 P93<ol><li>确定交互过程的上下文。</li><li>识别参与交互过程的对象。</li><li>为每个对象设置生命线，即确定哪些对象存在于整个交互过程中，哪些对象在交互过程中被创建和撤销。</li><li>从引发这个交互过程的初始消息开始，在生命线之间从顶到下依次画出随后的各个消息。</li><li>如果需要表示消息的嵌套，或/和表示消息发生时的时间点，则采用激活。</li><li>如果需要说明时间约束，则在消息旁边加上约束说明。</li><li>如果需要，可以为每个消息附上前置条件和后置条件。</li></ol></li></ul><h5 id="7-2-顺序图的组成部分"><a href="#7-2-顺序图的组成部分" class="headerlink" title="7.2 顺序图的组成部分"></a>7.2 顺序图的组成部分</h5><ul><li><strong><code>对象</code></strong><ul><li>从左到右布置在顺序图的顶部</li><li>匿名对象</li><li>生命线（lifeline）</li><li>激活（activation）＝控制焦点（focus of control，FOC）</li></ul></li><li><strong><code>消息</code></strong>：一个对象到另一个对象的消息用跨越对象生命线的消息线表示<ul><li><strong>调用消息</strong>：消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息接收者放弃或返回控制。一般地，调用消息的接收者必须是一个被动对象，即它是一个需要通过消息驱动才能执行动作的对象。</li><li><strong>返回消息</strong>：调用消息必有一个配对的返回消息，为了图的简洁和清晰，与调用消息配对的返回消息可以不用画出。如果为非过程调用，如果有返回消息，则必须明确表示出来。</li><li><strong>同步消息</strong>：调用消息。由于发送者等待接受者，调用消息又称为同步消息。</li><li><strong>异步消息</strong>：发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接收者返回消息或控制。异步消息的接收者和发送者是并发工作的。</li><li>其它：阻止消息，超时消息，反身消息<br><img src="/uml/消息符号1.png" width="40%">  <img src="/uml/消息符号2.png" width="40%"></li></ul></li><li><strong><code>时间</code></strong>：顺序图中垂直方向代表时间维，时间流逝的方向为自顶而下。</li></ul><h5 id="顺序图-汽车和车钥匙-P93"><a href="#顺序图-汽车和车钥匙-P93" class="headerlink" title="顺序图 - 汽车和车钥匙 P93"></a>顺序图 - 汽车和车钥匙 P93</h5><h5 id="顺序图-饮料销售机-P95"><a href="#顺序图-饮料销售机-P95" class="headerlink" title="顺序图 - 饮料销售机 P95"></a>顺序图 - 饮料销售机 P95</h5><h5 id="顺序图-一般顺序图-P97"><a href="#顺序图-一般顺序图-P97" class="headerlink" title="顺序图 - 一般顺序图 P97"></a>顺序图 - 一般顺序图 P97</h5><h5 id="顺序图-帧化顺序图-P100"><a href="#顺序图-帧化顺序图-P100" class="headerlink" title="顺序图 - 帧化顺序图 P100"></a>顺序图 - 帧化顺序图 P100</h5><ul><li>在UML2.0，帧化一个顺序图：用一个边框包围它并在左上角添加一个间隔区。这个间隔区包含了识别该顺序图的信息。</li><li>其中一小段信息是<strong>操作符</strong>，间隔区还包括了<strong>图所描述的交互的名字</strong>。</li><li>操作符：<ul><li><strong>顺序图</strong>：操作符为sd（sequence diagram）</li><li><strong>交互事件</strong>：操作符为ref（reference）</li><li><strong>交互片断的组合</strong>：操作符有alt（alternation）和par（parallel） <strong>P102</strong></li></ul></li></ul><h2 id="8-协作图"><a href="#8-协作图" class="headerlink" title="8. 协作图"></a>8. 协作图</h2><h5 id="8-1-协作图"><a href="#8-1-协作图" class="headerlink" title="8.1 协作图"></a>8.1 协作图</h5><ul><li>协作图的作用<ul><li>对象图展示的是对象之间的静态关系。</li><li>协作图是对象图的扩展。协作图除了展示出对象之间的关联，还显示出对象之间的消息传递。</li><li>对象图是一个快照；而协作图是一部电影。  </li></ul></li><li>协作图与顺序图两者之间是语意等价的。<ul><li>两种图表达的同一种信息，两者之间可以相互转换。</li></ul></li><li>顺序图与协作图之间的不同<ul><li>顺序图强调的是交互的时间顺序；</li><li>协作图强调的是交互的过程和参与交互的对象的整体组织。</li></ul></li></ul><h5 id="8-2-协作图-饮料销售机-P111"><a href="#8-2-协作图-饮料销售机-P111" class="headerlink" title="8.2 协作图 - 饮料销售机 P111"></a>8.2 协作图 - 饮料销售机 P111</h5><h2 id="9-状态图"><a href="#9-状态图" class="headerlink" title="9. 状态图"></a>9. 状态图</h2><h5 id="9-1-什么是状态图"><a href="#9-1-什么是状态图" class="headerlink" title="9.1 什么是状态图"></a>9.1 什么是状态图</h5><ul><li>状态图的概念：<ul><li>人或事物表现出来的形态。</li><li>当系统与用户（也可能是其它系统）交互的时候，组成系统的对象为了适应交互需要经历必要的变化。如果要对系统建立模型，那么模型中必须要反映出这种变化。</li></ul></li><li><strong>状态图与类图、对象图和用例图的本质区别</strong><ul><li>状态图只是对单个对象建立模型</li></ul></li><li>符号特征<ul><li>状态用圆角矩形表示</li><li>状态间带箭头的实线代表状态的迁移（转移），箭头指向目标状态</li><li>实心圆代表状态转移的起点，眼形圆圈代表终点<br><img src="/uml/状态图符号.png" width="50%"><img src="/uml/状态图区域.png" width="50%"></li></ul></li><li>增加状态图的细节<ul><li>常用的活动（入口动作；出口动作；动作）<br><img src="/uml/状态图例子.png" width="45%"></li></ul></li><li>增加转移的细节：事件和动作<ul><li>触发器事件：状态转移线可以指明引起转移发生的事件和引起状态发生变化所需之行的计算。</li><li>无触发器转移：有时候一个事件会引起没有相关动作的状态转移，或者一个转移是由于某个状态完成了它的活动所引起（而不是由于事件引起）</li><li>保护条件：当满足这个条件时，转移才能发生。<br><img src="/uml/状态图触发器.png" width="50%"></li></ul></li></ul><h5 id="8-2-子状态"><a href="#8-2-子状态" class="headerlink" title="8.2 子状态"></a>8.2 子状态</h5><ul><li>顺序子状态：按照顺序一个接着一个出现。</li><li><strong>并发子状态</strong>：在处于working状态时，GUI并不是<br><img src="/uml/子状态.png" width="35%"></li></ul><h2 id="9-活动图"><a href="#9-活动图" class="headerlink" title="9. 活动图"></a>9. 活动图</h2><h5 id="9-1-什么是活动图"><a href="#9-1-什么是活动图" class="headerlink" title="9.1 什么是活动图"></a>9.1 什么是活动图</h5><ul><li>活动图：被设计用于简化描述一个过程或者操作的工作步骤。</li><li>符号特征<ul><li>活动用圆角矩形表示（更接近椭圆）</li><li>箭头表示从一个活动转移到下一个活动</li><li>活动图中的起点用一个实心圆表示，终点用一个眼形圆表示<br><img src="/uml/活动图1.png" width="35%"></li></ul></li></ul><h5 id="9-2-活动图的组成"><a href="#9-2-活动图的组成" class="headerlink" title="9.2 活动图的组成"></a>9.2 活动图的组成</h5><ul><li><strong>判定(分支)</strong>：if-else    / if(无else)<br><img src="/uml/判断.png" width="35%"></li><li><strong>并发路径</strong>：两个单独的同时（并发）执行的路径。</li><li><strong>信号</strong>：活动序列中的活动可以发送信号。当信号被接受时，会引起另一个活动的发生<br><img src="/uml/并发1.png" width="22%"><img src="/uml/并发.png" width="33%"></li><li><strong>泳道</strong>：将活动图按执行的角色分割成多个平行的段，这些段被称为泳道。每个泳道的顶部显示出角色名，每个角色负责的活动放在各个角色的泳道中。<br><img src="/uml/泳道无.png" width="40%"><img src="/uml/泳道.png" width="50%"> </li><li>混合图：P122 对活动的描述更为具体、细化。</li></ul><h5 id="9-3-活动图-银行系统分析"><a href="#9-3-活动图-银行系统分析" class="headerlink" title="9.3 活动图 - 银行系统分析"></a>9.3 活动图 - 银行系统分析</h5><p><img src="/uml/登录.png" width="40%"><img src="/uml/存款.png" width="40%"></p><h2 id="10-构件图"><a href="#10-构件图" class="headerlink" title="10. 构件图"></a>10. 构件图</h2><h5 id="10-1-什么是构件"><a href="#10-1-什么是构件" class="headerlink" title="10.1 什么是构件"></a>10.1 什么是构件</h5><ul><li><strong>构件</strong>是系统中遵从一组接口且提供其实现的物理的、可替换的部分。</li><li><strong>构件图</strong>则显示一组构件以及他们之间的相互关系，包括编译、链接或执行时构件之间的依赖关系。<ul><li>构件图和部署图用于在OO系统中实现物理方面的建模</li></ul></li><li><strong>构件的类型</strong>：(构件就是一个实际文件，可以有以下几种类型)<ul><li><strong>部署构件</strong>，如dll文件、exe文件、COM+对象、动态Web页、数据库表等</li><li><strong>工作产品构</strong>件，如源代码文件、数据文件等，这些构件可以用来产生部署构件</li><li><strong>执行构件</strong>，也就是系统执行后得到的构件</li></ul></li><li><strong>构件与类的区别：</strong><ul><li>类是逻辑抽象，构件是物理抽象</li><li>构件是对其它逻辑元素，如类，协作的<strong>物理实现</strong></li><li>类可以有属性和操作；构件通常只有操作，而且这些操作只能通过构件的接口才能使用</li></ul></li><li>为什么要对构件和构件的关系建立模型<ul><li>使客户能够看到最终系统的结构和功能</li><li>让开发者有一个工作目标</li><li>让编写技术文档和帮助文件的技术人员能够理解所写的文档是关于哪方面的内容</li><li>利于复用</li></ul></li><li>符号特征：<ul><li>左侧附有两个小矩形的大矩形框；也可以用一个顶部带关键字<code>&lt;&lt;Component&gt;&gt;</code>的矩形表示</li><li>构件有自己的名称。如果构件属于一个包，可以在构件名称前面加上包名</li><li>可以在构件图标中列出构件的操作<br><img src="/uml/构件图标.png" width="50%"><img src="/uml/构件图标2.png" width="25%"> </li></ul></li></ul><h5 id="10-2-构件的接口表示法"><a href="#10-2-构件的接口表示法" class="headerlink" title="10.2 构件的接口表示法"></a>10.2 构件的接口表示法</h5><ul><li>可以用一个包含信息的矩形来表示接口，并用实现关系箭头和构件相连。</li><li>也可以用小圆圈表示接口，并用实现连接构件。<br><img src="/uml/构件接口.png" width="50%"></li></ul><h2 id="11-部署图"><a href="#11-部署图" class="headerlink" title="11. 部署图"></a>11. 部署图</h2><h5 id="11-1-什么是部署图"><a href="#11-1-什么是部署图" class="headerlink" title="11.1 什么是部署图"></a>11.1 什么是部署图</h5><ul><li>部署图的用途<ul><li>部署图用来描述系统硬件的物理拓扑结构以及在此结构上执行的软构件</li><li>部署图也称配置图，实施图。常常用于帮助理解分布式系统</li><li>部署图由体系结构设计师，网络工程师，系统工程师等描述</li></ul></li></ul><h5 id="11-2节点与连接"><a href="#11-2节点与连接" class="headerlink" title="11.2节点与连接"></a>11.2节点与连接</h5><ul><li>节点：<ul><li>节点代表一个物理设备以及其上运行的软件系统，如一台Unix主机、一个PC终端、一台打印机、一个传感器等</li><li>节点之间的连线表示系统之间进行交互的通信路径，在UML中称为连接。</li></ul></li><li>节点的划分<ul><li>处理器：能够执行软件构件的节点</li><li>设备：不能执行软件构件的外围硬件，但它通常都具备某种形式的与外部世界的接口。如modem、终端。</li></ul></li><li>符号特征：<ul><li>用立方体表示</li><li>加关键字<code>&lt;&lt;Device&gt;&gt;</code><br><img src="/uml/节点.png" width="25%"></li></ul></li><li>连接<ul><li>连接两个节点的一条线，表示了两个节点相连（但不一定要是一段电线或电缆）<br><img src="/uml/连接.png" width="25%"></li></ul></li></ul><h5 id="11-3-应用部署图-P147"><a href="#11-3-应用部署图-P147" class="headerlink" title="11.3 应用部署图 P147"></a>11.3 应用部署图 P147</h5><ul><li>家用计算机系统</li><li>令牌环网</li><li>ARCnet</li><li>细缆以太网</li><li>Ricochet无线网</li></ul><h5 id="11-4-部署图建模风格"><a href="#11-4-部署图建模风格" class="headerlink" title="11.4 部署图建模风格"></a>11.4 部署图建模风格</h5><ul><li>只对重要的软构件建模<ul><li>事实上，每个节点可能有几十甚至几百个软构件部署在上面，建模人员的目标不是把所有软构件都描绘出来，而是只描绘那些对理解系统来说至关重要的构件。</li><li>如果要探究软构件之间的关系，则采用UML构件图而不是部署图。</li></ul></li><li>对节点使用可视化的版型<ul><li>目前还没有关于如何在UML部署图中使用可视化版型的标准，但一般的经验法则是使用能找到的最合适的剪贴图。</li></ul></li></ul><h2 id="12-在开发过程中运用UML"><a href="#12-在开发过程中运用UML" class="headerlink" title="12. 在开发过程中运用UML"></a>12. 在开发过程中运用UML</h2><h5 id="12-1-开发过程方法学"><a href="#12-1-开发过程方法学" class="headerlink" title="12.1 开发过程方法学"></a>12.1 开发过程方法学</h5><ul><li>在进行程序设计前，开发人员必须要充分理解所要解决的问题，这需要专门有人负责需求的分析。在完成需求分析后，还必须有人将分析的产品转化为设计产品。然后，程序员再根据设计进行产品编制代码，这些代码在经过测试和部署后，最终称为目标系统。</li><li>传统的开发过程方法学：“瀑布”模型 <strong>分析 -&gt; 设计 -&gt; 编码 -&gt; 部署</strong></li><li>新的开发过程方法学：强调无缝集成</li><li>开发方式的变化<ul><li>个人→大型团队，短期→长期，交互与反馈，并行</li></ul></li><li>团队组成<ul><li>系统分析员：与客户交流，理解客户的问题</li><li>设计人员：设计问题的解决方案</li><li>程序设计人员：将解决方案编制成代码</li><li>系统工程师：将代码部署到硬件上运行</li></ul></li><li>一个开发方法学必须要能够做到：<ul><li>保证开发小组对所要解决的问题有个坚实的理解</li><li>要考虑到开发小组是由不同角色完成</li><li>能够在小组的不同角色成员之间培养良好的通信关系</li><li>考虑到跨越阶段的开发过程的反馈信息</li><li>开发出能够向客户反映出开发进度的工作产品，但是要避免产生过多的纸面制品</li></ul></li></ul><h5 id="12-2-GRAPPLE-快速应用工程指导原则"><a href="#12-2-GRAPPLE-快速应用工程指导原则" class="headerlink" title="12.2 GRAPPLE 快速应用工程指导原则"></a>12.2 GRAPPLE 快速应用工程指导原则</h5><ul><li>GRAPPLE的含义<ul><li>快速应用工程指导原则（Guidelines for Rapid APPLication Engineering）</li><li>强调可自适应的、灵活的开发思想</li></ul></li><li>GRAPPLE的结构：RADDD / RAD<sup>3</sup><ul><li>需求收集（requirements gathering）</li><li>分析（analysis）</li><li>设计（design）</li><li>开发（development）</li><li>部署（deployment）</li></ul></li><li><code>需求收集（一）</code><ul><li><strong>发现领域过程</strong>：获得客户业务领域词汇；活动图</li><li><strong>领域分析</strong>：高层类图</li><li><strong>识别协作系统</strong>：系统关系；部署图</li><li><strong>发现系统需求</strong>：联合应用开发会议；包图（每个包代表了一个系统功能的高层领域；每个包中包括了一组用例）</li><li><strong>将结果提交给用户</strong></li></ul></li><li><code>分析（二）</code><ul><li><strong>理解系统的用法</strong>：明确用例，开发新用例</li><li><strong>充实用例</strong>：分析出每个用例的步骤序列</li><li><strong>细化类图</strong>：关联名，抽象类，多重性，泛化，聚集</li><li><strong>分析对象状态变化</strong>：（对象）状态图</li><li><strong>定义对象之间的交互</strong>：顺序图，协作图</li><li><strong>分析与协作系统的集成</strong>：系统工程师完成</li></ul></li><li><code>设计（三）</code><ul><li><strong>开发和细化对象图</strong>：对象图，活动图</li><li><strong>开发构件图</strong>：构件图</li><li><strong>制定部署计划</strong>：部署图</li><li><strong>设计和开发用户界面原型</strong>：屏幕界面原型快照</li><li><strong>测试设计</strong>：外部专家</li><li><strong>开始编制文档</strong>：文档的高层结构</li></ul></li><li><code>开发（四）</code><ul><li><strong>编制代码</strong>：根据类图、对象图、活动图、构件图</li><li><strong>测试代码</strong></li><li><strong>构建用户界面和用户界面到代码的连接和测试</strong></li><li><strong>完成文档</strong></li></ul></li><li>部署（五）<ul><li><strong>编制备份和恢复计划</strong></li><li><strong>在硬件上安装最终系统</strong></li><li><strong>测试安装后的系统</strong></li><li>庆贺</li></ul></li></ul><h5 id="12-3-学习案例介绍-发现业务过程-P183"><a href="#12-3-学习案例介绍-发现业务过程-P183" class="headerlink" title="12.3 学习案例介绍 - 发现业务过程 P183"></a>12.3 学习案例介绍 - 发现业务过程 P183</h5><h2 id="13-领域分析"><a href="#13-领域分析" class="headerlink" title="13. 领域分析"></a>13. 领域分析</h2><h5 id="13-1-分析业务过程会谈"><a href="#13-1-分析业务过程会谈" class="headerlink" title="13.1 分析业务过程会谈"></a>13.1 分析业务过程会谈</h5><ul><li>概念性任务：运用技术来使外出就餐的人们感到更加满意</li><li>会谈目标<ul><li>建立领域词典（模型词典，初步类图）</li><li>通过谈话记录中整理名词、动词以及动词短语。其中的一些名词将可能成为模型中的类，另一些名词将成为类的属性。动词或者动词短语可能成为类的操作或类之间的关联标记。</li></ul></li></ul><h5 id="13-2-开发初步类图-P195"><a href="#13-2-开发初步类图-P195" class="headerlink" title="13.2 开发初步类图 P195"></a>13.2 开发初步类图 P195</h5><h5 id="13-3-对类分组"><a href="#13-3-对类分组" class="headerlink" title="13.3 对类分组"></a>13.3 对类分组</h5><h5 id="13-4-形成关联"><a href="#13-4-形成关联" class="headerlink" title="13.4 形成关联"></a>13.4 形成关联</h5><h5 id="13-5-形成聚集和组成"><a href="#13-5-形成聚集和组成" class="headerlink" title="13.5 形成聚集和组成"></a>13.5 形成聚集和组成</h5><h5 id="13-6-填充类的信息"><a href="#13-6-填充类的信息" class="headerlink" title="13.6 填充类的信息"></a>13.6 填充类的信息</h5><h2 id="14-收集系统需求"><a href="#14-收集系统需求" class="headerlink" title="14. 收集系统需求"></a>14. 收集系统需求</h2><ul><li>产生能反映系统功能的包图，每个包代表系统的一个功能模块，其中包含了详细说明该功能模块的若干个用例。<ul><li>系统部署图 </li><li>系统的功能包图 P219</li><li>新的类图（反映角色之间的静态关系） </li></ul></li></ul><h2 id="15-开发用例"><a href="#15-开发用例" class="headerlink" title="15. 开发用例"></a>15. 开发用例</h2><h5 id="15-1-用例分析"><a href="#15-1-用例分析" class="headerlink" title="15.1 用例分析"></a>15.1 用例分析</h5><ul><li>用例是一组场景的集合，每个场景又是由一系列步骤组成<ul><li>系统开发过程是用例驱动的</li><li>详细分析前面所列举出的用例，并开始研究如何将WIN系统中的构件具体化</li></ul></li><li>对于每个用例的每个场景，需要说明的内容有：<ul><li>场景的简单陈述</li><li>关于场景的假设条件</li><li>用例的发起参与者</li><li>场景的前置条件</li><li>场景中与系统相关的步骤序列</li><li>场景完成后的后置条件</li><li>用例的受益参与者</li><li>其它：异常条件，可选的场景流程</li></ul></li></ul><h5 id="15-2-Server包-P225"><a href="#15-2-Server包-P225" class="headerlink" title="15.2 Server包 P225"></a>15.2 Server包 P225</h5><h2 id="16-交互"><a href="#16-交互" class="headerlink" title="16. 交互"></a>16. 交互</h2><h5 id="16-1-系统中的工作部件-P223"><a href="#16-1-系统中的工作部件-P223" class="headerlink" title="16.1 系统中的工作部件 P223"></a>16.1 系统中的工作部件 P223</h5><ul><li>每个用例的背后都隐藏一张顺序图</li><li>绘制用例的顺序图可以帮助我们细化和修改用例</li><li>构件交互分析的结果应该能使程序员更容易地编制实现构件和构件之间通信的代码</li></ul><h2 id="17-设计外观、感觉和部署-P242"><a href="#17-设计外观、感觉和部署-P242" class="headerlink" title="17. 设计外观、感觉和部署 P242"></a>17. 设计外观、感觉和部署 P242</h2>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学笔记</title>
      <link href="/Cryptography/"/>
      <url>/Cryptography/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-计算机安全概念"><a href="#1-1-计算机安全概念" class="headerlink" title="1.1 计算机安全概念"></a>1.1 计算机安全概念</h3><p>网络和Internet安全领域涉及阻止、防止、检测和纠正信息传输中出现的安全违规欣慰的措施。<br><a id="more"></a></p><h3 id="1-2-OSI安全框架"><a href="#1-2-OSI安全框架" class="headerlink" title="1.2 OSI安全框架"></a>1.2 OSI安全框架</h3><ul><li>OSI安全框架主要关注：<ul><li>安全攻击：任何危机信息系统安全的行为。</li><li>安全机制：用来检测、阻止攻击或者从攻击状态恢复到正常状态的过程。</li><li>安全服务：加强数据处理系统和信息传输的安全性的一种处理过程或通信服务。</li></ul></li><li>安全在信息系统的范围很广<ul><li>信息安全</li><li>网络安全</li><li>计算机安全</li><li>数据库安全</li><li>软件安全  </li></ul></li></ul><h3 id="1-3-安全攻击"><a href="#1-3-安全攻击" class="headerlink" title="1.3 安全攻击"></a>1.3 安全攻击</h3><h5 id="四种类型"><a href="#四种类型" class="headerlink" title="四种类型"></a>四种类型</h5><ul><li><strong>阻断</strong>：使系统被破坏或者无法使用。<strong>对可用性的攻击</strong>。<ul><li>破环硬件</li><li>切断通信线路</li><li>禁用文件系统</li><li>DOS/DDOS (拒绝服务)</li></ul></li><li><strong>窃听</strong>：未经授权的一方访问信息。<strong>对保密性的攻击</strong>。<ul><li>窃听以捕获网络中的数据</li><li>非法复制文件/程序</li></ul></li><li><strong>修改</strong>：未经授权的一方不仅可以访问还可以修改信息。<strong>对完整性的攻击</strong>。<ul><li>更改文件中的数据</li><li>改变一个程序</li><li>修改消息的内容</li></ul></li><li><strong>伪装</strong>：未经授权的一方将假冒的对象插入到系统中。<strong>对真实性的攻击</strong>。<ul><li>在网络中插入虚假信息</li><li>将记录添加到文件中</li><li>改变程序</li></ul></li></ul><h5 id="两种类型"><a href="#两种类型" class="headerlink" title="两种类型"></a>两种类型</h5><ul><li><strong>主动攻击</strong>：对数据流进行修改或者伪造数据流。<strong>难以绝对地预防但容易检测。</strong><ul><li>伪装</li><li>重放</li><li>篡改</li><li>拒绝服务</li></ul></li><li><strong>被动攻击</strong>：对传输进行窃听和检测。<strong>难以检测但可以预防。</strong> <ul><li>泄密</li><li>流量分析</li></ul></li></ul><h3 id="1-4-安全服务"><a href="#1-4-安全服务" class="headerlink" title="1.4 安全服务"></a>1.4 安全服务</h3><ul><li>保密性：确保隐私或者秘密信息不向非授权者泄露，也不被非授权者所使用。</li><li>真实性：信息和信息的来源是正确的，能够验证用户的身份。</li><li>完整性：防止信息被不恰当修改或破坏。</li><li>可用性：确保信息的及时和可靠的访问和使用。</li><li>防止抵赖：防止发送方或者接收方否认传输或者接受过某条消息。</li><li>可控性：限制和控制那些通过通信连接对主机和应用进行访问。(eg. 读写权限)</li></ul><h3 id="1-5-安全机制-P14-表1-3"><a href="#1-5-安全机制-P14-表1-3" class="headerlink" title="1.5 安全机制 P14 表1.3"></a>1.5 安全机制 P14 表1.3</h3><h3 id="1-6-网络安全模型"><a href="#1-6-网络安全模型" class="headerlink" title="1.6 网络安全模型"></a>1.6 网络安全模型</h3><p><img src="/Cryptography/网络安全模型.png" width="70%"></p><h2 id="2-传统加密技术"><a href="#2-传统加密技术" class="headerlink" title="2. 传统加密技术"></a>2. 传统加密技术</h2><h3 id="2-1-密码学概念"><a href="#2-1-密码学概念" class="headerlink" title="2.1 密码学概念"></a>2.1 密码学概念</h3><h5 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h5><ul><li>密码编码学</li><li>密码分析学</li></ul><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ul><li>明文 <code>P</code>：原始可理解的消息或数据，加密算法的输入。</li><li>加密算法 <code>E</code>：加密算法对明文进行各种代替和变换。</li><li>密钥 <code>K</code>：加密算法的输入。</li><li>密文 <code>C</code>：加密算法的输出。</li><li>解密算法 <code>D</code>： 本质上是加密算法的逆运算。输入密文和密钥，输出原始明文。</li></ul><h5 id="古典加密技术"><a href="#古典加密技术" class="headerlink" title="古典加密技术"></a>古典加密技术</h5><ul><li>置换：置换符号的位置。eg. SPARTAN SCYTALE(密码棒)<ul><li>棱柱侧面的数量{x}</li><li>算法：明文一维数组-&gt;多维数组-行列变换-&gt;密文一维数组密文</li><li>评价：统计</li></ul></li><li>替换：将明文字母替换成其他字母、数字或符号的方法。eg. Caesar密码<ul><li>移位的长度 {S}</li><li>字符编码后的加法运算</li><li>缺点：密钥长度太短 </li></ul></li><li>多表代替密码<ul><li>Auto-key Cipher<br><img src="/Cryptography/Auto-key.png" width="40%"></li><li>Playfair密码：密文仍然完好地保留了明文语言的大部分结构特征。<br><img src="/Cryptography/Playfair.png" width="40%"></li><li>Vigenère密码：破译能否取得进展取决于能否判定密钥词的长度。<br><img src="/Cryptography/Vig.png" width="40%"></li><li>Hill密码：基于线性代数 P30。优点是完全隐藏了单字母频率特性。</li></ul></li></ul><h3 id="2-2-密码学概述"><a href="#2-2-密码学概述" class="headerlink" title="2.2 密码学概述"></a>2.2 密码学概述</h3><h5 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h5><ul><li>Kerckhoff准则：密码系统的安全性不在于算法的保密，而在于当对手获知了算法和密文后分析出密钥或明文的难度。</li><li>混淆：尽可能使密文和加密密钥间的统计关系更加复杂，以阻止攻击者发现密钥。</li><li>扩散：明文的统计特征消散在密文中。</li><li>雪崩效应：明文或密钥的某一位发生变化会导致密文的很多位发生变化。</li></ul><h5 id="分组密码与流密码"><a href="#分组密码与流密码" class="headerlink" title="分组密码与流密码"></a>分组密码与流密码</h5><ul><li>分组密码：将明文分组作为整体加密并且通常得到的是与明文等长的密文分组。</li><li>流密码：每次加密数据流的一位或者一个字节。</li></ul><h5 id="密码破解-分析-P23"><a href="#密码破解-分析-P23" class="headerlink" title="密码破解/分析 P23"></a>密码破解/分析 P23</h5><ul><li>唯密文攻击<ul><li>最容易防范的，攻击者拥有的信息量较少。</li><li>需要获取更多密文进行分析</li></ul></li><li>已知部分明文攻击<ul><li>可能词攻击</li></ul></li><li>选择明文攻击<ul><li>分析者通过某种方式获取信源系统，让发送方在发送的信息中插入一段由他选择的信息。</li></ul></li><li>选择密文攻击</li><li>选择文本攻击</li><li>蛮力攻击：在一个密文中尝试每个可能的密钥直到获得翻译成可理解的明文。一般需要尝试所有可能密钥的一半。</li></ul><h5 id="加密算法的安全"><a href="#加密算法的安全" class="headerlink" title="加密算法的安全"></a>加密算法的安全</h5><ul><li>无条件安全：无论有多少可使用的密文，都不足以唯一确定密文所对应的明文。</li><li>计算上安全：加密体制满足下面两条中任意一条：<ul><li>破译密码的代价超出密文信息的价值。</li><li>破译密码的时间超出密文信息的有效生命期。</li></ul></li><li>可证明安全：破译密码的难度与数学上某个困难问题的难度相同。</li><li>实际安全：包括可证明安全和计算安全</li></ul><h5 id="隐写术-信息隐藏"><a href="#隐写术-信息隐藏" class="headerlink" title="隐写术 / 信息隐藏"></a>隐写术 / 信息隐藏</h5><ul><li>隐写术：隐藏信息的存在。</li><li>密码学：通过对文本信息的不同转换而实现信息的对外不可读。</li></ul><h2 id="3-分组密码原理"><a href="#3-分组密码原理" class="headerlink" title="3. 分组密码原理"></a>3. 分组密码原理</h2><h3 id="3-1-分组密码和数据加密标准-DES"><a href="#3-1-分组密码和数据加密标准-DES" class="headerlink" title="3.1 分组密码和数据加密标准(DES)"></a>3.1 分组密码和数据加密标准(DES)</h3><h5 id="乘积密码"><a href="#乘积密码" class="headerlink" title="乘积密码"></a>乘积密码</h5><ul><li>P-box(置换)<ul><li>直接的P-box是可逆的，压缩和扩张的P-box不可逆。<br><img src="/Cryptography/pbox.png" width="40%"></li></ul></li><li>S-bos(替换)<ul><li>m x n的替换单元，m与n不一定相同。<br><img src="/Cryptography/sbox.png" width="40%"></li></ul></li><li>XOR<ul><li>相同为0不同为1</li><li>A XOR B XOR B = A </li></ul></li><li>循环移位<ul><li><img src="/Cryptography/循环移位.png" width="40%"></li></ul></li><li>交换<ul><li>是循环位移的一个特例，k = N / 2</li></ul></li><li><p>分离/合并 </p><p><img src="/Cryptography/乘积密码.png" width="40%"></p></li></ul><h5 id="Feistel密码"><a href="#Feistel密码" class="headerlink" title="Feistel密码"></a>Feistel密码</h5><ul><li>Feistel密码是对称加密算法在块加密结构中使用的一种密码结构。</li><li>基于可逆的乘积密码。Feistel密码解密是加密的逆过程。</li><li>实现了Shannon的S-P net 概念。</li><li><p>Feistel密码的属性：</p><ul><li>分组长度 </li><li>密钥长度</li><li>迭代轮数：多轮加密可以取得很高的安全性。</li><li>子密钥生成算法</li><li>轮函数F：提供“混乱”，非线性，雪崩效应</li><li>快速软件加 / 解密</li><li>简化分析难度</li></ul><p><img src="/Cryptography/Feistel密码.png" width="50%"></p></li></ul><h5 id="数据加密标准-DES"><a href="#数据加密标准-DES" class="headerlink" title="数据加密标准 DES"></a>数据加密标准 DES</h5><ul><li>DES加密过程：是由2个P-box 初始置换和最终置换、16轮Feistel加密组成。即，除了初始和末尾的置换，DES的结构与Feistel密码结构完全相同。<br><img src="/Cryptography/DES.png" width="40%"><ul><li>初始置换和末尾置换是互逆的</li><li>DES的核心是DES函数，他将一个48位的轮密钥加到32位的左半/右半部分并得到32位的输出。扩展后的右部分和轮密钥都是48位长度，且轮密钥仅在该轮使用。<br><img src="/Cryptography/DESF.png" width="30%"></li><li>DES使用了8个P-box来扩展，每个P-box有4位的输入和6位的输出</li><li>S-box做了真正的混淆。DES使用了8个S-box，且每个都有6位的输入和4位的输出<br><img src="/Cryptography/DESSbox.png" width="50%">  <img src="/Cryptography/DESSbox3.png" width="30%"><br><img src="/Cryptography/DESSbox2.png" width="50%"></li></ul></li><li>DES解密过程<ul><li>与加密过程算法相同</li><li>使用k<sub>1</sub> -&gt; k<sub>16</sub>加密</li><li>使用k<sub>16</sub> -&gt; k<sub>1</sub>解密</li></ul></li><li>DES密钥的生成和扩展<ul><li>64位随机数，丢弃8位重新排列成56位</li><li>轮密钥生成器在56位密钥中生成一个48位的轮密钥<br><img src="/Cryptography/DES密钥.png" width="40%"></li><li>16个子密钥由56位密钥分裂成两半，左右两部分各占一半，然后压缩置换他们，为48位的轮密钥。</li></ul></li><li>DES的弱点：<ul><li>P-box的弱点</li><li>S-box的弱点</li><li>密钥的弱点：56位密钥有 256 = 7.2×1016，随着计算机的发展，蛮力破解能越来越快地破解DES的密文。</li></ul></li><li>DES的密码分析<ul><li>微分密码分析</li><li>线性密码分析</li><li>相关密钥攻击</li></ul></li></ul><h5 id="多重DES"><a href="#多重DES" class="headerlink" title="多重DES"></a>多重DES</h5><ul><li>双重DES：2个密钥k<sub>1</sub>，k<sub>2</sub> <ul><li>C = E<sub>k<sub>1</sub></sub>(D<sub>k<sub>2</sub></sub>(E<sub>k<sub>1</sub></sub>(P)))</li><li>P = D<sub>k<sub>1</sub></sub>(E<sub>k<sub>2</sub></sub>(D<sub>k<sub>1</sub></sub>(C)))</li></ul></li><li>三重DES：3个密钥k<sub>1</sub>，k<sub>2</sub>，k<sub>3</sub><ul><li>C = E<sub>k<sub>3</sub></sub>(D<sub>k<sub>2</sub></sub>(E<sub>k<sub>1</sub></sub>(P)))</li><li>P = D<sub>k<sub>1</sub></sub>(P<sub>k<sub>2</sub></sub>(D<sub>k<sub>3</sub></sub>(P)))</li></ul></li><li>比DES更安全，但成本更高。</li></ul><h3 id="3-2-高级加密标准-AES"><a href="#3-2-高级加密标准-AES" class="headerlink" title="3.2 高级加密标准 AES"></a>3.2 高级加密标准 AES</h3><h5 id="数学基础：有限域算术"><a href="#数学基础：有限域算术" class="headerlink" title="数学基础：有限域算术"></a>数学基础：有限域算术</h5><ul><li>有限域：Galois域GF(2<sup>8</sup>)</li><li>任何一个字节f(x)可以表示为多项式：f(x) = b<sub>7</sub>x<sup>7</sup> + b<sub>6</sub>x<sup>6</sup> + b<sub>5</sub>x<sup>5</sup> + b<sub>4</sub>x<sup>4</sup> + b<sub>3</sub>x<sup>3</sup>+b<sub>2</sub>x<sup>2</sup> + b<sub>1</sub>x + b<sub>0</sub></li><li>1100101 —&gt; x<sup>7</sup> + x<sup>6</sup> +x<sup>3</sup> + 1 <ul><li>eg. 91<sub>hex</sub> = (1001  0001)<sub>bin</sub> = x<sup>7</sup> + x<sup>4&lt;/sup + 1 </sup></li></ul></li><li>加法运算：：a⊕b（XOR）<ul><li>封闭性：a∈F，b∈F =&gt; a⊕b∈F </li><li>交换律：a⊕b=b⊕a</li><li>结合律：a⊕（b⊕c）=（a⊕b）⊕c</li><li>单位元：0，使得a⊕0 = a</li><li>加法逆元：a⊕（-a）= 0（a = -a）</li></ul></li><li>乘法运算：a=f(x), b=g(x), m=m(x), a⊙b=f(x)×g(x) mod m(x)<ul><li>封闭性：a∈F, b∈F  =&gt; a⊙b∈F </li><li>交换律：a⊙b= b⊙a</li><li>结合律：a⊙(b⊙c)= (a⊙b)⊙c</li><li>分配率：a⊙(b⊕c)= (a⊙b)⊕(a⊙c)</li><li>单位元：1 =&gt; a ⊙1=a</li><li>乘法逆元：a⊙a-1= 1 mod m</li></ul></li><li>GF(2<sup>8</sup>)模乘法运算；m(x) = x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1<ul><li>{01} ⊙ { b<sub>7</sub>b<sub>6</sub>b<sub>5</sub>b<sub>4</sub>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub> } = { b<sub>7</sub>b<sub>6</sub>b<sub>5</sub>b<sub>4</sub>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub> }   <strong>被乘数不发生变化</strong></li><li>{02} ⊙ { b<sub>7</sub>b<sub>6</sub>b<sub>5</sub>b<sub>4</sub>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub> } = { b<sub>6</sub>b<sub>5</sub>b<sub>4</sub>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub> } <strong>b7 = 0 的情况</strong></li><li>{02} ⊙ { b<sub>7</sub>b<sub>6</sub>b<sub>5</sub>b<sub>4</sub>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub> } ={ b<sub>6</sub>b<sub>5</sub>b<sub>4</sub>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub> } ⊕ (00011011) <strong>b7 = 1 的情况</strong></li><li>{03} ⊙ {xx } ={xx} ⊕( {02} ⊙ {xx} )</li></ul></li><li>GF(2<sup>8</sup>)模乘法运算 eg. <ul><li>{02} ⊙ {2B} = {02} ⊙ { 0010 1011} = { 0101 0110}</li><li>{02} ⊙ {91}  = {02} ⊙ {1001 0001}  = {0010 0010} ⊕ {00011011}  = 00111001</li><li>{03} ⊙ {6E} = {6E} ⊕( {02}⊙{6E} ) = {0110 1110} ⊕ {10111100} = 10110010</li></ul></li></ul><h5 id="AES的评价标准"><a href="#AES的评价标准" class="headerlink" title="AES的评价标准"></a>AES的评价标准</h5><ul><li>NIST于1997年发出了AES的请求，NIST定义的选择AES的标准氛围三个方面：安全、成本、实施。</li><li>1998年6月接受了15名候选人。</li><li>1999年5个被选入名单：<ul><li>MARS􏰥IBM􏰦(IBM):􏱪􏲨 扩展Feistel密码， 􏰁􏰂􏰏128位分组，􏱉􏰚􏰷􏰏128-1248位密钥。复杂、快速，安全系数高。</li><li>RC6􏰥(USA)：􏰦􏱠128位分组，􏱉􏰚􏰷􏰏128-256位密钥。非常简单、快速，安全系数低。 􏱉􏰁􏰝􏰢􏳹􏰶􏲻􏲇􏰏􏳹􏰶􏳶􏰢􏰆􏰇􏰃􏰻􏳺􏰢 􏱉􏰁􏰝􏰢􏱨􏱩􏲕􏳶􏳷􏰢􏰆􏰇􏰃􏰻􏳸􏰢 􏱉􏰁􏰝􏰢􏱨􏱩􏲕􏳶􏳷􏰢􏰆􏰇􏰃􏰻􏳸􏰢</li><li>Rijndael􏰥(Belgium􏰦)：􏱠128位分组，􏱉􏰚􏰷􏰏128 - 256位密钥。干净、快，安全系数良好。</li><li>Serpent􏰥(Euro)：复杂、干净，安全系数非常高。</li><li>Twofish(􏰥USA􏰦􏱠􏱨􏱩􏲕􏳹􏰶􏳶􏰢􏰆􏰇􏰃􏰻􏳸􏰦􏱠􏳽􏲕􏳻􏳼􏰢􏰆􏰇􏰃􏰻􏳹􏰶􏳸􏰢)：复杂、非常快，安全系数高。</li></ul></li></ul><h5 id="AES算法加密过程"><a href="#AES算法加密过程" class="headerlink" title="AES算法加密过程"></a>AES算法加密过程</h5><ul><li>明文分组长度：128位 / 16字节</li><li>密钥长度：16字节(128位)，24字节(192位)或32字节(256位)。  </li><li>轮数：10 / 12 / 14</li><li>轮密钥长度：128位<ul><li>在<strong>第一轮开始前添加轮密钥</strong></li><li>在<strong>最后一回合没有列混淆</strong><br><img src="/Cryptography/AES.png" width="48%"><img src="/Cryptography/AES2.png" width="52%"><img src="/Cryptography/AES4.png" width="30%"></li></ul></li><li>加密和解密算法的输入是一个128位分组，这个分组被描述为4 * 4 的字节方阵。这个分组被复制到<strong>状态数组</strong>，并在加密或解密的各个阶段被修改。</li><li>四个不同的阶段<ul><li>字节替换：加密S盒，解密S盒<sup>-1</sup>，S盒必须是可逆的。S盒不是自逆的。   <strong>P103 S盒的构造</strong><br><img src="/Cryptography/AESS.png" width="30%"></li><li>行移位(<strong>以字节为单位</strong>)：第1行：不移，第2行：左移1字节，第3行，左移2字节，第4行：左移3字节。</li><li>列混淆：<br><img src="/Cryptography/AESC.png" width="40%"><img src="/Cryptography/AESC2.png" width="50%"></li><li>轮密钥加：加密过程中，每轮的输入与轮密钥异或一次（当前分组和扩展密钥的一部分进行按位异或）；因为二进制数连续异或一个数结果是不变的，所以在解密时再异或上该轮的密钥即可恢复输入。 轮密钥加是自逆的</li></ul></li></ul><h5 id="AES算法解密过程"><a href="#AES算法解密过程" class="headerlink" title="AES算法解密过程"></a>AES算法解密过程</h5><ul><li>是加密过程的逆。</li><li>字节变换：加密S盒，解密S盒<sup>-1</sup></li><li>列混淆：矩阵C进行加密，矩阵C<sup>-1</sup>解密。</li><li>反向轮密钥。</li></ul><h5 id="AES密钥扩展"><a href="#AES密钥扩展" class="headerlink" title="AES密钥扩展"></a>AES密钥扩展</h5><ul><li>AES使用密码扩展算法创建每一轮的轮密钥。如果轮数为Nr，密钥扩展算法会为一个128位(= 16个字节 = 4个字)的加密密钥输出 Nr+1 个轮密钥。</li><li>AES密钥扩展算法的输入值是4个字(16字节)，输出是44个字组成的一维线性数组。<br><img src="/Cryptography/AESkey.png" width="50%"></li></ul><h5 id="AES的实现"><a href="#AES的实现" class="headerlink" title="AES的实现"></a>AES的实现</h5><ul><li>AES可以在软件，硬件和固件中实现。 实现可以使用表查找过程或使用明确定义的代数结构的例程。</li><li>AES中使用的算法非常简单，可以使用廉价的处理器和最少的内存来轻松实现。</li></ul><h5 id="AES的安全性"><a href="#AES的安全性" class="headerlink" title="AES的安全性"></a>AES的安全性</h5><ul><li>AES是在DES之后设计的。 大多数针对DES的已知攻击已经在AES上进行了测试。</li><li>蛮力攻击：由于密钥较大，AES肯定比DES更安全。</li><li>统计攻击：许多测试未能成功对密文进行统计分析。</li><li>差分和线性攻击：目前还没有对AES的差异和线性攻击。</li></ul><h3 id="3-3-分组密码的工作模式"><a href="#3-3-分组密码的工作模式" class="headerlink" title="3.3 分组密码的工作模式"></a>3.3 分组密码的工作模式</h3><h5 id="更先进的对称密码"><a href="#更先进的对称密码" class="headerlink" title="更先进的对称密码"></a>更先进的对称密码</h5><ul><li>IDEA: International Data Encryption Algorithm<ul><li>1992, Lai Xuejia (来学嘉)</li><li>64位分组大小，128位密钥, 8轮<br><img src="/Cryptography/IDEA.png" width="50%"></li></ul></li><li>Blowfish<ul><li>Bruce Schneier, 1993 </li><li>Feistel密码结构</li><li>64位分组大小，32–448位密钥, 16轮</li><li>继承者: Twofish</li><li>Key Generator</li><li>complex<br><img src="/Cryptography/Blowfish.png" width="50%"></li></ul></li><li>RC5<ul><li>可变分组大小（32,64或128位），可变密钥大小（0到2040位）和可变轮次数（0到255）。 </li><li>最初建议的参数选择是块大小为64位，128位密钥和12轮。</li><li>继承者：RC6<br><img src="/Cryptography/RC5.png" width="15%"></li></ul></li><li>高级分组密码的特点<ul><li>可变性：密钥长度，分组大小，轮数，S盒，圆函数</li><li>复杂的轮函数生成</li><li>执行密钥的更多角色：S盒，圆形移位</li></ul></li></ul><h5 id="分组密码的操作模式"><a href="#分组密码的操作模式" class="headerlink" title="分组密码的操作模式"></a>分组密码的操作模式</h5><ul><li>对称加密模式可以使用现代分组密码完成。</li><li>操作模式已经被设计以使用DES或AES加密任何大小的文本。</li><li>实质上，工作模式是一项增强密码算法或者使算法适应具体应用的技术。</li></ul><h5 id="电子密码本-ECB"><a href="#电子密码本-ECB" class="headerlink" title="电子密码本 ECB"></a>电子密码本 ECB</h5><ul><li>一次处理一组明文分块，每次使用相同的密钥加密。<br><img src="/Cryptography/ECB.png" width="55%"></li><li>ECB评价<ul><li>消息中若有几个相同的明文组，那么密文也将出现几个相同的密文分组。</li><li>􏲒􏰍􏳿􏴀􏱺􏱮􏳾􏰅􏴁􏱅􏴂􏴃􏲒􏰍􏳿􏴀􏱺􏱮􏳾􏰅􏴁􏱅􏴂􏴃无法阻止长消息的修改攻击，</li><li>无错误传播：传输中的单个错误可能会在相应块的多个位中产生错误。但该错误对于其他块没有任何影响。（why：因为ECB一次处理一个明文分块，每个明文块使用相同的密钥独立编码。）</li></ul></li><li>ECB适用于：<ul><li>单个数据的安全传输</li><li>eg. 加密 密钥，口令 </li></ul></li></ul><h5 id="密码分组链接模式-CBC"><a href="#密码分组链接模式-CBC" class="headerlink" title="密码分组链接模式 CBC"></a>密码分组链接模式 CBC</h5><ul><li>为了克服ECB的弱点，我们需要将重复的明文文组加密成不同的密文分组。</li><li>CBC的输入是当前明文组的上一个密文组的异或，使用的密钥是相同的。  </li><li>IV 初始向量：为了产生密文的第一个密文块，初始向量IV与第一个明文块进行异或。</li><li>IV必须为收发双方共享，但第三方不能预测。为了最大限度的安全。IV不能不经授权而修改。<br><img src="/Cryptography/CBC.png" width="55%"></li><li>CBC的加密和解密是互逆的。</li><li>CBC方式要求如果最后的分组不是完整的分组，则需要填充至b位的满分组。<ul><li>P<sub>i</sub> = D<sub>K</sub>(C<sub>i</sub>)⊕C<sub>i-1</sub>= D<sub>K</sub>(E<sub>K</sub>(P<sub>i</sub>⊕C<sub>i-1</sub>))⊕C<sub>i-1</sub> = P<sub>i</sub>⊕C<sub>i-1</sub>⊕C<sub>i-1</sub></li></ul></li><li>CBC适用于：<ul><li>面向分组的通用传输</li><li>消息鉴别 / 认证</li></ul></li></ul><h5 id="密码反馈模式-CFB"><a href="#密码反馈模式-CFB" class="headerlink" title="密码反馈模式 CFB"></a>密码反馈模式 CFB</h5><ul><li>实时地传输长消息。</li><li>解密与加密使用相同的办法，只有一点不同：将收到的密文单元与加密函数的输出异或得到明文单元。这里使用的是加密函数而非解密函数。 </li><li>与明文异或的位流是<strong>与明文相关的</strong>。<br><img src="/Cryptography/CFB.png" width="50%">  <img src="/Cryptography/CFB2.png" width="50%"></li><li>CFB：错误传播<ul><li>消息认证</li><li>在<strong>可靠的信道</strong></li></ul></li><li>CFB适用于：<ul><li>面向<strong>数据流</strong>的通用传输  </li><li>认证 </li></ul></li></ul><h5 id="输出反馈模式-OFB"><a href="#输出反馈模式-OFB" class="headerlink" title="输出反馈模式 OFB"></a>输出反馈模式 OFB</h5><ul><li>没有错误传播：传输过程中某位上发生的错误不会影响其他位。OFB作为流密码，可以在<strong>不可靠信道</strong>使用。</li><li>不需要将明文填充到长度是分组长度的整数倍。</li><li>缺点：抗消息流篡改攻击能力不如CFB<br><img src="/Cryptography/OFB.png" width="50%">  <img src="/Cryptography/OFB2.png" width="50%"></li><li>OFB适用于<ul><li>噪声信道上<strong>的数据流传输</strong>，瑞卫星通信</li></ul></li></ul><h5 id="计数器模式-CTR"><a href="#计数器模式-CTR" class="headerlink" title="计数器模式 CTR"></a>计数器模式 CTR</h5><ul><li>没有反馈。</li><li>密钥流的伪随机用计数器来实现。<br><img src="/Cryptography/CTR.png" width="50%">  <img src="/Cryptography/CTR2.png" width="50%"></li><li>CTR适用于<ul><li>面向分组的通用传输，属于数据流的传输</li><li>用于高速需求</li></ul></li></ul><h2 id="4-流密码"><a href="#4-流密码" class="headerlink" title="4. 流密码"></a>4. 流密码</h2><h3 id="4-1-流密码概述"><a href="#4-1-流密码概述" class="headerlink" title="4.1 流密码概述"></a>4.1 流密码概述</h3><ul><li>一个典型的流密码每次加密一个字节的明文，产生伪随机密钥流，与明文流的每个字节进行按位异或运算，得到一个密文字节。</li><li>“一次一密”使用的是真正的随机数流，而流密码使用的是伪随机数流。</li><li>流密码的随机性完全破坏了消息中的统计的性质。</li><li>不能重复使用流密码，否则能够恢复消息。而分组密码可以重复使用密钥。<br><img src="/Cryptography/stream.png" width="60%"></li><li>一些需要考虑的方面：<ul><li>长时间没有重复</li><li>统计学上随机</li><li>取决于足够大的密钥的线形复杂性</li><li>正确设计，可以像具有相同大小密钥的分组密码一样安全，但通常更简单、快速。</li></ul></li><li>流密码：使用分组密码模式——OFB</li></ul><h3 id="RC4算法"><a href="#RC4算法" class="headerlink" title="RC4算法"></a>RC4算法</h3><h5 id="RC4概述"><a href="#RC4概述" class="headerlink" title="RC4概述"></a>RC4概述</h5><ul><li>RC4是流密码，RC5是分组加密算法</li><li>RC4是一个面向字节的流密码，其中明文的一个字节与一个密钥字节进行X-存储，以产生一个密文字节。</li><li>RSA DSI的私有的密码</li><li>另一个是Ron Rivest设计于1987年，简单、有效：<ul><li>可变长度的密钥，面向字节的流密码</li><li>广泛使用（网络SSL / TLS，无线WEP）</li><li>密钥形成所有8位数的随机排列，使用该排列来搅乱一次处理一个字节的输入信息</li></ul></li></ul><h5 id="RC4算法-1"><a href="#RC4算法-1" class="headerlink" title="RC4算法"></a>RC4算法</h5><ul><li>基本描述<ul><li>可变长度密钥K：1-256个字节(8-2048位)。密钥K的长度keylen与明文长度、密钥流长度无关，通常取16字节(128bits)</li><li>状态向量S：256个字节，S的元素记为S[0], S[1], … , S[256]。<strong>从始至终置换后的S包含从0-255的8位数，只不过位置发生了变化</strong></li><li>临时向量T：256个字节，每个单元也是一个字节。如果密钥K的长度是256字节，则直接把密钥的值赋给T，否则轮转地将密钥的每个字节赋给T。</li><li>密钥流：密钥流的长度和明文的长度是对应的(相等)<br><img src="/Cryptography/RC4.png" width="60%"></li></ul></li><li>RC4算法具体描述：<ul><li>初始化S和T</li><li>S的初始置换</li><li>密钥流的生成</li><li><strong>加密</strong>时将k的值与明文的下一字节<strong>异或</strong>；<strong>解密</strong>时将k的值与密文的下一个字节<strong>异或</strong>。</li></ul></li><li>RC4的安全性<ul><li>声称可以抵御已知攻击</li><li>有一些分析，没有实际意义</li><li>结果是非线性</li><li>由于RC4是流密码，因此不能用重复的密钥</li><li>关注WEP，但由于是密钥处理而不是RC4本身</li></ul></li></ul><h5 id="RC4-3bits"><a href="#RC4-3bits" class="headerlink" title="RC4 3bits"></a>RC4 3bits</h5><ul><li>是RC4算法的一个变体。</li><li>可变长度的密钥：3位 - 24位</li><li>24位的状态向量<strong>S</strong>的元素：S[0], S[1], … , S[8]</li><li>eg.<ul><li>明文：(7 2 5 1 5)<sub>oct</sub>     = {111 010 101 001 101}<sub>bin</sub></li><li>密钥：(7 4 3 2)<sub>oct</sub> = {111 100 011 010}<sub>bin</sub>   (密钥长度 = 4*3bit=12) </li><li>初始化：<br><img src="/Cryptography/初始化.png" width="60%"></li><li>初始置换：<br><img src="/Cryptography/初始置换.png" width="60%"><br><img src="/Cryptography/初始置换2.png" width="60%"></li><li>密钥流的生成：<br><img src="/Cryptography/流密钥1.png" width="60%"><br><img src="/Cryptography/流密钥2.png" width="60%"></li></ul></li></ul><h2 id="5-密钥管理和分发"><a href="#5-密钥管理和分发" class="headerlink" title="5. 密钥管理和分发"></a>5. 密钥管理和分发</h2><h5 id="密钥分发历史"><a href="#密钥分发历史" class="headerlink" title="密钥分发历史"></a>密钥分发历史</h5><ul><li>在第二次世界大战期间，德国高级司令部不得不将其每月的日记账分发给其所有谜运营商。而且，U型船往往需要长时间远离开基地，不得不以某种方式获得定期供应的钥匙。</li><li>美国政府的密钥由COMSEC管理和分发。在20世纪70年代，COMSEC负责每天运输大量的钥匙。当携带COMSEC材料的船舶进入码头时，密码管理机构将在船上行进，收集成堆的卡片，纸带，软盘，然后将它们交付给目标收件人。</li></ul><h5 id="密钥分发模型-P319"><a href="#密钥分发模型-P319" class="headerlink" title="密钥分发模型 P319"></a>密钥分发模型 P319</h5><ol><li>A选择一个密钥后以物理的方式(安全)传递给B。</li><li>第三方选择密钥后物理地传递给A和B。</li><li>如果A和B先前或者最近使用过一个密钥，则一方可以将新密钥用旧密钥加密后发送给另一方。</li><li>如果A和B到第三方C有加密连接，C可以在加密连接上传送密钥给A和B。</li><li>第三方加密：<strong>密钥分发中心(KDC)</strong>负责根据用户的需要来分发密钥。</li></ol><h5 id="密钥分发中心-KDC"><a href="#密钥分发中心-KDC" class="headerlink" title="密钥分发中心 KDC"></a>密钥分发中心 KDC</h5><ul><li>密钥分发中心是基于密钥层次体系的，最少需要两个密钥层。<ul><li>会话密钥：用于持续时间的逻辑连接，如帧的转发或传输连接，然后随着连接的断开而丢弃。</li><li>主密钥：用户和KDC共享的唯一的主密钥。用于会话密钥的加密分发。</li><li>主密钥的分发可以通过一些不加密的方式完成，如物理传递</li></ul></li><li>评价：<ul><li>在两个人可以交换秘密之前，他们必须已经分享了一个秘密。</li><li>大量的会话密钥通过互联网进行分发。</li></ul></li></ul><h5 id="密钥分配方案"><a href="#密钥分配方案" class="headerlink" title="密钥分配方案"></a>密钥分配方案</h5><ul><li>Needham/Schreoder 认证协议：KDC <strong>P321</strong><br><img src="/Cryptography/KDC.png" width="55%"></li><li>Denning认证协议 : timestamps<br><img src="/Cryptography/timestamps.png" width="55%"></li><li>Neuman协议：<br><img src="/Cryptography/Neuman.png" width="55%"></li></ul><h5 id="层次密钥控制"><a href="#层次密钥控制" class="headerlink" title="层次密钥控制"></a>层次密钥控制</h5><ul><li>对于大型网络，需要建立KDC的层次体系。<ul><li>同一个本地域的各个实体相互通信，由本地KDC负责密钥分发。</li><li>两个实体在不同域，由两个相对应的本地KDC通过全局KDC协商产生共享密钥。</li></ul></li><li>层次策略使得主密钥分发的开销最小化。</li></ul><h5 id="会话密钥的生命周期"><a href="#会话密钥的生命周期" class="headerlink" title="会话密钥的生命周期"></a>会话密钥的生命周期</h5><ul><li>会话密钥交换得越频繁就越安全。密钥分发会延迟交换的开始时间，增加网络负担。</li><li>对于<strong>面向连接的协议</strong>，在会话的整个生命周期中使用同一个会话密钥。</li><li>对于<strong>无连接的协议</strong>，没有明确的连接初始和终止。最安全的方法是每次都使用新的会话密钥，但开销变大。</li></ul><h5 id="控制密钥的使用"><a href="#控制密钥的使用" class="headerlink" title="控制密钥的使用"></a>控制密钥的使用</h5><ul><li>数据加密密钥，用于网络中通用通信</li><li>PIN加密密钥，用于电子资金过户的销售点应用的个人识别码(PIN)</li><li>文件加密密钥：用于存储可公开访问的加密文件。</li></ul><h2 id="6-密钥交换"><a href="#6-密钥交换" class="headerlink" title="6. 密钥交换"></a>6. 密钥交换</h2><h3 id="6-1-Diffie-Hellman-密钥交换"><a href="#6-1-Diffie-Hellman-密钥交换" class="headerlink" title="6.1 Diffie-Hellman 密钥交换"></a>6.1 Diffie-Hellman 密钥交换</h3><ul><li>加密和解密的密钥不同。(私钥和公钥)</li><li>相比对称加密的密钥分发，不用等待获取会话密钥，然后才能加密和发送消息。</li><li>基于一个单向函数：K = ( Y<sub>B</sub> )<sup>X<sub>A</sub></sup> mod q = ( Y<sub>A</sub> )<sup>X<sub>B</sub></sup> mod q</li><li>Diffie-Hellman算法的有效性建立在<strong>计算离散对数是很困难的</strong>这一基础上。</li><li>算法流程：  <strong>P218 具体计算</strong><br><img src="/Cryptography/Diffie-Hellman.png" width="62%"></li><li>缺点：不能抵抗所谓的中间人攻击。<br><img src="/Cryptography/中间人攻击.png" width="48%"></li></ul><h3 id="6-2-RSA算法"><a href="#6-2-RSA算法" class="headerlink" title="6.2 RSA算法"></a>6.2 RSA算法</h3><h5 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h5><ul><li>数论的核心问题：<strong>质数</strong></li><li><strong>因子分解定律</strong>：任何大于1的整数a都可以被这样分解：a = p<sub>1</sub><sup>a<sub>1</sub></sup> x p<sub>2</sub><sup>a<sub>2</sub></sup> x … x p<sub>k</sub><sup>a<sub>k</sub></sup>，p<sub>1</sub> &gt; p<sub>2</sub> &gt; … &gt; p<sub>k</sub> <ul><li>eg. 11011 = 7 x 11<sup>2</sup> x 13</li></ul></li><li><strong>素数有无限多个 </strong></li><li><strong>同模</strong>：两个整数如果a mod n = b mod n，则称a与b同模<ul><li>eg. 73 mod 23 = 4, 73 = 4 mod 23，则称4与73同模。 </li></ul></li><li>模运算的性质：<ul><li>定义：a mod n = b mod n → a ≡ b mod n</li><li>交换律：a ≡ b mod n → b ≡ a mod n</li><li>传递律：a ≡ b mod n &amp; b ≡ c mod n → a ≡ c mod n</li><li>有前提条件的消除律：如果a与n互质，则a x b  ≡ a x c mod n  → b ≡ c mod n </li></ul></li><li><strong>gcd(a, b)</strong>：表示a和b的最大公约数。</li><li>a与b互质，则gcd(a, b) = 1</li><li><strong>模乘的逆</strong>：<ul><li>定义Z<sub>n</sub>为正整数小于n的集合：Z<sub>n</sub> = {0, 1, …, (n-1)}</li><li>模乘的逆w<sup>-1</sup> ：对于每个w ∈ Z<sub>p</sub>，ョz，w * z  ≡ 1 mod p ，称z为w<sup>-1</sup></li></ul></li><li><strong>费马定理 / 费马小定理</strong>：<ul><li>p是一个质数，a是一个不能被p整除的正整数， 则a<sup>p-1</sup> = 1 mod p</li><li>eg. a = 6, p = 7, 6<sup>7-1</sup> ≡ 1 mod 7</li><li>另一种形式：p是一个质数，a是一个正整数。则a<sup>p</sup> = a mod p</li><li>eg. a = 3, p = 5, 3<sup>5</sup> = 243 ≡ 3 mod 5</li></ul></li><li><strong>欧拉函数</strong><ul><li>定义 φ(n) 为小于n且与n互质的正整数。</li><li>如果p为一个素数，那么φ(p) = p - 1</li><li>如果n = p<sub>1</sub><sup>a<sub>1</sub></sup> p<sub>2</sub><sup>a<sub>2</sub></sup> … p<sub>k</sub><sup>a<sub>k</sub></sup> 是素数分解的n，那么<img src="/Cryptography/oula.png" width="30%"></li></ul></li><li><strong>欧拉定理</strong><ul><li>对于任何互质的a和n，a<sup>φ(n)</sup> ≡ 1 mod n，或者 a<sup>φ(n)+1</sup> ≡ a mod n</li></ul></li><li><strong>欧拉定理的推论</strong><ul><li>给定两个素数p和q，以及整数n = pq，且0 &lt; m &lt; n</li><li>m<sup>φ(n)+1</sup> = m<sup>(p - 1)(q - 1) + 1 </sup> ≡ m mod n</li><li>对任意整数k有：[m<sup>φ(n)</sup>]<sup>k</sup> ≡ 1 mod n 或 m<sup>kφ(n)</sup>  ≡ 1 mod n</li><li>m<sup>kφ(n)+1</sup> = m<sup>k (p - 1)(q - 1) + 1 </sup> ≡ m mod n</li></ul></li></ul><h5 id="RSA算法描述"><a href="#RSA算法描述" class="headerlink" title="RSA算法描述"></a>RSA算法描述</h5><ul><li>对于<code>明文分组M</code>和<code>密文分组C</code>，加密和解密过程如下：<ul><li>C = M<sup>e</sup> mod n <strong>(加密)</strong></li><li>M = C<sup>d</sup> mod n = (M<sup>e</sup>)<sup>d</sup> mod n = M<sup>ed</sup> mod n <strong>(解密)</strong></li><li>其中，收发双方均已知n，发送方已知e，且<strong>只有接收方已知d</strong>，因此公钥加密算法的公钥PU = { e, n }，私钥PR = { d, n }</li></ul></li><li>必须满足以下条件：d 和 e 是模 φ(n) 的乘法逆元。即 d 与 φ(n) 互质（因此 e 也与 φ(n) 互质）<ul><li><strong>ed = kφ(n)+1</strong></li><li>ed ≡ 1 mod φ(n)</li><li>d ≡ e<sup>-1</sup> mod φ(n)</li><li>gcd( φ(n), d) = 1 ），gcd( φ(n), e) = 1 ）</li></ul></li></ul><h5 id="RSA密钥产生"><a href="#RSA密钥产生" class="headerlink" title="RSA密钥产生"></a>RSA密钥产生</h5><ul><li>选择(大)质数p, q（私有）</li><li>计算 n = p * q</li><li>计算 φ(n) = ( p - 1 )( q - 1 )</li><li>选择 e：gcd( φ(n), e) = 1 ）1 &lt; e &lt; φ(n)</li><li>计算 d ≡ e<sup>-1</sup> mod φ(n)（如何计算d -&gt; 扩展欧基里德算法）</li><li>公钥PU = { e, n }，私钥PR = { <strong>d</strong>, n }</li></ul><h5 id="RSA的安全性"><a href="#RSA的安全性" class="headerlink" title="RSA的安全性"></a>RSA的安全性</h5><ul><li>给定n确定p和q是不可行的</li><li>给定e和d确定d是不可行的</li><li>因子分解问题：对于有大素数因子的数字n，因式分解是个难题。</li><li>RSA密钥非常大所以很安全： 1024 / 2048 位</li><li>1994年，彼得肖尔表明，量子计算机可以将多项式时间（多项式时间）考虑在内，从而打破了RSA。如果n是300位或更短，则可以在个人计算机上在几个小时内计算出来 截至2008年，通用分解算法考虑的最大（已知）数量是663位长（参见RSA-200），使用最先进的分布式实现。下一个记录可能是768位模数<ul><li>RSA 秘密研制于上个世纪60年代初，用于控制战略导弹的发射. 70年代被麻省理工学院等高校的教授独立发明，建立在数论，特别是很难对大素数之积进行因式分解的基础之上。</li><li>一旦量子计算机投入实用，将给目前的公共加密技术带来极大威胁。</li></ul></li></ul><h5 id="公钥算法与对称加密"><a href="#公钥算法与对称加密" class="headerlink" title="公钥算法与对称加密"></a>公钥算法与对称加密</h5><ul><li>从最早开始到现代，虚拟（事实上）所有加密系统都基于替代和排列的基本工具。</li><li>公钥算法基于数学函数而不是替换和置换。</li><li>公钥密码可用于<ul><li>加密/解密</li><li>电子签名</li><li>密钥交换/管理</li></ul></li><li>应该提到一些关于PKC的常见误解（误解）：<ul><li>PKC比对称密钥加密更安全(✕)</li><li>PKC是一种通用技术，传统密码已经过时(✕)</li><li>使用PKC时，密钥分发没有意义(✕)</li></ul></li></ul><h2 id="7-消息认证"><a href="#7-消息认证" class="headerlink" title="7. 消息认证"></a>7. 消息认证</h2><h3 id="7-1-安全服务"><a href="#7-1-安全服务" class="headerlink" title="7.1 安全服务"></a>7.1 安全服务</h3><ul><li>对称密钥密码：使用相同的会话密钥K<sub>s</sub>进行/解密。</li><li>使用非对称密钥密码（RSA）来传递会话密钥K<sub>s</sub>。</li><li>已经被提出的5种信息攻击/安全问题<ul><li>泄露</li><li>流量分析</li><li>冒充</li><li>篡改：内容 / 顺序 / 时间 篡改</li><li>拒绝服务 / 推诿</li></ul></li><li>解决方法：<ul><li>信息保密：泄露，流量分析</li><li>数字签名：拒绝服务/推诿</li><li>消息认证： 冒充，篡改</li></ul></li></ul><h3 id="7-2-消息认证"><a href="#7-2-消息认证" class="headerlink" title="7.2 消息认证"></a>7.2 消息认证</h3><h5 id="消息认证"><a href="#消息认证" class="headerlink" title="消息认证"></a>消息认证</h5><ul><li>消息认证：验证所受到的消息确实是来自真正的发送方，且是未被修改的消息，也可以验证消息的顺序和及时性。 <ul><li>数字签名是消息认证机制之一。</li></ul></li><li>不同级别的消息认证：消息身份验证的两个基本级别部署机制</li><li>基础 - 低级别：身份验证<ul><li>消息加密</li><li>消息认证码(MAC)</li><li>Hash函数</li></ul></li><li>应用 - 高级别：身份认证协议<ul><li>PGP ( Pretty Good Privacy)</li><li>Kerberos </li></ul></li><li>对于对称加密，提供：<ul><li>保密</li><li>消息认证(eg. CBC模式)</li></ul></li><li>对于公钥加密，提供：<ul><li>消息认证：发送方用自己的私钥给消息加密，它提供了数字签名。</li><li>保密：发送方用接收方的公钥给已加密的消息再次加密，提供了保密性。</li></ul></li></ul><h5 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h5><ul><li>利用密钥来生成一个固定长度的<strong>短数据块</strong>，并将该数据块附加在消息之后。</li><li>假设A和B共享一个密钥，当A向B发送消息时：<ul><li>A计算MAC，<strong>它是消息和密钥的函数</strong>：MAC = C<sub>K</sub>(M)</li><li>消息和MAC一起发送给接收方B</li><li>当接收到消息后，B用同样的方式计算出MAC，并与接收到的MAC进行比较：MAC’ = C<sub>K</sub>(M)</li><li>如果MAC = MAC’ 则消息得到认证。</li></ul></li><li>MAC函数与加密类似，但是<strong>MAC算法不要求可逆性</strong>，而加密算法必须可逆。</li><li>MAC函数不能提供数字签名机制。MAC使用对称加密，既然一方能够验证你的MAC，就能够伪造你的MAC，因为发送方和接收方的秘钥是一样的。</li><li><strong>消息摘要与MAC的区别</strong><ul><li><strong>消息摘要只能保证消息的完整性</strong>。攻击者可以将原始消息和摘要都篡改成新的消息和摘要。而MAC由于是消息和密钥的函数，攻击者无法生成与篡改后内容匹配的MAC。</li><li>MAC不仅能够保证完整性，还能够保证真实性</li></ul></li></ul><h5 id="Hash函数-P239"><a href="#Hash函数-P239" class="headerlink" title="Hash函数 P239"></a>Hash函数 P239</h5><ul><li>发送者根据待发送的消息使用Hash函数计算一组Hash值，然后将Hash值和消息一起发送过去。</li><li>使用Hash函数的原因：<ul><li>加密软件速度慢</li><li>加密硬件成本不容忽视</li><li>加密硬件的优化通常是针对大数据的</li><li>加密算法可能受专利保护</li><li>加密算法受美国出口管制</li></ul></li><li>哈希函数的要求 <strong>P245</strong><ol><li>H（x）可以应用于任何大小的数据块x</li><li>H（x）产生固定长度的输出</li><li>3.对于任何给定的x，H（x）相对容易计算，使得硬件和软件实现都是现实的。</li><li>单向性：对于任何给定的代码h，它是计算上的不可能找到x使得H（x）= h。</li><li>弱碰撞阻力：对于任何给定的x，找到y≠x -&gt; H(y) = H(x)在计算上是不可行的。</li><li>6.强抗碰撞性：找到任何（x，y）使得H（x）= H（y）在计算上是不可行的。</li></ol></li><li>两个简单的Hash函数：<ul><li>最简单的Hash函数是每个块的逐位异或：C<sub>i</sub> = b<sub>i1</sub> ⊕ b<sub>i2</sub> ⊕ …  ⊕ b<sub>im</sub></li><li>Hash算法包括重复地使用一个压缩函数f：输入为链接变量(上一步的n位输入)和一个b位的块，产生一个n位的输出。<strong>P248</strong></li></ul></li><li>Hash函数的应用<ul><li>消息摘要</li><li>密码/口令保护</li><li>防止重放攻击：用户和Auth Sever秘密共享一个seed，Hash<sup>N-x(seed)，N是一个很大的初始值，x是登录验证的次数。(<strong><code>重放攻击</code></strong>是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，<strong>主要用于身份认证过程</strong>，破坏认证的正确性。)</sup></li></ul></li></ul><h5 id="安全Hash算法-SHA"><a href="#安全Hash算法-SHA" class="headerlink" title="安全Hash算法 SHA"></a>安全Hash算法 SHA</h5><ul><li>SHA-1 来自 MD4</li><li>SHA-2 family：SHA-224, SHA-256, SHA-384和SHA-512<br><img src="/Cryptography/SHA512.png" width="60%"></li></ul><h5 id="消息摘要"><a href="#消息摘要" class="headerlink" title="消息摘要"></a>消息摘要</h5><ul><li>MD5消息摘要算法<ul><li>MD5消息摘要算法由1990年麻省理工学院的Ron Rivest创建</li><li>它将任意长度的消息(但会分成512bits一组)作为输入并产生<strong>128位消息摘要</strong>作为输出。</li></ul></li></ul><h2 id="8-数字签名"><a href="#8-数字签名" class="headerlink" title="8. 数字签名"></a>8. 数字签名</h2><h3 id="8-1-数字签名简介"><a href="#8-1-数字签名简介" class="headerlink" title="8.1 数字签名简介"></a>8.1 数字签名简介</h3><h5 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h5><ul><li>数字签名或数字签名方案是用于证明数字消息或文档的真实性的数学方案。</li><li>有效的数字签名使接收方有理由相信该消息是由已知接收方创建的，并且该邮件在传输过程中未被更改。</li><li>数字签名通常用于软件分发，金融交易，以及其他情况需要检测修改的情况。</li></ul><h5 id="数字签名的特征"><a href="#数字签名的特征" class="headerlink" title="数字签名的特征"></a>数字签名的特征</h5><ul><li>能验证签名者、签名日期和时间</li><li>能认证被签的消息内容</li><li>签名应能由第三方仲裁，以解决争执</li></ul><h5 id="数字签名需求"><a href="#数字签名需求" class="headerlink" title="数字签名需求"></a>数字签名需求</h5><ul><li>签名必须是与消息相关的二进制串</li><li>签名必须使用发送方某些独有的信息，以防伪造和否认</li><li>产生、识别和验证数字签名比较容易</li><li>伪造数字签名在计算上是不可行的</li><li>保存数字签名副本是可行的</li></ul><p><img src="/Cryptography/数字签名.png" width="55%"></p><h5 id="数字签名过程-P300"><a href="#数字签名过程-P300" class="headerlink" title="数字签名过程 P300"></a>数字签名过程 P300</h5><ul><li>数字签名需要<strong>公钥系统</strong>。</li><li>签名者用他的私钥签名，验证者使用签名者的公钥进行验证。<br><img src="/Cryptography/数字签名1.png" width="55%"><br><img src="/Cryptography/数字签名2.png" width="55%"></li></ul><h5 id="数字签名提供的安全服务"><a href="#数字签名提供的安全服务" class="headerlink" title="数字签名提供的安全服务"></a>数字签名提供的安全服务</h5><ul><li>消息验证</li><li>消息完整性</li><li>防止抵赖</li><li>消息完整性</li></ul><h3 id="8-2-数字签名方案"><a href="#8-2-数字签名方案" class="headerlink" title="8.2 数字签名方案"></a>8.2 数字签名方案</h3><h5 id="RSA数字签名方案-P305"><a href="#RSA数字签名方案-P305" class="headerlink" title="RSA数字签名方案 P305"></a>RSA数字签名方案 P305</h5><p><img src="/Cryptography/RSA.png" width="50%"><br><img src="/Cryptography/DSA.png" width="50%"></p><h3 id="8-3-用户认证协议-P348"><a href="#8-3-用户认证协议-P348" class="headerlink" title="8.3 用户认证协议 P348"></a>8.3 用户认证协议 P348</h3><h5 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h5><ul><li>Kerberos概述：<ul><li>Kerberos是一种计算机网络认证协议，它允许通过非安全网络进行通信的节点以安全的方式相互证明其身份。</li><li>它也是麻省理工学院出版的一套免费软件，它实现了这个协议。</li><li>麻省理工学院开发了Kerberos来保护Project Athena提供的网络服务</li><li>存在多种版本的协议; 版本1-3仅在麻省理工学院内部发生。</li><li>版本4发表于20世纪80年代后期</li><li>版本5在1993年作为RFC 1510出现<br><img src="/Cryptography/Ker.png" width="70%"></li></ul></li><li>一个全方位服务的Kerberos环境包括：<ul><li>1个Kerberos服务器</li><li>多个客户端</li><li>多个应用服务器</li></ul></li><li>Kerberos环境要求：<ul><li>Kerberos服务器必须具有该用户ID和密码</li><li>Kerberos服务器必须与每一个服务器共享密钥  </li></ul></li></ul><blockquote><p>这种环境被称为领域</p></blockquote><h5 id="X-509"><a href="#X-509" class="headerlink" title="X.509"></a>X.509</h5><ul><li>X.509是用于单点登录（SSO）和权益管理基础设施（PMI）的公钥基础设施（PKI）的ITU-T（国际电信联盟）标准。</li><li>X.509除其他外指定了公钥证书，证书撤回列表，属性证书和证书路径确认算法的标准格式。<br>有关X.509的详细信息，请参阅第14.2节或维基百科</li></ul><h3 id="8-4-PGP-P445"><a href="#8-4-PGP-P445" class="headerlink" title="8.4 PGP P445"></a>8.4 PGP P445</h3><h5 id="PGP概述"><a href="#PGP概述" class="headerlink" title="PGP概述"></a>PGP概述</h5><ul><li>Pretty Good Privacy（PGP）是一种提供加密隐私和身份验证的计算机程序。</li><li>PGP通常用于签名，加密和解密电子邮件，以提高电子邮件通信的安全性。<br>它由Philip Zimmermann于1991年创建。<br>PGP和其他类似产品遵循OpenPGP标准（RFC 4880）来加密和解密数据。  </li><li>PGP-用户认证：<strong>P448</strong><br><img src="/Cryptography/PGP.png" width="50%"></li><li>PGP-保密：<br><img src="/Cryptography/PGP2.png" width="50%"></li><li>PGP-保密且认证<br><img src="/Cryptography/PGP3.png" width="60%"> </li></ul><h2 id="9-网络安全"><a href="#9-网络安全" class="headerlink" title="9. 网络安全"></a>9. 网络安全</h2><h3 id="9-1-网络安全概述-P396"><a href="#9-1-网络安全概述-P396" class="headerlink" title="9.1 网络安全概述 P396"></a>9.1 网络安全概述 P396</h3><ul><li>Web现在被广泛使用：政府、企业、个人，但互联网和Web容易受到攻击</li><li>TCP/IP 上的HTTP需要增加安全机制。</li><li>有各种各样的威胁：<ul><li>完整性</li><li>保密性</li><li>拒绝服务</li><li>认证 </li></ul></li><li>在哪里添加安全机制？<br><img src="/Cryptography/网络安全.png" width="40%"> </li></ul><h3 id="9-2-SSL-TLS"><a href="#9-2-SSL-TLS" class="headerlink" title="9.2 SSL / TLS"></a>9.2 SSL / TLS</h3><h5 id="SSL-TLS-P-397"><a href="#SSL-TLS-P-397" class="headerlink" title="SSL / TLS P 397"></a>SSL / TLS P 397</h5><ul><li>SSL：安全套接字层<ul><li>版本：1-3</li><li>最初由Netscape开发</li><li>使用TCP提供可靠和安全的端到端服务</li><li>SSL位于<strong>应用层和传输层之下</strong></li><li>SSL有两层四个协议</li></ul></li><li>TLS：传输层安全协议<ul><li>版本：1.1-1.2</li><li>TLS是SSL的继承者</li><li>成为互联网标准（RFC 2246）</li></ul></li></ul><h5 id="SSL-TLS提供服务："><a href="#SSL-TLS提供服务：" class="headerlink" title="SSL / TLS提供服务："></a>SSL / TLS提供服务：</h5><ul><li>Fragmentation(碎片?分段?)</li><li>压缩</li><li>消息完整性：MAC/HMA, 数字签名(公钥加密)</li><li>保密性：密钥交换(公钥加密)，对称密钥加密</li><li>Framing(取景? 框架？)</li></ul><h5 id="SSL-TLS-安全机制"><a href="#SSL-TLS-安全机制" class="headerlink" title="SSL/TLS 安全机制"></a>SSL/TLS 安全机制</h5><ul><li><p>密钥交换算法  - 保密性<br><img src="/Cryptography/Keyex.png" width="55%"> </p><ul><li>RSA<br><img src="/Cryptography/key1.png" width="55%"> </li><li>Anonymous(匿名的) Diffie-Hellman<br><img src="/Cryptography/key2.png" width="55%"> </li><li>Ephemeral(短暂的) Diffie-Hellman<br><img src="/Cryptography/key3.png" width="55%"></li></ul></li><li><p>对称加密/解密算法 - 保密性<br><img src="/Cryptography/ssl1.png" width="60%"></p></li><li>Hash函数 - 消息完整性<br><img src="/Cryptography/ssl2.png" width="55%"></li></ul><h5 id="SSL-TLS-结构"><a href="#SSL-TLS-结构" class="headerlink" title="SSL/TLS 结构"></a>SSL/TLS 结构</h5><ul><li>2层</li><li>4 个协议<br><img src="/Cryptography/sll3.png" width="40%"></li><li><strong>SSL / TLS 记录协议</strong>(Record Protocol)<ul><li>提供的安全服务：保密性，完整性</li><li>如何利用HMAC算法和会话密钥同意：握手 </li><li><img src="/Cryptography/sslrecord.png" width="55%"></li></ul></li><li><strong>SSL / TLS 握手协议</strong><ul><li>允许服务器和客户端：1. 相互认证 2. 协商加密和MAC算法 3. 协商要使用的加密密钥 </li><li>包括一系列分阶段的消息： 建立安全功能  -&gt; 服务器验证和密钥交换 -&gt; 客户端验证和密钥交换 -&gt; 结束<br><img src="/Cryptography/hs.png" width="50%"> <img src="/Cryptography/hs12.png" width="35%"><br><img src="/Cryptography/hs1.png" width="50%">  <img src="/Cryptography/hs13.png" width="40%">  <img src="/Cryptography/hs2.png" width="50%"><img src="/Cryptography/hs22.png" width="50%"><br><img src="/Cryptography/hs3.png" width="50%">  <img src="/Cryptography/hs32.png" width="50%"></li></ul></li></ul><h3 id="9-3-Wireshark-实验-TLS1-2"><a href="#9-3-Wireshark-实验-TLS1-2" class="headerlink" title="9.3 Wireshark 实验 - TLS1.2"></a>9.3 Wireshark 实验 - TLS1.2</h3><ul><li>POP3 and SMTP <strong>over TCP</strong><br><img src="/Cryptography/tcp1.png" width="30%"><img src="/Cryptography/tcp2.png" width="30%"></li><li>POP3 and SMTP <strong>over TLS</strong><br><img src="/Cryptography/pop31.png" width="30%"><img src="/Cryptography/pop32.png" width="30%"></li><li>Mail Agent(邮件代理): Foxmail 7.x</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发笔记</title>
      <link href="/web/"/>
      <url>/web/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Web开发技术概述"><a href="#1-Web开发技术概述" class="headerlink" title="1. Web开发技术概述"></a>1. Web开发技术概述</h2><h3 id="1-1-Web技术基础知识"><a href="#1-1-Web技术基础知识" class="headerlink" title="1.1 Web技术基础知识"></a>1.1 Web技术基础知识</h3><h5 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h5><ul><li>全称World Wide Web，缩写WWW，译为“万维网”,简称为Web</li><li>是一个可通过互联网来访问的、由许多互相链接的超文本组成的系统<a id="more"></a><blockquote><p>Web不等于Internet，它只是Internet中的一个部分，而且和浏览器有关。Web是Internet中的一个子集或者说Web是互联网提供信息的一种手段。</p></blockquote></li></ul><h5 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h5><ul><li>又称WWW服务器、网站服务器、站点服务器或HTTP服务器</li><li>为用户提供信息浏览和信息处理服务。将信息用超文本（Hypertext）组织，为用户在Internet上搜索和浏览信息提供服务。</li><li>Web服务器实际上就是一个软件系统。但它必须安装在一台高性能和高可靠性的计算机上，所以人们通常将那台计算机就叫做Web服务器。</li><li>常用的Web服务器有： ▪ Microsoft IIS     ▪ IBM  WebSphere ▪ Oracle  WebLogic   ▪ Apache 开源    ▪ Tomcat 开源   ▪ Jboss  开源  ▪ 金蝶公司 Apusic</li><li><code>一台计算机</code>可以安装<code>多个Web服务器</code>。</li></ul><h5 id="Web页面"><a href="#Web页面" class="headerlink" title="Web页面"></a>Web页面</h5><ul><li>Web在提供信息服务之前，所有信息都必须以文件方式事先存放在Web服务器所管辖磁盘中某个文件夹下，其中包含由超文本标记语言（HyperText Markup Language，HTML）组成的文本文件。</li><li>这些文本文件称为超链接文件，又称网页文件或Web页面文件（Web page）<ul><li>Web静态网页扩展名：HTM、HTML</li><li>Web动态网页扩展名：ASP、ASPX、JSP、PHP</li></ul></li><li><code>动态网页</code>/<code>Web服务器页面</code>需要Web服务器对它们进行<strong>重新处理</strong>后，动态生成新的HTML页面再传送给客户端供用户浏览。</li></ul><h5 id="URL-统一资源定位符"><a href="#URL-统一资源定位符" class="headerlink" title="URL(统一资源定位符)"></a>URL(统一资源定位符)</h5><ul><li>信息资源放在Web服务器之后，需要将它的地址告诉给用户，以便让用户来访问，这个地址就叫统一资源定位符（Uniform Resource Locators，URL），俗称为网址。</li><li>URL字串 = 协议名称 + 主机名 + 文件名(包含路径)</li><li>URL地址中的主机名也可直接输入对应的IP地址。手工输入的URL地址只能为绝对地址，相对地址用于网页文档内部的链接地址。</li><li>为什么有时URL地址中没有文件名还能照常显示页面内容呢？这是因为在Web服务器的配置中，可以<strong>事先设定一个或多个默认文件名</strong>，浏览器会<strong>自动查找这些默认的文件名</strong>。<ul><li><code>相对地址</code>：href=“../Shweather.htm” 也可写成   href=“/web/Shweather.htm” </li><li><code>绝对地址</code>：<a href="http://www.yahoo.com.cn/gif/stone.jpg" target="_blank" rel="noopener">http://www.yahoo.com.cn/gif/stone.jpg</a></li></ul></li></ul><blockquote><ul><li>统一资源标识符URI是一个用于标识某一互联网资源名称的字符串。 Web上可用的每种资源 -HTML文档、图像、视频片段、程序等都可由URI来定位。  </li><li>URL网址只是属于URI的一种，用来定位所需访问的网页地址。</li></ul></blockquote><h5 id="浏览器的工作原理及种类"><a href="#浏览器的工作原理及种类" class="headerlink" title="浏览器的工作原理及种类"></a>浏览器的工作原理及种类</h5><ul><li>浏览器就是Web客户端程序，要浏览Web页面必须在本地计算机上安装浏览器软件，用于与Web服务器建立连接，并与之进行通信。</li><li><p>在网络带宽相同的情况下同一台计算机使用不同的浏览器访问同一个网站，<strong>访问速度会不一样</strong></p><ul><li>浏览器是个软件，有软件复杂度的问题，也存在软件运行效率的问题。</li><li>浏览器安全级别设置也会影响访问速度，安全级别越高，访问速度越慢。</li></ul><p><img src="/web/浏览器工作原理.png" width="65%" height="80%"></p></li><li><p>浏览器Cookie：HTTP是一种<strong>无记忆的协议</strong>，有时需要浏览器能够记住一些信息，因此引入Cookie概念。浏览器允许用户通过Cookie读写一些信息，这在一定程度上实现了<strong>浏览器的记忆功能</strong>。</p></li><li>HTTPS即HTTP下加入套接字SSL层，对传输的网页进行加密处理，是以安全为目标的HTTP通道。</li></ul><h5 id="C-S模式与B-S模式"><a href="#C-S模式与B-S模式" class="headerlink" title="C/S模式与B/S模式"></a>C/S模式与B/S模式</h5><p><strong>C/S模式</strong></p><ul><li>几乎所有的应用逻辑都在客户端进行和表达，客户端完成与用户的交互任务。  </li><li>服务器端负责后台数据的查询和管理、大规模的计算等服务。</li><li>通常客户端的任务比较繁重，称作<strong>“肥”客户端</strong>，而服务器端的任务相对较轻，称作<strong>“瘦”服务器</strong>。<br><img src="/web/两层架构模型.png" width="50%" height="80%"></li><li><code>优点</code>：<ul><li>异种平台集成。</li><li>分布式管理。</li><li>能充分发挥客户端PC的处理能力。</li><li>运行安全、稳定、速度快，且在适当情况下可脱机操作。</li></ul></li><li><code>缺点</code>：<ul><li>必须在客户端安装大量的应用程序（客户端软件）。</li><li>需要在客户端安装支持系统运行的动态链接库等。</li><li>存在移植困难、用户界面风格不统一、操作复杂、不利于推广使用、维护和升级过程繁琐、信息内容和形式单一和不易应用新技术等不足。</li></ul></li></ul><p><strong>B/S模式</strong></p><ul><li>基于Web的协同计算模式，是一种三层架构的瘦客户机/肥服务器的计算模式。</li><li>用户工作界面是通过Web浏览器来实现，少部分事务逻辑在前端（浏览器）实现，主要事务逻辑在服务器端实现，形成所谓三层结构。</li><li>简化了客户端电脑载荷，减轻了系统维护与升级的成本和工作量，降低了用户的总体成本）。<br><img src="/web/三层架构.png" width="50%" height="80%"></li><li><code>优点</code>：<ul><li>具有良好的开放性。</li><li>无需下载安装，利用浏览器单一的访问点，用户可在任何时间和地点使用系统。</li><li>系统维护方便，有效地降低了整个系统的运行和维护成本。</li></ul></li><li><code>缺点</code>：<ul><li>运行速度没有C/S模式快，且受网络带宽的影响较大。</li><li>会出现更多安全性问题。</li></ul></li><li>B/S 模式 / Web 应用系统：采用B/S模式构建的应用系统<ul><li>基于Intranet的应用系统</li><li>基于Internet的应用系统</li><li>网站系统</li></ul></li></ul><blockquote><p><strong>需考虑</strong>：浏览器的兼容性；在网络带宽在有限和不稳定的情况下，仍然可被快速访问；互联网上使用的安全性、稳定性、可靠性、有效性等；浏览器的兼容性。</p></blockquote><h5 id="Web的访问原理"><a href="#Web的访问原理" class="headerlink" title="Web的访问原理"></a>Web的访问原理</h5><ul><li>静态网页：<ul><li>只有HTML标记和客户端脚本代码，这种网页以后缀.htm或.html的文件存放。</li><li>也可<strong>实现各种动态的效果</strong>，如.GIF动画、FLASH、滚动字母等，这些动态效果只是视觉上的。</li><li>静态网页<strong>访问速度快</strong>，容易被搜索引擎收录。</li></ul></li><li>动态网页：<ul><li>不仅含有HTML标记和客户端脚本代码，而且含有<strong>需Web服务器进行处理的代码</strong>（文件扩展名一般为ASPX、JSP、PHP等）。</li><li>用户登录、发布新闻、发布公司产品、交流互动、博客、网上调查等都需要动态网页来实现。<br><img src="/web/Web访问原理.png" width="90%" height="90%"> </li></ul></li></ul><h5 id="Web开发平台的组成"><a href="#Web开发平台的组成" class="headerlink" title="Web开发平台的组成"></a>Web开发平台的组成</h5><ul><li>Microsoft <strong>.NET开发平台</strong>：使用多种.NET兼容语言的任意组合来创建一个.NET应    用程序，如C#、VB、J#等</li><li>Oracle <strong>Java EE开发平台</strong>：能开发和部署可移植、健壮、可伸缩且安全的服务器端 Java应用程序</li><li><strong>LAMP</strong>开发平台（Linux+Apache+MySQL+PHP）</li></ul><h5 id="常用的Web开发工具"><a href="#常用的Web开发工具" class="headerlink" title="常用的Web开发工具"></a>常用的Web开发工具</h5><ul><li>常用网页制作工具<ul><li>Dreamweaver是最流行的开发工具之一。</li><li>Fireworks以处理网页图片为特长，并可轻松创作GIF动画。</li><li>FrontPage的主要功能是设计、制作、管理网页或站点。新版本为Expression Web 4.0。</li></ul></li><li>常用Web开发工具<ul><li>VS 用于生成 Web 应用程序、Web服务、桌面应用和移动应用程序等。可用多种编程语言VB、C++、C# 和J# 开发,通过.NET Framework简化Web应用程序和Web服务的开发过程。 </li><li>IBM Eclipse是一种可扩展的开放源代码的IDE（集成开发环境），使用灵活，易于扩展，大有成为Java第一开发工具之势。</li></ul></li></ul><h3 id="1-2-Web基本技术介绍"><a href="#1-2-Web基本技术介绍" class="headerlink" title="1.2 Web基本技术介绍"></a>1.2 Web基本技术介绍</h3><ul><li>Web前端(浏览器端)开发技术：HTML、CSS、DHTML/JavaScript、ActiveX、XML、XHTML</li><li>Web后端(服务器端)开发技术：CGI、PHP、JSP、ASP/ASP.NET、ADO/ADO.NET、Web Service、WCF</li></ul><h5 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h5><ul><li>用HTML来定义网页的结构，用CSS来控制网页显示的格式。</li><li>静态页面的缺点：<ul><li>无法支持后台数据库</li><li>无法有效地对站点信息进行及时的更新</li><li>无法实现动态显示效果</li></ul></li><li>采用 </li></ul><h5 id="DHTML"><a href="#DHTML" class="headerlink" title="DHTML"></a>DHTML</h5><ul><li>DHTML即动态的HTML语言(Dynamic HTML)。除了具有HTML语言的一切性质外，还可在下载网页后仍能实时变换页面元素效果，使人们在浏览网页时看到网页动态效果。</li><li>并不是一门新的语言，它是以下技术、标准或规范的一种集成：<ul><li>HTML</li><li>CSS(层叠样式单)</li><li>CSSL(客户端脚本语言)：JavaScript、Vbscript语言</li><li>HTML DOM(HTML文档对象模型)</li></ul></li><li>DHTML可实现功能：<ul><li>动态交互功能，使网页产生动态效果。</li><li>让用户站点易于维护。</li><li>可减轻服务器负荷，更大发挥网络能力。</li></ul></li></ul><h5 id="Java-Applet"><a href="#Java-Applet" class="headerlink" title="Java Applet"></a>Java Applet</h5><ul><li>Java Applet是指用Java编写的能够在Web页中运行的应用程序。它的可执行代码为class文件。</li><li>具有安全、功能强和跨平台等特性。</li><li>可提供动画、音频和音乐等多媒体服务，并且能产生原本只有CGI(公共网关接口)才能实现的功能。</li></ul><h5 id="JavaScript与VBScript"><a href="#JavaScript与VBScript" class="headerlink" title="JavaScript与VBScript"></a>JavaScript与VBScript</h5><ul><li>JavaScript是<strong>目前使用最广泛的脚本语言</strong>，它是由Netscape公司开发并随Navigator浏览器一起发布的，是一种介于Java与HTML之间、<strong>基于对象</strong>的事件驱动的编程语言。使用JavaScript，不需要Java编译器，而是<strong>直接在Web浏览器中解释执行</strong>。</li><li>VBScript脚本语言是Visual Basic Script（VBS）的简称，它是Microsoft Visual Basic的一个子集，可看作是VB语言的简化版。VBS和Javascript一样都用于创建客户方的脚本程序，并处理页面上的事件及生成动态内容。</li></ul><h5 id="ActiveX"><a href="#ActiveX" class="headerlink" title="ActiveX"></a>ActiveX</h5><ul><li>微软ActiveX控件技术是一种<strong>可重用的</strong>软件技术。</li><li>将一个或一组功能封装起来，以对象方式供开发者使用。</li><li>有大量商用或免费ActiveX控件供开发人员使用，也可用VC、VB等来开发一个ActiveX控件。<strong>ActiveX控件可在页面中直接使用</strong>。</li><li>当浏览的网页遇到ActiveX控件时，会检查用户本地系统的注册表，查看其是否已安装在本地机上。若已安装，浏览器显示该网页并激活控件。若未在用户本地安装，浏览器将查找并安装到本地。下载控件时，浏览器会缺省地显示一个消息框，通知用户将要开始下载，用户可以选择终止下载或继续下载。</li></ul><h5 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h5><ul><li><strong>HTML的不足</strong>：<ul><li>HTML不能适应信息检索和存档要求；</li><li>无法描述矢量图形、科技符号和一些其他特殊显示效果；</li><li>文档结构混乱而缺乏条理，导致浏览器的设计越来越复杂。</li></ul></li><li>XML弥补了HTML的不足：<ul><li>将网络上传输的文档<strong>规范化</strong>，并赋予标记一定的含义，</li><li>与此同时，还要保留其简捷、适于网上传输和浏览的优点。</li><li>XML是标记语言，可根据需要自定义新的标记。XML已在文件配置、数据存储、异构数据交换等众多方面得到广泛应用。</li></ul></li></ul><h5 id="XHTML"><a href="#XHTML" class="headerlink" title="XHTML"></a>XHTML</h5><ul><li>基于XML的标记语言。</li><li>是一个过渡技术，结合了部分XML的强大功能以及大多数HTML的简单特性。<ul><li><code>&lt;div&gt;</code>标记的配对标记是<code>&lt;/div&gt;</code>。在HTML中画横线标记为<code>&lt;hr&gt;</code>，而在XHTML中变成<code>&lt;hr /&gt;</code>。</li><li>在HTML中不配对的标记，在XHTML中必须用“/”结束。标记的属性，例如按钮标记中的type属性，在XHTML中必须放在引号中，而在HTML中则可有可无。</li></ul></li></ul><h5 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h5><ul><li>CGI是公共网关接口（Common Gateway Interface）的缩写，是用于连接WEB页面和应用程序的接口。</li><li>可用VB、VC、Delphi、 Perl语言开发Web Server端运行的可执行程序，由<strong>网页的一个超链接激活</strong>进行调用，并对该程序的返回结果进行处理后，显示在页面上。 </li><li>CGI<strong>编程困难且效率低</strong>，每一次修改程序代码后还须重新编译。</li><li>每一个网上客户在访问CGI程序时，Web服务器都要<strong>单独建立应用进程</strong>，加重了服务器的负荷。</li><li>CGI多用在安全级别要求高的Web应用中。</li></ul><h5 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h5><ul><li>PHP(超文本预处理器)：用开源和<strong>跨平台</strong>的PHP技术可创建动态网站，<ul><li>它包括完整的编程语言、支持因特网的各种协议；</li><li>提供与MYSQL、SQL SERVER、ORACLE等多种数据库的访问能力、支持ODBC数据库连接方式；</li><li>在Unix、GUN/Linux和微软Windows平台上均可运行。PHP的优点是安装方便、学习过程简单、数据库连接方便、兼容性强、扩展性强。</li></ul></li><li>PHP程序需在Apache、Tomcat等Web服务器上运行，Linux + PHP + MySQL + Tomcat + Apache + Dreamweaver是开发中小型企业网站系统的黄金组合，网站的<strong>运行效率佳，安全性高，可靠性和稳定性也非常好</strong>，受到广大开发者的青睐。</li></ul><h5 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h5><ul><li>JSP可用于建立先进、安全和跨平台的动态网页。</li><li>JSP技术是以Java语言作为脚本语言的，使用JSP标识或者Java Servlet小脚本来生成页面上的动态内容。JSP可通过JDBC技术连接数据库。</li><li>JSP代码被编译成Servlet并<strong>由Java虚拟机执行</strong>，这种编译操作仅在对JSP页面的第一次请求时发生。跨平台应用是JSP的最大特色。</li><li>作为Java平台的一部分，JSP拥有Java编程语言<strong>“一次编写，各处运行”</strong>的特点。不少大型企业使用Java EE平台提供的JSP技术构建Web应用系统。</li></ul><h5 id="ASP-ASP-NET"><a href="#ASP-ASP-NET" class="headerlink" title="ASP/ASP.NET"></a>ASP/ASP.NET</h5><ul><li>微软1996年11月推出ASP技术，可用VBScript或JavaScript脚本语言，结合HTML代码，快速完成服务器端动态网页的开发。Web服务器后台解释执行ASP动态网页，<strong>运行效率不高</strong>。</li><li>2002年微软将ASP和.NET技术结合，推出了全新的ASP.NET技术，提供<strong>基于组件、事件驱动的可编程Web窗体</strong>，大大简化了编程，还可以用于建立Web服务。</li><li>ASP.NET与ASP有着本质的不同：<ul><li>ASP.NET<strong>完全基于模块与组件</strong>；</li><li>具有更好的可扩展性与可定制性，数据处理方面引入了许多新技术，技术上远远超越了ASP；</li><li>ASP.NET与Windows Server 家族的完美组合为各种的Web应用提供了一个更为稳定、高效、安全的运行环境。</li></ul></li></ul><h5 id="ADO-ADO-NET"><a href="#ADO-ADO-NET" class="headerlink" title="ADO/ADO.NET"></a>ADO/ADO.NET</h5><ul><li>ADO技术使得客户端应用程序可通过ODBC、OLEDB等方式来访问和操作DB Server，易于使用、速度快、内存支出少、占用磁盘空间少。<ul><li>但它是<strong>面向连接的数据访问方式</strong>，即在操作数据库时，必须与数据库服务器<strong>进行联机操作</strong>。当并发用户操作时，会影响数据库性能。</li></ul></li><li>ADO.NET技术是.NET平台上的全新数据访问方式，数据源的数据可作为XML文档进行传输和存储。在访问数据的时候ADO.NET会利用XML制作数据的一份副本，<ul><li>用户<strong>可断开与数据库服务器的连接直接在副本上进行操作</strong>，最后根据需要再将副本中的数据更新到数据库服务器,以大大<strong>提高数据访问性能</strong>。</li></ul></li></ul><h5 id="Web-Service"><a href="#Web-Service" class="headerlink" title="Web Service"></a>Web Service</h5><ul><li>Web Service可以是一个小粒度的组件完成一个简单功能，也可是一个大粒度的应用程序。不管是作为组件还是应用程序，它都会向外界暴露一个<strong>能够通过Web进行调用的API</strong>，这就是说，能够用编程的方法通过Web访问来使用它。</li><li>用户在调用这些Web服务时，只需要提供输入数据就可得到返回的结果，然后对返回的结果进行加工即可。</li><li>在Web应用程序中<strong>无需下载安装Web服务可直接调用</strong>Web服务提供的方法来实现某个功能，而通过ActiveX控件来实现某个功能时，必须将它下载到客户端，在客户端安装后才可使用。所以Web服务可实现分布式应用。</li></ul><h5 id="WCF-Windows-Communication-Foundation，Windows通讯接口"><a href="#WCF-Windows-Communication-Foundation，Windows通讯接口" class="headerlink" title="WCF(Windows Communication Foundation，Windows通讯接口)"></a>WCF(Windows Communication Foundation，Windows通讯接口)</h5><ul><li>WCF是由微软发展的一组数据通信的应用程序开发接口，它是.NET框架的一部分，由.NET Framework 3.0开始引入，与Windows Presentation Foundation及Windows Workflow Foundation并列为新一代Windows操作系统的三大重要应用程序开发类库。WCF集合了几乎由.NET Framework所提供的所有通讯方法，可利用WCF来创建<strong>面向服务的应用程序</strong>。</li><li><strong>优点</strong>：统一性、互操作性、安全和可信赖、兼容性。</li></ul><h3 id="1-3-Web发展历程"><a href="#1-3-Web发展历程" class="headerlink" title="1.3 Web发展历程"></a>1.3 Web发展历程</h3><h5 id="Web-1-0-获取信息"><a href="#Web-1-0-获取信息" class="headerlink" title="Web 1.0 获取信息"></a>Web 1.0 获取信息</h5><ul><li>大都采用技术创新主导的模式。</li><li>盈利大都基于一个共同点：巨大的点击流量。</li><li>出现了向综合门户合流现象。</li><li>形成了主营与兼营结合的明晰产业结构。</li></ul><h5 id="Web-2-0-用户的交互作用"><a href="#Web-2-0-用户的交互作用" class="headerlink" title="Web 2.0 用户的交互作用"></a>Web 2.0 用户的交互作用</h5><ul><li><code>Ajax</code>（Asynchronous JavaScript and XML，异步JavaScript和XML）最早由Jesse James Garrett提出。区别于传统的Web应用，Ajax应用的主要目的就是提高用户体验：<ul><li>不刷新整个页面，在页面内与服务器通信；</li><li>使用<strong>异步方式</strong>与服务器通信，不需要打断用户的操作，具有更加迅速的的响应能力；</li><li>应用系统不需要由大量页面组成。大部分交互在页面内完成，不需要切换整个页面。</li></ul></li><li>由此可见，Ajax使得Web应用更加动态，带来了更高的智能，并且可以提供表现能力丰富的Ajax UI组件。这样一类新型的Web应用叫做<strong>RIA(Rich Internet Application)应用</strong>。</li><li><code>Blog</code>是一个易于使用的网站，您可以在其中迅速发布想法、与他人交流以及从事其它活动，所有这一切都是免费的。</li><li><code>网摘/网页书签/社会书签</code>：网摘是一种服务，它提供的是一种<strong>收藏、分类、排序、分享互联网信息资源</strong>的方式。</li><li><code>Wiki</code>：是一种多人协作的写作工具。Wiki站点可以有多人，甚至任何访问者维护，每个人都可以发表自己的意见，或者对共同的主题进行扩展或者探讨。<ul><li>Wiki指一种超文本系统。这种超文本系统支持<strong>面向社群的协作式写作</strong>，同时也包括一组支持这种写作的辅助工具。</li></ul></li><li><code>RSS</code>：站点用来和其它站点之间共享内容的一种简易方式（也叫聚合内容，Really Simple Syndication）的技术。<ul><li>RSS搭建了一个<strong>信息迅速传播的技术平台</strong>，使得每个人都成为潜在的信息提供者。</li><li>发布一个RSS文件后，这个RSS Feed中包含的信息就能直接被其它站点调用，而且由于这些数据都是标准的XML格式，所以也能在其它的终端和服务中使用。</li></ul></li></ul><h5 id="Web-3-0"><a href="#Web-3-0" class="headerlink" title="Web 3.0"></a>Web 3.0</h5><ul><li>全新版本的Web3.0纯属理论阶段，实际上目前还无法知道它会怎样工作。</li></ul><p><img src="/web/web发展历程.png" width="50%" height="80%"></p><h2 id="2-Web开发环境的建立"><a href="#2-Web开发环境的建立" class="headerlink" title="2. Web开发环境的建立"></a>2. Web开发环境的建立</h2><h3 id="2-1-如何配置IIS-Web服务器"><a href="#2-1-如何配置IIS-Web服务器" class="headerlink" title="2.1 如何配置IIS Web服务器"></a>2.1 如何配置IIS Web服务器</h3><h5 id="Web站点的配置"><a href="#Web站点的配置" class="headerlink" title="Web站点的配置"></a>Web站点的配置</h5><ul><li>运行在Windows Server操作系统上IIS Web服务器可<strong>创建和管理多个网站</strong>。</li><li>而Windows桌面版操作系统的IIS服务器<strong>一般只支持一个网站</strong>。IIS有IIS 5.1、IIS 6.0和IIS 7.等版本，版本越高，配置的复杂度也越高。</li></ul><h5 id="主目录和虚拟目录的建立"><a href="#主目录和虚拟目录的建立" class="headerlink" title="主目录和虚拟目录的建立"></a>主目录和虚拟目录的建立</h5><ul><li>每个网站的内容都存放在一个物理路径中，这个<code>物理路径</code>也即<code>主目录</code>。</li><li>一个网站所有文件不一定非要将它们全部放在一个目录下，可以<strong>分散存放在不同的硬盘分区</strong>中。</li><li>要从主目录以外的其他目录中发布网站，就必须创建<code>虚拟目录</code>。<ul><li>例如将photo放到F盘中，将student放在E盘中。Web服务器通过<strong>创建虚拟目录</strong>来管理分散存放的网站目录。</li></ul></li><li>虚拟目录的别名可以随意取定，一般就可按照实际文件夹名来取。使用别名的好处：<ul><li>别名可以比实际文件夹路径名短，<strong>便于用户输入</strong>。</li><li><strong>使用别名比较安全</strong>，因为虚拟目录的别名和实际路径之间是映射关系，用户很难知道文件所存放的实际位置。</li><li>虚拟目录对应的<strong>实际路径可以随意搬动</strong>，但用户访问虚拟目录的URL不变。</li></ul></li></ul><h3 id="2-2-VS-2013的使用"><a href="#2-2-VS-2013的使用" class="headerlink" title="2.2 VS 2013的使用"></a>2.2 VS 2013的使用</h3><h5 id="VS-2013中几个重要概念"><a href="#VS-2013中几个重要概念" class="headerlink" title="VS 2013中几个重要概念"></a>VS 2013中几个重要概念</h5><ul><li>微软.NET Framework：用于构建、部署和运行Web服务及应用程序的平台。<ul><li>提供一致的面向对象的编程环境，无论对象代码在哪儿执行。</li><li>提供软件部署和版本控制冲突最小、代码执行安全和运行性能高的代码执行环境。</li><li>减轻开发人员工具使用的复杂性。</li><li>按照工业标准进行，确保.NET Framework 代码可与任何其他代码集成。</li></ul></li><li>三个组成部分：<ul><li><code>CLR（Common Language Runtime，公共语言运行库）</code>：负责管理内存、线程执行、代码执行、代码安全验证、编译和其它系统服务。</li><li><code>托管代码</code>:需要以CLR环境来支撑运行的程序代码；非托管代码:用VB、VC++等工具开发的程序。</li><li><code>.NET Framework 类库</code>：提供很多现成的方法供开发人员编程使用，如复制、移动、删除一个文件、杀死一个进程、连接数据库等</li><li><code>ASP.NET</code>：使用托管代码来开发网站</li></ul></li></ul><h5 id="开发Web应用系统的一般过程"><a href="#开发Web应用系统的一般过程" class="headerlink" title="开发Web应用系统的一般过程"></a>开发Web应用系统的一般过程</h5><ul><li>个人开发</li><li>团队开发：涉及到源代码共享和源代码版本管理问题。</li></ul><h5 id="开发模式对比"><a href="#开发模式对比" class="headerlink" title="开发模式对比"></a>开发模式对比</h5><ul><li>开发模式：<ul><li>传统开发模式</li><li>MVC开发模式</li></ul></li><li>ASP.NET MVC的优势：<ul><li>将页面与业务逻辑进行分离</li><li>限制了ViewState的使用</li><li>最终生成的HTML清洁化，不会生成许多垃圾代码</li><li>客户端和服务器端的处理呈现速度更快</li><li>没有PostBack和页面回传事件机制，表单的提交方式完全采用Web的原生方式，传输的数据内容也更加合理。</li></ul></li><li>ASP.NET MVC的劣势：<ul><li>对大量且复杂的数据处理变得非常困难，没有现成的数据控件可以使用</li><li>不使用视图状态维护状态信息。</li></ul></li></ul><h3 id="2-3-源代码的版本控制"><a href="#2-3-源代码的版本控制" class="headerlink" title="2.3 源代码的版本控制"></a>2.3 源代码的版本控制</h3><ul><li>源代码的版本控制简称为源码控制，它在<strong>多人协作开发环境</strong>中是非常重要的，它包含了对应用程序中每个源文件修改的历史记录，可对多个开发者的行为进行协调。</li><li>在需要比较两种版本的文件或找回早期版本的文件时，源代码的控制是非常有用的。</li><li>常用的源码控制软件有微软的Visual SourceSafe 2005（VSS 2005）、Visual Studio Team Foundation（VSTF）、Dick Grune开发的CVS（Concurrent Versions System）开源软件和CollabNet开发的Subversion（SVN）开源软件等。前两者主要结合微软的开发工具使用，后两者通常在<code>UNIX/Linux</code>或<code>Java开发工具中</code>使用。</li></ul><h3 id="2-4-Web站点的发布"><a href="#2-4-Web站点的发布" class="headerlink" title="2.4 Web站点的发布"></a>2.4 Web站点的发布</h3><ul><li>当一个Web应用系统开发完成后，需要部署到服务器上，让最终用户通过浏览器进行操作，因此必须先将该Web应用系统进行发布，也称Web应用系统的部署。发布Web应用系统主要有：<ul><li>手工发布；</li><li>直接连接到远程服务器上，通过HTTP或者FTP协议等进行发布；</li><li>打包发布。</li></ul></li></ul><h2 id="3-HTML与CSS"><a href="#3-HTML与CSS" class="headerlink" title="3. HTML与CSS"></a>3. HTML与CSS</h2><h3 id="3-1-HTML基础"><a href="#3-1-HTML基础" class="headerlink" title="3.1 HTML基础"></a>3.1 HTML基础</h3><h5 id="HTML文件基本结构"><a href="#HTML文件基本结构" class="headerlink" title="HTML文件基本结构"></a>HTML文件基本结构</h5><ul><li>文档类型：&lt;!DOCTYPE HTML&gt;</li><li>标识这是一个HTML文档：<html>  …… </html>    </li><li>网页头部标识：<head>  …… </head>   </li><li>网页内容：<body> ……  </body></li><li>浏览器窗口标题：<title> 窗口标题</title><ul><li>标题是头元素的一部分</li><li>标题会出现在浏览器窗口标题栏上</li></ul></li><li>注释：<!-- ……  --></li><li>标记的属性：用来描述标记的外观、行为方式及内在表现<ul><li><code>&lt;a id=&quot;mylink&quot; href=&quot;aa.html title = &quot;it&#39;s me&quot;&gt;</code></li><li>id为超链接定义一个标识，因为HTML页面文档中可能有很多个超链接，通过ID可以确定是哪个超链接。title属性实现了将鼠标指针放在该超链接标记上时，会显示一个动态文本提示框“It’s me”。id、title属性是为大多数标记所共有的属性。每个标记有很多属性，但有许多是共有的属性</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>浏览器窗口标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Hello！</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="文本和格式标记"><a href="#文本和格式标记" class="headerlink" title="文本和格式标记"></a>文本和格式标记</h5><ul><li>换行标记： <br>   强制换行</li><li>段落标记：<code>&lt;p align=“center”&gt;…&lt;/p&gt;</code>  align的值可为“ left ”(左对齐)、“ center ”(居中)和“ right ”(右对齐)</li><li>文本缩进标记：<code>&lt;blockquote&gt;…&lt;/blockquote&gt;</code>在浏览器中按两边缩进的方式显示文本</li><li>文本居中标记：<center>…</center> 将文本居中显示  </li><li>特殊符号： 空格 <code>&amp;nbsp;</code>  版权符号 <code>&amp;copy;</code>   注册商标 <code>&amp;reg;</code>   小于号 <code>&amp;lt;</code>  大于号 <code>&amp;gt;</code></li><li>列表标记   <code>&lt;dl&gt;…&lt;/dl&gt;</code>、<code>&lt;dt&gt;…&lt;/dt&gt;</code>和<code>&lt;dd&gt;…&lt;/dd&gt;</code></li><li>列表标记  <code>&lt;ol&gt;…&lt;/ol&gt;</code>、<code>&lt;ul&gt;…&lt;/ul&gt;</code>和<code>&lt;li&gt;…&lt;/li&gt;</code></li><li>文本块标记   <code>&lt;div&gt;…&lt;/div&gt;</code>  <code>&lt;span&gt;…&lt;/span&gt;</code>  <code>&lt;p&gt;…&lt;/p&gt;</code><ul><li><code>&lt;span&gt;`</code><div><code></code><p>`均可用作放置一个文本块。</p></div></li><li>div和span标记除可用作文本容器外，还可用作其他HTML标记的容器。网页上的漂浮物就是用Div实现的。</li><li><code>&lt;address&gt;…&lt;/address&gt;</code>标记与<code>&lt;div&gt;</code>标记作用相似，就是显示一块文本，但里面的<strong>字体只能是斜体</strong>，主要用来在网页上放置<strong>署名信息</strong>。</li></ul></li></ul><h5 id="超链接标记和表格标记"><a href="#超链接标记和表格标记" class="headerlink" title="超链接标记和表格标记"></a>超链接标记和表格标记</h5><ul><li>超链接标记  <code>&lt;a&gt;…&lt;/a&gt;</code>  <ul><li>超链接标记是HTML标记最重要的标记，用属性href（hot reference）来指定锚点的链接信息，可为URL网址或文本、声音、图像等的URI地址。例如：<br><code>&lt;a href=&quot;http://www.cqu.edu.cn&quot;&gt; 重庆大学 &lt;/a&gt;</code></li></ul></li><li>表格标记：表格可简洁和一目了然地表现内容。表格标记由<code>&lt;table&gt;</code>和<code>&lt;/table&gt;</code>组成。<ul><li>表格的行标记<code>&lt;tr&gt;</code>是Table Row的缩写</li><li>表格的列标记<code>&lt;td&gt;</code>是Table Data的缩写</li></ul></li></ul><h5 id="图像、视频与动画、声音处理标记"><a href="#图像、视频与动画、声音处理标记" class="headerlink" title="图像、视频与动画、声音处理标记"></a>图像、视频与动画、声音处理标记</h5><ul><li>图像标记：<br><code>&lt;img src=“夜景.jpg” height=“100” width=“10%”  border=“10” &gt;</code></li><li>视频和动画标记：<ul><li><code>dynsrc</code>表示视频与动画来源文件所在的URL地址，其它标记内容同图像显示标记。</li><li>start = fileopen表示页面一被装入便播放；</li><li>start = onmouseover表示当鼠标从该区域滑过时才播放。</li><li>loop表示视频或动画播放的重复次数，为infinite或为负数时表示无限循环。</li></ul></li></ul><h5 id="控件标记"><a href="#控件标记" class="headerlink" title="控件标记"></a>控件标记</h5><ul><li>表单<code>form</code>标记：从用户收集信息，然后将这些信息提交给服务器进行处理。表单中可包含允许用户<strong>进行交互的各种控件</strong>，例如: 文本框、列表框、复选框和单选按钮等。用户在表单中输入或选择数据之后将其提交，<strong>该数据就会送交给表单处理程序进行处理</strong>。<ul><li>用户界面，提供用户输入数据的元件；</li><li>处理程序，可以是客户端程序，在浏览器中执行，也可以是服务器处理程序，处理用户提交的数据，返回结果。</li></ul></li></ul><h5 id="帧标记和iframe标记"><a href="#帧标记和iframe标记" class="headerlink" title="帧标记和iframe标记"></a>帧标记和iframe标记</h5><ul><li>帧标记/框架标记 Frame<ul><li>将浏览器显示部分分成多个区域，每个区域可显示各不相同的网页。</li><li>点击某个区域中的网页超链接，可在其他区域显示超链接对应的网页。</li></ul></li><li>Iframe标记/浮动帧标记 <ul><li>当前页面中设置<strong>多个浮动帧标记</strong>，每一个浮动帧标记都<strong>加载各自的网页</strong>，可实现浏览器网页加载的<strong>并发处理</strong>。</li></ul></li></ul><h5 id="HTML5介绍"><a href="#HTML5介绍" class="headerlink" title="HTML5介绍"></a>HTML5介绍</h5><ul><li>新一代超文本标记语言<strong>HTML5仍处于不断发展</strong>中。之前的HTML版本在功能上有限，例如无绘图处理功能等。</li><li>HTML5添加了许多新语法特性，包括用于媒介回放的 <code>video</code>和 <code>audio</code> 元素、用于绘画的 canvas 元素、其它新的元素包括<code>&lt;section&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;header&gt;</code>和<code>&lt;nav&gt;</code>，主要是为了丰富文档的<strong>数据内容</strong>。</li><li>一些标记添加了新属性，也有一些属性和元素<strong>被移除掉</strong>了，还有一些元素如<code>&lt;a&gt;</code>，<code>&lt;cite&gt;</code>和<code>&lt;menu&gt;</code>被修改，重新定义或标准化。同时<strong>应用程序接口API和文档对象模型DOM已成为HTML5中的基础部分</strong>。</li><li>HTML5特性：<ul><li><strong>语义特性</strong>：HTML5可使网页有更好的结构，标签更为丰富。</li><li><strong>本地存储特性</strong>：本地存储功能使HTML5网页运行更快，占用带宽更少。</li><li><strong>设备兼容特性</strong>：可获取地理位置；使外部应用与浏览器内部数据直接连接，例如视频影音可直接与麦克风及摄像头相联。</li><li><strong>连接特性</strong>：Server-Sent Event和WebSockets可实现服务器将数据“推送”到客户端。</li><li><strong>网页多媒体特性</strong>：提供Audio、Video等多媒体功能。</li><li><strong>三维、图像及特效特性</strong>：提供SVG、Canvas、WebGL及CSS 3的3D功能，用户会惊叹于在浏览器中所呈现的惊人视觉效果。</li><li><strong>性能与集成特性</strong>：通过XMLHttpRequest2等技术，帮助Web应用和网站在多样化的环境中更快速地工作。</li><li><strong>CSS 3 特性</strong>：在不牺牲性能和语义结构的前提下，CSS 3提供了更多的风格和更强的效果。</li></ul></li></ul><h3 id="3-2-CSS-层叠样式表"><a href="#3-2-CSS-层叠样式表" class="headerlink" title="3.2 CSS 层叠样式表"></a>3.2 CSS 层叠样式表</h3><ul><li>CSS是为弥补HTML在显示属性设定上的不足而制定的一套扩展样式标准。到98年，W3C在原有草案的基础上进行了扩展，建立了CSS2规范。</li><li>HTML注重的是内容本身，而不是显示方式。CSS注重解决网页字体大小、颜色、边框等格式问题，以提供给用户尽量美观、易读的网页。</li></ul><h5 id="CSS的特点"><a href="#CSS的特点" class="headerlink" title="CSS的特点"></a>CSS的特点</h5><ul><li>简化了网页的格式代码，外链样式还可以被浏览器保存在缓存里，加快了网页下载速度。</li><li>只要修改保存着网页格式的CSS样式表文件就可以改变整个站点的风格特色，保证了网站显示风格的一致。避免了一个个网页的修改，大大减少了重复工作量。</li></ul><h5 id="CSS的定义"><a href="#CSS的定义" class="headerlink" title="CSS的定义"></a>CSS的定义</h5><ul><li>样式格式为：<ul><li>选择符{ 属性1：值1；属性2：值2；……}</li><li>简写为：选择符{属性值对 }<br><code>div{font-family: 宋体; font-size: 12pt;}</code></li></ul></li></ul><h5 id="CSS中的选择符"><a href="#CSS中的选择符" class="headerlink" title="CSS中的选择符"></a>CSS中的选择符</h5><ul><li>HTML标记类选择符：直接用HTML标记或HTML元素名称作为CSS选择符</li><li>具有上下文关系的HTML标记类选择符<ul><li>包含在div内有一个input，div和input之间就有上下文关系；div内有span，span内有B，它们之间也构成了上下文关系。</li><li>这种上下文关系可以嵌套任意层次。</li><li>用div span b {color:yellow}表示了div标记中的span标记中的B元素用黄颜色显示。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS选择符问题 <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        input &#123; color: white; &#125;</span></span><br><span class="line"><span class="undefined">        div input &#123; color: red; &#125;</span></span><br><span class="line"><span class="undefined">        div span b &#123;color: yellow; &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"change me"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"change me"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>I'm a <span class="tag">&lt;<span class="name">b</span>&gt;</span>good <span class="tag">&lt;/<span class="name">b</span>&gt;</span>student <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>用户定义的类选择符</li><li>ID选择符<ul><li>每一个标记都可有ID属性，可唯一识别该标记元素。</li><li>可以用这个ID来作为样式的选择符，样式中必须在ID前加一个<code>#</code>，而不是点号。</li><li>一个ID选择符样式<strong>只能在HTML文件内被引用一次</strong>，而类选择符样式则可以多次被引用。</li><li>若有些较特别的标记需要应用较为特殊的样式，则建议使用ID选择符。</li></ul></li><li>虚类：虚类是一种特殊的类选择符，虚类的形式为：<ul><li>选择符:虚类{ 属性值对 }</li><li>虚类主要针对超链接A标记来使用，可指定超链接标记A以不同的方式显示链接。</li><li>超链接有4种不同的样式状态： </li><li>a:link    链接访问前的样式</li><li>a:visited 链接访问后的样式</li><li>a:active  链接活动时的样式</li><li>a:hover   鼠标在链接上的样式</li><li>可将虚类和自定义类名组合起来使用，以实现页面中各个超链接按不同样式来呈现。</li></ul></li><li>虚元素<ul><li>有2个特殊的选择符first-letter和first-line，用于P、div、span等<strong>块级元素的首字母和首行效果</strong>。格式为：</li><li>选择符:first-letter {属性值对}</li><li>选择符.类:first-letter {属性值对}</li></ul></li></ul><h5 id="CSS的使用方式"><a href="#CSS的使用方式" class="headerlink" title="CSS的使用方式"></a>CSS的使用方式</h5><ul><li>4种方式<ul><li>链入外部样式表：<code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;</code></li><li>导入外部样式表：<code>&lt;!-- @import &quot;mystyle.css&quot;; --&gt;</code></li><li>联入样式表：利用<code>&lt;style&gt;</code>标记将样式表联入HTML文件的头部</li><li>内联样式：是混合在HTML标记里使用的，用这种方法，可以很简单地对某个元素单独定义样式。<br><code>&lt;p style = &quot;color: red; background-color: yellow&quot;&gt;</code></li></ul></li><li>多重样式表的叠加的<strong>优先级</strong><ul><li>依优先级最高的是内联样式，其次是联入样式表，然后是导入外部样式表。外链样式和联入样式中，最后定义的样式优先级最高。</li><li>内联样式会向标记中添加更多属性及内容，对于网页设计者来说很难维护，应尽<strong>量减少使用内联样式。</strong></li></ul></li></ul><h5 id="用CSS控制Web元素的显示外观"><a href="#用CSS控制Web元素的显示外观" class="headerlink" title="用CSS控制Web元素的显示外观"></a>用CSS控制Web元素的显示外观</h5><ol><li><p>控制文字字体属性  </p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.myfont1</span> &#123;</span><br><span class="line">          <span class="attribute">font-family</span>: 宋体, Arial; <span class="comment">/*字体*/</span></span><br><span class="line">          <span class="attribute">font-size</span>: <span class="number">12px</span>; <span class="comment">/*字号*/</span></span><br><span class="line">          <span class="attribute">font-weight</span>: bold; <span class="comment">/*字体加粗*/</span></span><br><span class="line">          <span class="attribute">font-style</span>: italic; <span class="comment">/*字体风格*/</span></span><br><span class="line">          <span class="attribute">text-transform</span>: uppercase; <span class="comment">/*字体转换*/</span></span><br><span class="line">          <span class="attribute">color</span>: <span class="number">#FF0000</span>; <span class="comment">/*字体颜色*/</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><p>文本属性</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.myfont1</span> &#123;</span><br><span class="line">          <span class="attribute">letter-spacing</span>: <span class="number">2px</span>; <span class="comment">/*字符间隔*/</span></span><br><span class="line">          <span class="attribute">text-align</span>: left; <span class="comment">/*对齐方式*/</span></span><br><span class="line">          <span class="attribute">text-decoration</span>: underline line-through overline;<span class="comment">/*文本修饰*/</span></span><br><span class="line">          <span class="attribute">text-indent</span>: <span class="number">20pt</span>; <span class="comment">/*文本缩进*/</span></span><br><span class="line">          <span class="attribute">line-height</span>: <span class="number">22px</span>; <span class="comment">/*文本行间距*/</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><p>控制颜色和背景属性</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.mycolor</span> &#123;</span><br><span class="line">          <span class="attribute">color</span>: <span class="number">#FFFF00</span>;</span><br><span class="line">          <span class="attribute">background-color</span>: <span class="number">#FF0000</span>; <span class="comment">/*文本块、网页、几何形状等背景颜色*/</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><p>边框属性</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.myborder</span> &#123;</span><br><span class="line">          <span class="attribute">border-style</span>: double solid solid double; <span class="comment">/*边界线样式*/</span></span><br><span class="line">          <span class="attribute">border-width</span>: <span class="number">5px</span> <span class="number">5px</span> <span class="number">2px</span> <span class="number">5px</span>; <span class="comment">/*边界宽度*/</span></span><br><span class="line">          <span class="attribute">border-color</span>: <span class="number">#0000FF</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><p>列表属性： 设置列表标记(<code>&lt;ol&gt;</code>和<code>&lt;ul&gt;</code>)的显示样式</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">   ol &#123;</span></span><br><span class="line"><span class="css">   <span class="selector-tag">list-style-type</span><span class="selector-pseudo">:upper-alpha</span>;</span></span><br><span class="line"><span class="undefined">   &#125;</span></span><br><span class="line"><span class="undefined">   ul &#123;</span></span><br><span class="line"><span class="css">   <span class="selector-tag">list-style-type</span><span class="selector-pseudo">:circle</span>;  </span></span><br><span class="line"><span class="undefined">   &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span> <span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">计算机的六个逻辑部件为： <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>  输入部件 <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>   输出部件 <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>   存储器  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span> 算术逻辑部件(ALU)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span> 辅助存储器 <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>中央处理器(CPU)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>辅助存储器 <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>定位属性</p><ul><li>static：默认值。位置设置为static的元素，它始终会处于文档流给予的位置。</li><li>relative：生成相对定位的元素，<strong>相对于该元素在文档中的初始位置进行定位</strong>。</li><li>absolute：生成绝对定位的元素，<strong>相对于距该元素最近的已定位的父元素</strong>进行定位。</li><li>fixed：元生成绝对定位的元素。默认情况下，可定位于<strong>相对于浏览器窗口</strong>的指定坐标。</li></ul></li><li><p>控制鼠标形状</p><ul><li>hand：手型 <code>&lt;a href=&quot;#&quot; style=&quot;cursor:hand&quot;&gt;CSS鼠标手型效果&lt;/a&gt;</code></li><li>pointer：手型，推荐使用这种，可以在多种浏览器下使用。</li><li>crosshair：十字型</li><li>help：问号</li><li>text：移动到文本上</li><li>wait：等待，沙漏型</li><li>default：默认效果</li><li>e-resize：向右的箭头</li><li>ne-resize：向右上的箭头</li><li>n-resize：向上的箭头</li><li>nw-resize：向左上的箭头</li><li>w-resize：向左的箭头</li><li>sw-resize：左下的箭头</li><li>s-resize：向下的箭头</li><li>se-resize：向右下的箭头</li><li>auto：由系统自动给出效果</li></ul></li><li><p>滤镜</p><ul><li>alpha</li><li>blur</li><li>dropshadow</li><li>glow</li><li>chroma</li><li>flipH 与 flipV</li><li>wave</li><li>shadow</li><li>mask</li><li>light</li><li>gray / invert / xray</li></ul></li></ol><h2 id="4-DHTML"><a href="#4-DHTML" class="headerlink" title="4. DHTML"></a>4. DHTML</h2><h3 id="4-1-JavaScript编程技术"><a href="#4-1-JavaScript编程技术" class="headerlink" title="4.1 JavaScript编程技术"></a>4.1 JavaScript编程技术</h3><h5 id="JavaScript语言简述"><a href="#JavaScript语言简述" class="headerlink" title="JavaScript语言简述"></a>JavaScript语言简述</h5><ul><li>JavaScript嵌入在HTML文件中，能对鼠标点击、表单提交等用户事件做出反应和处理。</li><li>特点：<ul><li><code>简单性</code>：JS是简化的编程语言，变量类型简单，不声明也能使用。</li><li><code>基于对象</code>：JS<strong>不完全面向对象</strong>，不支持类和继承，是基于对象而不是面向对象的语言</li><li><code>可移植性</code>：JS可在浏览器上不经修改直接运行。</li><li><code>动态性</code>：可用来设计客户端交互式动态页面。</li><li><code>安全性</code>：JS是一种安全性语言，对本地资源的访问和操作有限，只能通过浏览器实现信息浏览或动态交互。</li></ul></li></ul><h5 id="JavaScript编程基础"><a href="#JavaScript编程基础" class="headerlink" title="JavaScript编程基础"></a>JavaScript编程基础</h5><ul><li>将JavaScript程序嵌入HTML文件的方法：<br><code>&lt;script scr=&quot;clock.js type=&quot;text/javascript&quot;</code></li><li>数据类型：<ol><li>字符型</li><li>数值型：整数和浮点值没有差别</li><li>布尔型</li></ol></li><li>常量</li><li>变量：<ul><li>变量声明：var关键字来进行变量声明。</li><li>变量命名：JavaScript是一种<strong>区分大小写</strong>的语言。</li></ul></li><li>运算符和表达式</li><li>函数：当函数没有返回值时，可以不用return语句。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">形式参数表</span>)</span>&#123;</span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>流程控制：if语句；for循环语句</li><li>事件驱动及事件处理<br><img src="/web/事件驱动.png" width="60%"></li></ul><h5 id="JavaScript对象编程技术"><a href="#JavaScript对象编程技术" class="headerlink" title="JavaScript对象编程技术"></a>JavaScript对象编程技术</h5><ul><li>JS语言是基于对象的语言，并非面向对象的语言，<strong>JS中没有类，只有对象</strong>，它没有提供抽象、继承、封装等面向对象的基本属性。</li><li>我们不能像在传统的语言里那样用class来定义类, 但我们可利用JS的<strong>闭包封装机制</strong>来实现JS中的类。</li><li>JavaScript的自定义对象<ul><li>把函数function当成对象</li><li>用prototype对象来实现js的自定义对象</li></ul></li></ul><ol><li>Array对象 <ul><li>可用Array对象创建数组。数组是若干元素的集合，每个数组都用一个名字作为标识。</li><li>JavaScript中没有提供明显的数组类型，可通过JavaScript内建对象Array和使用自定义对象的方式创建数组对象。</li></ul></li><li>String对象<ul><li>JS内置对象string只有一个属性，即length属性，包含了字符串中的字符数。</li><li>string 对象内置方法有30多种。例如anchor、link、substring、indexOf、replace、 fromCharCode等。</li></ul></li><li>Math对象<ul><li>Math对象提供了常用的数学常数和运算，如三角函数、对数函数、指数函数等。</li><li>Math中提供了６个属性。主要方法有绝对值abs()、正弦sin()、余弦cos()、反正弦asin()、反余弦acos()、正切tan()、反正切atan()、四舍五入round()、平方根sqrt() 等。</li></ul></li><li>Date对象<ul><li>JS内置对象Date可用来获取当前的年月日、时分秒以及星期几，它基于GMT 格林威治标准时间的，另外还有一个世界统一时间UTC，Universal Coordinated Time，正替代GMT的使用。</li></ul></li><li>Number对象</li><li>JavaScript中的与定义函数：与任何对象无关的预定义函数，不需创建实例就可直接使用。<ul><li>返回字符串表达式中的值。<br><code>eval（字符串表达式），例：test=eval(&quot;8+9+5/2&quot;)</code></li><li>返回字符的编码。<br><code>escape(string) //用 %xx 16进制形式编码</code><br><code>unescape(string) //将用escape编码过的字串复原</code> </li><li>返回实数。<br><code>parseFloat(floatstring) //字符数字变成实数</code></li><li>返回不同进制的数。<br><code>parseInt(numbestring,radix) //radix是数的进制，               numbestring字符串数。字符数字按进制变成整数</code></li></ul></li></ol><h5 id="JavaScript-ActiveX编程技术"><a href="#JavaScript-ActiveX编程技术" class="headerlink" title="JavaScript ActiveX编程技术"></a>JavaScript ActiveX编程技术</h5><ul><li>HTML页面可使用ActiveX控件播放声音和flash，如何在JS中进行ActiveX控件的编程？</li><li>计算机装上各种软件后，一些ActiveX控件就会安装在计算机上，可以利用这些ActiveX控件来实现我们所要的功能。<ul><li>例如FileSystemObject 控件对象提供对计算机文件系统的访问；Excel.Application和Word.Application提供对Excel和Word的控制和操作。</li></ul></li></ul><h3 id="4-2-HTML-DOM-程序设计初步"><a href="#4-2-HTML-DOM-程序设计初步" class="headerlink" title="4.2 HTML DOM 程序设计初步"></a>4.2 HTML DOM 程序设计初步</h3><h5 id="HTML-文档对象模型"><a href="#HTML-文档对象模型" class="headerlink" title="HTML 文档对象模型"></a>HTML 文档对象模型</h5><ul><li>HTML DOM 是一个可让脚本程序动态访问和更新HTML文档内容、结构和样式的技术。</li><li>它是<strong>跨平台</strong>、可适应不同程序语言的文件对象模型，采用直观一致的方式，将HTML文档进行模型化处理，是一种提供存取和更新文档内容、结构和样式的编程接口。<br><img src="/web/文档对象模型.png" width="90%"></li><li>使用DOM技术，不仅可访问和更新页面的内容及结构，而且还能<strong>操纵文档的风格样式</strong>，它将网页中的各个HTML元素看作一个个对象，从而使网页中的元素可以被JS等语言获取或者编辑。</li><li>DOM规范在不断发展中，<strong>各种浏览器对DOM的支持有所差异</strong>。经常看到在某个浏览器下显示正常的页面在另一浏览器下显示不正常，为什么？是浏览器对DOM的支持有所不同。</li><li>对于专业的大型网站，开发人员会编码识别浏览器类型，针对浏览器的不同而进行相应代码的处理，保证网页在各种浏览器上正常显示。</li></ul><h5 id="通过DOM操纵HTML元素"><a href="#通过DOM操纵HTML元素" class="headerlink" title="通过DOM操纵HTML元素"></a>通过DOM操纵HTML元素</h5><ul><li>通过DOM操控HTML元素，必须设置其唯一标识ID属性。一般不用HTML元素的name属性了。可以把HTML元素的ID属性看成是该控件的名称。</li><li>HTML DOM提供了同一访问HTML元素的6种方法：<ul><li>document.<strong>all.item</strong>(“HTML元素的id”)</li><li>document.<strong>getElementById</strong>(“HTML元素的id”)</li><li>document.<strong>getElementByName</strong>(“HTML元素的name”)</li><li>document.<strong>all.namedItem</strong>(“HTML元素的id或name”)</li><li>document.<strong>getElementByTagName</strong>(“HTML元素的<strong>标记名称</strong>“)</li></ul></li><li>当HTML元素无ID或Name属性时，可用getElementsByTagName方法进行访问。</li></ul><h5 id="HTML-DOM主要对象介绍"><a href="#HTML-DOM主要对象介绍" class="headerlink" title="HTML DOM主要对象介绍"></a>HTML DOM主要对象介绍</h5><p><strong>1. 窗口对象 window</strong></p><ul><li>组成<ul><li>浏览器窗口对象Window处于DOM对象模型的最顶端，它封装了各种属性、方法、事件和子对象。</li><li>window对象的子对象包括位置对象location、历史对象history、事件对象event、文档对象document等。</li></ul></li><li>使用<ul><li>prompt、alert、confirm方法实现对话框功能，其中prompt为接受用户输入字符串的对话框；confirm实现具有确认和取消按钮的对话框；alert为仅输出文本对话框。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> test = <span class="built_in">window</span>.prompy(<span class="string">"请输入数据"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> YorN = confirm(<span class="string">"你输入的数据是"</span>+test+<span class="string">",确定吗"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span>(YorN) alert(<span class="string">"输入正确"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">else</span> alert(<span class="string">"输入不正确"</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2. 浏览器对象 navigator</strong></p><ul><li>window的子对象浏览器对象navigator可用于提供浏览器名称、版本、客户端支持的MIME类型属性等浏览器环境信息。<br><img src="/web/navigator.png" width="30%"></li></ul><p><strong>3. 位置对象 location</strong></p><ul><li>window子对象location提供对当前页面URL进行操作的一些方法和属性。<br><img src="/web/location.png" width="30%"></li><li><p>使用</p><ul><li>通过href或url传递参数到另一个页面:</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">window.location.href="1.html?x=5;y=6;z=7";</span><br><span class="line">window.navigate("1.html?x=5;y=6;z=7");</span><br></pre></td></tr></table></figure></li></ul><p><strong>4. 历史对象 history</strong></p><ul><li>window子对象history历史对象提供了浏览器的浏览历史信息。用户在浏览器中通过点击超链接或其他方式跳转到新的页面，如果要后退看前面已经访问过的网页历史，可以在浏览器工具条单击“后退”。通过history对象可以在网页中进行控制。<br><img src="/web/history.png" width="30%"></li></ul><p><strong>5. 事件对象 event</strong></p><ul><li>window子对象事件对象event，用来获取或设置产生事件的对象是哪个对象、键盘按键的状态、当前鼠标指针的位置、鼠标按键的状态等等。<br><img src="/web/event.png" width="60%"></li><li>使用<ul><li>event.x:设置或者是得到鼠标相对于目标事件的父元素的外边界在x坐标上的位置。</li><li>event.clientX:相对于客户区域的x坐标位置，不包括滚动条，放置正文区域。</li><li>event.offsetx：设置或得到鼠标相对于目标事件的父元素的内边界在x坐标上的位置。</li><li>event.screenX:相对于用户屏幕。</li></ul></li></ul> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">  </span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">"event.x:"</span> + event.x + <span class="string">"\nevent.y:"</span> + event.y + <span class="string">"\nevent.clientX:"</span> + event.clientX + <span class="string">"\nevent.clientY:"</span> + event.clientY + <span class="string">"\nevent.offsetX:"</span> + event.offsetX + <span class="string">"\nevent.offsetY:"</span> + event.offsetY + <span class="string">"\nevent.screenX:"</span> + event.screenX + <span class="string">"\nevent.screenY:"</span> + event.screenY);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">style</span>=<span class="string">"position: relative; left: 100; top: 100"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">"show()"</span> <span class="attr">style</span>=<span class="string">"background: silver; cursor: hand"</span>&gt;</span></span><br><span class="line">       Click here to show.   <span class="tag">&lt;/<span class="name">div</span>&gt;</span>    <span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>6. 文档对象 document</strong></p><ul><li>document对象是浏览器对象的核心子对象，主要作用就是对网页显示区域的各个HTML元素进行处理。document对象对实现Web页面信息交互起关键作用。HTML5: 属性+方法+事件  255个<br><img src="/web/document.png" width="60%"></li><li>文档对象的属性 cookie<ul><li>cookie可用来存放当前页面的参数信息，也可用来存放同一网站打开的多个页面间的共享信息。</li><li>可以对cookie设置失效期限，既可永久保留，也可关闭网站后就删除，也可在指定时间内失效。</li><li>expires指定cookie的失效日期，当没有失效日期时，关闭浏览器即失效。</li><li><code>name=wcl;sex=male;color=red; expires=Sun May 27 22:04:25 UTC+0800 2008</code></li></ul></li><li>文档对象的方法<ul><li>有了Document对象的write方法，给我们带来了很大的方便。我们不需要事先将网页制作好，做一个死板的网页，而是可以通过脚本程序自动动态生成出来。</li></ul></li><li>文档对象的事件<ul><li>文档对象的事件除了响应键盘、鼠标常规操作事件外，还增加了其他大量事件，例如鼠标的拖拉操作事件、浏览器鼠标右键快捷菜单事件oncontextmenu等。</li></ul></li><li>docment的对象<ul><li>document有all、anchors、applets、childNodes、embeds、forms、frames、images、links、namespaces、scripts、styleSheets等集合对象。</li></ul></li></ul><h5 id="HTML-DOM树介绍"><a href="#HTML-DOM树介绍" class="headerlink" title="HTML DOM树介绍"></a>HTML DOM树介绍</h5><ul><li>HTML DOM是一种结构化的对象模型，采用DOM技术访问和更新HTML页面内容时，可依据HTML源代码，建立页面的树型结构模型，然后按照树型结构的层次关系来操纵Web页面。  </li><li>结构：<br><img src="/web/domtree.png" width="30%"></li><li>在DOM树型结构中，每个节点都是一个对象，各节点对象都有属性和方法。</li><li>DOM树型结构节点有<strong>只读属性</strong>和<strong>读写属性</strong>两类。通过只读属性可以浏览节点，并可获得节点的类型及名称等信息；通过读写属性可以访问文字节点的内容。</li><li>用DOM树方法可以<strong>动态创建html文档或html元素</strong>，并可通过JS程序随时改变文档的节点结构或内容，建立动态的网页生成效果。</li><li></li></ul><h3 id="4-3-如何用jQuery简化JavaScript开发"><a href="#4-3-如何用jQuery简化JavaScript开发" class="headerlink" title="4.3 如何用jQuery简化JavaScript开发"></a>4.3 如何用jQuery简化JavaScript开发</h3><h5 id="jQuery简介"><a href="#jQuery简介" class="headerlink" title="jQuery简介"></a>jQuery简介</h5><ul><li>把一些通用的函数事先写好，放在外部单独JS文件中，在手工编写网页代码时，就可重复使用这些通用函数，大大简化网页代码的编写工作，提高网页开发的效率。</li><li>jQuery是一个快捷、小巧和特性丰富的JavaScript库，凭借简洁语法和跨平台的兼容性，大大简化了JS开发人员遍历HTML文档、操作DOM、处理事件、执行动画和开发Ajax的操作。其独特而优雅的代码风格改变了JS程序员的设计思路和编写程序的方式。</li><li>jQuery主要功能：<ul><li><strong>获取文档中的元素。</strong>jQuery为准确地获取需要检查或操作的文档元素，提供了可靠而富有效率的选择符机制。</li><li>修改页面外观。jQuery提供了跨浏览器的标准解决方案，即使在页面呈现以后，仍能改变文档中某个部分的类或者个别的样式属性。</li><li><strong>改变文档的内容。</strong>jQuery能够影响的范围并不局限于简单的外观变化，使用少量的代码，jQuery就能改变文档的内容。</li><li><strong>响应用户的交互操作。</strong>jQuery提供了形形色色的页面事件的适当方式，而不需要使用事件处理程序使HTML代码看起来杂乱。此外，它的事件处理API也消除了经常困扰Web开发人员的浏览器不一致性问题。</li><li><strong>为页面添加动态效果。</strong>为了实现某种交互行为，设计者必须向用户提供视觉上的反馈。jQuery内置的一批淡入、擦除之类的效果，以及制作新效果的工具包，为此提供了便利。</li><li><strong>无需刷新页面从服务器获取信息。</strong>这种编程模式就是众所周知的AJAX，它能帮助Web开发人员创建出反应敏感、功能丰富的网站。jQuery通过消除这一过程中的浏览器特定的复杂性，使开发人员得以专注于服务器的功能设计。</li><li><strong>简化常用的JavaScript任务。</strong>除了这些完全针对文档的特性之外，jQuery也提供了对基本的JavaScript结构（例如迭代和数组操作等）的增强。</li></ul></li></ul><h5 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h5><ol><li><p>元素选择器</p><ul><li>采用元素名称如a、img、  input作为选择器。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(“div”)表示选择所有div元素$(“img”)表示选择所有img </span><br><span class="line">$(“tr”)表示选择所有tr元素</span><br></pre></td></tr></table></figure></li><li><p>ID选择器</p><ul><li><p>用元素ID作为选择器。<br><code>$(“#button1”)将选择ID为button1的元素。</code></p></li><li><p>ID选择器有时也和元素选择器一起使用：<br><code>$(“div #main”)选中ID为main的div元素。</code></p></li></ul></li><li><p>类选择器</p><ul><li>元素的class属性。类选择器的语法是以.开头，紧接着是CSS类名。<br><code>$(“.important”)将选择页面上所有应用了important类的元素。</code></li></ul></li><li><p>后代选择器</p><ul><li>若在一个选择器后面有一个空格，再跟另外一个选择器，则表示选择包含在第一个选择器中的第二个选择器。    <code>$(”div p”)将选择div中出现的所有p元素。</code></li></ul></li><li>子元素选择器<ul><li>若一个选择器后面是一个大于号 &gt; ，后面再跟另一个选择器，则表示选择直接包在第一个选择器中的第二个选择器。<br><code>$(‘#ss &gt; li’)  选择Id为SS元素中的所有li元素。</code></li></ul></li></ol><h5 id="jQuery中关于DOM的操作"><a href="#jQuery中关于DOM的操作" class="headerlink" title="jQuery中关于DOM的操作"></a>jQuery中关于DOM的操作</h5><p><img src="/web/jQuertdom.png" width="60%"><br><img src="/web/jQuertdom2.png" width="60%"></p><h5 id="jQuery事件"><a href="#jQuery事件" class="headerlink" title="jQuery事件"></a>jQuery事件</h5><h3 id="4-4-DHTML综合编程实例"><a href="#4-4-DHTML综合编程实例" class="headerlink" title="4.4 DHTML综合编程实例"></a>4.4 DHTML综合编程实例</h3><h5 id="广告条定时滚动"><a href="#广告条定时滚动" class="headerlink" title="广告条定时滚动"></a>广告条定时滚动</h5><h5 id="通过URL传递参数"><a href="#通过URL传递参数" class="headerlink" title="通过URL传递参数"></a>通过URL传递参数</h5><h5 id="超文本编辑器及其与Word的互操作"><a href="#超文本编辑器及其与Word的互操作" class="headerlink" title="超文本编辑器及其与Word的互操作"></a>超文本编辑器及其与Word的互操作</h5><h5 id="表格的美化"><a href="#表格的美化" class="headerlink" title="表格的美化"></a>表格的美化</h5><h2 id="5-XML"><a href="#5-XML" class="headerlink" title="5. XML"></a>5. XML</h2><h3 id="5-1-什么是XML？"><a href="#5-1-什么是XML？" class="headerlink" title="5.1 什么是XML？"></a>5.1 什么是XML？</h3><h5 id="XML-Extensible-Markup-Language-可扩展标记语言"><a href="#XML-Extensible-Markup-Language-可扩展标记语言" class="headerlink" title="XML  Extensible Markup Language 可扩展标记语言"></a>XML  Extensible Markup Language 可扩展标记语言</h5><ul><li>XML是一种类似于HTML的标记语言</li><li>XML是用来描述数据</li><li>XML的标记非预先定义，须<strong>自行定义标记</strong></li></ul><h5 id="XML的特点"><a href="#XML的特点" class="headerlink" title="XML的特点"></a>XML的特点</h5><ul><li><strong>XML的可扩展性</strong>：<ul><li>XML中，可建立任何需要的标记。可充分发挥想象力给文档起一些好记的标记名称。</li></ul></li><li><strong>标记的自描述性</strong>：<ul><li>标记（tag）又叫标识，也称元素名，用于描述数据，标识文档中的元素。通过标记，XML文档才便于阅读和理解。</li></ul></li><li><strong>XML语言的规则性</strong>：<ul><li>标记区分大小写，须配对且合理嵌套；属性须用引号括起来；名字不能以下划线开头，不能有空格，可有字母、数字及下划线；不能用XML等保留字。</li></ul></li><li><strong>文档的结构化</strong>：<ul><li>所有的信息按某种关系排列。</li></ul></li><li><strong>允许Meta数据(元数据)</strong>：<ul><li>可用XML描述你的信息在哪里，可通过meta来验证信息、执行搜索、强制显示或者处理其它的数据。</li></ul></li><li><strong>XML文档的多样显示</strong>：<ul><li>可通过CSS或者XSL可扩展样式语言（Extensible Stylesheet Language）在浏览器中呈现XML文档内容。</li></ul></li><li><strong>允许XML DOM操作</strong>：<ul><li>XML DOM的作用就是使用脚本语言如何对XML文档的节点和数据进行增删查改等各项操作。</li></ul></li></ul><h5 id="XML中有关名词的相互关系"><a href="#XML中有关名词的相互关系" class="headerlink" title="XML中有关名词的相互关系"></a>XML中有关名词的相互关系</h5><ul><li>XML DTD用以说明XML文档中数据的类型和格式，既可放在单独文件中，又可直接放在XML文档中。</li><li>由于XML DTD本身非XML文档结构，其对XML文档数据类型和格式的描述过于复杂，用户在使用时较难掌握，目前已被XML Schema所替代。</li><li>XML Schema中对XML文档中数据类型和格式的描述采用了XML文档结构，可以定义复杂数据类型。CSS和XSL用来实现XML文档在浏览器中的显示。<br><img src="/web/xml.png" width="70%"></li></ul><h5 id="XML文档结构"><a href="#XML文档结构" class="headerlink" title="XML文档结构"></a>XML文档结构</h5><ol><li>XML文档声明<ul><li>version：XML文档所遵循的XML规范的版本号；</li><li>可选项encoding：XML处理器使用的字符集，默认为UFT-8；</li><li>可选参数standalone：yes或no，默认值为yes，申明该文档为一个独立文档，无需DTD文档来验证其中的标识是否有效。<br><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;GB-2312 standalone=&quot;yes&quot;?&gt;</code></li></ul></li><li>文档显示方式或者文档类型定义的声明部分</li><li>XML标识的文档内容</li></ol><h5 id="XML文档内容的结构"><a href="#XML文档内容的结构" class="headerlink" title="XML文档内容的结构"></a>XML文档内容的结构</h5><ol><li>声明根元素：<ul><li>每一个有效的XML文档有且仅有一个根元素。</li><li><code>&lt;rootElementName&gt;...&lt;/rootElementName&gt;</code></li></ul></li><li>声明非根元素</li><li>数据元素属性<ul><li>一个数据元素可以有若干属性，属性必须在一个元素的起始标记中声明</li></ul></li><li><p>定义名称空间</p><ul><li>在XML中，用户可以自己定义标记名称也即元素名称， 因此，如果把多个XML文件合并为一个，就很可能出现名称冲突。</li><li>解决这一问题的方法就是使用名称空间。</li></ul></li><li><p>包含非标准文本</p><ul><li>在具体应用中，XML文档往往包含一些特殊符号和文本块，而这些特殊符号不需要应用程序或格式转换程序做任何处理，只需照原样输出时，称之为非标准文本，又称非解析数据(Character DATA)。 </li><li>XML文档的基本结构中用CDATA来表示。CDATA节的一般形式为：<code>&lt;![CDATA[text]]&gt;</code></li></ul></li></ol><h3 id="5-2-用CSS控制XML文档在浏览器中的显示"><a href="#5-2-用CSS控制XML文档在浏览器中的显示" class="headerlink" title="5.2 用CSS控制XML文档在浏览器中的显示"></a>5.2 用CSS控制XML文档在浏览器中的显示</h3><h5 id="XML文档的4中css样式定义方式"><a href="#XML文档的4中css样式定义方式" class="headerlink" title="XML文档的4中css样式定义方式"></a>XML文档的4中css样式定义方式</h5><ul><li>元素名称选择符</li><li>用户自定义类选择符</li><li>用户定义的ID选择符</li><li>成组选择符</li></ul><h5 id="CSS样式和XML文档的联系方式"><a href="#CSS样式和XML文档的联系方式" class="headerlink" title="CSS样式和XML文档的联系方式"></a>CSS样式和XML文档的联系方式</h5><ol><li>将定义的CSS样式表置于XML文档中</li><li>将CSS样式表放在单独的扩展名为css的文件中，然后在XML文档声明部分引用css文件</li><li>将上述两种方式结合起来</li></ol><h3 id="5-3-用XSL控制XML文档在浏览器中的显示"><a href="#5-3-用XSL控制XML文档在浏览器中的显示" class="headerlink" title="5.3 用XSL控制XML文档在浏览器中的显示"></a>5.3 用XSL控制XML文档在浏览器中的显示</h3><h5 id="XSL概述"><a href="#XSL概述" class="headerlink" title="XSL概述"></a>XSL概述</h5><ul><li>XSL(eXtensible Stylesheet Languge， 可扩展样式单语言)是由W3C 1999年11月制定的。XSL自提出以来争议颇多，前后经过了几番大的修改。</li><li>2007年1月 W3C 发布了修改后的XSLT 2.0 版本（<a href="http://www.w3.org/TR/xslt20/）。" target="_blank" rel="noopener">http://www.w3.org/TR/xslt20/）。</a> 2013年12月 发布 XSLT 3.0，它仍然在进一步修改完善中。 </li><li>XSLT能将XML文档<strong>转换</strong>成一个新的文档（包括HTML文档），通过浏览器或其它应用程序就可以显示出来。</li></ul><h5 id="XSL的组成"><a href="#XSL的组成" class="headerlink" title="XSL的组成"></a>XSL的组成</h5><ul><li>XSLT ： XSL Transformation，用于转换 XML 文档的语言。</li><li>Xpath： 用于在XML文档中选择元素的语言。</li><li>格式化符号集XSL-FO -：定义应用XML数据的复杂的格式化规则。用于格式化 XML 文档的语言。</li></ul><h5 id="XSL与CSS的异同"><a href="#XSL与CSS的异同" class="headerlink" title="XSL与CSS的异同"></a>XSL与CSS的异同</h5><ul><li>XSL与CSS在功能上类似，但XSL比CSS功能强大、复杂度高。</li><li>CSS只允许格式化XML元素内容，不允许改变或安排这些内容。但XSL没有这些限制，可提取元素、属性值、注释文本等各种文档内容。在XML领域，用XSL来格式化文档是未来发展的方向。</li><li>CSS样式描述格式不遵从XML的语法规范。而XSL遵守XML语法规则，是XML的一种具体应用，也即XSL本身就是一个XML文档，系统可使用同一个XML解释器对XML文档及其相关的XSL文档进行解释处理。</li></ul><h5 id="XSL模板元素"><a href="#XSL模板元素" class="headerlink" title="XSL模板元素"></a>XSL模板元素</h5><ul><li>在XSL中，数据的显示格式被设计细化成一个个模板，最后再将这些模板组合成一个完整的XSL。</li><li>这种方法可以使用户先从整体上考虑整个XSL的设计，然后将一些表现形式细化成不同的模板，再具体设计若干模板，最后将它们整合在一起。</li><li>由于XML的数据保存在具有严格层次结构的各个元素中，这种结构非常适合采用模板化的格式样式。  </li><li>模板定义好后，可通过call-template或apply-templates来调用模板，其过程就如同我们在C语言中定义了一个函数，就可在程序中需要的地方进行函数调用。<br><img src="/web/xsl.png" width="80%"></li><li>定义模板的语法结构：<br><code>&lt;xsl: template match=&quot;node-context&quot; name=&quot;template name&quot;&gt;...&lt;/xsl: template&gt;</code><ul><li>match确定什么样的情况下执行此模板，其中最上层的模板必须将match设为”/”。在一个XSL文档中必须有一个根模板，而且是唯一的。</li><li><code>&lt;xsl:template&gt;</code>元素用match属性从XML文档中选取满足条件的节点，针对这些特定的节点形成一个特定输出形式的模板。</li><li>name属性即是为定义的模板取一个用户自定义的名称。只能通过<code>&lt;xsl:call-template&gt;</code>元素来调用模板。</li></ul></li></ul><h5 id="XSL选择元素"><a href="#XSL选择元素" class="headerlink" title="XSL选择元素"></a>XSL选择元素</h5><ul><li>用选择的方式将满足条件的数据从XML文档中提取出来<br><img src="/web/select.png" width="80%"></li></ul><h5 id="XSL常用运算符"><a href="#XSL常用运算符" class="headerlink" title="XSL常用运算符"></a>XSL常用运算符</h5><p><img src="/web/operation.png" width="80%"></p><ul><li><code>&lt;xsl:for-each select=&quot;*/resume&quot;&gt;</code>  此处用通配符*代替了document元素名称。对每个resume 循环处理</li><li><code>&lt;xsl:for-each select=&quot;//resume [@id=&#39;008&#39;]&quot;&gt;</code> 对简历中具有Id属性编号为“0008”的人进行处理</li><li><code>&lt;xsl:for-each select=&quot;*/resume [cellphone]&quot;&gt;</code> 对简历中具有“cellph手机one”元素的人进行处理，也即对简历中提供了号码的人进行处理。</li><li><code>&lt;xsl:for-each select=&quot;*/resume [cellphone]&quot;&gt;</code> 对简历中具有“cellphone”元素的人进行处理，也即对简历中提供了手机号码的人进行处理。</li><li><code>&lt;xsl:for-each select=&quot;*/resume [skill=&#39;Web开发&#39;]&quot;&gt;</code> 对简历中具有”Web开发”技能的所有人进行处理</li></ul><h5 id="XSL常用内置函数"><a href="#XSL常用内置函数" class="headerlink" title="XSL常用内置函数"></a>XSL常用内置函数</h5><p><img src="/web/function.png" width="80%"></p><h5 id="XSL常用处理元素语法"><a href="#XSL常用处理元素语法" class="headerlink" title="XSL常用处理元素语法"></a>XSL常用处理元素语法</h5><p><img src="/web/other.png" width="80%"></p><h3 id="5-4-XML-DOM编程基础"><a href="#5-4-XML-DOM编程基础" class="headerlink" title="5.4 XML DOM编程基础"></a>5.4 XML DOM编程基础</h3><h5 id="XML-DOM简介"><a href="#XML-DOM简介" class="headerlink" title="XML DOM简介"></a>XML DOM简介</h5><ul><li>对于XML文档，可利用CSS的样式或XSLT格式转换后利用浏览器解析和浏览它，如何对XML文档进行数据的添加、删除、修改、查询等操作，就需要使用XML DOM技术了。 </li><li>XML DOM实际上就是访问XML文档的标准应用程序接口。</li><li>XML DOM是W3C提出的针对XML的文档对象模型，是一个与语言无关、与平台无关的标准接口规范，定义了一套标准的用于XML的对象和一种标准的访问与处理XML文档的方法。</li><li>对于XML应用开发来说，DOM 就是一个对象化的XML数据接口，它定义了XML文档的逻辑结构，可动态创建XML文档；遍历文档结构；添加、修改、删除文档内容；改变文档的显示方式等。无论是在浏览器里还是在浏览器外，无论是在服务器还是在客户端，只要有用到XML的地方，都可利用DOM接口进行编程应用。</li><li><strong>DOM将XML文档作为树结构来看待。</strong>XML文档中的每个成分都是一个节点。例如整个文档是一个文档根节点；每个XML标记是一个元素节点；包含在XML元素中的文本是文本节点；每一个XML属性是一个属性节点；注释属于注释节点。</li></ul><h5 id="XML-DOM与-SAX"><a href="#XML-DOM与-SAX" class="headerlink" title="XML DOM与 SAX"></a>XML DOM与 SAX</h5><ul><li>访问XML文档的标准应用程序接口有两种：DOM（Document Object Model）和SAX（Simple API for XML）。</li><li>DOM接口中的XML分析器，在对XML文档进行分析之后，不管这个文档有多简单或者多复杂，<strong>其中的信息都会被转化成一棵对象节点树——DOM 树</strong>。在这棵节点树中，有一个Document根节点，所有其他的节点都是根节点的后代节点。节点树生成之后，就可通过XML DOM接口访问、修改、添加、删除树中的节点和属性以及文本内容等。应用程序可在任何时候访问XML文档中的任何一部分数据，也即可随机访问。</li><li>与XML DOM不同，SAX提供的访问模式是一种顺序模式，这是一种快速读写XML数据的方式。当使用SAX分析器对XML文档进行分析时，会触发一系列事件，并激活相应的事件处理函数，应用程序通过编写的事件处理函数实现对XML文档的访问，因而SAX接口也被称作事件驱动接口。</li><li>由于DOM分析器把整个XML文档转化成DOM树放在了内存中，当XML文档很大或结构比较复杂时，对内存的需求就比较高。SAX分析器在对XML文档进行分析时，触发了一系列的事件，由于事件触发本身是有时序性的，SAX提供的是一种顺序访问机制，对于分析过的部分，不能再倒回去重新处理，因此SAX分析器缺乏灵活性但实现简单，对内存要求比较低。</li></ul><h5 id="XML-DOM对象"><a href="#XML-DOM对象" class="headerlink" title="XML DOM对象"></a>XML DOM对象</h5><ul><li><strong>Document对象</strong><ul><li>Document对象代表了整个XML文档，因此，它是整棵DOM树的根，提供了对文档中的数据进行访问和操作的入口。</li><li>通过Document节点，可以访问到文档中的其它节点，如处理指令、注释、文档类型以及XML文档的根元素节点等等。</li></ul></li><li><strong>Node对象：</strong>Node对象代表了树中的一个节点。子对象有Document、Element、Attribute、Text、Comment等。<ul><li><code>Element对象</code>：表示一个XML文档中的某个元素。元素可包含属性和文本。某个元素含有文本，则此文本就是一个文本节点。文本永远被存储于文本节点中。<code>&lt;year&gt;2005&lt;/year&gt;</code>其中year为一个元素节点，此节点之下存在一个文本节点，其中含有文本2005。由于元素对象也是一种Node，因此它继承了Node对象的属性和方法。</li><li><code>Attr对象</code>：表示某个Element对象的一个属性。Attr对象也是一种节点，因此它可继承Node对象的属性和方法。不过属性无法拥有父节点，同时属性也不被认为是元素的子节点。</li><li><code>Text对象</code>：Text对象表示元素或属性的文本内容。</li></ul></li><li><strong>Node List对象</strong><ul><li>NodeList对象表示节点的集合，它包含了某个节点中的所有子节点对象，可用于表示有顺序关系的一组节点（例如某个节点的子节点序列）。</li><li>可用GetNodeByName方法返回节点的值。可通过节点列表中的节点索引号来访问列表中的节点（索引号由0开始）。若节点列表或XML文档中的某个元素被删除或添加，列表会被自动更新。</li><li>NodeList对象的属性length可返回某个节点列表中的节点数目，方法item可返回节点列表中处于某个指定的索引号的节点。</li></ul></li><li><strong>NamedNodeMap对象</strong><ul><li>NamedNodeMap对象也表示节点的集合，利用该对象可建立节点名和节点之间的一一映射关系，从而利用节点名可以直接访问特定的节点。 </li><li>NamedNodeMap<strong>通过名称来描述节点</strong>，而不是通过序数索引。 </li></ul></li></ul><h3 id="5-5-XML与数据库"><a href="#5-5-XML与数据库" class="headerlink" title="5.5 XML与数据库"></a>5.5 XML与数据库</h3><h5 id="XML与数据库的关系"><a href="#XML与数据库的关系" class="headerlink" title="XML与数据库的关系"></a>XML与数据库的关系</h5><ul><li>XML不是数据库，数据库系统有它自己的一套管理模式，而XML仅仅是用来存放数据的文件，<strong>一个XML文档相当于数据库中的一个表</strong>。因此XML不可能取代数据库，但将数据库和XML结合起来，能够完成很多以前无法完成的工作，例如异构数据交换、应用系统集成等。</li><li>数据若放在数据库中共享，则受到数据库连接请求失败、防火墙隔离等各种限制。</li><li>XML是文本文件，可以穿透任何防火墙进行传输，已成为互联网上的事实数据交换标准。</li><li>随着XML的广泛应用，<strong>各数据库产品都被重新设计，使之能很好支持XML，</strong>如Oracle、SQL Server、DB2、Sybase、MySQL等。另外还出现了支持native（原生） XML文档进行存储管理的专属XML数据库系统，如X-Hive、XML Repository、eXcelon、BaseX、 Sedna、 XMLDB等，提供对标签和路径的操作，文档存储和检索迅捷，可提供高质量的全文搜索。</li><li>开发一个访问数据库的XML应用系统需要<strong>同时借助XML编程接口和数据库编程接口</strong>，前者用于对XML文档的解析、定位和查询，所需技术包括DOM和SAX；后者则是用于访问数据库，如数据库中数据的更新和检索等等，需要利用的技术有ODBC、JDBC、ADO/ADO.NET等。</li><li>XML文档可通过A<strong>DO.NET等各种数据接口方式</strong>存放到数据库中，也可将数据表中的数据形成一个XML文档通过XSL来呈现。</li></ul><h5 id="SQL-Server-对XML的支持"><a href="#SQL-Server-对XML的支持" class="headerlink" title="SQL Server 对XML的支持"></a>SQL Server 对XML的支持</h5><ol><li>使用SELECT语句中的FOR XML子句得到XML文档格式的数据：<br><code>select * from Northwind.dbo.customers  for xml auto</code></li><li>简单的HTTP URL请求<br><code>http://localhost/web?sql=select * from Northwind.dbo.customers  for xml auto</code></li><li>OPENXML函数可以让你像操作一个表那样来运用XML数据，可以将它们转换成内存中的一个行记录集。需调用<code>sp_xml_ preparedocument</code>存储过程完成。</li><li>通过SQLXML功能（包含有<code>updategram</code>和<code>XML BulkLoad</code>功能）</li><li>SQL SERVER支持基于XPath 表达式的XQuery语言，该语言被设计用来查询 XML 数据，作用类似 SQL语言对数据库的查询。SQL Server引入了 xml 数据类型，提供了用于对存储在列或变量中的 XML 数据执行操作的大量方法。</li><li>SQL Server支持在insert表达式中的 xml 变量向现有 XML 结构插入 XML 数据的支持。</li></ol><h5 id="关于JSON"><a href="#关于JSON" class="headerlink" title="关于JSON"></a>关于JSON</h5><ul><li>在XML中，需要许多开始标记和结束标记来标识数据，在互联网网上传输数据时效率不高，出现了JSON(JavaScript Object Notation) 轻量级的数据交换格式，易于阅读和编写，同时也易于机器解析和生成， 作为XML文档的一种有力补充。</li></ul><h2 id="6-NET-Web应用程序开发"><a href="#6-NET-Web应用程序开发" class="headerlink" title="6. NET Web应用程序开发"></a>6. NET Web应用程序开发</h2><h3 id="6-1-C-语言初步"><a href="#6-1-C-语言初步" class="headerlink" title="6.1 C#语言初步"></a>6.1 C#语言初步</h3><h5 id="ASP-NET的体系结构"><a href="#ASP-NET的体系结构" class="headerlink" title="ASP.NET的体系结构"></a>ASP.NET的体系结构</h5><ul><li>ASP.NET是微软.NET Framework的一部分，是开发Web应用程序的全新编程模式，可使Web开发人员更快捷和方便地开发Web应用程序。</li><li>图为ASP.NET的体系结构。ASP.NET页面通过ISAPI与IIS通信，有一个用作页面的缓存cache，以提高性能。</li><li>ASP.NET中采用强类型语言VB.NET、C#等，采用完全面向对象方式编程。C#是由C和C++发展而来的面向对象和类型安全的编程语言。C#读作C Sharp，它和Java非常相近。<br><img src="/web/ASP.NET.png" width="80%"></li></ul><h5 id="C-程序的基本结构"><a href="#C-程序的基本结构" class="headerlink" title="C#程序的基本结构"></a>C#程序的基本结构</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System  //名称空间</span><br><span class="line">class Hello&#123;</span><br><span class="line">static void Main()&#123;</span><br><span class="line">Console.WriteLine(&quot;Hello, World&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>using System使用了由Microsoft.NET类库中提供的System名称空间，用来组织类库的分层。分层的类库之间用操作符“.”表示上下级分层关系。</li><li>使用“using”后，就可无障碍地使用名称空间中的各种类型成员，名称空间提供了一种用来组织一个类库的分层方法。</li><li>名称空间除具有避免名称冲突之功能外，更重要的是在引用名称空间后，就可在程序代码中方便地使用系统提供的各种类库成员。</li></ul><h5 id="C-中的数据类型"><a href="#C-中的数据类型" class="headerlink" title="C#中的数据类型"></a>C#中的数据类型</h5><ul><li>数据类型<ul><li>简单类型</li><li>枚举类型</li><li>结构类型</li></ul></li><li>引用类型：对于引用类型，两个变量可引用相同的对象，因而可能出现对一个变量的操作影响到其他变量所引用对象的情况<ul><li>类类型</li><li>接口类型</li><li>代表类型</li><li>数组类型 </li></ul></li></ul><h5 id="C-变量声明及其初始化"><a href="#C-变量声明及其初始化" class="headerlink" title="C#变量声明及其初始化"></a>C#变量声明及其初始化</h5><ul><li>C#语言是一种强类型的语言，在使用变量前必须对该变量的类型进行声明，建议在声明变量时就对变量进行初始化。</li><li>变量名必须以英文字母或@开头，由字母、数字、下划线组成，不能有空格、标点、运算符号、C#中关键字名、C#中库函数名，且大小写敏感。<br><img src="/web/variable.png" width="80%"></li></ul><h5 id="C-枚举类型"><a href="#C-枚举类型" class="headerlink" title="C#枚举类型"></a>C#枚举类型</h5><ul><li>C#中定义常量用const修饰符，例如“public const double y=1.234;”。枚举类型是由一组特定常量构成的一种数据结构，是值类型的特殊形式。</li><li>当需要一个有指定常量集合组成的数据类型时，可使用枚举类型。</li><li>枚举类型不能实现接口、不能定义方法、属性、事件。</li></ul><h5 id="C-表达式"><a href="#C-表达式" class="headerlink" title="C#表达式"></a>C#表达式</h5><ul><li>算数表达式<ul><li>用算术操作符把数值连接在一起的、符合C#语法的表达式称为算术表达式。</li><li>算术操作符：+、–、*、/、%、++、– –</li><li>二进制操作符：&amp;（与）、|（或）、^（异或）、～（补）、&lt;&lt;（左移）、&gt;&gt;（右移）</li></ul></li><li>赋值表达式<ul><li>赋值操作符用于为变量、属性、事件或索引器元素赋予新值。</li><li>赋值操作符的运算对象、运算法则及运算结果如下：<br><img src="/web/list.png" width="80%"></li></ul></li><li>关系表达式<ul><li>= =、!=、&lt;、&gt;、&lt;=和&gt;=等操作符称为关系操作符。用关系操作符把运算对象连接起来并符合C#语法的式子称为关系表达式。关系表达式要么返回true要么返回false。C#中还定义了is操作符，其格式为：A(值) is B(类型)，意义是如果A是B类型或者A可以转化为B类型则返回true，否则为false。</li></ul></li><li>逻辑表达式<ul><li>（&amp;&amp;（and）、||（or）和!（not）操作符称为逻辑操作符。用逻辑操作符把运算对象连接起来并符合C#语法的式子称为逻辑表达式。 </li></ul></li></ul><h5 id="C-控制语句"><a href="#C-控制语句" class="headerlink" title="C#控制语句"></a>C#控制语句</h5><ul><li>分支语句3种：<ul><li>三元运算符，例如：a=(b&gt;5)?100:10表示b&gt;5时a=100，否则a=10；</li><li>if语句（一次仅测试一个条件）；</li><li>switch语句（一次将测试变量与多个值比较）。</li></ul></li><li>循环语句4种：<ul><li>可用break和continue语句</li><li>跳出循环或继续执行循环。</li><li>foreach语句可以遍历一个集合中的所有元素。</li><li>try-catch-finally语句用来捕捉异常，使用语法与JavaScript语言<br>中的相似。在Web开发中应尽量少用捕捉异常来实现某些功能。<br><img src="/web/iffor.png" width="80%"></li></ul></li></ul><h5 id="C-类声明"><a href="#C-类声明" class="headerlink" title="C#类声明"></a>C#类声明</h5><ul><li>类声明就是定义新的引用类型。类是一种将数据成员、函数成员和嵌套类型等进行封装的数据结构，一个类可从其他类继承。其数据成员可以是常量或域，函数成员可以是方法、属性、索引、事件、操作符或静态构造函数和析构函数。构造函数在创建对象时被自动调用，用来执行对象的初始化操作，其函数名总是与类名相同。析构函数在释放对象时被调用，用来删除对象前做一些清理工作。</li><li>类中的每个成员都必须定义其被访问的范围，用类的访问修饰符来表示访问这个成员的程序文本的区域。类的访问修饰符有五种形式：</li></ul><h3 id="6-2-ASP-NET常用控件的使用介绍"><a href="#6-2-ASP-NET常用控件的使用介绍" class="headerlink" title="6.2 ASP.NET常用控件的使用介绍"></a>6.2 ASP.NET常用控件的使用介绍</h3><h5 id="ASP-NET控件"><a href="#ASP-NET控件" class="headerlink" title="ASP.NET控件"></a>ASP.NET控件</h5><ul><li>客户端控件：Web服务器对客户端控件不做任何处理，交由客户端浏览器来处理。</li><li>服务器端控件：需要占用Web服务器的内存、CPU等系统资源等来处理服务端控件，最终转变成客户端控件，再交由客户端浏览器来处理。</li><li>为提供网页访问速度，页面中<strong>尽量使用客户端控件</strong>。</li></ul><h5 id="服务器端标准控件"><a href="#服务器端标准控件" class="headerlink" title="服务器端标准控件"></a>服务器端标准控件</h5><ul><li>服务器端控件的常见属性<br><img src="/web/service.png" width="80%"></li><li>当某控件的EnableViewState属性为true时，表示该控件的值在页面刷新或回传重新显示页面后不会丢失，但却耗费网络资源和服务器资源。因此当页面回传后无须保值处理时应设为false</li></ul><ol><li>Label和Literal控件<ul><li>Label用来放置文本串，通过Text属性设置和显示文本。Text中可以包含其他HTML标记。<br><code>&lt;asp:Label ID=&quot;Lable1&quot; runat=&quot;server&quot; Text=&quot;Lable&quot;&gt;&lt;/asp:Lable&gt;</code></li><li>Literal和Label类似，text文本中不能添加任何HTML标记。<br><code>&lt;asp:Literal ID=&quot;Literall&quot; runat=&quot;server&quot;&gt;&lt;/asp:Literal</code></li></ul></li><li>TextBox文本框控件<ul><li>该控件用于获取用户输入的文本或显示文本。<br><code>&lt;asp:TextBox ID=&quot;TextBox1&quot; runat=&quot;server&quot;&gt;&lt;/asp:TextBox&gt;</code></li></ul></li><li>Image控件<ul><li>该控件是用来插入图片。<br><code>&lt;asp:Image ID=&quot;Image1&quot; runat=&quot;server&quot;&gt;</code></li></ul></li><li><p>Button、LinkButton、ImageButton控件</p><ul><li>分别表示普通按钮、超链接形式的按钮和图像按钮。允许用户通过单击来执行操作。每当用户单击按钮时，即调用Click事件处理程序。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;asp:Button ID=&quot;Button1&quot; runat=&quot;server&quot; Text=&quot;Button&quot; /&gt;</span><br><span class="line">&lt;asp:LinkButton ID=&quot;LinkButton1&quot; runat=&quot;server&quot;&gt;LinkButton&lt;/asp:LinkButton&gt;</span><br><span class="line">&lt;asp:ImageButton ID=&quot;ImageButton1&quot; runat=&quot;server&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>HyperLink控件</p><ul><li>用于制作文本或图片超级链接。<br><code>&lt;asap:hyperlink runat=&quot;server&quot;&gt;HyperLink&lt;/asp:hyperlink&gt;</code></li></ul></li><li><p>RadioButton和RadioButtonList单选按钮</p><ul><li>为用户提供由两个或多个互斥选项组成的选项集。</li><li>当用户选择某单选按钮时，同一组中的其他单选按钮不能同时被选定。</li><li>当单击RadioButton按钮时，其Checked属性设置为true，并且调用Click事件处理程序。</li><li>当Checked属性的值更改时，将引发Checked- Changed事件。用户可以通过用Text属性设置控件内显示的文本。<br><code>&lt;asp:hyperlink runat=&quot;server&quot;&gt;HyperLink&lt;/asp:hyperlink&gt;</code></li></ul></li><li><p>CheckBox、CheckBoxlist复选框</p><ul><li>该控件通常是成组使用，完成多重选项的目的。</li><li>这个控件与RadionButton控件相比，它们的相似之处在于都是用于指示用户所选的选项，不同之处在于，单选框一次只能选一个按钮，而复选框则可以选择任意数量。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;asp:checkbox runat=&quot;server&quot;&gt;&lt;/asp:checkbox&gt;</span><br><span class="line">&lt;asp:checkboxlist runat=&quot;server&quot;&gt;&lt;/asp:checkboxlist&gt;</span><br></pre></td></tr></table></figure></li><li><p>DropDownList控件</p><ul><li>使用户可以从下拉列表框中进行选择。其选择项列表在用户单击下拉按钮前一直保持隐藏状态，同时它不支持多重选择。<br><code>&lt;asp:dropdownlist runat=&quot;server&quot;&gt;&lt;/asp:dropdownlist&gt;</code></li></ul></li><li><p>ListBox列表框</p><ul><li>列表框通过显示多个选项供用户选择达到与用户对话的目的，如果候选项较多的时候它还可以自动地加上滚动条。</li><li>可通过设置列表框的Items属性来添加列表框的内容。在属性菜单中找到Items选项，鼠标单击右边的按钮，会弹出的ListItem集合编辑器，就可方便添加列表框中的每一项。<br><code>&lt;asp:listbox runat=&quot;server&quot;&gt;&lt;/asp:listbox&gt;</code></li></ul></li><li>FileUpload文件上载控件<ul><li>该控件可实现让用户在客户端选择一个文件,然后放到Web服务器的某个指定的文件夹下。<br><code>&lt;asp:fileupload runat=&quot;server&quot;&gt;&lt;/asp:fileupload&gt;</code></li></ul></li><li><p>Panel和Placeholder控件</p><ul><li>Panel和Placeholder控件都属于容器控件。容器控件是指该控件可以动态容纳其他控件或HTML元素。利用容器控件即可实现运行时刻动态添加内容到Web页中。</li><li>Panel和Placeholder控件（占位控件）转换成客户端HTML代码后，呈现为div元素。</li><li>Placeholder控件可将空的容器控件放置到页内，然后在运行时动态添加、删除子元素等。该控件只呈现其子元素，不呈现容器外观。</li><li>Panel控件在设计页面时就可添加其他控件，而且在运行过程中也允许动态添加控件。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;asp:panel runat=&quot;server&quot;&gt;&lt;/asp:panel&gt;</span><br><span class="line">&lt;asp:placeholder runat=&quot;server&quot;&gt;&lt;/asp:placeholder&gt;</span><br></pre></td></tr></table></figure></li><li><p>服务器端验证控件</p><ul><li>当用户输入不合法或输入错误时，验证控件可以显示错误信息。验证控件在正常工作情况下是不可见的，只有当用户输入数据有误时，它们才是可见的。</li></ul></li><li>数据访问空间<ul><li>数据源控件：实现对不同数据源的数据访问，主要包括连接数据源，使用SQL语句获取数据。</li><li>数据绑定控件：将数据源控件与数据绑定控件结合起来，以多种方式将数据显示在页面上。<br><img src="/web/data1.png" width="80%"><br><img src="/web/data2.png" width="80%"></li></ul></li></ol><h5 id="服务端控件使用注意事项"><a href="#服务端控件使用注意事项" class="headerlink" title="服务端控件使用注意事项"></a>服务端控件使用注意事项</h5><ul><li>使用控件进行Web开发的初学者很容易产生对服务器控件的依赖，几乎所有页面都采用服务器控件，HTML控件（客户端控件）被束之高阁，当然这是一种简便的编程方法，但却是一种不考虑运行效率的做法。</li><li>服务器控件意味着要消耗更多的网络带宽和服务器资源，而客户端控件的处理逻辑全部在浏览器中进行。因此不能养成使用服务器控件的习惯性思维，在使用控件的时候有必要思考一下采用客户端控件的可能性。</li></ul><h3 id="6-3-ASP-NET内置服务器对象"><a href="#6-3-ASP-NET内置服务器对象" class="headerlink" title="6.3 ASP.NET内置服务器对象"></a>6.3 ASP.NET内置服务器对象</h3><h5 id="常用内置服务器对象"><a href="#常用内置服务器对象" class="headerlink" title="常用内置服务器对象"></a>常用内置服务器对象</h5><ol><li>Page：指代Web窗体，设置或执行与Web窗体有关的属性、方法和事件</li><li>Response(Page的子对象)：决定服务器在什么时候或如何输出数据到客户端</li><li>Request(Page的子对象)：用来捕获由客户端返回到服务器的数据</li><li>Server(Page的子对象)：获取Web服务器对象的各项参数</li><li>Application(Page的子对象)：处理由不同客户端共享的变量</li><li>Session(Page的子对象)：处理由各个客户端专用的共享变量</li><li>Cookies：为Web应用程序保存访问者的信息</li></ol><h3 id="6-4-Web-config与Global-asax"><a href="#6-4-Web-config与Global-asax" class="headerlink" title="6.4 Web.config与Global.asax"></a>6.4 Web.config与Global.asax</h3><h5 id="Web-config-配置文件的使用"><a href="#Web-config-配置文件的使用" class="headerlink" title="Web.config 配置文件的使用"></a>Web.config 配置文件的使用</h5><ul><li>在VS中创建ASP.NET应用程序时会自动生成一个基于XML格式的web.config纯文本文件，可用来放置系统的相关配置信息。</li><li>Web.config可存在于应用程序的各个目录下，它决定了站点所在目录及其子目录的配置信息，并且子目录下的配置信息覆盖其父目录的配置。一般对～/web.config配置即可<h5 id="Global-asax文件的使用"><a href="#Global-asax文件的使用" class="headerlink" title="Global.asax文件的使用"></a>Global.asax文件的使用</h5></li><li>可对Global.asax文件的相关事件进行编程，<strong>实现网站访客数量统计</strong>等。</li></ul><h3 id="6-5-ADO-NET数据库访问技术"><a href="#6-5-ADO-NET数据库访问技术" class="headerlink" title="6.5 ADO.NET数据库访问技术"></a>6.5 ADO.NET数据库访问技术</h3><h5 id="关于ADO-NET"><a href="#关于ADO-NET" class="headerlink" title="关于ADO.NET"></a>关于ADO.NET</h5><ul><li>ADO.NET是.NET平台下的数据库访问技术，提供了断开式的数据访问模型；提供了与XML的紧密集成；提供了与.NET框架的无缝连接。</li><li>ADO.NET中有两个核心组成部分：数据提供程序Data Provider、数据集DataSet</li><li>DataSet是ADO.NET的断开式结构的核心组件，实现独立于任何数据源的数据访问，可用于多种不同的数据源，包括XML数据。它包含一个或多个DataTable对象的集合，这些对象由数据行和数据列以及主键、外键、约束和有关DataTable对象中数据关系组成。</li><li>Data Provider包括4个核心对象<ul><li>Connection：建立与特定数据源的连接</li><li>Command：对数据源执行数据库命令，用于返回和修改数据、运行存储过程等。</li><li>DataReader：从数据源中获取高性能的数据流，例如只进且只读数据流。</li><li>DataAdapter：用数据源填充DataSet，并可处理数据的更新。</li></ul></li><li>ASP.NET数据库应用操作步骤：<br><img src="/web/database.png" width="60%"></li><li>ADO.NET中连接数据库访问常用三种方式：<ul><li>ODBC：可连接各种数据库</li><li>OLEDB：可连接各种数据库</li><li>SQLClient：SQL Server数据库专用连接方式</li></ul></li></ul><h5 id="Connection对象"><a href="#Connection对象" class="headerlink" title="Connection对象"></a>Connection对象</h5><ul><li>建立与数据库的连接</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System.Data;</span><br><span class="line">using System.Data.OleDb;</span><br><span class="line"></span><br><span class="line">//新建一个Connection对象</span><br><span class="line">  OleDbConnection conn = new OleDbConnection();</span><br><span class="line"></span><br><span class="line">  conn.ConnectionString //设置数据库连接的字符串</span><br><span class="line">  conn.ConnectionTimeout //设置数据库连接超时，超过时间连不上数据库则停止连接</span><br><span class="line">  conn.DataSource//获取数据源服务器名或文件名</span><br><span class="line">  conn.State //获取当前数据库连接的状态</span><br><span class="line">  conn.Open  //进行数据库连接</span><br><span class="line">  conn.Close  //断开数据库连接</span><br><span class="line">  conn.Database //返回数据库名称或设置要连接的数据库</span><br><span class="line">  conn.ChangeDatabase//更改当前数据库</span><br><span class="line">  conn.BeginTransaction //开始数据库事务处理</span><br></pre></td></tr></table></figure><h5 id="Command对象"><a href="#Command对象" class="headerlink" title="Command对象"></a>Command对象</h5><ul><li>创建Command对象有四种方法，分别是（P337）：<ol><li>无参数</li><li>使用一个参数</li><li>使用两个参数</li><li>使用Connection对象的CreateCommand方法</li></ol></li></ul><h5 id="DataReader对象"><a href="#DataReader对象" class="headerlink" title="DataReader对象"></a>DataReader对象</h5><ul><li>DataReader对象用来从数据表中检索只读、只进的数据流，占用内存少、访问数据快，不能用它修改数据表记录。–<strong>数据库游标操作</strong></li></ul><h5 id="DataAdapter与Dataset-对象"><a href="#DataAdapter与Dataset-对象" class="headerlink" title="DataAdapter与Dataset 对象"></a>DataAdapter与Dataset 对象</h5><ul><li>DataSet通过DataAdapter填充数据后，可断开数据库的连接来操作其中的数据，而不影响数据库中的实际数据，直到你通过DataAdapter把数据更新到数据库。</li><li>Dataset对象可独立于各种数据源，无论什么类型数据源（数据库、XML文件</li><li>DataSet对象包含DataTable集合对象。通过DataTable又可生成数据视图DataView。</li><li>DataTable不仅是数据行（DataRow）和列（DataColumn）的集合，它包含了表的关系、主键及其约束等信息。</li></ul><h5 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h5><ul><li>Connection对象：只负责数据库连接而不关心结果集的表示。</li><li>Dataset对象：只关心访问操作数据，而不关心数据信息关联哪个Connection对象。</li><li>DataAdapter对象：作为Connection和DataSet对象之间的桥梁。<ul><li>将执行SQL语句后获得的结果集填充到DataSet对象中；将DataSet里增加、修改、更新后的数据返回到数据库中。</li></ul></li></ul><h5 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h5><ul><li>使用Command对象和DataAdapter对象实现不带参数存储过程调用</li><li>使用Command对象实现带参数存储过程调用</li><li>使用DataAdapter对象实现带参数存储过程调用</li></ul><h5 id="执行数据库事务"><a href="#执行数据库事务" class="headerlink" title="执行数据库事务"></a>执行数据库事务</h5><ul><li>数据库事务处理是把一组数据库操作合并为一个逻辑上的工作单元。要么在事务处理中的所有操作都得到执行，要么没有任何操作得到执行。</li></ul><h5 id="数据绑定技术"><a href="#数据绑定技术" class="headerlink" title="数据绑定技术"></a>数据绑定技术</h5><ul><li>数据绑定技术最通常的应用是把Web控件中用于显示的属性跟数据源绑到一起，从而在Web页面上显示数据。此外也可以使用数据绑定技术设置Web控件的其他属性。</li></ul><h3 id="6-6-用Visual-Studio创建和访问Web服务"><a href="#6-6-用Visual-Studio创建和访问Web服务" class="headerlink" title="6.6 用Visual Studio创建和访问Web服务"></a>6.6 用Visual Studio创建和访问Web服务</h3><ul><li>Saas是指软件部署在互联网上，你可免费或购买直接使用，例如我们使用的Gmail Web邮箱、阿里云邮箱、百度云管家就属于Saas的一种。</li><li>另一种Saas的应用就是网上提供的Web服务。Web服务实际上也是一个应用程序，它向外界提供了一个可以通过Web进行调用的API，也就是说可以用编程的方法调用这个程序。</li><li><strong>Web服务是一套标准，它定义了应用程序如何在Web上实现互相操作。</strong>可用任何语言在任何平台上编写Web服务，只要通过Web服务标准对这些服务进行查询和访问就行了（.Net上开发的Web服务，Java平台也可用）。要实现这样的目标，Web服务使用了XML技术和SOAP协议。<ul><li><strong>XML是在Web上传送结构化数据的有效方式</strong>，Web服务要以一种可靠的自动的方式操作数据，XML可以使Web服务方便地处理数据，十分理想地实现数据与表示的分离。</li><li>SOAP协议（Simple Object Access Protocol）是服务需求者向Web服务发送请求并接收应答的协议。<strong>SOAP的数据编码方式是基于XML的</strong>。</li></ul></li></ul><h5 id="Web服务的应用"><a href="#Web服务的应用" class="headerlink" title="Web服务的应用"></a>Web服务的应用</h5><ul><li><strong>实现跨防火墙的应用</strong><ul><li>能突破客户端和Web服务器之间的各种防火墙进行通信，采用传统的分布组件技术如DCOM可能会通信失败。</li></ul></li><li><strong>应用程序集成</strong><ul><li>可通过创建Web Services解决数据的互联互通。B2B大都采用这种方式。</li></ul></li><li><strong>软件和数据重用</strong><ul><li>软件重用最基本的形式是源代码、函数、模块或者类一级的重用，另外就是控件和组件的重用、框架的重用。Web Services不仅可重用代码，还可重用代码背后的数据，例如天气预报数据。</li></ul></li></ul><h3 id="6-7-Web开发中类库的构建与访问"><a href="#6-7-Web开发中类库的构建与访问" class="headerlink" title="6.7 Web开发中类库的构建与访问"></a>6.7 Web开发中类库的构建与访问</h3><ul><li>在Web开发过程中，可将许多通用的完成一定功能的方法或结构等独立出来，放在类库中，编译后形成一个动态链接库DLL文件，在Web应用程序中通过添加引用后，就可实现代码的重用。</li></ul><h2 id="7-AJAX技术"><a href="#7-AJAX技术" class="headerlink" title="7. AJAX技术"></a>7. AJAX技术</h2><h3 id="7-1-Ajax概述及开发案例"><a href="#7-1-Ajax概述及开发案例" class="headerlink" title="7.1 Ajax概述及开发案例"></a>7.1 Ajax概述及开发案例</h3><h5 id="Ajxa概述"><a href="#Ajxa概述" class="headerlink" title="Ajxa概述"></a>Ajxa概述</h5><ul><li>Ajax(Asynchronous Javascript and XML)是Jesse James Garrett于2005年提出的一种技术。</li><li>该技术的目标是让用户动态地与页面进行交互，加快服务器的响应速度，减少用户的等待时间，是一种创建交互式Web应用程序的开发技术。其技术的最简单描述就是实现局部刷新。(<strong>异步执行</strong>)</li><li>Ajax的局部刷新：<ul><li>通过<strong>异步数据交换和处理</strong>，显著提高Web应用程序运行效率。<br>Ajax不是新技术，是各个已有核心技术的创新应用。</li></ul></li><li>Ajax的核心是支持异步请求的XmlHttpRequest对象，使开发者可使用JavaScript向服务器提出异步请求并处理响应。</li><li>实现Ajax技术的应用开发主要有：<ul><li>直接基于XMLHttpRequest对象</li><li>利用各种Ajax框架，简化Ajax开发</li></ul></li></ul><h5 id="XmlHttpRequest对象的属性和方法"><a href="#XmlHttpRequest对象的属性和方法" class="headerlink" title="XmlHttpRequest对象的属性和方法"></a>XmlHttpRequest对象的属性和方法</h5><p><img src="/web/attributes.png" width="60%"><br><img src="/web/method.png" width="60%"></p><h3 id="基于Ajax的Web窗体"><a href="#基于Ajax的Web窗体" class="headerlink" title="基于Ajax的Web窗体"></a>基于Ajax的Web窗体</h3><ul><li>ASP.NET Ajax扩展中，Timer定时器用于定时异步刷新页面，例如定期刷新股票价格或天气情况。<br>UpdateProgress 控件提供一条等待信息让用户知道页面还在工作，最后的请求还在继续处理中，可用来显示“正在处理中，请稍后！”<ul><li>一个页面可包括多个UpdatePanel控件。Ajax技术可用来生成功能丰富、以客户端为中心的Web应用程序，使用户获得更好的用户体验（user experience）。</li><li>传统网站开始转型为单页Web应用（single page web application，SPA），如Gmail、Evernote等，可使用户无需网站地图、免除跳转网页的烦恼，使用户获得流畅的使用体验，这是Web应用程序的开发的一个方向，Ajax扮演重要角色。</li></ul></li></ul><h2 id="8-Web开发环境的建立"><a href="#8-Web开发环境的建立" class="headerlink" title="8. Web开发环境的建立"></a>8. Web开发环境的建立</h2><h3 id="8-1-关于Web站点规划"><a href="#8-1-关于Web站点规划" class="headerlink" title="8.1 关于Web站点规划"></a>8.1 关于Web站点规划</h3><h5 id="Web站点规划所包含的内容"><a href="#Web站点规划所包含的内容" class="headerlink" title="Web站点规划所包含的内容"></a>Web站点规划所包含的内容</h5><ol><li><strong>在Web站点建设前对市场进行分析</strong><ul><li>市场有什么特点？</li><li>是否适合在互联网上开展此业务？</li><li>市场竞争对手情况如何？</li><li>市场优势在哪儿？</li><li>有什么市场竞争力？</li></ul></li><li><strong>确定Web站点的目的和功能</strong><ul><li>要明确Web站点的建设目的是什么？</li><li>Web站点的功能有哪些？</li></ul></li><li><strong>根据Web站点规模确定Web站点建设的技术</strong><ul><li>用什么开发平台？</li><li>用什么开发技术？</li><li>安全性有什么要求？</li></ul></li><li><strong>确定Web站点建设的人力和投入费用</strong><ul><li>需要投入的人力和成本情况如何？</li><li>将来收益情况如何？</li></ul></li><li><strong>确定Web站点的测试方法和维护过程</strong><ul><li>Web站点建好后，要进行哪些测试？</li><li>如何测试？</li><li>站点维护有什么要求？</li></ul></li><li><strong>确定Web站点的推广策略</strong><ul><li>规划Web站点的推广策略？</li><li>广告推广、邮件推广、百度推广、论坛推广？</li></ul></li></ol><h5 id="Web站点的目录结构"><a href="#Web站点的目录结构" class="headerlink" title="Web站点的目录结构"></a>Web站点的目录结构</h5><ul><li>站点目录结构会对站点维护、站点扩充和站点移植带来影响，      Web站点目录结构的建立可遵循以下建议：<ul><li><strong>不要将网站内容全部放在一个目录中</strong>，按菜单栏目内容建立子目录。将网站内容全部放在一个目录中会造成文件管理混乱 <strong>不易于文件查找和维护</strong>。</li><li><strong>目录的层次不要太深</strong>，不超过3层，<strong>尽量用英文命名目录和文件名</strong>。目录路径过深，跳转的URL地址就会变长，增加了页面的链接复杂性。而使用中文命名会可能对网址的正确显示造成困难，尽量使用英文意义明确的目录名和文件名，便于维护和管理。</li></ul></li></ul><h5 id="设计Web站点的一般性原则"><a href="#设计Web站点的一般性原则" class="headerlink" title="设计Web站点的一般性原则"></a>设计Web站点的一般性原则</h5><ol><li><strong>以客户为中心进行Web站点设计</strong><ul><li>建设Web站点的目的是什么？</li><li>为谁提供服务和产品?</li><li>企业能提供什么样的产品和服务？</li><li>Web站点的目标消费者和受众的特点是什么？</li><li>企业产品和服务适合什么样的表现方式或风格？</li></ul></li><li><strong>总体设计方案主题鲜明</strong><ul><li>对Web站点的整体风格和特色做出定位，对Web站点的组织结构进行规划。</li><li>好的Web站点应主题鲜明、要点明确，要充分展现Web站点的个性和情趣，体现Web站点的特色。</li></ul></li><li><strong>网页形式与内容统一</strong><ul><li>运用对比与调和、对称与平衡、节奏与韵律以及留白等手。</li><li>利用空间、文字、图形之间的相互关系来达到整体的均衡以及和谐的美感。</li></ul></li><li><strong>Web站点的结构</strong><ul><li>应遵循结构清晰、导向清楚、使用方便的原则。</li><li>使用一些醒目的标题或文字来突出产品与服务，在导航设计中使用超文本链接或图片链接，且页面之间的链接关系要一目了然。</li></ul></li><li><strong>访问速度</strong><ul><li>通过网页减肥、Ajax技术等来加快访问速度，避免使用过多的图片及尺寸过大的图片</li></ul></li><li><strong>充分利用多媒体技术</strong><ul><li>为了吸引浏览者的注意力，页面内容可采用动画、Flash等形式来表现。</li></ul></li><li><strong>Web站点信息的动态发布</strong><ul><li>站点信息的不断更新，会让浏览者了解企业的最新发展动态和网上服务等，同时也会帮助企业建立良好的形象。</li><li>应在后台建立信息的动态发布机制及时更新企业站点内容。</li></ul></li><li><strong>提供和用户相互沟通的渠道</strong><ul><li>应建立和用户的沟通渠道，例如建立留言板和在线E-mail系统、短消息等</li></ul></li></ol><h3 id="8-2-建设Web站点的一般步骤"><a href="#8-2-建设Web站点的一般步骤" class="headerlink" title="8.2 建设Web站点的一般步骤"></a>8.2 建设Web站点的一般步骤</h3><ol><li><strong>Web站点的准备</strong><ul><li>进行可行性分析，规划出Web站点的大致结构。</li><li>考虑采用哪一种操作系统、Web服务器、邮件服务器、数据库服务器。进行数据库的初步规划，考虑开发和维护Web站点的费用预算。</li></ul></li><li><strong>域名注册</strong><ul><li>域名注册实际上就是申请Web站点的一个名称，以方便人们访问Web站点。</li><li>域名具有唯一性，是“企业的网上商标”。域名中.cn表示中国，.hk表示香港；.edu表示教育机构；.gov表示政府部门；.net表示网络服务部门；.ac表示科研机构。</li></ul></li><li><strong>Web站点的需求分析和总体设计</strong><ul><li>需求分析是网站设计的重要环节。在需求分析的基础上进行总体设计和数据库设计。</li><li>在此过程中确定站点建设所需要的软件和硬件配置、连接因特网的方式、运行和维护费用等。</li></ul></li><li><strong>确定Web站点的组织与风格</strong><ul><li>在上述工作基础上，确定Web站点的主页版面，色彩搭配等，勾画出整个Web站点系统的所有全貌，包括每个页面的版式布局、链接关系、注意事项等。</li><li>一个网页应包含Web站点名称、Web站点logo、网页标题、网页内容、指向主页的链接、指向其他网页的链接、版权陈述、Web站点的E-mail地址和其他联系方法等基本要素。</li></ul></li><li><strong>Web站点开发和运行环境的确定</strong><ul><li>Web站点运行在什么操作系统上？</li><li>采用什么数据库?采用什么样的Web服务器？采用什么开发平台和开发工具？</li></ul></li><li><strong>Web站点的开发和测试</strong><ul><li>Web站点的开发涉及到项目负责人、设计人员、程序员、网页制作人员和美工等，要实现协同开发。各个网页整合成网站后，要进行功能测试、性能测试、安全测试、稳定测试、浏览器兼容性测试、链接测试、压力测试等。</li></ul></li><li><strong>将Web站点接入Internet，并做好网站推广</strong><ul><li>可选择虚拟服务器/主机、服务器租用或托管、铺设专线来接通Internet。</li><li>通过各种有效的手段提高Web站点知名度，提升Web站点访问量。</li></ul></li><li><strong>Web站点的运行安全和维护管理</strong><ul><li>Web站点安全性包括身份窃取、非授权存取、否认、拒绝服务等。及时修复站点服务器操作系统漏洞，精心配置Web服务器、数据库服务器的各项参数。</li><li>Web站点维护包括服务器的维护、站点程序的维护、内容的更新和信息的发布等。</li></ul></li></ol><h3 id="8-3-Web站点性能优化及安全性"><a href="#8-3-Web站点性能优化及安全性" class="headerlink" title="8.3  Web站点性能优化及安全性"></a>8.3  Web站点性能优化及安全性</h3><h5 id="Web站点性能优化"><a href="#Web站点性能优化" class="headerlink" title="Web站点性能优化"></a>Web站点性能优化</h5><ul><li><strong>优化Web服务器硬、软件配置</strong>:<ul><li>为Web服务器增加缓冲代理机制和使用高性能服务器能明显改进Web站点访问速度，包括快速的磁盘、高性能网卡，强劲的CPU、大容量内存等；可通过对数据库服务器和Web服务器的配置在缓冲、压缩、带宽限制、进程限制等方面提高Web站点的性能。</li></ul></li><li><strong>改善Web应用程序的性能</strong>:<ol><li><strong>帮页面减肥</strong>：网页文件字节数越小，下载到浏览器的速度就快。因此将网页中的空格、注解及无用字符清除掉、调整JPEG图片文件大小等均可加快下载速度。有专门的网页减肥器软件可帮助减少网页的大小。</li><li><strong>尽量使用静态HTML页面，减少对Web服务器资源的占用</strong>：不要在Session中存放大的数据对象，当不需要Session时，应尽快将它从服务器内存中释放；由于Application对象一直会占用服务器资源，应少用或及时清理无用的Application对象。</li><li><strong>数据库方面的优化</strong>：数据库连接成功使用后，应及时关闭连接；使用存储过程加快数据处理；优化数据库查询语句以减少执行时间（比如不在查询语句中包含子查询语句、充分利用索引等）。</li><li><strong>其他</strong>：在编写Web应用程序时，采用一些技术手段可提高应用程序的性能。</li></ol></li></ul><h5 id="Web站点的安全性"><a href="#Web站点的安全性" class="headerlink" title="Web站点的安全性"></a>Web站点的安全性</h5><ul><li><strong>Web服务器的安全</strong><ul><li>采用NTFS分区；尽可能安装操作系统的最新服务包和修补程序；增强口令的安全性；停掉或卸载不必要的进程或服务。</li><li>设置Web内容目录的访问权限，授予匿名用户对所提供内容的适当只读访问权限。根据需要设置文件夹的读写访问权限。</li><li>安装防病毒软件和防木马软件等，启用计算机防火墙功能。仅留必要的端口号。</li><li>重要敏感信息通过设置虚拟目录来指定Web访问路径。</li><li>通过对Web访问的日志进行审计，可以发现一些对安全方面有帮助的信息。</li><li>配置URLScan过滤非法url，使其只允许应用程序中使用的扩展集</li></ul></li><li><strong>数据库服务器的安全</strong><ul><li>如应用程序不使用“命名管道”协议，则删除之。</li><li>限制数据库用户只具有用得到的数据库操作权限。</li><li>xp_cmdshell是扩展存储过程，可以执行操作系统级命令，该存储过程的功能通过SQL Server安装目录中的文件MSSQL\Binn\xplog70.dll获得，系统没用到xp_cmdshell则文件换名或删除掉。</li></ul></li><li><strong>Web站点应用程序的安全</strong><ul><li>采用登录名、密码、验证码进行登录，防止注入式攻击。验证码可防止以程序自动方式遍历登录账户和密码。将一串随机产生的数字或符号，生成一幅图片，图片里加上一些干扰像素，由用户肉眼识别其中的验证码信息，输入表单后提交网站进行登录验证。</li><li>在用户登录输入密码的时候，为防止木马程序非法录制按键操作，利用自定义软键盘让用户只能通过单击鼠标输入密码。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac OS X下连接校园网VPN [L2TP方式]</title>
      <link href="/macvpn/"/>
      <url>/macvpn/</url>
      
        <content type="html"><![CDATA[<p>以重庆大学校园网VPN为例，操作系统OS X 10.11.6。</p><ul><li>首先查看<a href="http://net.cqu.edu.cn/info/1025/1255.htm" target="_blank" rel="noopener">重庆大学校园网VPN说明</a>：</li></ul><blockquote><p>重庆大学VPN支持<strong>标准的PPTP和L2TP两种方式</strong>。用户在网络连接的设置中，新增虚拟专网VPN连接。VPN的地址请填写域名vpn.cqu.edu.cn，系统会自动解析相应地址。</p></blockquote> <a id="more"></a> <ul><li>打开<code>系统偏好设置</code> - &gt; <code>网络</code> - &gt; <code>右下角＋号</code>新建VPN服务<ul><li>接口：VPN</li><li>VPN类型：IPSec上的L2TP</li><li>服务名称：CQU VPN</li></ul></li><li>新建VPN完成后，<code>服务器地址</code>填写为<code>vpn.cqu.edu.cn</code>，账户名称为学号。</li><li><p>现在点击<code>链接</code>，输入密码(默认为身份证后六位)会提示，IPSec 共享密钥丢失。需要在终端进行进一步设置：</p><ul><li>在/etc/ppp/下创建options文件：<br><code>sudo vim /etc/ppp/options</code></li><li>在options文件中输入(键入A - &gt; INSERT)并保存(ESC - &gt; wq)</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugin L2TP.ppp</span><br><span class="line">l2tpnoipsec</span><br></pre></td></tr></table></figure></li><li><p>回到VPN设置，选择<code>高级</code>- &gt; <code>选项</code> - &gt; <code>通过VPN连接发送所有流量</code></p></li><li>再次点击连接VPN，连接成功。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac OS X </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记11 文件系统</title>
      <link href="/os11/"/>
      <url>/os11/</url>
      
        <content type="html"><![CDATA[<h4 id="文件系统接口-用户角度"><a href="#文件系统接口-用户角度" class="headerlink" title="文件系统接口(用户角度)"></a>文件系统接口(用户角度)</h4><h5 id="文件概念"><a href="#文件概念" class="headerlink" title="文件概念"></a>文件概念</h5><ul><li><strong><code>文件</code></strong>是逻辑外存单元的最小分配单元。</li><li><strong>类型</strong><ul><li>数据：数字字符，二进制…</li><li>程序</li></ul></li><li><p><strong>文件结构</strong></p><ul><li>无： 一个字节序列</li><li>简单的记录结构：①行 ②固定长度 ③可变长度</li><li>复杂结构：①格式化文档 ②对象文件 ③可执行文件</li></ul><a id="more"></a></li><li><strong>谁决定文件结构？</strong><ul><li>操作系统：可执行文件和共享库文件的结构</li><li>程序</li></ul></li><li><strong>文件属性</strong>：所有文件的信息都保存在目录结构中。<ul><li>名称：文件符号名称是唯一的、按照人们易读取的形式保存。</li><li>标识符：标示文件系统内文件的唯一标签，通常为人不可读。</li><li>类型：被支持不同类型的文件系统所使用。</li><li>位置：该信息指向设备和设备上文件位置的指针。</li><li>大小：文件当前大小，也可包括文件允许的最大容量值。</li><li>保护：决定谁能读、写、执行等的访问控制信息。</li><li>时间，日期和用户标识：文件创建、上次修改和赏赐访问的相关信息。这些数据用于保护、安全和使用跟踪。</li></ul></li><li><strong>文件操作</strong><ul><li>创建，打开，关闭，读，写，在文件内重定位(搜索目录相应条目)，删除，截短(删除内容保留属性，长度设置为0并释放)。</li><li>打开文件：当一个文件被打开时，除了存储在设备上的信息之外，还会执行几条数据来管理打开的文件<br>①<strong>文件指针</strong>：指向上次读取/写入位置的指针，这种指针对于打开文件的每个进程唯一。<br>②<strong>文件打开计数器</strong>：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间会不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件。该计数器跟踪打开和关闭的数量，当该计数为0 时，系统关闭文件，删除该条目。<br>③<strong>文件磁盘位置</strong>：绝大多数文件操作都要求系统修改文件数据。该信息保存在内存中以免为每个操作都从磁盘中读取。<br>④<strong>访问权限</strong>：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等)。该信息保存在进程的打开文件表中以便操作系统能允许或拒绝之后的 I/O 请求。</li></ul></li><li><strong>文件类型</strong><br><img src="https://i.loli.net/2018/06/19/5b2914df7a5d7.png" width="65%" height="80%"></li><li><strong>文件访问</strong>：文件访问<ul><li>顺序访问：从头开始读取所有字节/记录。不能跳转，但当存储设备是磁带时可以倒带或备份。</li><li>随机访问/直接访问：读/写顺序无限制。字节/记录以任何顺序读取，这种访问对数据库很重要。</li></ul></li></ul><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><ul><li><strong>目录操作</strong>：<ul><li>搜索文件</li><li>创建文件</li><li>删除文件</li><li>遍历目录</li><li>重命名文件</li><li>跟踪文件系统</li></ul></li><li><strong><code>单层目录结构</code></strong><ul><li>限制：①文件必须具有唯一名称(命名问题) ②(文件过多)分组问题<br><img src="https://i.loli.net/2018/06/19/5b28ff48b0896.png" width="55%" height="80%"></li></ul></li><li><strong><code>双层目录结构</code></strong><ul><li>为每个用户创建<strong>独立目录</strong></li><li>特点：①文件或目录可以按其路径定位 ②不同的用户可以使用相同文件名<br><img src="https://i.loli.net/2018/06/19/5b28ff4703f01.png" width="55%" height="80%"></li></ul></li><li><strong><code>树状目录结构</code></strong><ul><li>分组能力</li><li>禁止共享文件或目录</li><li>路径名有两种形式：①绝对路径名 ②相对路径名</li><li>每个进程都有一个当前目录，在启动时分配给它。<br><img src="https://i.loli.net/2018/06/19/5b28ff481348c.png" width="55%" height="80%"></li></ul></li><li><strong><code>无环图目录</code></strong>：树状结构目录的扩展<ul><li>允许目录含有共享子目录和文件。同一文件或子目录可出现在两个不同目录中。</li><li>某些操作系统不支持无环图目录，例如MS-DOS</li><li>UNIX/LINUX和Windows（7+）通过<strong>符号链接</strong>支持它<br><img src="https://i.loli.net/2018/06/19/5b29157df0de1.png" width="55%" height="80%"></li></ul></li></ul><h5 id="文件系统挂载"><a href="#文件系统挂载" class="headerlink" title="文件系统挂载"></a>文件系统挂载</h5><ul><li>文件系统在被系统上的进程使用之前必须安装/挂载。</li><li>目录结构可以建立在多个卷上。这些卷必须安装以使它们在文件系统命名空间可用。(U盘)</li><li>文件系统的安装位置称为<strong>安装点</strong>，为一个空目录。<ul><li>Windows操作系统在引导过程中安装包含FAT（-12，-16，-32）或NTFS文件系统的所有分区，分别是“C：”，“D：”等。</li><li>在UNIX / Linux中，系统管理员必须发出命令来在设备中安装文件系统。<code>mount -t iso9660 / mnt / cdrom / dev / cdrom</code></li></ul></li></ul><h5 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h5><ul><li>在多用户系统上共享文件是可取的。</li><li>大多数系统通过其唯一的用户标识或UID来识别用户。除了UID，一些系统还实现了组功能</li><li>每个组都分配一个唯一的组标识或GID。每个用户可以在一个或多个组中</li><li>当文件或目录最初创建时，它与用户的UID和GID相关联。拥有文件的用户是该文件的所有者。</li></ul><h5 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h5><ul><li>文件所有者应该能够控制可以完成什么以及由谁来完成</li><li>访问类型：读取（R），写入（W），执行（X），添加，删除，列表</li><li>访问控制列表（ACL）指定用户名和每个用户允许的访问类型。<ul><li>它用于执行细粒度的文件和目录保护。 ACL的主要问题是它们的长度。</li><li>因此，最常见的方法是将UNIX样式保护与ACL结合使用。</li><li>例如，Windows NT或更高版本以及Solaris 2.6或更高版本使用此组合方法。</li></ul></li></ul><h4 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h4><h5 id="文件系统结构"><a href="#文件系统结构" class="headerlink" title="文件系统结构"></a>文件系统结构</h5><ul><li>文件<ul><li>逻辑存储单元</li><li>相关信息的集合</li><li><strong>文件控制块(FCB)</strong>：包含文件的所有信息。在UNIX中，FCB通常称为inode</li></ul></li><li>文件系统：提供对磁盘的高效且便捷的访问，用以轻松地存储、定位和提取数据。<ul><li>在二级存储器中，采用分层结构实现文件系统能够最大限度地减少重复的代码。<br><img src="https://i.loli.net/2018/06/19/5b29075ab4052.png" width="20%" height="80%"></li></ul></li><li>一个典型的文件控制块FCB：<br><img src="https://i.loli.net/2018/06/19/5b29078f88bfe.png" width="35%" height="80%"></li></ul><h5 id="虚拟文件系统-VFS"><a href="#虚拟文件系统-VFS" class="headerlink" title="虚拟文件系统(VFS)"></a>虚拟文件系统(VFS)</h5><ul><li>问题：<ul><li>操作系统如何把多个文件系统整合成一个目录？</li><li>用户如何在访问文件系统空间时，可以无缝地在文件系统之间移动？</li></ul></li><li>虚拟文件系统(VFS)：</li><li>大多数操作系统包括UNIX使用面向对象的技术来简化，组织和模块化实现过程。  <ul><li>一个通用的文件系统接口与文件系统实现分离，文件系统接口包含“打开”，“关闭”，“读取”，“写入”和“查找”等系统调用。<br><img src="https://i.loli.net/2018/06/19/5b2909f0cae33.png" width="50%" height="80%"></li></ul></li><li><strong><code>VFS接口</code></strong>有两个重要功能：<ul><li>VFS层通过定义一个清晰的VFS接口，以将文件系统的通用操作和具体实现分开。</li><li>VFS提供了在网络上唯一标识一个文件的机制。VFS基于名为<strong>vnode</strong>的文件表示结构，该结构包含一个数值标识符以表示位于整个网络范围的唯一文件。</li></ul></li></ul><h5 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h5><ul><li>一些操作系统（包括UNIX）将目录完全视为文件<ul><li>它为每个文件或其子目录保存两条信息：文件/子目录名称和指向文件/子目录的FCB的指针（它们通常被组织成一个C“struct dirent”）</li></ul></li><li>一个目录可能包含很多文件或子目录，如何组织这些“dirent”？(Unix的一个结构体)</li><li><strong>线性列表</strong>：使用存储文件名和数据快指针的线性列表。<ul><li>√ 实现简单</li><li>× 搜索耗时</li></ul></li><li><strong>哈希表</strong>：线性列表存储结构 + 哈希数据结构<ul><li>√ 减少目录搜索时间，插入和删除也很简单。</li><li>× 其通常固定的大小和哈希函数对大小的依赖性。<strong>增长困难。</strong></li></ul></li><li>大多数操作系统使用“线性列表”来组织目录。</li></ul><h5 id="分配方法"><a href="#分配方法" class="headerlink" title="分配方法"></a>分配方法</h5><ul><li>如何为文件分配空间以便利用磁盘空间并快速访问文件？</li><li>三种主要分配方法<ol><li>连续分配</li><li>链接分配</li><li>索引分配</li></ol></li></ul><h5 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h5><ul><li>要求每个文件在磁盘上占用一组连续块。</li><li>优缺点：<ul><li>√ 简单：只有起始位置（块号）和长度（块数）保存在FCB中</li><li>√ 支持随机访问</li><li>√ 对缓存友好</li><li>× 产生外部碎片：动态存储分配问题</li><li>× 难以扩展文件<br><img src="https://i.loli.net/2018/06/19/5b290e7e8879c.png" width="50%" height="80%"></li></ul></li></ul><h5 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h5><ul><li>每个文件都是磁盘块的链接列表。<ul><li>FCB包含文件<strong>第一块的指针</strong>和<strong>最后一块的指针</strong>。</li><li>每个块包含一个指向下一个块的指针。</li><li>这些指针对用户不可见，因此，如果每个块是512字节,磁盘地址（指针）为4个字节，则用户看到508个字节的块。</li></ul></li><li>优缺点：<ul><li>√ 简单：只需要起始地址</li><li>√ 不浪费空间</li><li>√ 指针需要额外的空间</li><li>√ 没有随机存取，(用单项链表)只能顺序访问</li><li>× 可靠性：分散在整个磁盘上的指针</li></ul></li><li>指针的开销可以通过将几个块收集到一个称为群集的较大块中来降低</li><li>为了解决简单链接分配的问题，每个分区开始处的一段磁盘被放置在一旁，以包含一个包含文件系统所有指针的表。</li><li>文件分配表(FAT)：一个简单但有效的磁盘空间分配方法，<strong>用于MS-DOS和OS/2</strong>。<ul><li>每一个卷的开始部分用于存储该FAT。</li><li>每块都在该表中有一项。</li><li>该表可以通过块号码来索引。<br><img src="https://i.loli.net/2018/06/19/5b29116fb0aca.png" width="60%" height="80%"></li></ul></li></ul><h5 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h5><ul><li>将所有指向文件磁盘块的指针合并到一个位置：索引块。索引块包含一系列磁盘块地址。</li><li>解决了连续分配的外部碎片和大小声明问题。<br><img src="https://i.loli.net/2018/06/19/5b2912b622534.png" width="45%" height="80%"></li><li>优缺点<ul><li>√ 支持直接/随机访问</li><li>√ 没有外部碎片(但有索引块的开销)。</li><li>× 需要索引表。  </li></ul></li><li>索引块的大小：<ol><li>链接方案</li><li>多级索引</li><li>(以上两种)组合方案 (这是大多数UNIX文件系统使用的方案)<br><img src="  https://i.loli.net/2018/06/19/5b2913335d5d3.png" width="55%" height="80%"></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记10 虚拟内存</title>
      <link href="/os10/"/>
      <url>/os10/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul><li>自从有了计算机以来，我们就希望能够方便、高效地使用(今天仍然)十分有限的内存：<ol><li>用户总是可以认为自己计算机的<strong>内存大到足够运行任何程序</strong>。</li><li>程序员可以认为自己的程序将运行<strong>在巨大、连续的内存</strong>中。不需要用overlay或swap等技术来自己管理内存。</li><li>进程在运行过程中<strong>不能访问(包括读写)其他进程的数据</strong>，更<strong>不能访问属于操作系统的数据</strong>。而且某一个进程引起的问题不会波及到操作系统或其他进程。</li><li>由于内存有限，应该尽可能地<strong>共享一些公用的代码和数据</strong>。</li></ol></li><li><p>前面介绍的各种技术解决了上述问题的某一些方面，但没有提出一个整体的解决方案。</p><ul><li>虚拟内存技术基于已有的各种技术给出了一个完整的解决方案, 是20世纪计算机技术最重要的发明之一。</li></ul><a id="more"></a></li></ul><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><ul><li><strong><code>虚拟内存</code></strong>：将用户逻辑内存与物理内存的分离。<ul><li>为每个进程提供一个巨大的，连续的和私有的逻辑内存，可能比物理内存大得多。只有部分程序需要在内存中执行。</li><li>允许地址空间被多个进程共享，更有效的进程创建。<br><img src="https://i.loli.net/2018/06/19/5b28aed7c426e.png" width="40%" height="80%"></li></ul></li><li>虚拟内存可通过以下方式实现：<ul><li><strong>按需调页</strong></li><li>按需分段  </li></ul></li></ul><h4 id="按需调页"><a href="#按需调页" class="headerlink" title="按需调页"></a>按需调页</h4><ul><li><strong><code>按需调页</code></strong>：仅在需要时才调入相应的页，即<strong><code>懒惰交换</code></strong>。<ul><li>需要更少的 I/O 。</li><li>需要更少的内存。</li><li>响应更快。</li><li>更多的进程。</li></ul></li><li><strong>交换程序</strong>是对<strong>整个进程</strong>进行操作，而<strong>调页程序</strong>只对<strong>单个页</strong>进行操作。 因此按需调页需要使用调页程序。<br><img src="https://i.loli.net/2018/06/19/5b28b017d35a8.png" width="45%" height="80%"></li><li><strong><code>有效-无效位</code></strong>：当操作系统调度某个进程运行时，判断该进程的页面是否已经调入内存中。<ul><li>！每个页表项(PTE)都有一个有效无效位关联。</li><li>设置为“有效”：关联页面合法且在内存中。</li><li>设置为“有效”：该页面不合法(不在该进程的逻辑地址空间中)，或者是合法的，但是在磁盘上。<br><img src="https://i.loli.net/2018/06/19/5b28b144e932a.png" width="45%" height="80%"></li></ul></li><li>在MMU中的地址转换期间，如果PTE中的有效-无效位是“无效”<ol><li>CPU触发一个<strong><code>页面错误陷阱</code></strong>(<strong>page-fault</strong> trap)陷入操作系统。这种陷阱是由于操作系统未能将所需的页调入内存中引起的。</li><li>操作系统检查内部页表（通常与PCB一起保存）来确定该引用是合法还是非法的地址访问。<br>①引用非法，OS终止进程；②引用有效但尚未调入页面，OS将调入该页面。</li><li>找到一个空闲帧。</li><li>调度一个磁盘操作，以便将所需的页面调入刚分配的帧。</li><li>当磁盘操作完成后，修改进程的内部表和页表，以表示该页已在内存中</li><li>(CPU自动执行)重新开始因陷阱而中断的指令。进程现在能访问所需的页，就好像它似乎总在内存中。<br><img src="https://i.loli.net/2018/06/19/5b28b58f5e1f1.png" width="58%" height="80%"></li></ol></li><li>架构要求(硬件)<ol><li><strong>页表</strong>：该表能够通过<code>有效-无效位</code>或保护位，将条目设定为无效。</li><li><strong>次级存储器</strong>：该次级存储器用来保护不在内存中的页。次级存储器通常为快速硬盘。它通常称为交换设备，用于交换的这部分磁盘称为<strong><code>交换空间</code></strong>。</li><li>能在发生页面错误后<strong>准确重新执行指令</strong>。在出现页错误时，保持中断进程的状态(寄存器、条件代码、指令计数器)，必须能够按完全相同的位置和地址重新开始执行进程)。对于绝大多数情况，这种要求容易满足。</li></ol></li></ul><h4 id="页面置换"><a href="#页面置换" class="headerlink" title="页面置换"></a>页面置换</h4><ul><li>如果增加了多道程序的程度。那么会<strong><code>过度分配</code></strong>内存。</li><li>发生页面错误时，没有可用的空闲帧。如何进行？<ul><li>在内存中找到一个没有被充分使用的帧，将其分页。</li></ul></li><li><strong><code>页面替换</code></strong>：修改页<code>错误处理程序</code>以包括页置换。<strong>页面置换可以在较小的物理内存上提供大的虚拟内存</strong><br><img src="https://i.loli.net/2018/06/19/5b28ba339487d.png" width="58%" height="80%"><ol><li>查找所需页在磁盘上的位置。</li><li>查找一个空闲帧：<br>①如果有空闲帧，那么就使用它。<br>②如果没有空闲帧，那么就使用<strong>页面置换算法</strong>以选择一个<strong>牺牲“帧”</strong>。<br>③将“牺牲”帧的内容写到磁盘上，改变页表和帧表。</li><li>将所需页读入(新)空闲帧，改变页表和帧表。</li><li>重启用户进程。<br><img src="https://i.loli.net/2018/06/19/5b28bb1c5ee42.png" width="58%" height="80%"></li></ol></li><li>注意：<ul><li>如果没有帧空闲，则需要两次页传输：一次换入和一次换出。页面处理时间加倍。</li><li>可以通过将每页或帧与<strong>修改位</strong>（或<strong>脏位</strong>）通过硬件关联，来降低额外开销。<br>①每当页面被修改时，硬件就会设置该页的修改位以表示该页已修改。<br>②<strong>当修改位被设置时，才需要进行页换出操作。</strong></li></ul></li><li>页面置换是按需调页的基础。</li></ul><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><ul><li>算法目标：得到最低的页面错误率。</li><li>为了方便研究各种页面置换算法，计算各个算法所产生的页面错误，引入如下概念：<ul><li>引用串：内存引用的字符串。 通常以页面为单位。</li></ul></li><li>通过在引用串上运行页面置换算法，并计算该引用串上的<code>页面错误</code>数来评估算法。</li><li>页错误和帧数量图：<br><img src="https://i.loli.net/2018/06/19/5b28bde285b5f.png" width="40%" height="80%"></li><li>类型<ul><li>FIFO页置换</li><li>最优置换</li><li>LRU页置换</li><li>近似LRU页置换（二次机会算法）</li></ul></li></ul><h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><ul><li>页面错误率：0 ≤ p ≤ 1.0。<ul><li>如果p = 0，则不存在页面错误;</li><li>如果p = 1，则每个引用都会出现页面错误</li></ul></li><li>有效访问时间(EAT)<br>EAT = (1 - p) × (内存访问时间)+p × (页面错误时间)</li><li>一般来说，内存访问时间远小于处理页面错误的时间。因此，我们可以假设EAT与p成正比，即页面错误率。</li></ul><h5 id="FIFO页置换"><a href="#FIFO页置换" class="headerlink" title="FIFO页置换"></a>FIFO页置换</h5><ul><li>FIFO页置换：置换最旧的页。<br><img src="https://i.loli.net/2018/06/19/5b28c00a3454e.png" width="60%" height="80%"></li><li><strong><code>Belady</code>异常</strong>：一般情况下，page-fault会随着frame的数量增加而减少。但如果采用FIFO算法，<strong>情况有时并非如此</strong>。<br><img src="https://i.loli.net/2018/06/19/5b28c00a2b78c.png" width="40%" height="80%"></li></ul><h5 id="最优置换-OPT-MIN"><a href="#最优置换-OPT-MIN" class="headerlink" title="最优置换(OPT / MIN)"></a>最优置换(OPT / MIN)</h5><ul><li>最优置换：置换最长时间不会使用的页。</li><li>最优页面置换算法是所有算法中产生页错误率最低的。</li><li>最优置换难以实现，因为需要参考串的未来的知识。最优算法主要用于研究。<br><img src="https://i.loli.net/2018/06/19/5b28c1260fab8.png" width="60%" height="80%"></li></ul><h5 id="LRU页置换-最近最少使用算法"><a href="#LRU页置换-最近最少使用算法" class="headerlink" title="LRU页置换/最近最少使用算法"></a>LRU页置换/最近最少使用算法</h5><ul><li>FIFO算法使用的是页面调入的时间。OPT算法使用的是页将来使用的时间。</li><li>LRU页置换：置换最近最少使用的页面。近似的最佳页面替换。<br><img src="https://i.loli.net/2018/06/19/5b28c20f69818.png" width="60%" height="80%"></li><li>LRU置换可能需要一定的硬件支持来为页帧确定一个排序序列。有两种可行实现：①计数器 ②栈</li></ul><h5 id="近似LRU页置换"><a href="#近似LRU页置换" class="headerlink" title="近似LRU页置换"></a>近似LRU页置换</h5><ul><li>二次机会页置换算法/时钟置换算法：基本算法是FIFO置换算法。<ul><li>当要选择一个页时，检查其引用位。</li><li>如果值为0，则直接置换。如果访问位是1，就给它第二次机会。并选择下一个FIFO页面。</li><li>当一个页面得到第二次机会时，它的访问位就清为0，它的到达时间就置为当前时间。如果该页在此期间被访问过，则访问位置为1。  </li></ul></li><li>可以采用循环队列实现。<br><img src="https://i.loli.net/2018/06/19/5b28c30cbe814.png" width="45%" height="80%"><br><img src="https://i.loli.net/2018/06/19/5b28c30cbf0e9.png" width="50%" height="80%"></li></ul><h4 id="为什么虚拟内存运行良好？"><a href="#为什么虚拟内存运行良好？" class="headerlink" title="为什么虚拟内存运行良好？"></a>为什么虚拟内存运行良好？</h4><ul><li><strong><code>局部模型</code></strong>：<ul><li>局部：经常使用的页的集合。当进程执行时，它从一个局部移向另一个局部。</li><li>一个程序通常由多个不同局部组成。它们可能<strong>重叠</strong>(共享页面)。</li></ul></li><li>局部模型也是缓存工作正常的原因。</li><li>内存引用模式中的局部性：<br><img src="https://i.loli.net/2018/06/19/5b28c77b89a47.png" width="30%" height="80%"></li></ul><h4 id="颠簸"><a href="#颠簸" class="headerlink" title="颠簸"></a>颠簸</h4><ul><li>如果系统没有“足够”的帧，页面错误率非常高。 这导致：<ul><li>CPU利用率低。</li><li>长期调度员认为需要提高多程序的程度。</li><li>系统中增加了更多进程。</li></ul></li><li>颠簸：是一个系统忙于将页面导入和导出并且没有任何用处的情况。<ul><li>原因：所有局部大小的总和 &gt; 总内存大小<br><img src="https://i.loli.net/2018/06/19/5b28c84c5483c.png" width="40%" height="80%"></li></ul></li></ul><h4 id="工作集合模型"><a href="#工作集合模型" class="headerlink" title="工作集合模型"></a>工作集合模型</h4><ul><li><strong><code>工作集合模型</code></strong>是基于局部性假设的。<ul><li>该模型使用参数 &Delta; 定义<strong>工作集合窗口</strong></li><li>这最近 &Delta; 个引用的页面集合称为<strong>工作集合</strong>。因此，工作集是进程的局部性的近似值。</li></ul></li><li><p>将WSS<sub>i</sub>表示为最近进程P<sub>i</sub>的工作集。D为总的帧需求量。</p><ul><li>D = &Sigma; WSS<sub>i</sub></li><li>如果D &gt; 可用帧的数量，有的进程就会得不到足够的帧，从而会出现颠簸。<br><img src="https://i.loli.net/2018/06/19/5b28c9f434159.png" width="70%" height="80%"></li></ul></li><li><p>使用工作集合模型</p><ul><li>操作系统监视每个进程的工作集合，并为其分配大于其工作集合的帧数。</li><li>如果还有空闲帧，那么可以启动另一进程。</li><li>如果所有工作集合大小之后 &gt; 可用帧的总数，那么操作系统会选择暂停一个进程。</li><li>工作集合策略可以防止颠簸，并尽可能保持多道程序的程度。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记09 内存管理</title>
      <link href="/os9/"/>
      <url>/os9/</url>
      
        <content type="html"><![CDATA[<h4 id="内存管理介绍"><a href="#内存管理介绍" class="headerlink" title="内存管理介绍"></a>内存管理介绍</h4><ul><li>进程管理回顾 <ul><li>进程管理提供了一个虚拟的机器接口，让每一个进程都以为是自己在独占CPU，如下图所示:<br><img src="https://i.loli.net/2018/06/18/5b27ad8cd9ef4.png" width="50%" height="80%"></li></ul></li><li><p>内存管理的任务：提供一个虚拟的机器接口，让每一个进程都以为是自己在独占RAM。</p><a id="more"></a></li></ul><h4 id="基本方法-以MS-DOS为例"><a href="#基本方法-以MS-DOS为例" class="headerlink" title="基本方法 - 以MS-DOS为例"></a>基本方法 - 以MS-DOS为例</h4><ul><li>MS-DOS (Microsoft Disk Operating System)<ul><li>单用户、单任务 只能访问1MB内存：INTEL 8086/80286只有20根地址线</li><li>没有任何保护机制：INTEL 8086/80286没有提供硬件保护机制支持</li></ul></li><li>在MS-DOS中, MS-DOS自己要占用1/3左右; 剩余部分留给系统唯一的进程使用。</li><li>问题1：如果某个MS-DOS下的应用程序<strong>需要超过640K的内存才能运行</strong>,怎么办?</li><li><strong><code>覆盖</code></strong>：一种允许内存能分配的小于一个进程中所需空间的技术。<ul><li><strong>基本原理</strong>：只保留在任何给定时间需要的指令和数据。程序运行时<strong>并非任何时候都要访问程序及数据的各个部分</strong>，因此可以把用户空间分成一个固定区和若干个覆盖区。经常活跃的部分放在固定区，其余部分按调用关系分段。在覆盖区和外存(即磁盘)中屡次<strong>调入调出</strong>。除了程序本身外，程序员还要提供一个所谓的“overlay driver”来负责模块的调入调出。</li><li>无论进程在运行时占有多大的内存,在某一段时间内，它<strong>只会访问其中的一部分</strong>。</li><li><strong>打破</strong>了必须将一个进程的全部信息装入主存后才能运行的<strong>限制</strong>。</li></ul></li><li>目前覆盖技术已经<strong>很少被使用</strong>，除了在一些内存资源相当紧张的<code>嵌入式系统</code>中。</li><li><p>假设MS-DOS支持多任务,即系统中有多个进程。</p><ul><li>进程必须在内存中才能运行。</li><li>运行中的进程可能会申请额外的内存。</li></ul></li><li><p>问题2：假设系统目前有两个进程：P<sub>1</sub>和P<sub>2</sub>，而且系统已经没有内存可以使用。此时，正在运行的P<sub>1</sub>又要申请更多的内存才能继续运行，怎么办?</p></li><li><strong><code>交换</code></strong>：一个进程可以<strong>暂时</strong>从内存交换到backing-store，然后再加载到内存中<strong>继续执行</strong>。<ul><li>OS可以将(不在运行的)P<sub>2</sub>交换到backing-store中，同时释放P<sub>2</sub>所占用的内存，并分配给P<sub>1</sub>让其继续运行。</li><li>当调度器重新调度P<sub>2</sub>运行时，OS从backing-store中加载P2到内存继续运行。</li><li>此时可能要把P<sub>1</sub>交换到backing-store中以释放足够的内存空间供P<sub>2</sub>运行。<br><img src="https://i.loli.net/2018/06/18/5b27b3384a591.png" width="50%" height="80%"></li></ul></li><li><strong>Swap方法存在的限制</strong>：<ul><li>要求计算机必须有<strong>足够大的备份存储</strong>。备份存储一般是快速、大容量的硬盘。</li><li><strong>上下文切换要花费大量的时间</strong>：主要用于磁盘数据传输。调度算法的设计尤其重要，应尽量减少上下文切换。</li><li>被swap-out的进程必须被重新swap-in到<strong>相同的内存地址</strong>才能继续运行。</li></ul></li><li>这种原始的swap-in/out已经<strong>很少被使用</strong>。但是，swap的思想非常重要：当系统内存不足时，可以向备份存储“借”一部分来使用。</li></ul><h4 id="多任务系统的内存管理"><a href="#多任务系统的内存管理" class="headerlink" title="多任务系统的内存管理"></a>多任务系统的内存管理</h4><ul><li>多任务环境下会带来许多内存管理问题：<ul><li>重定位(relocation)问题</li><li>内存保护(protection)问题</li><li>内存分配(allocation)问题</li></ul></li></ul><h5 id="源程序变成进程的过程："><a href="#源程序变成进程的过程：" class="headerlink" title="源程序变成进程的过程："></a>源程序变成进程的过程：</h5><ul><li>程序员编写的<strong>源代码</strong>必须先被编译成<strong>目标文件</strong>。</li><li>然后通过<strong>链接器</strong>链接成<strong>可执行文件</strong>。</li><li>最后由操作系统<strong>加载</strong>可执行文件到内存从而<strong>形成进程</strong>。</li></ul><h5 id="重定位-amp-地址绑定概念"><a href="#重定位-amp-地址绑定概念" class="headerlink" title="重定位 &amp; 地址绑定概念"></a>重定位 &amp; 地址绑定概念</h5><ul><li>在多任务的环境中，可执行文件可能会被加载到内存中的任何位置运行。</li><li>链接器在生成可执行文件时必须确定程序中各个符号(如函数、全局变量)的地址。<ul><li>把程序中的符号映射为地址的过程叫做<strong><code>地址绑定</code></strong>。</li></ul></li><li>事实上，由于链接器无法预知程序将被加载到哪个内存位置，因此无法完成绝对的地址绑定。</li><li>因此，链接器只能假定程序中第一条指令的地址是0，从而用相对于它的<strong>偏移量</strong>来进行相对的<strong>地址绑定</strong>。</li><li>这样的程序只能被加载到0地址的内存运行。如果该程序被加载到其他非0的地址，必须对程序中所引用的地址进行修改才能运行，这个修改过程就称为<strong><code>重定位</code></strong>。</li><li>几个概念：<ul><li>逻辑地址：指<strong>程序中引用的地址</strong>，亦即CPU产生的地址。</li><li>物理地址：指系统中内存单元所看到的地址。</li><li>内存管理单元：指专门完成逻辑地址到物理地址<strong>转换</strong>的硬件单元，一般是CPU的一部分。<br><img src="https://i.loli.net/2018/06/18/5b27b73f52d0f.png" width="50%" height="80%"></li></ul></li><li>这里介绍的是最简单的重定位技术，只是冰山一角。</li><li>今天使用的操作系统(如Windows, Linux)所采用的重定位技术相当复杂，涉及到编译器、链接器、可执行文件、函数库、操作 系统内核和硬件等多个组件之间的协作才能完成。</li></ul><h5 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h5><ul><li>在多任务的环境中，必须要保护各个进程的内存不被其他进程访问或破坏。<ul><li>其实，即使在单任务的环境中也存在着操作系统如何保护自己不被应用程序访问或破坏的问题。 在MS-DOS中，应用程序可以合法地把MS-DOS的内核所占的内存全部破坏。</li></ul></li><li>对应用程序访问的每一个内存地址进行检查，看是否超出了内存范围。为了获得最好的性能，一般用<strong><code>内存管理单元</code></strong>(MMU)通过硬件来实现这种检查的功能。</li><li>内存保护是现代操作系统必备的功能之一，它需要硬件的支持才能实施保护。</li><li>后面讲解的各种内存管理方法都包含有内存保护的方法。<br><img src="https://i.loli.net/2018/06/18/5b27b98f2c33e.png" width="60%" height="80%"></li></ul><h5 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h5><ul><li>在多任务的环境中，操作系统需要为每个新创建的进程分配一定数量的内存才能运行。当进程退出时，操作系统要回收它所占用的内存。</li><li>操作系统如何有效地管理内存的分配和回收，以尽量满足进程的需求？这个问题也称为<strong><code>动态内存分配问题</code></strong>。</li><li>操作系统有一张表格，用于指出哪些内存可用和哪些内存已被占用。可用内存块称为<strong>孔</strong>。<ul><li>最初，所有内存都可用于用户进程。</li><li>当有新进程需要内存时，为该内存查找足够大的孔。</li><li>当一个进程终止时，它将释放内存，如果新的孔与其他孔相邻，这些相邻的孔合并形成一个更大的孔。<br><img src="https://i.loli.net/2018/06/18/5b27beab9738f.png" width="50%" height="80%"></li></ul></li><li>分配算法<ul><li><strong>首次适应</strong>：分配第一个足够大的孔。</li><li><strong>最佳适应</strong>：分配最小的足够大的孔。</li><li><strong>最差适应</strong>：分配最大的孔。 </li></ul></li><li>另一种方法：把系统内存分成固定大小的内存块，操作系统以块为单位进行内存的分配和释放。最终分配给进程的内存可能会比所请求要多一点，称多出来的这部分为<strong><code>内部碎片</code></strong>。</li><li>分配主要解决在多任务的环境中，操作系统采用什么算法进行内存的分配和回收，减少<strong><code>外部碎片</code></strong>或<strong>内部碎片</strong>，提高内存利用率。相对于外部碎片，内部碎片的情况不是很严重。</li><li>事实上，内存的分配和回收问题不仅出现在OS中，应用程序面临着同样的问题。<ul><li>当进程被创建时,操作系统会采用某种算法分配一块足够大的内存给进程,由进程自己管理(其中的一部分)。</li><li>eg. heap由进程自己管理。库函数new/delete(或malloc/free)就是操纵heap中的内存。它们所采用的分配与回收算法非常通用，相应的空间和时间利用率也很一般。在一个大型的项目中，已有的库函数可能不会满足应用的要求，需要自己开发更好的来替换它们以负责heap中内存的分配与回收。</li></ul></li></ul><h4 id="分页内存管理"><a href="#分页内存管理" class="headerlink" title="分页内存管理"></a>分页内存管理</h4><ul><li>基本内存管理方法存在着很大的限制：<ul><li>每个进程所占用的物理内存<strong>必须连续</strong>。</li><li>系统可能会<strong>产生大量外部碎片</strong>，最后不可避免地要进行compaction。</li><li>对<strong>整个进程</strong>进行(<strong>交换</strong>)swap-in/swap-out非常地<strong>耗时</strong>。</li></ul></li><li>分页很好地解决了上面的问题：<ul><li>进程所占用的物理内存<strong>不必连续</strong>。</li><li>没有外部碎片，但是会<strong>产生</strong>一定的<strong>内部碎片</strong>。</li><li>对进程所占用的<strong>部分内存</strong>进行swap-in/swapout。</li></ul></li><li>在早期，分页系统主要由<strong>硬件</strong>来实现。如今分页由<strong>硬件和操作系统</strong>共同完成。</li><li>基本概念：<ul><li>将物理内存分为固定大小的块，称为<strong><code>帧</code></strong>。</li><li>将逻辑内存也分为同样大小的块，称为<strong><code>页</code></strong>。</li><li><strong><code>页表</code></strong>包含每页所在物理内存的基地址，用于页到帧的映射。</li><li>页表的一个条目称为<strong><code>页表项（PTE）</code></strong>。</li></ul></li><li>把逻辑地址分成两部分: <ul><li>第一部分称为<strong><code>页号(p)</code></strong>，页号作为页表的索引。 </li><li>第二部分称为<strong><code>页偏移(d)</code></strong>。</li></ul></li><li>地址转换：在页表的帮助下，MMU把CPU产生的逻辑地址转换成物理地址。</li><li>过程如图：<br><img src="https://i.loli.net/2018/06/18/5b27c49f4dbb7.png" width="50%" height="80%"></li><li>两个例子：<br><img src="https://i.loli.net/2018/06/18/5b27c48c6758f.png" width="37%" height="80%"><br><img src="https://i.loli.net/2018/06/18/5b27c486e7c06.png" width="37%" height="80%"></li><li>页 &amp; 帧:<ul><li>它们的大小必须相同，都是2的幂次方。</li><li>具体由CPU体系结构决定，常见的有1K、4K、8K、4M等。</li></ul></li><li>地址划分<ul><li>如果逻辑地址空间的大小为2<sup>m</sup>，而page或frame的大小为2<sup>n</sup>(n &lt; m)，那么逻辑地址的划分如图所示：<br><img src="https://i.loli.net/2018/06/18/5b27c4e64d7b4.png" width="37%" height="80%"></li></ul></li></ul><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><ul><li>分页的一个重要方面是用户的内存视图和实际物理内存之间的明确分离。地址翻译硬件使这些差异得到调和。该<strong>映射对用户是隐藏的</strong>，由操作系统控制。</li><li>由于是操作系统在控制地址映射，它必须记录系统物理内存的使用状况。<ul><li>通常使用一个称为<strong><code>帧表</code></strong>的数据结构来保存系统中每一个帧的状态，如果占用，被哪个(些)进程的哪个页所占用。</li><li>为每一个进程保存一个页表，只包括进程所拥有的那些页。</li></ul></li></ul><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ul><li>页表必须被保存在内存中。CPU中的两个寄存器记录了它的信息:<ul><li>页表基寄存器(PTBR)：保存了页表的地址。</li><li>页表长度寄存器(PTLR)：保存了页表的大小。</li></ul></li><li>因此在分页中,每一个内存访问都需要两次内存操作：一次访问页表，一次访问内存数据。考虑到CPU访问内存的频率，这种<strong>地址转换成了系统性能的颈瓶</strong>。</li><li>为了提高地址转换效率，MMU中包含了一个高速缓存称为<strong><code>转换表缓冲区(TLBs)</code></strong>。</li><li>TLB条目由<strong>键和值</strong>组成，当关联内存根据定值查找时，会同时与所有键进行比较，如果找到条目，那么就得到相应的值域。<ul><li>TLB这种查找方式比较快。但由于硬件昂贵，通常TLB的条目数并不多，在64-1024之间。</li><li>A的地址转换：如果A在TLB（<strong>TLB命中</strong>）中，则将帧取出。否则，从<strong>内存中的页表获取帧。</strong><br><img src="https://i.loli.net/2018/06/18/5b27c9366d11f.png" width="47%" height="80%"></li></ul></li><li><strong>性能</strong>：假设<ul><li>TLB查找时间 = x</li><li>存储器周期时间为1微秒（10<sup>-6</sup>秒)</li><li>TLB命中率 = y，在TLB中找到页码的次数的概率百分比。</li></ul></li><li>有效访问时间 EAT = (1 + x) y + (2 + x) (1 - y) = 2 + x - y</li></ul><h5 id="内存保护-1"><a href="#内存保护-1" class="headerlink" title="内存保护"></a>内存保护</h5><ul><li>在<strong>分页系统</strong>中，<strong>内存保护是以页为单位</strong>。 <ul><li>保护信息通常都保存在PTE中， 可以提供只读、读写和执行(RWX - Read, Write, eXecute)保护。</li></ul></li><li>此外，不是所有的PTE都可以使用。因此，PTE中的一位表示该PTE是否可以使用(valid/invalid)。<ul><li>仅当该位有效时，MMU才能用它进行地址转换。 否则，MMU将通过异常向OS报告错误。<br><img src="https://i.loli.net/2018/06/20/5b29bf28312c1.png" width="50%" height="80%"></li></ul></li></ul><h5 id="页表问题"><a href="#页表问题" class="headerlink" title="页表问题"></a>页表问题</h5><ul><li>假设：<ul><li>逻辑地址空间大小：2<sup>32</sup>，即4GB。</li><li>page和frame的大小：2<sup>12</sup>，即4KB。</li><li>sizeof(PTE) = 4B。</li></ul></li><li>一个页表要消耗多少内存?<ul><li>(2<sup>32</sup> / 2 <sup>12</sup>) × 4 = 4MB</li></ul></li><li>记住：每一个进程都需要一个页表。</li><li>一个只有256MB内存的系统如何能同时运行几十个进程呢?</li></ul><h5 id="页表结构"><a href="#页表结构" class="headerlink" title="页表结构"></a>页表结构</h5><ul><li>事实上，很少的进程会使用整个地址空间(如32位机器上的4GB和64位机器上的2<sup>64</sup>B );<ul><li>页表中大部分的PTE都是处于invalid状态。 </li><li>OS无法预测一个进程的页表大小，因此只能根据进程使用内存的情况动态地伸缩。 </li><li>显然线性的页表结构太简单，不能满足这个要求，需要新的页表结构。</li></ul></li><li>现有的页表结构:<ul><li>层次型页表 Hierarchical Page Tables</li><li>哈希页表 Hashed Page Tables</li><li>反向页表 Inverted Page Tables</li></ul></li></ul><h5 id="层次型页表"><a href="#层次型页表" class="headerlink" title="层次型页表"></a>层次型页表</h5><ul><li>这种方法采用“树”结构来组织页表,形成一个层次结构的页表。<ul><li>根据这颗树的深度可以分为:一、二、三级页表等。其中，一级页表(也称为单级页表)就退化成了线性页表。</li><li>这里以32位逻辑地址、页面大小为4KB为例来讲解二级页表。</li></ul></li><li>二级页表设计：<ul><li>把一个巨大的线性页表分割成很多小的页表。</li><li>然后通过一个称为<strong><code>外页表</code></strong>(outer page table)的表把这些小页表组织起来。<br><img src="https://i.loli.net/2018/06/19/5b2895ea7742b.png" width="40%" height="80%"></li><li>采用二级页表的逻辑地址与地址转换<br><img src="https://i.loli.net/2018/06/19/5b2896f44e766.png" width="46%" height="80%"><br><img src="https://i.loli.net/2018/06/19/5b28982d23bff.png" width="35%" height="80%"></li></ul></li></ul><h4 id="帧管理"><a href="#帧管理" class="headerlink" title="帧管理"></a>帧管理</h4><ul><li>前面介绍了页面的管理，以及页面到帧的映射。但是，<strong>最终保存数据的地方是帧</strong>，而不是页面。 </li><li>操作系统需要管理系统中所有帧的分配和回收,<ul><li>当进程被创建时，操作系统要分配足够多的帧给它，并在该进程的页表中做相应的映射。</li><li>当进程退出时，操作系统回收它所占用的帧。</li></ul></li><li>最简单的方法是维护一个空闲帧链表。如图所示:<br><img src="https://i.loli.net/2018/06/19/5b2897f562b1d.png " width="47%" height="80%"></li></ul><h4 id="页面共享"><a href="#页面共享" class="headerlink" title="页面共享"></a>页面共享</h4><ul><li>在<strong>分页系统</strong>中,显然应该<strong>以页面为单位进行内存共享</strong>。<ul><li>eg. 假设系统中有三个用户同时运行某个编辑器在编辑各自的文件，显然编辑器的代码可以被共享，而各自的文件数据则是私有的。<br><img src="https://i.loli.net/2018/06/19/5b28990756fee.png" width="47%" height="80%"></li></ul></li></ul><h4 id="分段内存管理"><a href="#分段内存管理" class="headerlink" title="分段内存管理"></a>分段内存管理</h4><ul><li>为什么分段？<ul><li>通常用户<strong>不会</strong>将内存视为一个<strong>线性字节数组</strong>，有的包含指令而其它的包含数据。</li><li>用户通常愿意将内存视为一组<strong>长度不同的段的集合</strong>。分段就是支持这种</li></ul></li><li><strong><code>分段</code></strong>把进程的<strong>逻辑地址空间</strong>分成一个个<strong>大小不等</strong>的段，每一段集中了一种类型的数据，如代码，数据，栈等等。<ul><li>与分页系统一样，这些段在物理内存中也不一定是连续的</li></ul></li></ul><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><ul><li><p>逻辑地址由有序对组成：&lt;segment-number, offset&gt; (&lt;段号，段内偏移&gt;)。(为了简单，段是编号的段号而不是通过段名来引用)<br><img src="https://i.loli.net/2018/06/19/5b28ab03eefee.png" width="20%" height="80%">&lt;img src=”<a href="https://i.loli.net/2018/06/19/5b28ab0404f03.png&quot;" target="_blank" rel="noopener">https://i.loli.net/2018/06/19/5b28ab0404f03.png&quot;</a> width=40%” height=”80%” /&gt;</p></li><li><p><strong><code>段表</code></strong>用于将逻辑地址映射到物理地址。 每个表项都有</p><ul><li>段基地址：含该段在内存中开始的物理地址。</li><li>界限：指定该段的长度。<strong>段表长度不固定，页表固定。</strong></li><li>保护位(RWX)。</li></ul></li><li>段基地址寄存器(STBR)：指向段表在存储器中的位置。</li><li>段界限寄存器(STLR)：表示进程使用的段的个数。  </li><li>地址转换：<br><img src="https://i.loli.net/2018/06/19/5b28ab040db5c.png" width="45%" height="80%"></li><li>在<strong>分段系统</strong>中，<strong>内存的保护与共享以段为单位</strong></li><li>由于段的长度是根据需要变化的,因此分段会产生<strong>外部碎片</strong>。<ul><li>这个问题的严重程度与<strong>操作系统的内存分配算法</strong>和<strong>进程各个段的平均大小</strong>有关。</li></ul></li><li>由于系统无法预测各个进程使用内存的状况，<strong>外部碎片很难控制</strong>。因此，单纯的分段系统目前很少使用。</li><li>各个硬件产商也不再支持单纯的分段系统。<ul><li>INTEL 80386以前的CPU只支持分段,而80386以后(包括80386) 的CPU则增加了分页支持。</li></ul></li></ul><h4 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h4><ul><li>分页和分段系统有各自的优缺点，因此人们就考虑结合分页和分段，这就形成了段页式内存管理。</li><li>段页式内存管理的地址转换包括两个步骤：<strong>先分段，再分页。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记08 死锁</title>
      <link href="/os8/"/>
      <url>/os8/</url>
      
        <content type="html"><![CDATA[<h4 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h4><ul><li><p>如果集合中的每个进程正在等待只有集合中的另一个进程可能导致的事件，则会导致一组进程死锁。    </p><ul><li>Kansas立法机构通过的一个法律：当两列列车在十字路口逼近时，它们要完全停下来，且在一列列车开走之前，另一列列车不能启动。</li><li>只有一个方向的交通：桥的每个部分都可以被视为一个资源。如果发生死锁，则可以解决一辆车是否备份（抢占资源并回滚），可能需要“备份几辆汽车。 饥饿是可能的。</li></ul><a id="more"></a></li></ul><p>#####系统模型</p><ul><li>一个系统由有限数量的资源组成，分配给多个竞争过程。</li><li>资源被分成几种类型：资源类型R<sub>1</sub>，R<sub>2</sub>，…，R<sub>m</sub>，例如CPU周期，内存空间和 I/O 设备。</li><li>每个资源类型R<sub>i</sub>都有W<sub>i</sub>实例操作来使用资源<ol><li><strong>申请</strong>：如果不能立即授予请求，则请求进程必须等待直到它获得该资源为止。</li><li><strong>使用</strong>：进程正在使用该资源。</li><li><strong>释放</strong>：进程释放资源。</li></ol></li></ul><h4 id="死锁特征"><a href="#死锁特征" class="headerlink" title="死锁特征"></a>死锁特征</h4><ul><li>如果以下4个条件同时满足，则会出现死锁：<ol><li>互斥：至少有一个资源必须处于非共享模式，即一次只有一个进程可以使用该资源。 </li><li>占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其它资源所占有。</li><li>非抢占：资源不能抢占，即资源只能在进程完成任务后自动释放。</li><li>循环等待：有一组等待进程{P<sub>0</sub>，P<sub>1</sub>，… ，P<sub>n</sub>}，P<sub>0</sub>等待的资源由P<sub>1</sub>占有，P<sub>1</sub>等待的资源由P<sub>2</sub>占有，… ，P<sub>n-1</sub>等待的资源由P<sub>n</sub>占有，并且P<sub>n</sub>等待的资源由P<sub>0</sub>占有。</li></ol></li></ul><blockquote><p>所有4个条件必须同时满足才会出现死锁。循环等待条件意味着占有并等待条件，这样的4个条件并不完全独立。</p></blockquote><h4 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h4><ul><li>死锁问题可用称为<strong>系统资源分配图</strong>的有向图进行更精确地描述。</li><li>该图由一组顶点集合V和一组边集合E组成。</li><li>V被分成两种类型：<ul><li>P = {P<sub>0</sub>，P<sub>1</sub>，…，P<sub>n</sub>}，系统中的所有进程的集合。</li><li>R = {R<sub>0</sub>，R<sub>1</sub>，…，R<sub>m</sub>}，系统中所有资源类型的集合。</li></ul></li><li>申请边：P<sub>i</sub> → R<sub>j</sub></li><li>分配边：R<sub>j</sub> → P<sub>i</sub><br><img src="https://i.loli.net/2018/06/18/5b27ab5721290.png" width="25%" height="80%"><br><img src="https://i.loli.net/2018/06/18/5b27ab5ac25d8.png" width="33%" height="80%"></li><li>如果资源分配图不包含环，则系统中的<strong>任何进程都不会</strong>死锁;</li><li>如果资源分配图包含环，则<strong>可能存在</strong>死锁。</li></ul><h4 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h4><ul><li>可以设计一个协议来预防或避免死锁，确保系统永远不会进入死锁状态。</li><li>可以允许系统进入死锁状态，检测并从中恢复。</li><li>可以完全忽略这个问题，并假设系统中永远不会发生死锁。(鸵鸟算法)<ul><li>大多数操作系统都使用该解决方案，包括Windows和Unix。</li><li>由于死锁<strong>很少发生</strong>，并且死锁预防、死锁避免或死锁检测和恢复<strong>算法成本很高</strong>。</li><li>这是便利性和正确性之间的权衡。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记07 进程同步</title>
      <link href="/os7/"/>
      <url>/os7/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul><li>协作进程可以通过内核提供的IPC工具共享一块内存。一个进程中的多个线程可以通过使用全局变量来共享一段内存。</li><li>共享数据的并发访问可能会导致数据不一致。 保持数据一致性需要机制来确保协作进程的有序执行。</li><li><p>对生产者和消费者问题的解决方案：允许同时在缓冲区内最多只有（BSIZE - 1）项。</p><a id="more"></a></li><li><p>假设我们通过添加一个变量计数器来修改代码。<br><img src="https://i.loli.net/2018/06/18/5b275da7bfa0f.png" width="40%" height="80%"><img src="https://i.loli.net/2018/06/18/5b275daa58ac3.png" width="45%" height="80%"></p></li><li>需要注意的是，可能由于这两个进程并发操作变量counter，而得到不正确的运行结果。</li><li><strong><code>竞争条件</code></strong>：多个进程并发地访问和操作同一数据且执行结果与访问发生的特定顺序有关。<ul><li>为避免竞争条件，需要保证一段时间内只有一个进程能够操作变量。</li><li>为了实现这种保证，要求进行一定形式的<strong><code>进程同步</code></strong>。</li></ul></li></ul><h4 id="临界区问题"><a href="#临界区问题" class="headerlink" title="临界区问题"></a>临界区问题</h4><ul><li><strong><code>临界区</code></strong>：一段访问共享资源的代码。</li><li>竞态条件的解决方案必须满足以下4个要求：<ol><li>相互排斥：任何两个进程不能同时处于临界区。</li><li>前进：临界区外运行的进程不能阻塞其他进程尝试进入其临界区，以确定谁能下一个进入临界区。且这种选择不能无限推迟。</li><li>有限等待：没有任何一个进程需要无限期等待进入其临界区。</li><li>速度：不应该对CPU的速度和数量做任何假设。 </li></ol></li><li>临界区问题：设计一个以便进程协作的协议。<ul><li>每个进程必须请求允许进入其临界区。实现这一请求的代码段称为<strong>进入区</strong>。</li><li>临界区之后可有<strong>退出区</strong>。其余代码为<strong>剩余区</strong>。 </li></ul></li></ul><h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p><img src="https://i.loli.net/2018/06/18/5b2765a247934.png" width="45%" height="80%"></p><blockquote><p>First &amp; Second try都不满足“前进”这个要求。Third try即为Peterson算法，满足四个要求。</p></blockquote><h4 id="硬件同步"><a href="#硬件同步" class="headerlink" title="硬件同步"></a>硬件同步</h4><ul><li>可以使用简单的硬件指令来解决竞争条件。</li></ul><ol><li>单处理器环境(通常为非抢占内核所用)：<strong>禁用中断</strong></li><li>多处理器环境：<strong>特殊指令</strong> ①TSL（Test and Set Lock）②SWAP</li></ol><h5 id="禁用中断"><a href="#禁用中断" class="headerlink" title="禁用中断"></a>禁用中断</h5><ul><li>禁止中断，就能确保当前指令序列的执行不会被中断。由于其它指令不可能执行，共享变量不会被意外修改。</li><li>进程就可以访问共享内存而不用担心受到任何其他进程干预。</li><li>缺点<ol><li>用户进程不应该禁用中断。</li><li>在多处理器系统中不可行。</li></ol></li></ul><h5 id="TSL-and-SWAP"><a href="#TSL-and-SWAP" class="headerlink" title="TSL and SWAP"></a>TSL and SWAP</h5><ul><li>TSL和SWAP指令分别具有以下功能：<br><img src="https://i.loli.net/2018/06/18/5b276be04718e.png" width="75%" height="80%"></li><li>TSL和SWAP是以<strong>原子方式</strong>执行的，即作为一个<strong>不间断单元</strong>执行。</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>上述解决方案有一个共同缺点：<strong>繁忙等待</strong>。 <ul><li>当进程处于临界区时，其他进程尝试进入临界区必须在进入区代码中循环。 </li><li>繁忙等待浪费了一些其他进程可能可以有效使用的CPU周期。</li></ul></li><li>这种类型的解决方案也被称为<strong>自旋锁</strong>。<ul><li>因为该过程在等待锁的过程时定时“旋转”，一直在循环抢锁。 </li><li>自旋锁<strong>仅在多处理器系统中</strong>有用。可以避免一次上下文切换。</li></ul></li></ul><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul><li>上一节描述的基于硬件的临界区问题的解决方案并不容易推广到更复杂的问题。为了克服这个困难，我们可以使用一个名为semaphore的同步工具。它由Edsger Dijkstra发明并首次在THE操作系统中使用。</li><li><strong><code>信号量S</code></strong>是个整数变量，<strong>除初始化之外</strong>，只能通过两个标准的<strong>原子操作</strong>来访问：P(down) 和V(up）。<br><img src="https://i.loli.net/2018/06/18/5b276ff356715.png" width="65%" height="80%"></li><li>“value”的大小是<strong>可用资源(&gt;0)的数量</strong>或<strong>等待信号量(&lt;0)的进程的数量</strong>。</li><li>P 和 V 必须以原子方式执行。<ul><li>有两种方法：①禁用单处理器系统或中断 ②多处理器系统中的自旋锁。</li></ul></li></ul><h5 id="二进制信号量"><a href="#二进制信号量" class="headerlink" title="二进制信号量"></a>二进制信号量</h5><ul><li>上述的信号量构造通常被称为计数信号量。因为它的值可以覆盖不受限制的域。</li><li>二进制信号量是一个整数值范围只在0和1之间的信号量。<ul><li>在某些硬件体系结构上实现比计数信号量更简单。计数信号可以使用二进制信号量来实现。<br><img src="https://i.loli.net/2018/06/18/5b277a3576f4b.png" width="80%" height="80%"><br><img src="https://i.loli.net/2018/06/18/5b277a3524a9e.png" width="80%" height="80%"></li></ul></li></ul><h5 id="死锁与饥饿"><a href="#死锁与饥饿" class="headerlink" title="死锁与饥饿"></a>死锁与饥饿</h5><ul><li>虽然信号量为进程同步提供了一种方便有效的机制，但它们的不正确使用仍然会导致难以检测到的错误。<ul><li>eg. 假设生产者循环中的两个P操作按顺序颠倒过来。</li></ul></li><li>集合中的每个进程正在等待只有集合中的另一个进程可能导致的事件，则会导致一组进程<strong>死锁</strong>。</li><li>与死锁有关的另一个问题：饥饿/不确定阻塞，即进程在信号量内无限期地等待。<ul><li>例如，解决<code>读者-作者问题</code>的方法可能会导致饥饿。</li><li>通过使用FCFS调度策略可以避免饥饿。</li></ul></li></ul><h4 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h4><ul><li>生产者-消费者问题</li><li>读者-作者的问题<ul><li>一个数据库可以为多个并发进程所共享。</li><li>读者可能只需要读取数据库，写者可能需要更新数据库(即读和写)。</li><li>多个读者可以同时访问共享数据，写者对共享数据有<strong>排他的访问</strong>。</li></ul></li><li>哲学家进餐问题</li></ul><h5 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h5><ul><li>访问缓冲区时使用信号量互斥锁来保护临界区，初始化为值1。</li><li>empty被初始化为值BSIZE(缓冲项个数)，full被初始化为0。生产者为消费者生产满缓冲项，消费者为生产者生产空缓冲项。<br><img src="https://i.loli.net/2018/06/18/5b2774f9a0ad0.png" width="65%" height="80%"></li></ul><h5 id="读者-作者的问题"><a href="#读者-作者的问题" class="headerlink" title="读者-作者的问题"></a>读者-作者的问题</h5><ul><li>信号量<code>wrt</code>用于保护共享数据对象，初始化为值1。</li><li>变量readcount用来跟踪多少进程正在读对象，初始化为0。</li><li>另一个信号量mutex用于确保在更新变量readcount时的互斥，初始化为1。<br><img src="https://i.loli.net/2018/06/18/5b2774a70cbcf.png" width="65%" height="80%"></li></ul><h5 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h5><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><ul><li>管程：是一组方法、变量、函数..的集合。</li><li>管程结构确保了<strong>只有一个进程可以在管程中处于活动状态</strong>。在实现互斥方面很有用。<br><img src="https://i.loli.net/2018/06/18/5b278148f0f3e.png" width="40%" height="80%"><img src="https://i.loli.net/2018/06/18/5b278156992a9.png" width="48%" height="80%"><br><img src="https://i.loli.net/2018/06/18/5b2784cd6bc52.png" width="35%" height="80%"></li></ul><h5 id="带条件变量的管程"><a href="#带条件变量的管程" class="headerlink" title="带条件变量的管程"></a>带条件变量的管程</h5><ul><li>管程内部可定义condition类型的变量以提供同步机制，称其为<strong><code>条件变量</code></strong>。条件型变量c实际上是一个指针，它指向一个等待该条件的PCB队列。</li><li>它只与两个操作相关联：<ul><li>c.wait()：意味着调用它的进程会被挂起，直到另一个进程调用</li><li>c.signal()：重新启动一个悬挂的进程。</li><li>请注意，如果没有进程挂起，那么signal()没有任何影响。</li></ul></li><li>管程模式下的 x.signal() 和信号量的 signal() 区别在于： <ul><li>信号量操作 signal() 会影响信号量的状态</li><li>管程下的 c.signal() 在 c 不存在挂起进程的情况下没有任何影响。</li></ul></li></ul><h5 id="c-signal（）之后会发生什么？"><a href="#c-signal（）之后会发生什么？" class="headerlink" title="c.signal（）之后会发生什么？"></a>c.signal（）之后会发生什么？</h5><ul><li>假设一个进程P调用c.signal（），另一个进程Q被条件变量c阻塞。</li><li>P完成c.signal（）后，可能P和Q在监视器内同时处于活动状态。</li><li>这将打破显示器的属性！ 存在三种可能性：<ul><li>Hoare风格：暂停P并让Q运行。 </li><li>Brinch-Hansen风格：P必须立即离开显示器。 </li><li>Mesa风格（Mesa是一种编程语言）：让P运行并暂停Q.</li></ul></li></ul><h5 id="语言支持"><a href="#语言支持" class="headerlink" title="语言支持"></a>语言支持</h5><ul><li>管程结构需要编程语言支持才有用。也就是说，编译器必须识别管程结构并生成代码以支持其功能。</li><li>示例：Java（仅包含一个条件变量的Mesa样式监视器）<ul><li>通过将关键字synchronized添加到方法声明中，Java保证一旦任何线程开始执行该方法，就不允许其他线程开始执行该类中的任何其他同步方法。</li><li>Java提供了两种操作：等待并通知阻塞线程，唤醒线程。</li></ul></li></ul><h4 id="信号量与管程的关系"><a href="#信号量与管程的关系" class="headerlink" title="信号量与管程的关系"></a>信号量与管程的关系</h4><ul><li>信号量和管程在功能上是等效的。</li><li>但是它们的使用和实现是非常不同的。<br><img src="https://i.loli.net/2018/06/18/5b2785f39478e.png" width="35%" height="80%"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记06 CPU调度</title>
      <link href="/os6/"/>
      <url>/os6/</url>
      
        <content type="html"><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>CPU调度是多道程序操作系统的基础。通过在进程之间切换CPU，操作系统可以提高计算机的<strong>吞吐率</strong>。</li><li>在内核级支持线程的操作系统中，是线程被操作系统调度，而不是进程。</li><li><p>调度是操作系统的基本功能。 几乎所有的计算机资源在使用前都要调度。 CPU调度对操作系统设计来说很重要。</p><a id="more"></a></li></ul><h5 id="CPU-I-O-区间周期"><a href="#CPU-I-O-区间周期" class="headerlink" title="CPU- I/O 区间周期"></a>CPU- I/O 区间周期</h5><ul><li>CPU的成功调度依赖于进程的如下属性：<ul><li>进程执行由<strong>CPU执行</strong>和 <strong>I/O 等待周期</strong>组成</li><li>进程在这两个状态之间切换。</li><li>由CPU区间开始- I/O 区间 -..-最后的CPU区间通过系统请求终止执行。</li></ul></li><li>CPU区间时间曲线图：通常为指数/超指数形式，具有大量短CPU区间和少量长CPU区间。<br><img src="https://i.loli.net/2018/06/18/5b274fd5857b6.png" width="35%" height="80%"><br><img src="https://i.loli.net/2018/06/18/5b2750265b65e.png" width="55%" height="80%"> </li></ul><h5 id="CPU调度程序"><a href="#CPU调度程序" class="headerlink" title="CPU调度程序"></a>CPU调度程序</h5><ul><li>每当CPU空闲时，操作系统就必须从就绪队列中选择一个进程来执行。晋城选择由<strong>短期调度程序</strong>或CPU调度程序来执行。</li><li>CPU调度决策可在如下4种情况下发生：<ol><li>当一个进程从运行切换到等待状态。</li><li>当一个进程从运行状态切换到就绪状态。</li><li>当一个进程从等待切换到就绪状态。</li><li>当一个进程终止。</li></ol></li><li>当调度只能发生1和4两种情况下，称调度方案是<strong>非抢占的/协作</strong>的，否则，称调度方案是<strong>抢占的</strong>。</li><li>抢占调度：对访问共享数据是有代价的，对操作系统内核的设计也有影响。</li></ul><h4 id="调度标准"><a href="#调度标准" class="headerlink" title="调度标准"></a>调度标准</h4><ul><li>CPU使用率：使CPU尽可能忙。</li><li>吞吐量：一个时间单元内所完成的进程的数量。</li><li>周转时间：从进程提交到进程完成的时间段。</li><li>等待时间：进程在就绪队列中等待的时间量。</li><li>响应时间：从提交请求到产生第一个响应所花费的时间量。</li></ul><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><h5 id="先到先服调度-FCFS"><a href="#先到先服调度-FCFS" class="headerlink" title="先到先服调度(FCFS)"></a>先到先服调度(FCFS)</h5><ul><li>先请求CPU的进程先分配CPU</li><li>非抢占：一旦CPU被分配给了一个进程，该进程就会保持CPU直到释放CPU位置。  </li><li>1 - 2 - 3进程等待时间: P1 = 0; P2 = 24; P3 = 27; 平均等待时间: (0 + 24 + 27) / 3 = 17 </li><li>2 - 3 - 1进程等待时间: P1 = 6; P2 = 0; P3 = 3; 平均等待时间: (6 + 0 + 3) / 3 = 3<br><img src="https://i.loli.net/2018/06/18/5b27443f91882.png" width="35%" height="80%"><br><img src="https://i.loli.net/2018/06/18/5b274417bceb8.png" width="49%" height="80%"><br><img src="https://i.loli.net/2018/06/18/5b274425dba0b.png" width="49%" height="80%"></li></ul><h5 id="最短作业优先调度-SJF"><a href="#最短作业优先调度-SJF" class="headerlink" title="最短作业优先调度(SJF)"></a>最短作业优先调度(SJF)</h5><ul><li>将每个进程与其下一个CPU区间段相关联。当CPU为空闲时，它会赋给具有最短CPU区间的进程。</li><li>SJF调度算法可证明为最佳，对给定的一组进程，平均等待时间最短。</li><li>具有理论价值，无法实现，因为没有办法知道下一个CPU区间的长度。</li><li>两种方案：<ul><li>非抢占：一旦CPU给予该进程，它就不可能被抢占。eg. 平均等待时间: (0 + 6 + 3 + 7)/4 = 4.</li><li>抢占：如果一个到达的新的进程CPU区间长度小于当前执行进程的剩余时间，则抢占。也被称为最短剩余时间优先（SRTF）调度。eg. 平均等待时间: (9 + 1 + 0 + 2)/4 = 3.   </li></ul></li></ul><p><img src="https://i.loli.net/2018/06/18/5b2750dbb6036.png" width="25%" height="80%">   <img src="https://i.loli.net/2018/06/18/5b2750cd7f5a5.png" width="35%" height="80%"><img src="https://i.loli.net/2018/06/18/5b2750d34e6ca.png" width="35%" height="80%"></p><h5 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h5><ul><li>每一个进程都有一个优先级与其关联。具有最高优先级的进程会分配到CPU。</li><li>优先级通常为固定区间的数字。此处用小数字表示高优先级。</li><li>SJF算法是优先级调度的一个特例，其优先级为下一个CPU区间的倒数。CPU区间越大，优先级越小。</li><li>优先级调度可以是抢占或非抢占的<br><img src="https://i.loli.net/2018/06/18/5b2754621eca0.png" width="35%" height="80%"><img src="https://i.loli.net/2018/06/18/5b27545d3e4a1.png" width="50%" height="80%"></li><li>存在的问题<ol><li>饥饿/无穷阻塞：低优先级进程可能永远不会执行。</li><li>优先级反转：高优先级进程需要访问资源，被另一个优先级较低的进程持有，该低优先级进程不运行则不释放资源。</li></ol></li><li>解决办法<ul><li>老化：逐渐增加在系统中等待很长时间的进程的优先级。</li></ul></li></ul><h5 id="轮转法调度-RR"><a href="#轮转法调度-RR" class="headerlink" title="轮转法调度(RR)"></a>轮转法调度(RR)</h5><ul><li>轮转法调度算法专门为分时系统设计。类似FCFS调度，但增加了抢占以切换进程。</li><li>定义一个较小时间单元，称为<strong>时间片</strong>，通常为10-100ms。</li><li>将就绪队列作为循环队列。CPU调度程序循环就绪队列，为每个进程分配不超过一个时间片的CPU。<ol><li>进程只需要小于时间片的CPU区间，释放CPU，继续就绪队列的下一个进程。</li><li>进程的CPU区间比时间片长，经过这段时间片的CPU区间，进程被抢占并加入到就绪队列的末尾。</li></ol></li><li>如果在就绪队列中有n个进程并且时间量为q，那么每个进程会得到 1 / n 的CPU时间，其长度不超过q时间单元。每个进程必须等到的CPU时间不超过 ( n - 1 ) q 个时间单元，直到它的下一个时间片为止。</li><li>性能很大程度上依赖于时间片的大小<ul><li>时间片非常大 ➡ FCFS</li><li>时间片很小 ➡ 时间片要比上下文切换时间长，否则开销太高。</li></ul></li></ul><h5 id="多级队列调度"><a href="#多级队列调度" class="headerlink" title="多级队列调度"></a>多级队列调度</h5><ul><li>就绪队列被分成多个独立队列。</li><li>根据进程的属性，如内存大小、进程优先级、进程类型etc，一个进程被永久地分配到一个队列。</li><li>每个队列有自己的调度算法<ul><li>eg. 前台队列（用于交互式进程）使用RR算法调度，后台队列（用于批处理）使用FCFS算法调度。<br><img src="https://i.loli.net/2018/06/18/5b275848a05ce.png" width="40%" height="80%"></li></ul></li></ul><h5 id="多级反馈队列调度"><a href="#多级反馈队列调度" class="headerlink" title="多级反馈队列调度"></a>多级反馈队列调度</h5><ul><li>一个进程可以在各个队列之间移动。<ul><li>eg. 如果进程使用过多CPU时间，那么它就被转移到更低优先级队列。<br><img src="https://i.loli.net/2018/06/18/5b2758db6dfa5.png" width="40%" height="80%"></li></ul></li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>在实践中正确实施比在原则上正确实施要困难得多。因此，调度程序很少做出最佳选择。</li><li>解决方案：<strong>调度策略和调度机制的分离</strong>。也就是说，调度算法以某种方式被参数化，但参数可以由用户填写。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记05 线程管理</title>
      <link href="/os5/"/>
      <url>/os5/</url>
      
        <content type="html"><![CDATA[<h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><ul><li>传统意义上，一个进程只有一个控制线程。<strong>在这种情况下</strong>进程是<strong>①资源分配单位和②调度单位</strong>。</li><li>将上述两个概念分开并允许单个进程包括多个控制线程，得到线程。也就是说，进程用于将资源组合在一起，线程是派发（调度）在CPU上执行的实体。</li><li><p>线程是现代操作系统中CPU使用的基本单位。也称为轻量级过程（LWP）。</p><a id="more"></a></li><li><p>多线程</p><ul><li>在同一个进程中允许多个线程。</li><li>进程是<strong>资源分配的单位</strong>，线程是<strong>调度的单位</strong>。</li><li><strong>共享</strong>属于同一进程的资源，例如是<strong>代码段，数据段，打开的文件</strong>和信号等。</li><li>一个进程中的每个线程都有一个<strong>私有线程上下文</strong>（包括<strong>CPU寄存器集</strong>和<strong>其他状态信息：?函数参数，变量，返回地址etc</strong>）和一个<strong>私有堆栈</strong>。<br><img src="https://i.loli.net/2018/06/18/5b2736316b722.png" width="75%" height="80%"></li></ul></li><li>进程：①地址空间 ②全局变量 ③打开的文件 ④子进程 ⑤未决(pending)警报 ⑥信号和信号处理程序 ⑦计数信息</li><li>线程：①程序计数器 ②寄存器 ③堆 ④状态</li></ul><h4 id="多线程编程优点"><a href="#多线程编程优点" class="headerlink" title="多线程编程优点"></a>多线程编程优点</h4><ul><li><strong>响应度高</strong>：即使一个或多个线程被阻塞或正在执行冗长的操作，允许其他线程继续响应用户。</li><li><strong>资源共享</strong>：由于同一进程内的线程共享内存和资源，它们可以在不调用内核的情况下相互通信。它能允许一个应用进程在同一地址空间有多个不同的活动进程。</li><li><strong>经济</strong>：创建一个新线程比一个进程花费的时间和资源要少得多。在同一个进程中，线程比上下文切换花费的时间更少。</li><li><strong>多处理器体系结构的利用</strong>：通过为每个CPU分配一个线程可以实现并行，在多CPU上使用多线程加强了并发功能。</li></ul><h4 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h4><ul><li>多线程实现的地方：<strong>不一定在内核实现</strong><ul><li>用户线程：在用户空间实现。</li><li>内核线程：在内核实现。</li><li>通过组合用户线程和内核线程的混合方案。</li></ul></li></ul><h5 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h5><ul><li>它在内核之外用户空间的<strong>线程库</strong>实现。<ul><li>线程库是为线程创建，调度和管理提供支持的库。</li><li>就内核而言，它正在管理普通的单线程进程。</li></ul></li><li>eg. ①Mach C-threads ②Solaris 2 UI-threads</li><li>优点<ul><li>线程管理和上下文切换不需要陷入内核。这将节省大量的CPU周期。</li><li>允许每个进程拥有自己的自定义调度算法。</li></ul></li><li>缺点<ul><li>执行阻塞系统调用的任何用户级线程都将导致整个进程阻塞。即使其他线程已准备好在进程中运行。</li><li>在多处理器的系统上，不能调度用户级线程并行执行。</li></ul></li></ul><h5 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h5><ul><li>由操作系统直接支持。内核在内核空间执行线程创建，调度和管理。</li><li>eg. ①Windows NT / XP ②Solaris</li><li>优点和缺点：和用户线程的相反。</li></ul><h4 id="多线程应用程序编程接口"><a href="#多线程应用程序编程接口" class="headerlink" title="多线程应用程序编程接口"></a>多线程应用程序编程接口</h4><ul><li>Pthreads<ul><li>Pthreads是指为线程创建和同步定义API的POSIX标准（IEEE 1003.1c）。</li><li>这是线程行为的规范，而不是实现。 </li></ul></li><li>Win32<ul><li>CreateThread，ExitThread和TerminateThread等。</li><li>POSIX Threads for Win32 （<a href="http://sources.redhat.com/pthreads-win32）" target="_blank" rel="noopener">http://sources.redhat.com/pthreads-win32）</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记04 进程管理</title>
      <link href="/os4/"/>
      <url>/os4/</url>
      
        <content type="html"><![CDATA[<h4 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h4><ul><li>流程批处理系统出现之前：工作</li><li>多程序或分时：程序或任务</li><li><p>进程：正在运行的作业/程序/任务的抽象</p></li><li><p><strong><code>进程</code></strong>是执行中的程序，形成所有计算机的基础。</p><a id="more"></a></li><li><p>一个过程不仅仅是一个程序。它包括</p><ul><li><strong>文本段</strong>：可执行的机器代码    /程序代码</li><li><strong>数据段</strong>：包括全局变量</li><li>当前活动：通过程序计数器的值和处理器寄存器的内容表示</li><li><strong>堆栈段</strong>：包含临时数据，如函数参数，返回地址和局部变量 </li><li>(如果需要的话)<strong>堆</strong>：进程运行期间动态地分配内存</li><li>许多其他资源，如打开的文件等<br><img src="https://i.loli.net/2018/06/17/5b260aa24cf1d.png" width="50%" height="80%"></li></ul></li><li>程序只是被动实体，如存储在磁盘上包含一系列指令的文件内容(可执行文件)</li><li>进程时活动实体，它有一个程序计数器用来表示一个要执行的命令和相关资源的合集。</li><li>多个进程可能运行同一程序。尽管它们共享相同的文本段，但它们被当作两个独立的执行程序，数据段、堆、堆栈段不同。</li></ul><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><ul><li>当一个进程执行时，它会改变状态。过程的状态由其当前活动定义。</li><li>每个进程可能处于以下状态之一：<ul><li>新建：进程正在被创建。</li><li>运行：指令正在被执行。</li><li>等待：进程正在等待某个事件发生(如 I/O 完成或收到信号)。</li><li>就绪：进程等待分配处理器。</li><li>终止：进程完成执行。</li></ul></li><li>随着进程的运行，它将从当前状态转换到另一个状态。这五个状态中有六个过渡。<br><img src="https://i.loli.net/2018/06/17/5b26104f11cf7.png" width="80%" height="80%"></li></ul><h4 id="进程块"><a href="#进程块" class="headerlink" title="进程块"></a>进程块</h4><ul><li>每个进程在操作系统中由过程控制块（PCB）表示，也称为任务控制块。<ol><li>进程号是进程的唯一标识符，也称为PID。</li><li>程序计数器（PC）：是寄存器之一。</li><li>CPU调度信息：包括<strong>进程的优先级</strong>、调度队列的指针和其它调度参数。<br><img src="https://i.loli.net/2018/06/17/5b2610656be5b.png" width="30%" height="80%"></li></ol></li></ul><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>当运行进程因某种原因无法继续时，操作系统必须决定下一个要运行的进程。<strong>进程调度</strong>选择一个可用的进程到CPU上执行。</p><h5 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h5><ul><li>上下文切换：将 CPU 转向另一个进程需要保存当前进程的状态，并载入为新进程存储的状态。</li><li>是额外的开销。操作系统越复杂，上下文切换需要做的工作越多。</li><li>上下文切换时间与硬件支持有密切相关。根据处理器的不同。</li><li>上下文切换是一个性能瓶颈，程序员正在使用新的结构来尽可能地避免它。</li></ul><h5 id="调度队列"><a href="#调度队列" class="headerlink" title="调度队列"></a>调度队列</h5><ul><li>作业队列：由系统中的所有进程组成;</li><li>就绪队列：由等待CPU执行的进程组成;<br>-操作系统也有其他队列。<ul><li>I/O 设备队列：由等待特定 I/O设备的进程组成。<br><img src="https://i.loli.net/2018/06/17/5b2613f4c3e27.png" width="75%" height="80%"><br><img src="https://i.loli.net/2018/06/17/5b2614aca2536.png" width="75%" height="80%"></li></ul></li></ul><h5 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h5><p>调度程序从就绪队列中选择一个进程并为其分配CPU。我们称这个调度程序为CPU调度程序。</p><h4 id="合作进程"><a href="#合作进程" class="headerlink" title="合作进程"></a>合作进程</h4><ul><li>如果一个进程不会影响系统中其它的进程，而且也不被其它进程影响，那么它是一个独立进程。不与其它进程共享数据(临时的或长久的)的进程是独立进程。</li><li>如果一个进程会影响系统中其它的进程而且也被影响，那么它是一个协作进程。与其它进程共享数据的进程是协作进程。</li><li>进程协作的优点<ul><li><strong>信息共享</strong>：多个进程可能需要同一条信息。</li><li><strong>计算加速</strong>：将问题分解成几个可以并行运行的子任务;</li><li><strong>模块化</strong>：通过设计将不同功能分散到进程中。</li></ul></li><li>但是，协作进程的并发执行需要<strong>允许进程彼此通信</strong>并使其<strong>动作同步</strong>的机制。</li></ul><h5 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h5><ul><li>这是协作进程的通用范例。</li><li>生产者进程产生信息以供消费者进程消费。必须要又一个缓冲来被生产者填充并被消费者所使用。<ul><li><strong>无限缓冲</strong>：对缓冲大小没有限制。消费者可能不得不等待新项，但生产者总可以产生新项。</li><li><strong>有限缓冲</strong>：缓冲大小固定。如果缓冲为空，消费者必须等待；如果缓冲为满，生寒症必须等待。</li></ul></li><li>操作系统可以通过使用进程间通信（IPC）工具来提供缓冲区。<strong>程序员</strong>只是使用系统调用来填充或清空缓冲区。</li><li>缓冲区也可以位于生产者和消费者可以访问的<strong>共享存储器</strong>中。在这种情况下，<strong>程序员</strong>必须自己管理共享缓冲区。</li></ul><h4 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信(IPC)"></a>进程间通信(IPC)</h4><ul><li>在消费者-生产者问题中，缓冲区可以由操作系统提供。操作系统必须同步消费者和生产者对缓冲区的访问。</li><li>进程间通信(<strong>IPC</strong>)提供了一种机制，允许进程进行通信，并在非共享相同地址空间的情况下同步他们的动作。</li><li>eg.<strong>①Message-passing, ②pipe, ③socket, etc.</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记03 操作系统结构</title>
      <link href="/os3/"/>
      <url>/os3/</url>
      
        <content type="html"><![CDATA[<ul><li>一个像现代操作系统一样庞大而复杂的系统必须仔细设计，才能正常运行并易于修改。</li><li>一种常用的方法是将任务分成小部件，而不是一个单一的系统。</li><li>这些组件中的每一个都应该是系统的一个明确定义的部分，具有详细定义的<strong>输入，输出和功能</strong>。</li><li><p>系统设计人员如何组织这些组件？</p><ul><li>简单结构（或没有结构）</li><li>分层结构</li><li>微内核</li><li>虚拟机</li></ul><a id="more"></a></li></ul><h4 id="简单结构"><a href="#简单结构" class="headerlink" title="简单结构"></a>简单结构</h4><ul><li>许多系统没有明确的结构。</li><li>他们从小、简单和有限的系统开始，然后演变成复杂的系统。</li><li>eg. MS-DOS和Unix</li></ul><h4 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h4><ul><li>操作系统分解成多个层，<strong>高层只能调用低一层的功能</strong>。</li><li>分层结构的主要难点在于：<ul><li>仔细定义每一层</li><li>效率较低。</li></ul></li><li>eg. The <strong>THE</strong> operating system by Dijkstra.</li></ul><h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4><ul><li>随着Unix操作系统的扩展，内核变得庞大而难以管理。</li><li>微内核方法通过<strong>从内核中删除所有非必要组件</strong>并将它们实现为系统级和用户级程序来构造操作系统。</li><li>提供精简的内核。哪些组件应该保留在微内核中？ <ul><li>CPU管理</li><li>内存管理</li><li>通信设备</li></ul></li><li>eg. ①卡内基梅隆大学的开源Mach(用作Apple Mac OS X和DEC Tru64 Unix的内核) ②QNX Inc.的QNX实时操作系统 ③Micorsoft Windows NT / XP</li></ul><h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><ul><li>从微内核进一步迈进：<ul><li>低级真实的硬件被“克隆”到几个相同的<strong>虚拟机</strong>中。</li><li>虚拟机提供的接口与底层裸机相同。</li></ul></li><li>然后，操作系统功能建立在虚拟机之上。<br><img src="https://i.loli.net/2018/06/17/5b2606003dd2f.png" width="70%" height="80%"></li><li>eg. ①IBM VM/370 ②VMware ③Microsoft Virtual PC ④Sun microsystem’s Java Virtual Machine (JVM).Sun微系统的Java虚拟机</li><li>虚拟机的优与劣<ul><li>虚拟机概念提供了<strong>对系统的全面保护</strong>。因为每个虚拟机都与其他所有虚拟机隔离开来。</li><li>然而，这种隔离<strong>不允许直接分享资源</strong></li><li>虚拟机系统是<strong>操作系统研究和开发</strong>的理想<strong>工具</strong>。</li><li>虚拟机的概念很难实现，因为需要<strong>准确地</strong>为底层机器提供一个完全相同的副本。</li></ul></li></ul><h4 id="政策和机制"><a href="#政策和机制" class="headerlink" title="政策和机制"></a>政策和机制</h4><ul><li><strong>政策：做什么</strong><br>eg. 用户应该无法读取其他用户的文件。</li><li><strong>机制：如何做</strong><br>eg. 在打开的系统调用中检查文件权限。</li><li><strong>政策与机制的分离</strong>是一个非常重要的原则。<ul><li>如果政策决定以后将改变，它可以提供最大的灵活性。</li></ul></li><li>两个极端：<ul><li>微内核：所有机制，几乎没有政策</li><li>Apple Macintosh：策略和机制绑定在一起</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记02 计算机系统结构</title>
      <link href="/os2/"/>
      <url>/os2/</url>
      
        <content type="html"><![CDATA[<h4 id="Bootstrap-引导"><a href="#Bootstrap-引导" class="headerlink" title="Bootstrap 引导"></a>Bootstrap 引导</h4><ul><li>我们必须将操作系统内核从某些永久性存储（如磁盘和网络服务器）加载到内存中。装入内核以启动计算机的过程称为<strong>引导</strong>系统。</li><li>绝大多数计算机系统都有一小块代码，称为<strong>引导程序/引导装载程序</strong>。这段代码能定位内核，将它装入内存，开始执行。</li><li><strong>引导加载程序不是操作系统的一部分。</strong>引导程序被存储在固件中，而操作系统保存在磁盘上。</li><li><p>例子：</p><ul><li>NTLDR: 用于Windows NT / XP的boot-loader（驻留在C:\）。</li><li>GRUB: Unix / Linux的启动加载器之一。</li></ul><a id="more"></a></li></ul><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><ul><li>现代计算机和操作系统是<strong>由中断驱动</strong>的。<ul><li>外围设备使用**中断信号通知CPU发生了某些事情。</li></ul></li><li>当CPU发生中断时，它必须通过<strong>硬</strong>件、ISR中<strong>的汇编语言程序</strong>和<strong>C程序</strong>来服务中断：<ol><li>硬件：将一些寄存器和分支保存到<strong><code>中断服务程序</code></strong>（<strong><code>ISR</code></strong>）;</li><li>ISR中的汇编语言程序：必要时保存其余寄存器营造便利的环境;</li><li>ISR中的C语言程序：确实服务于中断，通常读取并缓冲来自外围设备的输入数据;</li><li>ISR中的C语言程序：返回在ISR中的汇编语言;</li><li>ISR中的汇编语言程序：恢复保存的寄存器并返回到被中断的位置。</li></ol></li></ul><h5 id="中断向量"><a href="#中断向量" class="headerlink" title="中断向量"></a>中断向量</h5><ul><li>通常，计算机系统具有多个外围设备。发生中断时，CPU必须知道哪个设备触发了它。</li><li>中断向量（Interrupt vector）是中断服务程序的入口地址，或中断向量表的下标，中断服务程序的入口地址存放在该数组中。<ul><li>计算机系统为每个设备分配一个唯一的<strong><code>中断请求号</code></strong>（例如，一个8-bit整数），简称<strong><code>IRQ</code></strong>。</li><li>中断向量表中存有所有ISR的地址。它是一个地址的数组。</li><li>在服务中断时，CPU使用<strong>IRQ</strong>(中断请求号)来<strong>索引中断向量</strong>，以获取ISR的地址并跳转到它。<br><img src="https://i.loli.net/2018/06/17/5b25d57c9fb57.png" width="80%" height="40%"> </li></ul></li></ul><h5 id="中断vs异常"><a href="#中断vs异常" class="headerlink" title="中断vs异常"></a>中断vs异常</h5><ul><li><code>中断</code>：<strong>异步</strong>，由<strong>外围设备</strong>触发</li><li><code>异常</code>：<strong>同步</strong>，处理器在执行指令时检测到错误情况（例如除零和无效内存访问）时会发生异常。</li><li>除上述以外，处理中断和异常是相同的。异常也称为<strong>软件生成的中断</strong>或<strong>同步中断</strong>。 </li></ul><h4 id="I-O结构"><a href="#I-O结构" class="headerlink" title="I/O结构"></a>I/O结构</h4><ul><li>当CPU使用外围设备进行 I/O 时，有两种方法可用：<ul><li>同步 I/O ：I/O 操作开始，等待 I/O 操作完成时将控制返回给用户进程。</li><li>异步 I/O ：并不等待输入输出结束，而是直接将控制返回给用户程序。<br><img src="https://i.loli.net/2018/06/17/5b25dac98ff90.png" width="80%" height="40%"> </li></ul></li><li>(外围)设备控制器中的寄存器被称为 <strong>I/O 端口</strong><ul><li>一个唯一的地址（称为<strong>端口</strong>，一个8/16-bit整数）被分配给设备控制器中的每一个寄存器。</li></ul></li><li>特殊的 I/O 指令旨在允许这些<strong>寄存器和内存之间的数据传输</strong>。</li><li>例如：IBM-PC<ul><li>16位 I/O 端口用于<strong>寻址</strong>设备控制器的寄存器。</li><li>两个特殊的 I/O 指令：IN和OUT包含在INTEL x86 CPU中。<br>1.IN reg，端口 - 从端口读取一个字节/字到CPU寄存器寄存器<br>2.OUT端口，reg  - 将CPU寄存器的内容写入端口。</li></ul></li></ul><h4 id="内存映射-I-O"><a href="#内存映射-I-O" class="headerlink" title="内存映射 I/O"></a>内存映射 I/O</h4><ul><li>在 I/O 端口的方法中，我们可以将 I/O 端口视为另一个单独的地址空间，与存储器地址空间无关。</li><li>设备控制器内的寄存器只是一个存储器。<ul><li>为什么不使用与内存相同的方法访问这些寄存器？</li><li>在这种情况下，（唯一的）<strong>内存地址</strong>被分配给每个寄存器，而<strong>不是</strong>一个<strong>端口地址</strong>。</li></ul></li><li><p>内存映射 I/O 。</p><ul><li>内存映射 I/O 使用<strong>相同的总线</strong>来寻址内存和I / O设备</li><li>为了容纳 I/O 设备，CPU<strong>可寻址空间</strong>的区域必须<strong>为 I/O 而不是内存预留</strong>。</li></ul></li><li><p>优点</p><ul><li>每个可以引用内存的指令也可以引用设备控制器寄存器。（设备驱动程序可以完全用C语言编写。）</li><li>不需要特殊的保护机制来保持用户进程不执行 I/O 。</li></ul></li><li>缺点<ul><li>现在大多数电脑都有某种形式的缓存记忆词。但是，缓存<strong><code>设备控制器寄存器</code></strong>将会产生灾难性的后果。</li></ul></li><li>现代计算机系统使用它们两个：<ul><li><strong>用于数据缓存</strong>的存储器映射 I/O 和<strong>用于命令寄存器</strong>的单独 I/O 端口，</li><li>就像Mobility Radeon 7500的例子一样。</li></ul></li></ul><h4 id="硬件保护"><a href="#硬件保护" class="headerlink" title="硬件保护"></a>硬件保护</h4><ul><li>为确保正常运行，我们必须保护操作系统和所有其他程序及其数据免受任何故障程序的影响。</li><li>不同的硬件保护方式：<ul><li><strong>双模式操作</strong>：防止用户程序占用部分操作系统，并使用它覆盖其他程序，甚至修改操作系统本身。</li><li><strong>特权指令</strong>：防止用户程序通过发出<strong>非法 I/O 指令</strong>而中断系统的正常操作。</li><li><strong>内存保护</strong>：防止用户程序<strong>直接访问</strong>其他用户程序或操作系统的<strong>内存</strong>。</li><li><strong>CPU保护</strong>：防止用户程序<strong>陷入无限循环</strong>，并且永远不会将控制权交还给操作系统。</li></ul></li></ul><h5 id="1-双模式操作"><a href="#1-双模式操作" class="headerlink" title="1. 双模式操作"></a>1. 双模式操作</h5><ul><li>用户模式：代表用户程序执行。</li><li>监控模式：代表操作系统执行。也称为管理员/系统/特权或内核模式。</li><li><strong><code>模式位</code></strong>被添加到计算机硬件以指示当前模式：监视器（0）或用户（1）。<ul><li>在<strong>系统启动时</strong>被设置为<strong>监视模式</strong>，然后加载操作系统，以<strong>用户模式</strong>启动<strong>用户程序</strong>。</li></ul></li><li>当发生中断或异常时硬件切换到监视模式。<ul><li>只要操作系统获得对计算机的控制权，就处于监视模式。</li><li>系统总是在将控制权交给用户程序前切换到用户模式。</li></ul></li><li>INTEL IA-32支持4种工作模式，命名为保护环。<ul><li>但是，运行在IA-32上的大多数操作系统只使用4个中的2个。环0为监视模式，环3为用户模式。<br><img src="https://i.loli.net/2018/06/17/5b25e64b601a8.png" width="70%" height="40%"> </li></ul></li></ul><h5 id="2-特权指令"><a href="#2-特权指令" class="headerlink" title="2. 特权指令"></a>2. 特权指令</h5><ul><li>所有 I/O 指令都是特权指令。<ul><li>硬件允许特权指令仅在监视器模式下执行。</li><li>如果这些指令在用户模式下执行，硬件不会执行指令，而是将其视为非法并生成异常。</li><li>eg. <strong>IN</strong>和<strong>OUT</strong>是INTEL IA-32中的2条<strong>特权指令</strong>。</li></ul></li><li>必须确保用户程序无法在监视模式下获得对计算机的控制权。</li><li>转移到用户模式操作，定时器管理，中断管理…</li></ul><h5 id="3-内存保护"><a href="#3-内存保护" class="headerlink" title="3. 内存保护"></a>3. 内存保护</h5><ul><li>为了保护内存，用两个寄存器来确定程序可以访问的合法地址的范围：<ul><li><strong>基地址寄存器</strong>：保存最小的合法物理内存地址</li><li><strong>界限地址寄存器</strong>：保存地址范围的大小。</li></ul></li><li>见内存管理章节<br><img src="https://i.loli.net/2018/06/17/5b25e8e5bc99d.png" width="80%" height="80%"> </li></ul><h5 id="4-CPU保护"><a href="#4-CPU保护" class="headerlink" title="4. CPU保护"></a>4. CPU保护</h5><ul><li>操作系统只有在有机会运行时才能执行一种策略。<ul><li>如果用户程序陷入死循环或不调用系统服务，并不将控制权返回到操作系统，则CPU不受操作系统的控制。</li></ul></li><li><strong>定时器</strong>：在给定的时间段后中断CPU，控制权自动交给操作系统以确保操作系统能维持对CPU的控制。<ul><li>发生中断时，<strong>操作系统将通过ISR获得控制权</strong>。</li></ul></li></ul><h5 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h5><ul><li>计数寄存器每经过一个时间周期，都要递减(减1)。</li><li>当计数器寄存器达到0时，定时器将中断CPU。</li><li>然后，计数器寄存器将重新加载<code>保持寄存器</code>的值并重复递减的步骤。</li><li>示例：IBM-PC中的计时器<ul><li>具有16位计数器和保持寄存器和脉冲的INTEL i8253可编程间隔定时器达到1193182Hz。<br><img src="https://i.loli.net/2018/06/17/5b25f4b3a9c3e.png" width="90%" height="80%"> </li></ul></li></ul><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><ul><li>操作系统本身没有任何用处，但它通过系统调用用户程序提供了一些有用的服务。如，从磁盘读取文件并通过网络适配器将数据发送到远程主机。</li><li><strong>系统调用</strong>：操作系统和用户程序之间的（明确定义的）接口。<ul><li>用户程序<strong>只能</strong>通过系统调用请求操作系统提供的服务。</li><li>系统调用接口因操作系统而异，也称为<strong>主管电话</strong>。</li></ul></li></ul><h5 id="系统调用v-s-库函数"><a href="#系统调用v-s-库函数" class="headerlink" title="系统调用v.s.库函数"></a>系统调用v.s.库函数</h5><ul><li>系统调用会<strong>陷入OS内核</strong>;而库函数没有。所以，<strong>系统调用比库函数慢得多</strong>。</li><li>库函数与用户定义的函数相同。用户可以用自己的版本替换现有的库函数，而系统调用则不能替换。</li><li>一个操作系统中的系统调用可能会成为另一个操作系统中的库函数，反之亦然。<br><img src="https://i.loli.net/2018/06/17/5b25fe9f393cb.png" width="60%" height="60%"> </li></ul><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p><img src="https://i.loli.net/2018/06/17/5b25f6b86d9dd.png" width="60%" height="80%"> </p><ul><li>1 - 3 准备参数；</li><li>4 调用系统调用的包装器（用汇编语言编写）；</li><li>5 将读取的<strong>系统调用号</strong>存储到寄存器中；</li><li>6 陷入操作系统；</li><li>7 通过使用<strong>系统调用号</strong>索引<strong>系统调用表</strong>获取<strong>系统调用服务程序</strong>以进行读取；</li><li>8 - 11 系统调用服务程序运行，并在完成时返回到用户程序。<br><img src="https://i.loli.net/2018/06/17/5b25fc997f84d.png" width="50%" height="80%"> </li><li>这里的驻留监视器（或简单的监视器）意味着操作系统</li><li>n是系统调用号。</li></ul><h5 id="陷入操作系统"><a href="#陷入操作系统" class="headerlink" title="陷入操作系统"></a>陷入操作系统</h5><ul><li>用户程序不能直接陷入操作系统。如何陷入操作系统？</li><li>方法1：异常（软件生成的中断）<ul><li>INTEL IA-32提供触发异常的指令INT。eg. Linux / FreeBSD使用INT 0x80陷入操作系统，Windows NT / XP使用INT 0x2e。 </li></ul></li><li>方法2：特殊指令。<ul><li>由于INT指令的额外开销，INTEL IA-32提供了两个特殊指令来陷入操作系统：<code>SYSENTER</code>和<code>SYSEXIT</code>。仅在Pentium II之后的处理器上支持，即Family 6，Model 3，Stepping 3。</li><li>ARM处理器使用swi (Short for SoftWare Interrupt) 陷入操作系统。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记01 导论</title>
      <link href="/os1/"/>
      <url>/os1/</url>
      
        <content type="html"><![CDATA[<h4 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h4><ul><li>多个作业同时保存在主存储器中，CPU通过在作业之间切换来执行多个作业。<br><img src="https://i.loli.net/2018/06/17/5b25c15f99ea2.png" width="40%" height="40%"> </li></ul><h4 id="台式机的操作系统"><a href="#台式机的操作系统" class="headerlink" title="台式机的操作系统"></a>台式机的操作系统</h4><ul><li><p>这些计算机的操作系统从主机操作系统的开发中受益良多。</p><ul><li>Microsoft MS-DOS, Windows 9x/NT</li><li>Apple Macintosh, Mac OS X</li><li>IBM OS/2</li><li>Unix: Solaris by Sun microsystem, HP-UX by Hewlett-Packard, AIX by IBM, Free (as in freedom) software such as BSD (Berkeley Software Distribution) Unix, GNU/Linux</li></ul><a id="more"></a></li></ul><h4 id="实时-嵌入式系统"><a href="#实时-嵌入式系统" class="headerlink" title="(实时)嵌入式系统"></a>(实时)嵌入式系统</h4><ul><li><strong>嵌入式计算机</strong>通常用作<strong>工业控制系统</strong>等专用应用中的控制设备。通常他们资源有限：<ul><li>处理器缓慢、内存有限</li><li>小甚至没有显示屏幕、有限的电源</li><li>有限的功能，只具有很少甚至没有用户接口</li></ul></li><li>嵌入式系统几乎都运行<strong>实时操作系统</strong>。</li><li>他们资源有限：处理器缓慢、内存有限、小甚至没有显示屏幕、有限的电源 etc..<ul><li>Microsoft Windows CE (Consumer Electronics)</li><li>Windriver vxWorks </li><li>GNU / Linux</li></ul></li><li>一些控制设备具有时间要求，即实时：<ul><li><strong>硬实时</strong>：处理必须在固定时间约束内完成，不允许任何超出时限的错误。</li><li><strong>软实时</strong>：可以容忍偶然的超时错误。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程导论笔记</title>
      <link href="/sei/"/>
      <url>/sei/</url>
      
        <content type="html"><![CDATA[<h3 id="1-软件工程概述"><a href="#1-软件工程概述" class="headerlink" title="1. 软件工程概述"></a>1. 软件工程概述</h3><h4 id="软件的概念和特点"><a href="#软件的概念和特点" class="headerlink" title="软件的概念和特点"></a>软件的概念和特点</h4><p><code>软件</code>(广义)：计算机系统中与硬件相互依存的一部分  </p><blockquote><p><strong>程序</strong>：计算机可以接受的一系列指令，运行时可以提供所要求的功能和性能。<br><strong>数据</strong>：使得程序能够适当地操作信息的数据结构。<br><strong>文档</strong>：描述程序的研制过程、方法和使用的图文资料。 </p></blockquote><a id="more"></a><ul><li>软件所具有的<strong>复杂性</strong>、<strong>一致性</strong>、<strong>可变性</strong>、<strong>不可见性</strong>等特性，使得软件开发过程变得难以控制。</li><li>软件的特点：<ul><li>软件是一种<strong>逻辑实体</strong>，不是具体的物理实体。</li><li>软件产品的生产主要是研制。</li><li>软件具有<strong>“复杂性”</strong>，其开发和运行常受到计算机系统的限制。</li><li>软件<strong>成本昂贵</strong>，其开发方式目前尚未完全摆脱手工生产方式。</li><li>软件不存在磨损和老化问题，但存在<strong>退化问题</strong>。</li></ul></li></ul><h4 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h4><ul><li><code>软件危机</code>：落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。  </li><li>体现在：   <ol><li>软件产品无质量保证，可靠性差，甚至开发过程就夭折。  </li><li>软件生产率太低  </li><li>无法开发复杂程度高的软件</li><li>成本和进度估计不准</li><li>无统一科学的规范，软件不可维护</li><li>软件常不能满足用户的需求</li></ol></li><li>解决途径： <ol><li>管理措施:项目管理、配置管理、过程管理、质量控制</li><li>技术措施:开发过程、开发技术与方法和开发工具 </li></ol></li></ul><h4 id="软件工程的发展"><a href="#软件工程的发展" class="headerlink" title="软件工程的发展"></a>软件工程的发展</h4><ul><li>史前时代(1965-1967)<ol><li>软件开发没有方法可循</li><li>软件设计是在开发人员头脑中完成的隐藏过程</li><li>60世纪中期的软件危机</li></ol></li><li>瀑布过程模型(1968-1982) <ol><li>1968年提出“软件工程”</li><li>结构化开发方法</li><li>瀑布式软件生命周期模型 成为典型</li></ol></li><li>质量标准体系<ol><li>面向对象开发方法</li><li>软件过程改进运动</li><li>CMM/ISO9000/SPICE等 质量标准体系</li></ol></li><li>20世纪90年代至今<ol><li>敏捷开发方法流行</li><li>更紧密的团队协作</li><li>有效应对需求变化</li><li>快速交付高质量软件</li><li>迭代和增量开发过程 </li></ol></li></ul><h4 id="软件工程的定义"><a href="#软件工程的定义" class="headerlink" title="软件工程的定义"></a>软件工程的定义</h4><p><code>软件工程</code>是①将系统性的、规范化的、可定量的方法应用于软件的开发、运行和维护，即工程化应用到软件上；②对①中所述方法的研究。</p><blockquote><p>是一门指导计算机和维护的工程学科。</p></blockquote><h4 id="软件工程三要素"><a href="#软件工程三要素" class="headerlink" title="软件工程三要素"></a>软件工程三要素</h4><ol><li><strong>方法</strong>: 研究软件开发<strong>“如何做”</strong>的技术。涵盖了项目计划、需求分析、系统设计、程 序实现、测试与维护等一系列的开发活动如何来做。开发方法经历了从面向结构、面向对象、 面向组件到面向服务的发展工程。 </li><li><strong>过程</strong>: 为<strong>及时</strong>、<strong>合理</strong>地开发出满足用户需求的计算机软件而进行<strong>一系列有组织的活动</strong>。</li><li><strong>工具</strong>: 为过程和方法提供自动的或半自动的支持。这些软件工具被<strong>集成</strong>起来，建立起一个支持软件开发的系统，称之为<strong>计算机辅助软件工程 </strong>(CASE ，Computer Aided Software Engineering)。</li></ol><h3 id="2-软件过程模型"><a href="#2-软件过程模型" class="headerlink" title="2.软件过程模型"></a>2.软件过程模型</h3><p><code>软件过程模型</code>定义任务之间关系和规程和方法，软件过程模型是对软件过程的抽象描述。</p><h4 id="瀑布模型："><a href="#瀑布模型：" class="headerlink" title="瀑布模型："></a>瀑布模型：</h4><ul><li>瀑布模型：将软件生存周期各活动规定为依线性顺序联接的若干阶段的模型。一个系统的、顺序的软件开发方法。</li><li>该模型说明整个软件开发过程是按图中的各个阶段进行的，每个阶段的任务完成之后，产生右边相应的文档</li><li>优点：<ul><li>为项目提供了按阶段划分的检查点</li><li>当前一阶段完成后，只需要去关注后续阶段</li><li>可在迭代模型中应用瀑布模型</li></ul></li><li>缺点：<ul><li>各个阶段的划分完全固定，阶段之间产生了大量的文档，增加了工作量</li><li>由于开发过程是线性的，开发过程中很难响应用户的变更要求</li><li>早期错误要等到后期测试阶段才能发现</li><li>实际项目开发中很少遵守瀑布模型提出的顺序</li><li>客户要等到开发周期的晚期才能得到可执行的程序</li></ul></li></ul><h4 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h4><ul><li>为了描述、述软件开发过程中可能的回溯，尤其是维护阶段往往要经历上描述各个阶段，采用循环模型描述。</li><li>原型是一个部分开发的产品，用于加强对系统的理解，有助于明确需求和选择可行的设计策略。 </li></ul><h4 id="迭代式开发"><a href="#迭代式开发" class="headerlink" title="迭代式开发"></a>迭代式开发</h4><ul><li>迭代式开发：将描述、开发和验证等不同活动交织在一起，在开发过程中建立一系列版本，将系统一部分一部分地逐步交付。 </li></ul><h4 id="增量模型："><a href="#增量模型：" class="headerlink" title="增量模型："></a>增量模型：</h4><ul><li>增量模型：先开发主要功能模块，再开发次要功能模块，逐步完善直到构造全部功能。</li><li>优点：<ul><li>分步开发，降低复杂性和难度。</li><li>当配备的人员不能在设定的期限内完成产品时，它提供了一种先推出核心产品的途径。</li><li>可先发布部分功能给客户，对客户起到镇静剂的作用。</li><li>边开发边投入，可及早发现问题，减少投资风险。</li><li>适用于需求不完整的软件开发，可以灵活应对用户的需求变化。</li></ul></li><li>缺点：<ul><li>加入构件不能破坏已构造好的系统部分，这需要软件具备开放式的体系结构。 </li><li>需求改变过大会导致软件过程的控制失去整体性。</li><li>如果增量包之间存在相交的情况且未很好处理，则必须做全盘系统分析。</li></ul></li></ul><h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><ul><li>一种风险驱动型的过程模型，一种演进式软件过程模型。它结合了原型的<strong>迭代性质</strong>和瀑布模型的<strong>系统性和可控性</strong>特点。具有快速开发越来越完善软件版本的潜力。</li><li>螺旋模型将开发过程分为几个螺旋周期，每个螺旋周期可分为4个工作步骤:<ol><li>确定目标、方案和限制条件；</li><li>评估方案、标识风险和解决风险；</li><li>开发确认产品；</li><li>计划下一周期工作。</li></ol></li><li>优点：<ul><li>开发大型系统和软件的理想方法。</li><li>客户始终参与每个阶段的开发，每个阶段的成果需客户确认，避免错误的积累。</li><li>增加风险分析，一旦风险成立，原方案应终止、修订，力求风险可控。</li></ul></li><li>缺点：很难说服客服演进的方法是可控的，依赖于低昂的风险评估专家来保证成功。</li></ul><h4 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h4><ul><li>敏捷宣言<ul><li>个体和交互&gt;过程和工具</li><li>可以工作的软件&gt;面面俱到的文档</li><li>客户合作&gt;合同谈判</li><li>响应变化&gt;遵循计划</li></ul></li><li>极限编程(XP)：偏重编程实践 </li><li>Scrum开发方法：偏重项目管理<ul><li>特点：计划性、灵活性</li></ul></li></ul><h3 id="3-软件需求分析"><a href="#3-软件需求分析" class="headerlink" title="3. 软件需求分析"></a>3. 软件需求分析</h3><ul><li>目的：弄清用户对系统的细节要求，完整、准确、清晰、具体地回答目标系统 “做什么”。准确地理解用户 出的软件功能、性能及其环境的要求。</li><li>必要性：用户与开发者的知识领域不同，产生歧义;软件开发失败 50%是需求 不合理，早期错误易放大。</li></ul><h4 id="需求工程活动"><a href="#需求工程活动" class="headerlink" title="需求工程活动"></a>需求工程活动</h4><ul><li><strong>需求获取</strong><ul><li>需求获取技术：面谈、问卷调查、群体诱导技术、参与调查法、文档分析、原型化方法、需求讨论会..<br>。</li></ul></li><li><strong>需求分析与建模</strong></li><li>需求规约：软件需求规约(文档)</li><li><strong>需求管理</strong></li><li><p><strong>需求验证</strong></p></li><li><p>业务需求：反映企业/组织对软件系统的高层次目标要求，即软件系统的建设目标。</p></li><li>用户需求：用来描述用户使用产品必须要完成的任务，使用业务领域的术语描述，采用开发者与用户都能理解的语言和图形表达。</li><li>功能需求：开发人员必须实现的软件功能，结果在需求规格说明书中。</li><li>（也包括非功能需求）：如界面的交互性、数据的安全性、 数据的事务性、用户的并发性、响应的快速性、操作的实时性、错误与异常的恢复性、软件 的容错性等等<h4 id="需求分析方法"><a href="#需求分析方法" class="headerlink" title="需求分析方法"></a>需求分析方法</h4></li><li>功能分析方法：将系统看作若干功能模块的集合，每个功能又可以分解为若干子功能，子功能还可继续分解，分解的结果已经是系统的雏形。</li><li>结构化分析方法(SA法)：是一种以数据、数据的封闭性为基础，从问题空间到某种表示的映射方法，由数据流图（DFD图）表示。</li><li>信息建模法：是从数据的角度对现实世界建立模型的，基本工具是ER图。</li><li>面向对象的分析方法（OOA）的关键是识别问题域内的对象，分析它们之间的关系，并建立起三类模型。<ul><li>面向对象的特性有<strong>抽象性、封装性、继承性、多态性和消息机制</strong>等五大特性。</li></ul></li></ul><h4 id="结构化分析方法-SA法"><a href="#结构化分析方法-SA法" class="headerlink" title="结构化分析方法(SA法)"></a>结构化分析方法(SA法)</h4><ul><li>基本思想<ul><li>分解：对于一个复杂的系统，为了将复杂性降低到可以掌握的程度，可以把大问题分解成若干小问题，然后分别解决。</li><li>抽象：分解可以分层进行，即先考虑问题最本质的属性，暂把细节略去，以后再逐层添加细节，直至涉及到最详细的内容，</li></ul></li><li><strong>DFD图</strong><ul><li>箭头表示<strong>数据流</strong>(表示数据流的名称和数据的流向)</li><li>圆或椭圆表示<strong>加工</strong></li><li>双杠或者单杠表示<strong>数据存储</strong></li><li>矩形框表示数据的源点或终点，即<strong>外部实体</strong>(系统外与系统交互的人或实体)。</li></ul></li><li>分层DFD图<ul><li>先确定系统范围，画出顶层的DFD图。顶层图说明了系统的边界，<br>即系统的输入和输出数据流，顶层图只有一张。</li><li>逐层分解顶层DFD图，获得若干中间层DFD图。中间层的数据流图描述了某个加工的分解，而它的组成部分又要进一步分解。 </li><li>画出底层的DFD图。底层图由一些不能再分解的加工组成。</li></ul></li><li><strong>数据字典(DD)</strong>：描述数据流图中出现的所有数据和加工。<ul><li>分层数据流图只是表达了系统的“分解”，为了完整地描述这个系统，还需借助“数据词典”和“小说明”对图中的每个数据和加工给出解释。</li><li><strong>数据流条目</strong>：给出了DFD中数据流的定义，通常对数据流的简单描述为列出该数据流的各组成数据项。</li><li><strong>文件条目</strong>：给出某个文件的定义，文件的定义通常是列出文件记录的组成数据流，还可指出文件的组织方式。</li><li><strong>数据项条目</strong>：给出某个数据单项的定义，通常是该数据项的值类型、允许值等。</li><li><strong>加工条目</strong>：说明DFD中基本加工的处理逻辑。由于上层的加工是由下层的基本加工分解而来，只要有了基本加工的说明，就可理解其他加工。</li></ul></li></ul><h3 id="4-软件体系结构设计"><a href="#4-软件体系结构设计" class="headerlink" title="4.软件体系结构设计"></a>4.软件体系结构设计</h3><h4 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h4><ul><li>软件设计阶段要解决“如何做”的问题</li><li>软件所有的开发工作都将根据设计的方案进行</li><li>软件的总体结构设计决定了系统的质量</li><li><strong>软件设计包括软件结构设计、数据设计、接口设计和过程设计。</strong><ul><li>结构设计：定义软件系统<strong>各主要部件之间的关系</strong></li><li>数据设计：将分析时创建的模型转化为数据结构的定义</li><li>接口设计：描述软件内部、软件和操作系统之间及软件与人之间如何通信</li><li><strong>过程设计</strong>：把<strong>系统结构部件</strong>换成<strong>软件</strong>的过程描述。</li></ul></li></ul><h4 id="软件设计的任务"><a href="#软件设计的任务" class="headerlink" title="软件设计的任务"></a>软件设计的任务</h4><ul><li>将分析阶段获得的需求说明转换为计算机中可实现的系统。</li><li>完成系统的结构设计，包括：数据结构和程序结构，最后得到软件设计说明书。</li><li>对模块内部的过程进行设计。</li></ul><h4 id="软件设计阶段任务"><a href="#软件设计阶段任务" class="headerlink" title="软件设计阶段任务"></a>软件设计阶段任务</h4><ol><li><strong>划分模块，确定软件结构</strong>：开发方法不同，确定软件结构的方法也不同。例如SD法，是从分层的DFD图导出初始的结构图，再对初始的结构图进行改进，获得最终的结构图。一般包括确定系统的软件结构，分解模块，确定系统的模块层次关系。</li><li>确定<strong>系统的数据结构</strong>：数据结构的建立对于<strong>信息系统</strong>而言尤为重要。要确定数据的类型，组织、存取方式，相关程度及处理方式等。</li><li>设计<strong>用户界面</strong>：作为人机接口的用户界面起着越来越重要的作用，它直接影响到软件的寿命。</li></ol><h4 id="软件的层次结构"><a href="#软件的层次结构" class="headerlink" title="软件的层次结构"></a>软件的层次结构</h4><ul><li>模块：是程序对象有名字的集合(过程、函数、子程序、宏..)。</li><li>深度：表示软件结构从顶层模块到最底层模块的层数。</li><li>宽度：表示控制的总分布。</li><li>扇出度：一个模块直接控制下属的模块个数。</li><li>扇入度：一个模块的直接上属模块个数。</li><li>好的软件结构的形态准则：顶部宽度小，中部宽度大，底部宽度次之；在结构顶部有较高的扇出数，在底部有较高的扇入数。</li></ul><h4 id="软件结构图-SC图"><a href="#软件结构图-SC图" class="headerlink" title="软件结构图(SC图)"></a>软件结构图(SC图)</h4><ul><li>　结构图（Structure Chart，简称SC图）是精确表达软件结构的图形表示方法，它以特定的符号表示模块、模块间的调用关系和模块间信息的传递。<ul><li>模块（Module）：用矩形框表示，框中写有模块的名字，说明模块的功能。</li><li>调用：从一个模块指向另一个模块的箭头表示前一模块对后一模块的调用，一般是上层调用下层。</li><li>数据：调用箭头边上的小箭头表示调用时从一个模块传送给另一模块的数据。通常在短箭头附近应注有信息的名字。</li></ul></li></ul><h4 id="模块独立性"><a href="#模块独立性" class="headerlink" title="模块独立性"></a>模块独立性</h4><ul><li>模块独立性的度量标准：<ul><li>耦合性——用于描述<strong>模块之间</strong>联系的紧密程度。</li><li>内聚性——用于描述<strong>模块内部</strong>联系的紧密程度。</li></ul></li><li>模块独立性比较强的模块，具有：<strong>高内聚性、低耦合度</strong>。</li><li>内聚性低 &rarr; <strong>高</strong>：偶然型  &rarr; 逻辑型 &rarr; 瞬时型  &rarr; 通信型  &rarr; 顺序型  &rarr; <strong>功能性</strong></li><li>耦合性高 &rarr; <strong>低</strong>：内容耦合 &rarr; 公共耦合 &rarr; 控制耦合 &rarr; 复合耦合 &rarr; <strong>数据耦合</strong></li></ul><h4 id="软件设计-SD"><a href="#软件设计-SD" class="headerlink" title="软件设计(SD)"></a>软件设计(SD)</h4><ul><li>软件设计定义：软件设计是把软件需求（定义阶段）转换为软件的具体设计方案，即划分模块结构的过程，是软件开发阶段最重要的步骤。</li><li>软件设计划分：按工程管理角度划分为：概要（总体）设计和详细设计。<br>概要（总体）设计完成高层次结构设计；详细设计进行低层次过程设计，并穿插数据设计和接口设计。</li></ul><ol><li>概要/总体设计：分解模块，确定系统模块的层次结构。<ul><li>任务：① 划分模块 ② 确定模块功能 ③ 确定模块间调用关系 ④ 确定模块间界面</li><li>步骤：从DFD图导出初始的模块结构图，按照SD法设计总则，改进模块结构图。</li><li>得出：<strong>软件/模块结构图</strong>及其模块功能说明。</li></ul></li><li>详细设计：对模块图中每个模块的过程进行描述，把功能描述转变为精确的、结构化的过程描述。<ul><li>常用<strong>描述方式</strong>：伪代码，流程图，N-S图，PAD图…</li></ul></li></ol><blockquote><p>软件设计过程，概要设计是关键，根据需求确定<strong>软件和数据的总体框架</strong>，详细设计是进一步精化成软件的算法和数据结构。</p></blockquote><h4 id="软件结构化方法的优化准则"><a href="#软件结构化方法的优化准则" class="headerlink" title="软件结构化方法的优化准则"></a>软件结构化方法的优化准则</h4><ul><li>抽象：抽取事物最基本的特性和行为，忽略非基本的细节。采用分层次抽象的办法可以控制软件开发过程的复杂性，有利于软件的可理解性和开发过程的管理。</li><li>信息隐藏：采用封装技术，将程序模块的实现细节（过程或数据）隐藏起来，不被不需要这些信息的其它模块访问。</li><li>模块化：模块是程序中逻辑上相对独立的单元；模块的大小要适中；高内聚、低耦合。<ul><li>使开发工作更易于规划</li><li>可以定义和交付软件增量</li><li>容易实施变更</li><li>更有效地开展测试和调试</li></ul></li><li>一致性：整个软件系统（包括文档和程序）的各个模块均应使用一致的概念、符号和术语；程序内部接口应保持一致； </li></ul><h3 id="5-软件测试"><a href="#5-软件测试" class="headerlink" title="5. 软件测试"></a>5. 软件测试</h3><ul><li>软件测试是为了发现错误而运行程序的过程</li><li>软件测试的目的是发现程序中的错误，是为了证明程序有错， 而不是证明程序无错</li><li>测试对象不仅是程序，还应该包括开发过程中产生的所有产品，包括文档，其目的是为了尽早地、尽可能多的发现并排除软件中潜在的错误。<h4 id="软件测试分类"><a href="#软件测试分类" class="headerlink" title="软件测试分类"></a>软件测试分类</h4></li><li>程序执行角度<ul><li><strong>静态测试</strong>：通过人工分析或<strong>程序正确性证明</strong>的方式来确认程序正确性。</li><li><strong>动态测试</strong>：通过<strong>动态分析</strong>和<strong>程序测试</strong>等方式检查程序执行状态，以确认是否有问题。</li></ul></li><li>测试技术角度：<ul><li><strong>黑盒测试</strong>：将测试对象看做一个黑盒子，完全<strong>不考虑程序内部</strong>的逻辑结构和内部特性，只依据程序的<strong>需求规格说明书</strong>，检查<strong>程序的功能</strong>是否符合它的功能说明。</li><li><strong>白盒测试</strong>：把测试对象看做一个透明的盒子，允许测试人员<strong>利用程序内部</strong>的逻辑结构及有关信息，设计或选择测试用例，对程序所有<strong>逻辑路径</strong>进行测试。</li></ul></li><li>测试对象角度：</li><li><strong>单元测试</strong>：对软件基本组成单元进行的测试，其测试对象是软件设计的<strong>最小单位</strong>(<strong>模块</strong>或者类)。</li><li><strong>集成测试</strong>：在单元测试的基础上，将所有模块按照总体设计的要求组装成为<strong>子系统</strong>或<strong>系统</strong>进行的测试。测试对象是模块间的接口，其主要目的是找出在模块接口(包括系统体系结构)设计上的问题。</li><li><strong>功能测试</strong>：在已知产品所应具有的功能基础上，从<strong>用户角度</strong>来进行功能验证，以确认每个功能是否都能正常使用。</li><li><strong>性能测试</strong>：在实际或模拟实际的运行环境下，针对<strong>非功能特性</strong>所进行的测试。</li><li><strong>验收测试</strong>：软件产品完成了系统测试之后、产品发布之前进行的软件测试活动，其<strong>目的</strong>是验证软件的功能和性能是否能够满足用户所期望的要求。</li><li>人工干预角度：<ul><li><strong>手动测试</strong>：手工地输入测试数据并记录测试结果</li><li><strong>自动化测试</strong>：利用开发的软件测试工具或者脚本</li></ul></li></ul><h4 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h4><ul><li><strong>互审</strong>：程序员相互检查对方的代码</li><li><strong>走查</strong>：一个小组集体来走查程序或文档(分析方法：调用图、数据流分析图)</li><li><strong>会议</strong>：召开一个正式的会议，并有相应的记录、纪要、相应结果的文档。</li></ul><h4 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h4><h5 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h5><ul><li>逻辑覆盖法：<ul><li>语句覆盖：只覆盖可执行语句至少执行一次。</li><li>判定覆盖：又叫分支覆盖，对每个判定式取真、假各一次，使每个判定的每个分支都至少执行一次，同时满足语句覆盖。</li><li>条件覆盖：把程序中每个判断的每个条件为真和假各取值一次。 条件覆盖深入到判定中的每个条件，但不一定满足判定覆盖的要求。</li><li>判定/条件覆盖：同时满足判定、条件两种覆盖标准的取值。就是使得判定中每个条件的所有可能取值至少执行一次，同时每个判定本身所有取值至少执行一次。</li><li>条件组合覆盖：按每个判断的所有条件取值进行组合。这是 5 种覆盖中最强的覆盖。它不但可<strong>覆盖所有条件</strong>，还可<strong>覆盖所有判断的可取分支</strong>。</li></ul></li><li>基本路径覆盖法<ul><li>导出程序流程图的拓扑结构-流图(控制流程图)</li><li>计算流图 G 的环路复杂性 V(G)</li><li>确定只包含独立路径的基本路径集，设计测试用例</li></ul></li></ul><h5 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h5><ul><li>等价类划分法：<ul><li>对测试数据进行区间划分，从这些区间中选取典型值作为用例代表，认为测试等价类中的一个代表值的结果就等于对该类其它值的测试。</li><li>如果某个等价类的一个输入数据（代表值）测试中查出了错误，表示该等价类的其它值也有错误。</li><li>选择测试用例：① 为每个等价类编号 ② 使一个测试用例尽可能覆盖多个有效等价类<br>（<strong>注意：一个测试用例只能覆盖一个无效等价类。</strong>）</li><li><code>有效等价类</code>：对于程序的规格说明，是合理的、有意义的输入数据构成的集合。</li><li><code>无效等价类</code>：对于程序的规格说明，是不合理的、没有意义的输入数据构成的集合。</li></ul></li><li>边界值分析法：对输入或输出的边界值进行测试的一种方法。因为在等价类的边界处，是最可能出现错误的。<ul><li>步骤：划分等价类，选择测试用例，测试等价类边界。</li><li>边界选择原则：① 输入值范围的边界 ② 输入/输出值个数的边界 ③ 输出值域的边界 ④ 输入/输出有序集（如顺序文件、线性表）的边界</li></ul></li><li>错误推测法</li><li>因果图法</li></ul><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul><li>驱动模：模拟主程序或者调用模块的功能，用于向被测模块传递数据，接收、打印从被测模块返回的数据。<strong>一般只设计一个驱动模块</strong>。</li><li>桩模块：又称为假模块，用于模拟那些由被测模块所调用的下属模块的功能。可以设计<strong>一个或者多个桩模块</strong>，才能更好地对下属模块进行模拟。</li><li>测试方法以<strong>白盒法</strong>为主，驱动模块和桩模块都是额外开销。</li></ul><h4 id="集成-组装测试"><a href="#集成-组装测试" class="headerlink" title="集成/组装测试"></a>集成/组装测试</h4><ul><li>一次性集成方式：分别测试每个单元，再一次性将所有单元组装在一起进行测试。</li><li>渐增式集成方式：先对某几个单元进行测试，然后将这些单元逐步组装成较大的系统，在组装过程中边连接边测试。（自顶而下增值，自底而上增值，混合增值）<br>自顶而下增值，自底而上增值可以选择<strong>深度优先</strong>或者<strong>宽度优先</strong>增值</li><li>两种方式都需要设计驱动模块或桩模块，对每一个新组装的子系统进行测试主要采用黑盒法，对发现问题较多的子系统或模块应该用白盒法作回归测试。</li><li>集成过程原则：尽早测试关键模块  &rarr; 提高测试效率，尽早测试包含I/O的模块   &rarr; 为以后测试提供方便</li></ul><h4 id="系统-性能测试"><a href="#系统-性能测试" class="headerlink" title="系统/性能测试"></a>系统/性能测试</h4><ul><li>恢复测试：让软件强制地发生故障，然后来验证是否能恢复到正常工作。</li><li>安全测试：验证保护机制是否能够正常工作。</li><li>压力(强度)测试：在一种需要反常数量、频率或资源的方式下执行系统。</li><li>性能测试：测试软件在集成系统中的运行性能。</li></ul><h4 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h4><ul><li>测试的目的：显示存在错误</li><li>调试的目标：发现错误或导致程序失效的错误原因，并修改程序以修正错误。调试是测试之后的活动。</li><li><strong>三种调试方法</strong><ul><li>蛮力法(强行排错法)</li><li>返回法、回溯法</li><li>原因排除法 <h3 id="软件维护"><a href="#软件维护" class="headerlink" title="软件维护"></a>软件维护</h3></li></ul></li><li><code>软件维护</code>：在软件运行／维护阶段对软件产品进行<br>  的修改是所谓的维护。</li><li>软件维护类型<ul><li><strong>改正性维护</strong>：修改软件缺陷或者不足</li><li><strong>适应性维护</strong>：修改软件使其适应不同操作环境，主要包括硬件变化、操作系统变化或者其他支持软件变化。</li><li><strong>完善性维护</strong>：增加或修改系统功能，使其适应业务变化。</li><li><strong>预防性维护</strong>：采用先进的软件工程方法对需要维护的软件或软件中的某一部分（重新）进行设计、编制和测试。是为了提高软件的<strong>可维护性、可靠性</strong>等，为<strong>以后进一步改进软件</strong>打下良好基础。</li></ul></li><li>维护的副作用<ul><li>代码副作用</li><li>数据副作用</li><li>文档副作用。</li></ul></li><li>维护工作面临的困难：周期长、难度大、费用高。维护费用高</li></ul><h4 id="Point"><a href="#Point" class="headerlink" title="Point"></a>Point</h4><ul><li><strong>三层C/S结构</strong>包含表示层、功能层和数据层。</li><li><strong>软件</strong>由程序、数据和文档构成的。</li><li>从工程管理方面来分类，<strong>软件设计</strong>一般分为概要设计和详细设计，它们之间的关系是全局和局部。</li><li><strong>面向对象程序设计原则</strong>包括开闭原则、里氏替换原则、单一职责原则和依赖倒转原则。<ul><li><strong>开闭原则</strong>：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。抽象化是开闭原则的关键           </li><li><strong>单一职责原则</strong>：一个类只负责一个功能领域中的相应职责。或者说，一个类，应该只有一个引起它变化的原因。</li><li><strong>里氏替换原则</strong>：所有引用基类（父类）的地方必须能透明的使用其子类的对象。（实现开闭原则的重要方式之一）</li><li><strong>依赖倒转原则</strong>：抽象不应该依赖于细节，细节应当依赖于抽象。</li><li><strong>合成复用原则</strong>：尽量使用对象组合，而不是继承来达到复用的目的。</li></ul></li><li>在软件结构化设计方法中，指导模块划分的最重要原则是高内聚、低耦合。</li><li>需求分析最终结果是产生需求规格说明书。</li><li>模块独立性中，使得每个模块只完成一个相对独立的特定子功能，并且与其它模块的关系很简单。</li><li><strong>产品需求</strong>又可以细分为功能性需求和非功能性需求。</li><li><strong>需求内容来源</strong>于干系人、组织规章制度、业务过程和现有系统。</li><li>在<strong>需求工程过程</strong>中，最重要的工程活动包括需求获取、需求分析与建模、需求验证和需求管理。</li><li><strong>软件设计原则</strong>是系统分解和模块设计的基本标准，应用这些原则可以使代码更加灵活、易于维护和扩展。一些通用的原则包括抽象、封装、模块化、层次化和复用。</li><li>在测试过程中，需要考察<strong>模块间的接口</strong>和<strong>各模块之间联系**</strong>的测试属于集成测试。</li><li><strong>软件测试用例</strong>主要由输入用例和预期输出结果两部分组成</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络笔记05 链路层</title>
      <link href="/cn5/"/>
      <url>/cn5/</url>
      
        <content type="html"><![CDATA[<h3 id="5-1-链路层概述"><a href="#5-1-链路层概述" class="headerlink" title="5.1 链路层概述"></a>5.1 链路层概述</h3><ul><li>基本概念:<ul><li>主机和路由器：结点</li><li>相邻结点的通信信道：链路 eg.wired links, wireless links, LANs</li><li>链路层的数据分组</li><li>帧 <code>frame</code>: 封装网络层的数据报 </li></ul></li><li>链路层的背景<ul><li>在不同的链路当中使用不同的协议来传输数据报:e.g.,<br>第一个链路以太网Ethernet，第二个链路是帧中继网络，第三个网络是802.11</li><li>不同的链路提供的服务也不同</li></ul></li></ul><a id="more"></a> <h4 id="链路层的服务"><a href="#链路层的服务" class="headerlink" title="链路层的服务"></a>链路层的服务</h4><ul><li>成帧, 链路接入: <ul><li>将数据报封装成帧, 加上首部和尾部字段</li><li>多路访问(接入)</li><li>“MAC” 地址用于标识发送结点和接收节点</li></ul></li><li>相邻结点间的可靠传输：<ul><li>保证无差错地经链路层移动每个网络层数据报</li><li>在错误率低的链路中(光纤,某类双绞线)中不需提供，而无线链路:具有较高的错误率</li></ul></li><li>流控制: 匹配相邻结点的 (发送/接收)速度</li><li>差错检验: <ul><li>由信号衰减、噪声等产生差错</li><li>接收结点需要检测是否出现bit差错: 丢弃错误帧，告知发送结点重传(可选) </li></ul></li><li>差错恢复（可选）: 接收结点可以发现并修复bit差错，不需发送结点进行重传</li><li>半 / 全双工: 半双工指结点不能在发送的时候同时接收数据</li></ul><h4 id="链路层协议在何处实现"><a href="#链路层协议在何处实现" class="headerlink" title="链路层协议在何处实现"></a>链路层协议在何处实现</h4><ul><li>(most)在每个主机上(硬件)：链路层协议在<code>网络适配器</code>/<code>网络接口卡</code>上部署 <ul><li>a.k.a. network interface card NIC<br>Ethernet card, PCMCI card, 802.11 (wifi) card</li><li>通过系统总线接入系统</li><li>适配器上还包括物理层协议</li></ul></li><li>(少数)在运行于主机CPU上的软件中实现</li></ul><blockquote><p>链路层是软件、硬件的结合体，即此处是协议栈中软件与硬件交接的地方</p></blockquote><h3 id="5-2-差错检验和纠正"><a href="#5-2-差错检验和纠正" class="headerlink" title="5.2 差错检验和纠正"></a>5.2 差错检验和纠正</h3><ul><li>EDC = 差错检验和纠正比特(redundancy)</li><li>D = 数据, 保护首部信息</li><li>差错检验并不是100% 可靠，也有可能出现<strong>未检出比特差错</strong><br><img src="https://i.loli.net/2018/06/06/5b17b5ba7d457.png" width="60%" height="60%"> </li></ul><h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><ul><li>单个奇偶校验位: 检测单个bit差错(当差错“突发”式聚集，偶数个/奇数个bit差错)</li><li>二维奇偶校验: 检测和<strong>恢复</strong>单个比特差错<h4 id="检验和方法"><a href="#检验和方法" class="headerlink" title="检验和方法"></a>检验和方法</h4></li><li><p>目标: 检测数据分组的差错(传输层)</p></li><li><p>发送方:把报文段分成16bit的整数序列</p><ul><li>检验和: 16bit的整数序列求和</li><li>将检验和封装到TCP/UDP首部</li></ul></li><li>接收方:计算接收报文段的检验和<ul><li>与首部中的检验和字段进行比对:不同 - &gt; error detected 相同 - &gt; no error detected. </li></ul></li><li>与链路层使用CRC相比，提供相对较弱的差错保护。<ul><li>因为<strong>运输层</strong>的差错检验用<strong>软件</strong>实现，采取简单而快速的方法</li><li>而<strong>链路层</strong>的差错检验在适配器中用<strong>专用的硬件</strong>实现，能够快速执行更复杂的CRC操作</li></ul></li></ul><blockquote><p>检验和比对结果相同是不是绝对没出错？</p></blockquote><h4 id="循环冗余检测"><a href="#循环冗余检测" class="headerlink" title="循环冗余检测"></a>循环冗余检测</h4><ul><li>将数据分组<strong>D</strong>看作一个二进制整数</li><li>双方协商一个r+1的<strong>生成多项式，G</strong><ul><li>G的最高比特位为1</li></ul></li><li>目标: 选择长度为r的附加比特, R, 使得<ul><li>用 <strong>&lt;D,R&gt;</strong> 对G进行模2除法 </li><li>接收方也知道 <strong>G</strong>, 用 <strong>&lt;D,R&gt;</strong> 除以<strong>G</strong>. </li><li>如果余数不为零: error detected!</li><li>可以检测小于r+1个比特的差错</li></ul></li><li>广泛应用于多种链路协议(Ethernet, 802.11 WiFi, ATM)  </li><li>其他用途：CRC32: 压缩文件检验 / CRC 可作为hash函数<br><img src="https://i.loli.net/2018/06/06/5b17b92459d0c.png" width="30%" height="30%"> </li></ul><h2 id="5-3-多址访问协议"><a href="#5-3-多址访问协议" class="headerlink" title="5.3 多址访问协议"></a>5.3 多址访问协议</h2><h4 id="两种类型的“链路”"><a href="#两种类型的“链路”" class="headerlink" title="两种类型的“链路”:"></a>两种类型的“链路”:</h4><ul><li>点对点链路：链路一端的单个发送方和另一端的单个接收方<br>eg. <code>PPP</code>：拨号接入 <code>HDLC</code>：高级数据链路控制</li><li>广播链路：(共享链路和物理媒介)<br>eg. <code>Ethernet</code>：以太网 <code>802.11 wireless LAN</code>：wifi无线局域网</li></ul><h3 id="多址访问协议"><a href="#多址访问协议" class="headerlink" title="多址访问协议"></a>多址访问协议</h3><ul><li>只有一个信道，供多对通信实体访问</li><li>两个以上的并发通信: 干扰<ul><li>碰撞：如果同一时刻两个以上的结点同时发送信息    (信号纠缠在一起，发送的数据帧都会出错(丢失))</li></ul></li><li>分布式的算法<ul><li>结点怎么共享链路，如：确定哪个结点在什么时候可以发送数据</li><li>结点之间的协同也使用相同的链路，没有“带外信道”进行协同</li></ul></li></ul><h4 id="理想的多路访问协议"><a href="#理想的多路访问协议" class="headerlink" title="理想的多路访问协议"></a>理想的多路访问协议</h4><p>设广播信道的带宽为R bps </p><ol><li>当结点需要传输数据, 它可以充分利用带宽R.  </li><li>当M个结点需要传输数据, 每个结点可以平均使用带宽 R/M  </li><li>完全分布式控制:<br>不需要特殊的结点来协调(不需要主持人)<br>不需要时钟同步、划分时隙  </li><li>简单、易于实现  </li></ol><h4 id="多址访问协议：分类"><a href="#多址访问协议：分类" class="headerlink" title="多址访问协议：分类"></a>多址访问协议：分类</h4><ul><li>信道划分协议<ul><li>将信道划分为小的分片 “pieces” (时隙, 频段, 编码)</li><li>将每个信道分片分配给特定的用途，“各行其道，避免撞车”</li></ul></li><li>随机访问协议：信道不进行划分, 允许产生碰撞，重点是怎么从碰撞中“恢复”</li><li>轮流协议：结点按次序轮流传送数据</li></ul><h4 id="信道划分多址访问协议"><a href="#信道划分多址访问协议" class="headerlink" title="信道划分多址访问协议"></a>信道划分多址访问协议</h4><h5 id="TDMA-分时多址访问"><a href="#TDMA-分时多址访问" class="headerlink" title="TDMA: 分时多址访问"></a>TDMA: 分时多址访问</h5><ul><li>按照时间的“回合”来访问链路 </li><li>每个结点分配固定长度的时间间隙(time slot)<br>(length = pkt trans time) in each round </li><li>没有发送数据的时隙就空闲起(是一种浪费) </li></ul><h5 id="FDMA-分频多址访问"><a href="#FDMA-分频多址访问" class="headerlink" title="FDMA: 分频多址访问"></a>FDMA: 分频多址访问</h5><ul><li>信道根据频谱划分成若干个频段</li><li>每个结点使用固定的频段</li><li>不发送数据的结点所在的频段空闲 </li></ul><p><img src="https://i.loli.net/2018/06/06/5b17bd9ab1583.png" width="60%" height="60%"> </p><h5 id="CDMA-码分多址访问"><a href="#CDMA-码分多址访问" class="headerlink" title="CDMA: 码分多址访问"></a>CDMA: 码分多址访问</h5><p>为每个接入的结点分配一种不同的编码。如果精心挑选这些编码，CDMA具有不同的结点能够同时传输的性质。</p><blockquote><p>类似：很多人之间使用不同的语言交流。</p></blockquote><h4 id="随机多址访问协议"><a href="#随机多址访问协议" class="headerlink" title="随机多址访问协议"></a>随机多址访问协议</h4><ul><li>当结点需要发送数据时: 利用链路的全带宽来发送数据，不需要结点之间事先协调</li><li>两个以上的结点传输 ➜ 产生“碰撞”</li><li>随机多址访问协议将规约: 怎样检测碰撞，怎样从碰撞中恢复 (e.g., 延迟一下传输)</li><li>随机多址访问协议的案例: 时隙ALOHA, ALOHA, CSMA, CSMA/CD, CSMA/CA<h5 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h5></li><li>假设:<ul><li>所有帧的长度相同: L</li><li>划分成等长的时隙: t<br>时隙为传输1个帧的时间, t= L/R</li><li>结点只能在时隙开始时传输帧</li><li>结点必须保持<strong>时钟同步</strong></li><li>如果两个结点在一个时隙内传数据，所有结点都可以检测到碰撞</li></ul></li><li>操作:当结点准备传输一个帧<ul><li><strong>如果没有碰撞</strong>: 结点就在下一个时隙传输该帧</li><li><strong>如果产生碰撞</strong>: 结点就以<strong>概率p</strong>重传帧直到成功传输完该帧</li></ul></li><li>时隙ALOHA是<strong>高度分散</strong>的，因为每个节点检测碰撞并独立决定何时重传。<br><img src="https://i.loli.net/2018/06/06/5b17c1739ac0f.png" width="50%" height="50%"> </li></ul><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>单个活动结点:可充分利用带宽(相比TDMA)</td><td>碰撞后要等待, 浪费时隙</td></tr><tr><td>分布式</td><td>空闲时隙</td></tr><tr><td>简单</td><td>结点需要快速检测出碰撞、时钟同步</td></tr></tbody></table><h5 id="纯ALOHA"><a href="#纯ALOHA" class="headerlink" title="纯ALOHA"></a>纯ALOHA</h5><ul><li>非时隙Aloha: 更简单, 不需要时钟同步</li><li>当帧封装好，待发送时：马上发送该帧(不需要等待到时隙的开始) </li><li>增加了碰撞的概率:<br>如下图：t0时刻发送的帧与其他时刻发送的帧产生了碰撞<br><img src="https://i.loli.net/2018/06/06/5b17c173ae5a6.png" width="60%" height="60%"> </li></ul><h5 id="CSMA-载波监听多址访问"><a href="#CSMA-载波监听多址访问" class="headerlink" title="CSMA (载波监听多址访问)"></a>CSMA (载波监听多址访问)</h5><ul><li>传输之前先监听信道:<ul><li>如果信道空闲: 传输整个帧</li><li>如果信道忙碌, 推迟发送帧</li></ul></li><li>监听，仍然会产生碰撞: 信道传输时延产生“异步”</li><li>碰撞: 整个数据帧就会丢失(可惜)</li><li>注意: 距离和传播时延对碰撞检测的作用</li></ul><h5 id="CSMA-CD-具有碰撞检测的CSMA"><a href="#CSMA-CD-具有碰撞检测的CSMA" class="headerlink" title="CSMA/CD (具有碰撞检测的CSMA)"></a>CSMA/CD (具有碰撞检测的CSMA)</h5><ul><li>载波监听/碰撞检测<ul><li>在较短的时间检测到碰撞，并终止碰撞的传输，避免信道的浪费。</li></ul></li><li>碰撞检测功能: <ul><li>在有线网络中容易实现: 比较发送和接收信号 </li><li>在无线网络中难以检测: 接收信号衰减严重 </li></ul></li></ul><h5 id="CSMA-CD-算法描述"><a href="#CSMA-CD-算法描述" class="headerlink" title="CSMA/CD 算法描述"></a>CSMA/CD 算法描述</h5><ol><li>网卡接收到网络层的数据报，封装成帧</li><li>如果网卡检测到信道是空闲的, 则开始传输帧；如果信道是繁忙的, 则等到信道空闲后再传输.</li><li>如果网卡在传输帧的整个过程中没有检测到其他帧的传输, 则网卡成功传输该帧；</li><li>如果网卡检测到其他帧的传输，则取消发送该帧，并发送一个拥堵信号(jam signal)</li><li>取消之后, 网卡等待一个随机时间量，然后返回步骤2 (<strong>二进制指数回退</strong>): <ul><li>发生m次碰撞, 网卡从{0,1,2, …, 2m-1}中随机选择一个数K, 等待 K·512 比特时间后返回步骤2</li></ul></li></ol><ul><li>什么是<code>比特时间</code>？<br>如1Gbps，每比特时间是10<sup>-9</sup>s，若K=1023，则等待时间 t = 1023<em> </em>512<em> </em>10<sup>-9</sup>= 50 μs </li></ul><h4 id="轮流多址访问协议"><a href="#轮流多址访问协议" class="headerlink" title="轮流多址访问协议"></a>轮流多址访问协议</h4><ul><li>信道划分多址访问协议:<ul><li>在负荷高的时候：信道利用率、公平性等都比较好</li><li>在负荷低的时候：信道访问的产生时延(空闲时隙)，哪怕只有1个活动结点，链路的利用率也只有1/N! </li></ul></li><li>随机多址访问协议<ul><li>负荷低的时候：效率高，单个结点可以利用整个带宽</li><li>负荷高的时候：经常发送碰撞</li></ul></li><li>“轮流” 协议<ul><li>无论负荷高还是低，都可以有效利用网络</li></ul></li></ul><h5 id="轮询-Polling"><a href="#轮询-Polling" class="headerlink" title="轮询 Polling"></a>轮询 Polling</h5><ul><li>主结点按次序“邀请” 从发送数据</li><li>主要用于 “哑终端” </li><li>存在的问题: 引入轮询时延, 单点故障 (master)<h5 id="令牌传递协议-Token-passing"><a href="#令牌传递协议-Token-passing" class="headerlink" title="令牌传递协议 Token-passing"></a>令牌传递协议 Token-passing</h5></li><li>按照次序传递令牌: 得到令牌的结点可以传数据.</li><li>一个称为<code>令牌</code>的小的特殊帧在节点之间以某种固定次序进行交换</li><li>存在的问题: 令牌开销，单点故障(token)</li></ul><h4 id="多址访问协议总结"><a href="#多址访问协议总结" class="headerlink" title="多址访问协议总结"></a>多址访问协议总结</h4><ul><li>信道划分：分时, 分频</li><li>随机访问 (dynamic), <ul><li>ALOHA, S-ALOHA, CSMA, CSMA/CD</li><li>载波监听: easy in some technologies (wire), hard in others (wireless)</li><li>CSMA/CD used in Ethernet</li><li>CSMA/CA used in 802.11</li></ul></li><li>轮流访问<ul><li>polling, token passing</li><li>Bluetooth, FDDI, IBM Token Ring </li></ul></li></ul><h2 id="5-4-局域交换网"><a href="#5-4-局域交换网" class="headerlink" title="5.4 局域交换网"></a>5.4 局域交换网</h2><h3 id="链路层寻址和地址解析协议"><a href="#链路层寻址和地址解析协议" class="headerlink" title="链路层寻址和地址解析协议"></a>链路层寻址和地址解析协议</h3><h4 id="链路层编址"><a href="#链路层编址" class="headerlink" title="链路层编址"></a>链路层编址</h4><ul><li>MAC地址(LAN地址/物理地址)：烧写在网卡的ROM中</li><li>功能：<ul><li>给每一个<strong>网络接口</strong>编的地址</li><li>在<strong>局域网</strong>内工作</li><li>将数据帧从一个<strong>网络接口</strong>传输到<strong>物理连接</strong>的另外一个<strong>网络接口</strong></li></ul></li><li>6字节/48bit MAC地址(-分16进制)，如：1A-2F-BB-76-09-AD，共有<strong>2<sup>48</sup></strong>个可能的MAC地址</li><li>MAC 地址 vs IP地址<ul><li>工作在不同的协议层次</li><li>IP地址是在广域网/互联网中寻址</li><li>IP地址可以<strong>动态改变</strong>，MAC地址一般是<strong>固定</strong>的(也不会重复)</li><li>IP地址是<strong>层次结构</strong>，MAC地址是<strong>扁平结构</strong></li></ul></li><li>分配MAC地址？<ul><li>IEEE (国际电气和电子工程师协会)：设备生产商向IEEE购买MAC地址段</li></ul></li></ul><h4 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议: ARP"></a>地址解析协议: ARP</h4><ul><li>每个IP结点(主机或路由器端口)，在链路层有一个ARP表<br>&lt; IP address; MAC address; TTL&gt;</li></ul><p>A想给B发送数据报，且B的MAC地址不在A的ARP表中<br>——A通过链路广播来发送查询分组(帧)</p><ul><li><strong>广播</strong>的目的MAC地址：FF-FF-FF-FF-FF-FF<ul><li>who has IP address x.x.x.x，</li><li>tell a.a.a.a (A’s IP地址)</li></ul></li><li>局域网内的所有主机都会收到这个广播的查询帧</li><li>B收到这个APR查询后，向A回应自己的MAC地址<ul><li>B封装一个响应数据帧，发送到A的MAC地址</li><li>这次是<strong>单播</strong>，不是广播</li></ul></li><li>A收到B的响应之后，将它存入ARP表中</li><li>APR是<strong>“即插即用”</strong>的协议: 结点<strong>自主创建/更新</strong>ARP表，不需网络管理员干预</li></ul><h4 id="跨子网的地址解析"><a href="#跨子网的地址解析" class="headerlink" title="跨子网的地址解析"></a>跨子网的地址解析</h4><p><img src="https://i.loli.net/2018/06/06/5b17c62386e2a.png" width="70%" height="70%"> </p><p>如何穿过路由器<br>设：A知道B的IP地址，A知道路由器的IP地址/MAC地址(如何知道？)</p><ul><li>A创建IP数据报(源IP<sub>A</sub>, 目的IP<sub>B</sub>)</li><li>A创建链路帧(源MAC<strong><sub>A</sub></strong>, 目的MAC<strong><sub>R1</sub></strong>) </li><li>数据帧从A到达R，R解析数据帧，提交到IP层</li><li>R封装数据帧(源MAC<strong><sub>R2</sub></strong>, 目的MAC<strong><sub>B</sub></strong>)</li><li>R将IP数据报向B的子网转发</li><li>B收到数据帧，并解析数据帧并向上层提交数据报</li></ul><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><ul><li>有线局域网<ul><li>以太网：802.3  CDMA/CD</li><li>令牌环网：802.5</li></ul></li><li>无线局域网<ul><li>wifi: 802.11  CSMA/CA</li><li>…   802.15<br><img src="https://i.loli.net/2018/06/06/5b17c7e1f289b.png" width="40%" height="70%"> </li></ul></li><li>以太网是<strong>最典型的局域网</strong></li><li>以太网是局域网技术的主流 <ul><li>网络接口(网卡)造价低廉</li><li>简单(相比于令牌网和ATM)</li><li>速度不断升级: 10 Mbps – 10 Gbps </li></ul></li></ul><h4 id="以太网帧结构"><a href="#以太网帧结构" class="headerlink" title="以太网帧结构"></a>以太网帧结构</h4><p><img src="https://i.loli.net/2018/06/06/5b17c910ac45a.png" width="60%" height="70%"> </p><ul><li>前同步码: 共8个字节<ul><li>前七个字节都为：10101010, 最后一个字节为：10101011</li><li>用于发送方和接收方的<strong>时钟同步</strong></li></ul></li><li>MAC地址: 共12个字节，目的地址和源地址各6个字节<ul><li>接收方的网卡收到帧，如果<strong>目的地址</strong>是<strong>自己的MAC地址</strong>或者<strong>目的地址</strong>是<strong>广播地址</strong>，则解析该帧并向网络层提交；否则<strong>丢弃该帧</strong>。</li></ul></li><li>类型: 2个字节，<ul><li>标识封装上层协议的类别，可能是IP数据报 / APR数据分组 / 其他链路层数据分组</li></ul></li><li>CRC: 4字节(32bit) 循环冗余检测码</li></ul><h5 id="以太网提供的服务"><a href="#以太网提供的服务" class="headerlink" title="以太网提供的服务"></a>以太网提供的服务</h5><ul><li>无连接服务：发送方和接收方不需要事先握手</li><li>不可靠的通信<ul><li>链路层的接收方不会给发送方确认(ACK/NAK都不发送)</li><li>存在问题：帧出错/丢失了怎么办？</li></ul></li><li>尽最大努力交付<ul><li>碰撞后：二进制指数回退</li></ul></li></ul><h5 id="以太网标准系列"><a href="#以太网标准系列" class="headerlink" title="以太网标准系列"></a>以太网标准系列</h5><ul><li>802.3</li><li>相同的MAC协议(CSMA/CD)和帧结构</li><li>不同的物理层<ul><li>不同的传输速度：2Mbps/10Mbps/100Mbps/1Gbps/10Gbps</li><li>不同的物理媒体：光纤、同轴电缆、双绞线</li></ul></li></ul><h3 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h3><h4 id="以太网的拓扑结构"><a href="#以太网的拓扑结构" class="headerlink" title="以太网的拓扑结构"></a>以太网的拓扑结构</h4><ul><li>总线结构(1990s): 所有的结点都在一个碰撞域(和其他结点都可能碰撞)</li><li>星型结构(当今主流): 通过交换机进行局域网连接，碰撞域隔离：结点不相互碰撞</li></ul><h4 id="链路层交换机-1"><a href="#链路层交换机-1" class="headerlink" title="链路层交换机"></a>链路层交换机</h4><ul><li>工作在链路层的网络设备</li><li>作用：<ul><li>存储、转发以太网帧</li><li>检测帧的目标MAC地址，选择性地发送到1个或多个输出链路</li></ul></li><li><strong>透明的</strong>：主机观测不到交换机的存在(交换机的接口没有MAC地址)</li><li>即插即用、自学习：交换机不需要配置</li><li>“交换”的含义：A-A’ 和 B-B’可以并行传输，不会碰撞</li><li>如何进行转发? <strong>交换机(/转发)表</strong> &lt; interface<sub>m</sub>, MAC<sub>x</sub> , TTL &gt;</li><li>如何生成转发表？<code>自学习机制</code> </li><li>双工，任何交换机接口能够同时发送和接收</li><li>性质</li><li>消除碰撞：交换机的缓存帧绝不会在网段伤同时传输多于一个帧</li><li>异质的连接：交换机将链路彼此隔离，因此局域网的不同链路能够以不同速率运行且能够在不同媒体上运行</li><li>管理：提供强化的安全性，并且易于管理。</li></ul><table><thead><tr><th></th><th>交换机</th><th>路由器</th></tr></thead><tbody><tr><td>存储转发</td><td>链路层设备</td><td>网络层设备</td></tr><tr><td>转发表</td><td>自学习</td><td>路由选择算法</td></tr><tr><td>适用于</td><td>小网络：几个局域网网段</td><td>几千台主机组成的更大网络</td></tr></tbody></table><h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><ul><li>动机<ul><li>出于网络管理的需要: 将局域网分成更多的组，更方便地管理用户</li><li>流量隔离: ARP/DHCP广播, 自学习产生flood</li><li>网络安全/隐私的考虑</li></ul></li><li>手段: 使用支持VLAN的交换机<ul><li>“三层”交换机: 带路由(工作在网络层、第三层)功能的交换机；使得单个交换机能够物理隔离出多个“子网”</li><li>多个交换机进行VLANs: 对以太网帧封装格式进行扩展：802.1Q, 增加了VLAN标签字段</li></ul></li></ul><h3 id="一次Web请求所要做的工作"><a href="#一次Web请求所要做的工作" class="headerlink" title="一次Web请求所要做的工作"></a>一次Web请求所要做的工作</h3><ul><li>物理连接：WLAN(802.3) or WIFI(802.11)</li><li>配置主机IP等参数<ul><li>手工配置</li><li>动态主机配置：DHCP</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) DHCP RequestAPP layer：DHCP MessageUDP封装：Sport 68 Dport 67ChecksumIP封装：SIP：0.0.0.0</span><br><span class="line">DIP：255.255.255.255(广播)(2) Framing DHCP-UDP-IP数据报MAC地址DMAC：FF-FF-FF-FF-FF-FFSMAC：bb-bb-bb-bb-bb-bbCRC</span><br><span class="line">(3) 交换机转发Frame链路泛洪(flooding)Why？(4) 路由器(DHCP服务器)解析帧 - &gt; 向上提交 - &gt; 接收到DHCP请求(5) DHCP ACKAPP Layer：提供CIDR编址信息- 分配给Bob的IP- Gateway- SubMask- DNS ServerUDP封装：Sport 67, Dport 68IP封装： SIP: DHCP服务器的IP    DIP: 255.255.255.255Framing：DMAC bb-bb-bb-bb-bb-bb     SMAC：DHCP服务器的MAC(6) 交换机转发帧不再泛洪(Why?), 自学习(7) 客户机接收到DHCP响应逐层解析数据分组, 操作系统为客户机机配置网络参数</span><br></pre></td></tr></table></figure><ul><li>浏览器输入HTTP请求，但需要得知目的IP</li><li>DNS查询、ARP查询</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(8) 客户机DNS请求APP Layer：DNS报文服务器的主机名查询类别：-type=aUDP封装：Sport bobport   Dport 53IP封装：SIP: bob的IP  DIP: DNS SeverFraming</span><br><span class="line">问题来了：DMAC? 网关的MAC地址是多少？(9) 需要知道网关的MAC(10) ARP查询客户机网卡- 封装ARP查询报文“Who has 网关IP，Tell Bob”- FramingDMAC：FF-FF-FF-FF-FF-FFSMAC：bb-bb-bb-bb-bb-bb(11) ARP响应- 网关接口 - 封装ARP响应报文 - FramingDMAC：bb-bb-bb-bb-bb-bbSMAC：网关的MAC(12) 客户机获得网关的MAC(13) FramingDMAC: 刚刚从ARP查询得知SMAC: bb-bb-bb-bb-bb-bb</span><br></pre></td></tr></table></figure><ul><li>路由选择到DNS服务器</li></ul><p><code>`</code><br>(14) DNS查询到达网关路由器</p><ul><li>存储</li><li>转发：通过转发表来确定输出链路<br>(15) Comcast网络边界路由器们</li><li>存储</li><li>转发：通过转发表来确定输出链路<br>(16) DNS Server收到查询报文</li><li>DNS缓存中没有记录<ul><li>向上级DNS迭代查新</li></ul></li><li>DNS缓存中有记录<ul><li>封装DNS回答报文, 通过网络交付<br>(17)Bob便携机从DNS报文中抽取出服务器的IP地址<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- Web客户-服务器交互：TCP和HTTP</span><br><span class="line"></span><br><span class="line">```(18) HTTP和TCP的合作：套接字- 浏览器创建Socket (四元组标识) - Sport：浏览器随机生成;  Dport：80 - SIP：Bob的IP; DIP：Google WWW的IP(刚刚通过DNS查询到)- TCP三次握手开始, 客户端发送TCP SYN请求(19) 路由转发…(20) 服务器对连接请求做出响应 TCP SYN ACK(21) 客户机收到SYN ACK --套接字创建成功！！(22) HTTP请求 --HTTP GET报文(23) 报文进入套接字- TCP封装</span><br><span class="line"> - 端口号 - 序号</span><br><span class="line"> - 确认号……(23) HTTP响应- Sever读取HTTP请求- 找到Web对象- 封装HTTP响应- 发送到TCP套接字中(24) Bob终于收到了报文！</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络笔记04 网络层</title>
      <link href="/cn4/"/>
      <url>/cn4/</url>
      
        <content type="html"><![CDATA[<h3 id="4-1-网络层概述"><a href="#4-1-网络层概述" class="headerlink" title="4.1 网络层概述"></a>4.1 网络层概述</h3><ul><li>网络层服务和协议: 提供主机之间的<strong>逻辑通信</strong>。</li><li>在<strong>端系统</strong>中<ul><li>发送方：将报文段封装成<strong>数据报</strong>，提交给数据链路层。</li><li>接收方：将数据报解析成报文段，提交给运输层。</li></ul></li><li>在<strong>网络核心</strong>节点中<ul><li>路由器：转发数据报，交付到目的主机<a id="more"></a> </li></ul></li></ul><h4 id="分组转发和路由选择"><a href="#分组转发和路由选择" class="headerlink" title="分组转发和路由选择"></a>分组转发和路由选择</h4><ul><li>网络的两个主要功能<ul><li><strong>分组转发</strong>：分组到达路由器的输入链路，路由器将分组移动到正确的输出链路</li><li><strong>路由选择</strong>：确定分组的路径<br><img src="https://i.loli.net/2018/06/06/5b17832ee7016.png" width="40%" height="40%"></li><li>(第三个功能 可选)<strong>建立连接</strong>  </li><li>在某些网络体系中存在连接:ATM (异步传输模式), 帧中继, MPLS</li><li>在交付数据报之前，要建立虚拟的连接：主机和路由器都参与连接</li></ul></li><li>网络层 v.s. 运输层 连接服务:<ul><li>网络层: 两个主机以及中间的路由器创建的虚电路</li><li>运输层: 两个进程直接建立连接的端到端连接，中间的路由器不参与</li></ul></li></ul><h4 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h4><p>网络层能够提供的<strong>数据交付服务</strong>包括:</p><ul><li>当运输层向网络层<strong>传递一个分组</strong>时:<ul><li>确保交付</li><li>具有时延上界确保交付</li></ul></li><li>为给定的源和目的地之间的<strong>分组数据流</strong>提供的交付服务:<ul><li>有序分组交付</li><li>确保最低带宽</li><li>确保最大时延抖动</li><li>安全性服务</li></ul></li></ul><h3 id="4-2-虚电路和数据报网络"><a href="#4-2-虚电路和数据报网络" class="headerlink" title="4.2 虚电路和数据报网络"></a>4.2 虚电路和数据报网络</h3><table><thead><tr><th>数据报网络</th><th>虚电路网络</th></tr></thead><tbody><tr><td>无连接的服务</td><td>面向连接的服务</td></tr><tr><td>目标地址决定路径</td><td>分组携带虚电路ID</td></tr><tr><td>分组的路径可能<strong>会改变</strong></td><td>分组的路径<strong>不变</strong></td></tr><tr><td>类比: 自驾、问路</td><td>类比：火车</td></tr></tbody></table><h4 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h4><ul><li>端到端的路径类似于电话线路<ul><li>性能稳定</li><li>网络行为与端到端的路径紧密相关</li></ul></li><li><strong>3个阶段</strong>：建立连接、数据传输、虚电路拆除</li><li>每个数据分组携带虚电路标识<ul><li><strong>不是目标主机的地址</strong></li><li>可能要给虚电路预留资源：链路带宽、路由器缓存</li></ul></li><li>虚电路的<strong>组成</strong>：端到端的路径，虚电路标识，路由器中的转发表</li><li>虚电路<strong>标识</strong>：不是目的地址，一个连接中的虚电路号<strong>在不同的链路中</strong>可能<strong>标识不同</strong></li><li>虚电路的转发表: 路由器维护连接的状态信息</li><li>虚电路的<strong>信令协议</strong>：用于建立、维护、拆除虚电路，在ATM, frame-relay(帧中继), X.25等网络体系中使用；<strong>因特网中不再采用信令协议</strong>。</li></ul><h4 id="数据报网络——无连接的分组交换网络"><a href="#数据报网络——无连接的分组交换网络" class="headerlink" title="数据报网络——无连接的分组交换网络"></a>数据报网络——无连接的分组交换网络</h4><ul><li>网络层不需要建立连接</li><li>路由器：不需要维护端到端连接的状态，网络层不再有“连接”的概念</li><li>分组通过<strong>目的主机的地址</strong>来转发：一个端到端通信中，<strong>相同目的地址</strong>的分组可能走<strong>不同的路径</strong></li><li>数据报网络的转发表<ul><li>由于有40亿多IP地址, 转发表的记录是针对IP地址段</li><li>目的IP地址封装在数据报的首部</li><li><strong>最长前缀匹配</strong></li></ul></li></ul><h4 id="虚电路网络-vs-数据报网络"><a href="#虚电路网络-vs-数据报网络" class="headerlink" title="虚电路网络 vs. 数据报网络"></a>虚电路网络 vs. 数据报网络</h4><table><thead><tr><th>虚电路网络</th><th>数据报网络</th></tr></thead><tbody><tr><td>在电话网的基础上演化而来</td><td>计算机之间通信的网络</td></tr><tr><td>类似人的通信: 时延/可靠性/需要较多服务保障</td><td>弹性服务, 没有严格的时延需求</td></tr><tr><td>哑终端: 端系统较简单，如电话，网络较复杂</td><td>智能终端: 可控制处理差错，网络核心简单、边缘复杂</td></tr><tr><td></td><td>多种链路类型：特性不同，难以统一服务类型</td></tr></tbody></table><h4 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h4><h3 id="4-3-路由器的工作原理"><a href="#4-3-路由器的工作原理" class="headerlink" title="4.3 路由器的工作原理"></a>4.3 路由器的工作原理</h3><h4 id="路由器的体系结构"><a href="#路由器的体系结构" class="headerlink" title="路由器的体系结构"></a>路由器的体系结构</h4><ul><li>两个主要功能：分组转发、路由选择  </li><li>四个主要构件：输入、输出端口；路由选择处理器、交换结构<br><img src="https://i.loli.net/2018/06/06/5b178cfd397cf.png" width="50%" height="50%"> </li></ul><h4 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h4><p><img src="https://i.loli.net/2018/06/06/5b178cfd3210b.png" width="50%" height="50%"> </p><ul><li>链路终端：物理层，Bit信号接收</li><li>链路层协议接收端：数据链路层，e.g.以太网 参见第5章</li><li>查找转发排队：分布式交换<ul><li>转发：给定目的地址, 在路由转发表查找输出链路 (“match plus action”)</li><li>目标：匹配链路速度</li><li>排队：输入速度大于输出速度，产生队列</li></ul></li></ul><h4 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h4><ul><li>作用：将分组从输入端口的缓存</li><li>交换速度: rate at which packets can be transfer from inputs to outputs</li><li>三种类型的交换结构：经内存交换、经总线交换、经互联网络交换</li></ul><h4 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h4><p><img src="https://i.loli.net/2018/06/06/5b178cfd2f6ec.png" width="50%" height="50%"> </p><blockquote><p>缓存：输入速度大于输出时，将分组缓存/排队</p></blockquote><h3 id="4-4-IP-网际协议"><a href="#4-4-IP-网际协议" class="headerlink" title="4.4 IP:网际协议"></a>4.4 IP:网际协议</h3><p><img src="https://i.loli.net/2018/06/06/5b178f1377a25.png" width="50%" height="50%"> </p><h4 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h4><ul><li>网络层IP数据报：<ul><li>可封装为运输层的报文段(帧)：为上层提供服务 TCP/UDP</li><li>可封装<strong>ICMP</strong>控制报文—工作在<strong>网络层</strong><br><img src="https://i.loli.net/2018/06/06/5b1790cb0ea40.png" width="60%" height="60%"> </li></ul></li><li>版本(4 bits)：IP协议的版本号(4 或 6)，不同版本的IP数据报首部字段不同，路由器能确定如何解释剩余字段</li><li>首部长度(4 bits)：4 bytes为1个单位，20字节固定首部长度+扩展首部(选项字段)</li><li>服务类型(8 bits)：低时延、高吞吐量、实时、可靠性等<br>，告知路由器，以便按需调度(排队、转发)</li><li>数据报长度(16 bits)：IP数据报的总长度(单位为字节)，理论上最大长度为2<sup>16</sup>-1字节，实际：1500字节。</li><li>16比特标识 + 标志 + 片偏移（16 bits + 3 bits + 13 bits)：用于IP数据报的分片和组装，后面详解。</li><li>生存次数(8 bits)：IP数据报最多能通过多少个节点<ul><li>每经过一个路由器，TTL减1</li><li>TTL=0时数据分组将被丢弃，意味着没有为分组找到合适的路径</li></ul></li><li>上层协议(8 bits)：IP数据报到达终点后才会使用，告诉接收方顶层使用什么协议。<code>6：TCP</code>  <code>17：UDP</code></li><li>首部检验和(16 bits)：只对首部字段检验，每个路由器都要检验，因为TTL减1的性质，每跳后首部检验和都会变化。</li><li>源IP地址、目的IP地址(各32bits)：用于对主机、路由器进行网络标识</li><li>选项字段 + 填充(长度可变，4 bytes的整数倍)：用于对IP协议的扩展</li></ul><h4 id="IP数据报的分片和组装"><a href="#IP数据报的分片和组装" class="headerlink" title="IP数据报的分片和组装"></a>IP数据报的分片和组装</h4><ul><li>网络链路最大传输单元(MTU) <ul><li>链路中能传送数据分组最大尺寸</li><li>不同链路的最大传输单元不同</li></ul></li><li>跨越不同网络时，需要将大数据报分片<ul><li>在边界路由器拆分成片</li><li>到目的地(端系统)后将分片组装</li><li>IP 首部中有3个字段<code>标识</code> <code>标志</code> <code>片偏移</code>：是否分片，如何组装</li></ul></li></ul><blockquote><p>为坚持网络内核保持简单的原则。IPv4的设计者决定将数据报的重新组装工作放到端系统中，而不是放到网络路由器中。<br>例子：P224 表4-2</p></blockquote><h4 id="IPv4网络编址"><a href="#IPv4网络编址" class="headerlink" title="IPv4网络编址"></a>IPv4网络编址</h4><ul><li>IP 地址: 对主机和路由器网络接口进行标识，32bit </li><li>接口: 主机(路由器)与链路之间的边界<ul><li>路由器有多个接口(路由器与它的任意一条链路之间的边界)</li><li>主机一般有1-2个网络接口 (e.g. wired Ethernet, wireless 802.11)</li></ul></li><li>IP地址是对每个网络接口进行编址</li><li>网络接口之间如何连接(链路层问题 5/6章)<ul><li>有线以太网的接口通过以太网交换机相互连接</li><li>无线局域网的接口通过无线基站连接. </li></ul></li></ul><blockquote><p>点分十进制：223.1.1.1 = 11011111 00000001 00000001 00000001</p></blockquote><h5 id="子网划分-将高位IP相同的端口划分为子集，不通过路由器转发而进行通信"><a href="#子网划分-将高位IP相同的端口划分为子集，不通过路由器转发而进行通信" class="headerlink" title="子网划分:将高位IP相同的端口划分为子集，不通过路由器转发而进行通信"></a>子网划分:将高位IP相同的端口划分为子集，不通过路由器转发而进行通信</h5><ul><li>IP地址分两段：高位：子网标识，低位：主机标识</li><li>子网划分方法:使用<strong>路由器的端口</strong>将网络划分成独立的”孤岛”，每个”孤岛”为一个子网</li><li>子网掩码：/24记法 前24bit是子网标识，置为1。<br>子网掩码: 255.255.255.<strong>0</strong><br>aka: 11111111 11111111 11111111 <strong>00000000</strong></li></ul><p><img src="https://i.loli.net/2018/06/06/5b17979878a32.png" width="30%" height="30%"> </p><h5 id="子网划分方法-CIDR"><a href="#子网划分方法-CIDR" class="headerlink" title="子网划分方法 CIDR"></a>子网划分方法 CIDR</h5><ul><li>(旧)分类编址：IP地址分为四类，根据规模划分子网<ul><li>A：0.0.0.0-127.0.0.0，126个网络× 16777214个地址</li><li>B：128.0.0.0-191.254.0.0，16256个网络×65534个地址</li><li>C：192.0.0.0-223.254.254.0，2064512个网络×254个地址</li><li>D：224-254，用于组播和调查等特殊用途</li></ul></li><li>CIDR：无类别域间路由选择<ul><li>子网标识部分的长度任意选择(不对子网分类)</li><li>地址格式：a.b.c.d / x ，x 是子网标识的长度(子网掩码)<br>200.23.16.0/23 子网掩码:  255.255.254.0</li><li>分层编址的优点：路由聚集</li></ul></li></ul><h5 id="组织机构获得IP地址块-子网-的方法："><a href="#组织机构获得IP地址块-子网-的方法：" class="headerlink" title="组织机构获得IP地址块(子网)的方法："></a>组织机构获得IP地址块(子网)的方法：</h5><ul><li>从ISP的地址空间中来获得一个地址块</li><li>ICANN向区域性因特网注册机构分配地址，这些记过一起形成了ICANN的地址支持组织，处理本地域内的地址分配/管理。</li></ul><h5 id="获取主机地址：DHCP-动态主机配置协议"><a href="#获取主机地址：DHCP-动态主机配置协议" class="headerlink" title="获取主机地址：DHCP 动态主机配置协议"></a>获取主机地址：DHCP 动态主机配置协议</h5><p>获取主机地址:手动配置 / 动态主机配置<br><strong>DHCP: 动态主机配置协议</strong></p><ul><li>DHCP协议不仅仅配置IP地址，还有其他重要的联网参数：<ul><li>网关地址(邻接路由器网络接口的IP地址)</li><li>DNS服务器的名字和IP地址</li><li>子网掩码</li></ul></li><li>DHCP工作的协议栈：<strong>工作在应用层</strong>，port：67(目的端口)、68(源端口)，传输层：UDP</li><li>4个步骤：<ul><li>DHCP服务器发现：客户在UDP分组向端口67发送<code>DHCP发现报文</code>，使用广播地址 255.255.255.255 并且使用源地址 0.0.0.0。链路层将该帧<strong>广播</strong>到<strong>所有</strong>与该子网连接的子网。</li><li>DHCP服务器提供：<code>DHCP提供报文</code>，同样使用<strong>广播</strong>地址 255.255.255.255。每台服务器提供的报文有收到的<strong>发现报文的事务ID</strong>，<strong>向客户推荐的IP地址</strong>，<strong>网络掩码</strong>以及<strong>IP地址租用期</strong>。</li><li>DHCP请求：新到达的客户从一个或多个服务器提供中选择一个，并向选中服务器提供一个<code>DHCP请求报文</code>进行响应，回显配置参数。仍然使用<strong>广播</strong>地址。</li><li>DHCP ACK：<code>DHCP ACK报文</code>，对DHCP请求报文进行响应，证实所要求的参数</li></ul></li></ul><h4 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换: NAT"></a>网络地址转换: NAT</h4><ul><li>动机<ul><li>多个用户可以使用一个IP接入互联网</li><li>不需要再从ISP获得地址段</li><li>内部设备的地址更改不需要告知外部网络</li><li>更换ISP后，内网的地址不需要变更</li><li>内网的结构被屏蔽(出于安全的考虑)</li></ul></li><li>NAT的实现: 端口/地址映射，NAT路由器上的一张<strong>NAT转换表</strong><br><img src="https://i.loli.net/2018/06/06/5b179ecc1c356.png" width="70%" height="70%"> </li><li>NAT的争议<ul><li>优势：有效解决IPv4地址空间的问题</li><li>问题：IETF对NAT提出了质疑<ul><li>路由器应该仅仅工作在网络层，但是NAT Router触及了运输层(端口)！端口号原本是用作进程编址的。</li></ul></li><li>NAT违反了端到端原则：主机之间应该直接对话，节点不应介入修改IP地址和端口号</li><li>IPv4的地址空间应该过度到IPv6来解决</li></ul></li><li>Anyway，NAT已经成为因特网的重要组件</li><li>NAT的穿越：外网的客户端怎么主动连接NAT内网的服务器？<ul><li>在NAT Router上静态配置映射</li><li>使用UPnP协议，通用即插即用协议</li><li>中继穿越</li></ul></li></ul><h4 id="因特网控制报文协议-ICMP"><a href="#因特网控制报文协议-ICMP" class="headerlink" title="因特网控制报文协议: ICMP"></a>因特网控制报文协议: ICMP</h4><ul><li>用途：主机/路由器直接沟通网络层的信息，如：错误报告<br>、回声响应(echo request/reply)</li><li>协议层次: 被看做是IP的一部分，ICMP报文由IP协议封装。但从体系结构上讲它是位于IP之上的。</li><li>ICMP报文格式：<ul><li>类型+编码：各1字节，用于标识ICMP数据报的类型、用途 <code>P236 图4-23</code></li><li>初始IP首部：20字节，初始数据内容：8字节</li></ul></li><li>ICMP应用：TraceRoute<ul><li>用来判断源和目的地址见所有路由器的名字、地址和数量。</li><li>向目的主机发送一系列普通IP数据报。这些数据报都携带了一个不可达UDP端口号和UDP报文段，TTL分别设置为1, 2, 3…</li><li>第n个数据报到达第n个路由器，TTL刚好过期。</li><li>根据IP协议规则，路由器丢弃该数据报病发送一个ICMP告警报文给源主机，该告警报文包含了路由器的名字和地址</li></ul></li></ul><h4 id="IPV6简要介绍"><a href="#IPV6简要介绍" class="headerlink" title="IPV6简要介绍"></a>IPV6简要介绍</h4><ul><li>IPv6 的动机<ul><li>初始动机：32-bits的IPv4地址空间很快就会耗尽</li><li>其他动机：首部字段：提高处理和转发速度，提高服务质量</li></ul></li></ul><h5 id="IPv6-数据报格式"><a href="#IPv6-数据报格式" class="headerlink" title="IPv6 数据报格式"></a>IPv6 数据报格式</h5><p><img src="https://i.loli.net/2018/06/06/5b17a3609039c.png" width="50%" height="50%"> </p><ul><li>版本：6</li><li>流量类型：同IPv4的服务类型</li><li>流标签：标识一条数据报的流</li><li>有效载荷长度：数据的长度</li><li>下一个首部：相当于IPv4的上层协议</li><li>跳限制：相当于IPv4的TTL</li><li>源地址和目的地址：各128位(RFC 4291)</li><li>数据：IPv6数据报的有效载荷部分</li><li>其他方面：<ul><li>取消分片/重装：在发送端分片，网络不进行分片和组装</li><li>取消首部Checksum：中间路由器不再进行检验，提高效率</li><li>取消选项字段：通过“下一个首部”来扩展</li></ul></li></ul><blockquote><p>首部40 bytes的固定长度，在该版本中不允许分片</p></blockquote><h5 id="从IPv4到IPv6的迁移"><a href="#从IPv4到IPv6的迁移" class="headerlink" title="从IPv4到IPv6的迁移"></a>从IPv4到IPv6的迁移</h5><ul><li>不能一下子将所有的路由器全部升级到IPv6</li><li>IPv4 和 IPv6 路由器混杂工作 <code>隧道技术</code>: <ul><li>IPv6 的数据报，封装成IPv4数据报，以便在IPv4的路由器上面进行处理</li></ul></li></ul><h3 id="4-5-路由选择算法"><a href="#4-5-路由选择算法" class="headerlink" title="4.5 路由选择算法"></a>4.5 路由选择算法</h3><h4 id="路由选择介绍"><a href="#路由选择介绍" class="headerlink" title="路由选择介绍"></a>路由选择介绍</h4><ul><li>网络结点的核心功能</li><li>网络的建模 <code>图论模型</code> : 图(Graph) ，点(Node)-路由器，边(Edge)-链路，权(cost)-网络的开销(链路长度/链路速度/链路费用)<br>图: G = (N,E)<br>N = 路由结点的集合= { u, v, w, x, y, z }<br>E = 链路的集合={ (u,v), (u,x), (u,w), (v,x), (v,w), (x,w), (x,y), (w,y), (w,z), (y,z) }</li><li>路由选择：寻找图中一个点到其他点的最”短”路径</li></ul><blockquote><p>图的概念也可以用于其它类型的网络，如: P2P, N 是Peer的集合，E是TCP连接的集合</p></blockquote><h5 id="路由选择算法的分类"><a href="#路由选择算法的分类" class="headerlink" title="路由选择算法的分类"></a>路由选择算法的分类</h5><ul><li>全局式路由选择算法 or 分布式路由选择算法<ul><li>全局式: 结点知道完整的网络拓扑。eg. 链路状态算法</li><li>分布式: 结点只知道自己的邻居是谁。eg.距离向量算法</li></ul></li><li>静态路由选择算法  or 动态路由选择算法 <ul><li>静态：路由信息不经常变化</li><li>动态：路由信息随网络状态经常变化</li></ul></li><li>负载敏感路由选择算法 or 负载迟钝路由选择算法<ul><li>负载名感算法中，链路费用会动态地变化以反应出底层链路的当前拥塞水平。 </li></ul></li></ul><h4 id="链路状态路由选择算法-LS"><a href="#链路状态路由选择算法-LS" class="headerlink" title="链路状态路由选择算法: LS"></a>链路状态路由选择算法: LS</h4><ul><li>算法输入：<ul><li>网络的完整拓扑</li><li>所有结点都知道完整拓扑</li><li>通过链路状态广播来实现 </li><li>所有结点的网络拓扑相同</li></ul></li><li>算法输出：计算本结点到其他结点的最短路径，并为该结点生成转发表</li><li>迭代算法: 经过k次迭代，得到k个结点的最“短”路径</li><li>标记:<ul><li>c(x, y): x到y链路的费用；如果x和y不是邻居,则c(x, y) = ∞</li><li>D(v): 在当前迭代中，从源结点到目标结点v的最低费用</li><li>p(v): 从源到v沿着当前最“短”路径中，v的前置结点</li><li>N’: 结点子集，如果从源到v的最短路径已确知，v在N’中.</li></ul></li><li>算法结构：初始化，迭代k次（网络中有k个结点）</li><li>算法复杂性：对于n个结点，每次迭代: 检测所有没在N’中的结点，n(n+1)/2 相当于: O(n<sup>2</sup>)</li><li>算法优化后的复杂度: O(n log n)</li><li>算法特点：  <ul><li><strong>分布式</strong>：每个结点都要从一个或多个邻居结点获得某些信息，作为算法的输入  </li><li><strong>迭代的</strong>：交换信息的过程要持续，迭代计算  </li><li><strong>异步的</strong>：不要求所有结点步伐一致地操作  </li></ul></li></ul><h4 id="距离向量-DV-路由选择算法"><a href="#距离向量-DV-路由选择算法" class="headerlink" title="距离向量(DV)路由选择算法"></a>距离向量(DV)路由选择算法</h4><ul><li><code>BF方程</code> 设：d<sub>x</sub>(y)为x结点到y节点的最短路径</li><li>则：d<sub>x</sub>(y) = min<sub>v</sub> {c(x, v) + d<sub>v</sub>(y) }</li><li><p>其中：</p><ul><li>v是x的邻居，x与y不是邻居，则选择x-v-…-y的一条最短路径</li><li>直观地：就是选择邻居(next router)</li></ul></li><li><p>距离向量: x到其他结点y的距离: D<sub>x</sub> = [D<sub>x</sub>(y): y ∈ N]</p></li><li><p>对于任意结点x</p><ul><li>了解它自己到每个邻居v的距离：D<sub>x</sub>(v) = c(x, v)</li><li>因此得出它自己的距离向量D<sub>x</sub> = [Dx(y): y ∈ N]</li><li>另一方面，x通过与邻居v交换信息，也了解它每个邻居v的距离向量：D<sub>v</sub> = [D<sub>v</sub>(y): y ∈ N]</li></ul></li><li><p>算法基本思想: </p><ul><li>随着时间的推移，每个节点都会与邻居交换距离向量，当x结点从邻居处接收到距离向量，它便通过 B-F方程更新自己的距离向量:D<sub>x</sub>(y) ← min<sub>v</sub>{c(x,v) + Dv(y)}    for each node y ∊ N</li><li>经过有限次迭代, 费用估计 D<sub>x</sub>(y) 收敛到实际最低费用 d<sub>x</sub>(y) </li><li>节点的三个活动：<code>等待</code> 来自链路或者邻居的信息，<code>计算</code> 更新DV，<code>通知</code> 向邻居更新自己的DV。</li></ul></li><li>算法特点<ul><li>迭代, 异步: 每次本地迭代由以下两种情况触发: 本地链路的费用发生变化的时候 or 从邻居获得更新的DV之后</li><li>分布式:节点DV更新后通知邻居，邻居更新DV后再通知它们的邻居 </li></ul></li></ul><blockquote><p>链路费用改变与链路故障、 增加毒性逆转</p></blockquote><table><thead><tr><th></th><th>LS</th><th>DV</th></tr></thead><tbody><tr><td>报文复杂性</td><td>G(N, E), 需发送O(NE)个报文</td><td>只需邻居之间交互报文</td></tr><tr><td>收敛速度</td><td>O(N<sup>2</sup>)，可能存在震荡</td><td>收敛速度不均(路由环路问题、无穷计数问题)</td></tr><tr><td>健壮性</td><td>结点广播变化的链路费用，每个结点独立创建自己的转发表</td><td>费用变化，逐层告知，一个不正确的结点计算值会扩散到整个网络</td></tr></tbody></table><h3 id="4-6-因特网中的路由选择"><a href="#4-6-因特网中的路由选择" class="headerlink" title="4.6 因特网中的路由选择"></a>4.6 因特网中的路由选择</h3><h3 id="4-7-广播和多播路由选择"><a href="#4-7-广播和多播路由选择" class="headerlink" title="4.7 广播和多播路由选择"></a>4.7 广播和多播路由选择</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络笔记03 运输层</title>
      <link href="/cn3/"/>
      <url>/cn3/</url>
      
        <content type="html"><![CDATA[<h3 id="3-1-概述和运输层服务"><a href="#3-1-概述和运输层服务" class="headerlink" title="3.1 概述和运输层服务"></a>3.1 概述和运输层服务</h3><ul><li>提供了不同主机中应用进程之间的<code>逻辑通信</code>而非物理通信</li><li>运输层协议工作在<strong>端系统</strong>中<ul><li>发送方：将报文封装成报文段，提交给网络层</li><li>接收方：解析成报文，提交给应用层</li></ul></li><li>提供了两种协议 TCP &amp; UDP<a id="more"></a> </li></ul><h4 id="运输层和网络层的关系"><a href="#运输层和网络层的关系" class="headerlink" title="运输层和网络层的关系"></a>运输层和网络层的关系</h4><ul><li>从通信和信息处理的角度看，运输层向上面的<strong>应用层</strong>提供通信服务，属于<strong>面向通信部分的最高层</strong>，同时也是<strong>用户功能中的最底层</strong>。</li><li>网络层：<strong>主机</strong>之间的逻辑通信</li><li>运输层：<strong>进程</strong>之间的逻辑通信</li></ul><p><img src="https://i.loli.net/2018/06/05/5b169835a9038.png" width="40%" height="40%"></p><h4 id="运输层的服务"><a href="#运输层的服务" class="headerlink" title="运输层的服务"></a>运输层的服务</h4><ul><li>可靠的、有序的交付：<code>TCP</code><ul><li>面向连接的逻辑通信：握手机制</li><li>流控制：发送速度不能大于接收速度</li><li>拥塞控制：从发送端系统感知、避免网络的拥塞</li></ul></li><li>不可靠的、无序的交付：<code>UDP</code><ul><li>不提供必要的服务</li><li>尽最大努力向网络交付数据</li></ul></li><li>运输层没有提供的服务<ul><li>最低时延保障</li><li>最低带宽保障</li></ul></li></ul><h4 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h4><ul><li>多路分解：将运输层报文段中的数据交付到正确的套接字</li><li><p>多路复用：在源主机从不同的套接字中收集数据快，并为每个数据快封装上首部信息从而生成报文段，并将报文段传递到网络层<br><img src="https://i.loli.net/2018/06/05/5b1698361410c.png" width="60%" height="60%"></p></li><li><p>端口：</p><ul><li>使用16bit的整数来标识进程</li><li>在不同主机上，相同端口可能有不同的用途</li><li>两种类型的端口<br>0~1023 :  周知端口，用于标准协议，如FTP/HTTP/SMTP<br>1024~65535:  扩展端口，用于特定协议或客户端进程标识</li></ul></li><li>套接字：<ul><li>UDP套接字：目的IP地址 + 一个目的端口号 </li><li>TCP套接字：源端口号 + 源主机IP地址 + 目的端口号 + 目的主机IP地址</li></ul></li></ul><h5 id="多路分解的机制"><a href="#多路分解的机制" class="headerlink" title="多路分解的机制"></a>多路分解的机制</h5><ul><li>主机收到IP数据报<ul><li>数据报有源IP和目的IP</li><li>数据报中封装了应用报文</li><li>每个报文段中标识着源端口号和目的端口号 </li></ul></li><li>主机使用IP地址+端口号来定向应用进程的套接字</li></ul><h5 id="无连接的复用和分解"><a href="#无连接的复用和分解" class="headerlink" title="无连接的复用和分解"></a>无连接的复用和分解</h5><ul><li>使用<code>端口号</code>创建套接字: DatagramSocket mySocket1 = new DatagramSocket(99111);</li><li>UDP 套接字使用二元组来标识 :(dest IP address, dest port number)</li><li>当主机收到UDP报文:识别报文首部的目的端口号，将报文提交给该端口号对应的应用进程</li><li><strong>不同主机</strong>发送过来的报文，只要<strong>目的端口号</strong>相同，都提交给<strong>相同的套接字</strong></li></ul><h5 id="面向连接的复用和分解"><a href="#面向连接的复用和分解" class="headerlink" title="面向连接的复用和分解"></a>面向连接的复用和分解</h5><ul><li>TCP 套接字是一个四元组，包括: source IP address, source port number, dest IP address, dest port number</li><li>接收端的主机通过这四个值来定位到对应的套接字</li><li>服务器端的应用进程可能有并发的TCP套接字：每个套接字由一个四元组来标识</li><li>如：Web服务器对为个连接的客户端创建不同的套接字：非持久性连接HTTP对每个请求创建一个套接字</li><li><strong>不同主机</strong>发送过来的报文，即使<strong>目的端口号</strong>相同，<strong>不是</strong>都提交给相同的的套接字</li></ul><h3 id="3-3-无连接运输：UDP"><a href="#3-3-无连接运输：UDP" class="headerlink" title="3.3 无连接运输：UDP"></a>3.3 无连接运输：UDP</h3><ul><li>不提供额外服务的运输层协议：让网络尽最大努力交付，不能解决<strong>分组失序、丢失</strong>问题</li><li>是一个<strong>无连接</strong>的运输协议：UDP协议的发送端和接收端没有“握手”机制，每个分组单独处理，分组互不关联</li><li>优点：<ul><li>时延：没有连接(握手)的过程，减少时延</li><li>简单：没有连接状态管理，</li><li>高效：首部字段短<strong>(8 bytes)</strong></li><li>快速：可以<strong>突发式地传输</strong></li></ul></li></ul><p>基于UDP的应用：</p><ul><li>DNS：因特网目录服务，域名解析系统</li><li>SNMP：简单网络管理协议</li><li>流媒体传输</li><li>因特网电话</li></ul><p>基于UDP协议，如何实现可靠传输？</p><ul><li>将可靠传输的机制放在<code>应用层</code></li><li>在<code>应用程序</code>中定义<code>差错控制</code>的机制</li></ul><h5 id="UDP报文段结构"><a href="#UDP报文段结构" class="headerlink" title="UDP报文段结构"></a>UDP报文段结构</h5><p><img src="https://i.loli.net/2018/06/06/5b17294ed150c.png" width="40%" height="40%">  </p><ul><li>提供差错检验: 检验和</li><li>没有差错控制</li><li>长度: 报文段的总长度</li><li>UDP检验和的计算：<br><img src="https://i.loli.net/2018/06/06/5b17336a6347d.png" width="40%" height="40%">  </li></ul><h3 id="3-4-可靠传输原理"><a href="#3-4-可靠传输原理" class="headerlink" title="3.4 可靠传输原理"></a>3.4 可靠传输原理</h3><p><code>不可靠信道</code>的特点决定了可靠服务传输的复杂性<br><code>可靠数据传输</code>：为上层实体提供的服务抽象是，数据可以通过一条<code>可靠的信道</code>进行传输。借助于可靠信道，传输比特就不会受到损坏或丢失。</p><p><img src="https://i.loli.net/2018/06/05/5b16a2795eb54.png" width="50%" height="50%"><img src="https://i.loli.net/2018/06/05/5b16a27ec0049.png" width="50%" height="50%"></p><ul><li>过程：<ul><li>逐渐引入问题，bit差错-&gt;分组丢失……</li><li>发送端和接收端的协议逐渐丰富，版本演进</li></ul></li><li>工具：<ul><li>有限状态机(Finite State Machine, FSM)</li><li>分别定义发送方和接收方的状态(行为)</li></ul></li></ul><p><code>rdt1.0</code>：    <strong>理想信道</strong>中的数据传输<br><code>rdt2.x</code>：处理信道中的<strong>bit差错</strong><br><code>rdt3.0</code>：处理信道中的<strong>bit差错</strong>和<strong>分组丢失</strong>  </p><h4 id="rdt1-0：经完全可靠信道的可靠数据传输"><a href="#rdt1-0：经完全可靠信道的可靠数据传输" class="headerlink" title="rdt1.0：经完全可靠信道的可靠数据传输"></a>rdt1.0：经完全可靠信道的可靠数据传输</h4><ul><li>前提：下层信道是可靠的。底层信道没有bit差错、分组丢失</li><li>发送端和接收端的有限状态机：发送端向底层信道发送数据，接收端从底层信道读取数据</li></ul><h4 id="rdt2-0：处理bit差错"><a href="#rdt2-0：处理bit差错" class="headerlink" title="rdt2.0：处理bit差错"></a>rdt2.0：处理bit差错</h4><ul><li><code>检测bit差错？</code>差错检测：checksum()</li><li><code>恢复bit差错？</code>接收方反馈：<ul><li>肯定确认：接收方告诉发送方数据分组正确到达</li><li>否定确认：接收方告诉发送方数据分组出错</li><li>重传：发送方收到否定确认后重传该分组</li></ul></li><li>rdt2.0的机制：<code>停止等待协议</code>(Automatic Repeat reQuest, <code>ARQ</code>)<ul><li>检测：接收方检测bit差错</li><li>反馈：接收方发送确认消息(ACK或NAK)给发送方</li></ul></li></ul><p><code>rdt2.0存在的问题</code>：当接收方的ACK/NAK信息出错时，可能导致接受方数据重复。<br><code>解决办法</code>：识别重复的数据分组rdt2.1</p><h4 id="rdt2-1：处理“混淆的确认”——为分组编号"><a href="#rdt2-1：处理“混淆的确认”——为分组编号" class="headerlink" title="rdt2.1：处理“混淆的确认”——为分组编号"></a>rdt2.1：处理“混淆的确认”——为分组编号</h4><ul><li>识别重复分组：为数据分组进行编号 - &gt; 接收方丢弃重复分组 - &gt; 重传肯定确认(ACK)</li><li><p>序号空间最小为多少？理论上1个bit就够了，因为它可让接收方知道发送方是否正在重传前一个分组。</p></li><li><p>发送端:</p><ul><li>为分组编号：两个编号 {0,1}足矣</li><li>必须检测确认信息是否出错 </li><li>状态数量翻倍(相对于rdt2.0)：在状态值中必须记录当前的数据分组号是0 还是 1。</li></ul></li><li>接收端:<ul><li>必须检测数据分组是否出错</li><li>必须检测数据分组是否重复，状态值暗示了期待的分组号</li></ul></li></ul><p><code>rdt2.1存在的问题</code>：接收方不知道最后的确认信息是否被发送方正确收到。</p><h4 id="rdt2-2：小改进——不要否定确认-NAK-的协议"><a href="#rdt2-2：小改进——不要否定确认-NAK-的协议" class="headerlink" title="rdt2.2：小改进——不要否定确认(NAK)的协议"></a>rdt2.2：小改进——不要否定确认(NAK)的协议</h4><ul><li>和rdt2.1的功能相同</li><li>只使用肯定确认(ACK)，对ACK进行编号{0,1}足矣</li><li>发送方收到重复编号的ACK等同于收到NAK，此时发送方将重传分组</li></ul><h4 id="rdt3-0：处理信道中的bit差错和分组丢失"><a href="#rdt3-0：处理信道中的bit差错和分组丢失" class="headerlink" title="rdt3.0：处理信道中的bit差错和分组丢失"></a>rdt3.0：处理信道中的bit差错和分组丢失</h4><ul><li>差错控制：检测、确认、重传</li><li>处理分组丢失(如何让发送方认识到分组丢失了？)：<ul><li>基于时间的重传机制：发送端设置“ 定时器 ” timer ，超时重发</li><li>接收方仍然会收到重复分组：rdt2.2通过对分组编号能够处理冗余分组的情况</li></ul></li></ul><h4 id="停止等待-gt-流水线可靠数据传输协议"><a href="#停止等待-gt-流水线可靠数据传输协议" class="headerlink" title="停止等待 - &gt;流水线可靠数据传输协议"></a>停止等待 - &gt;流水线可靠数据传输协议</h4><p><code>rdt3.0</code>是一个<code>停等协议</code>，效率较低。<br>eg. 对于1Gbps的链路，有15ms的<strong>端到端时延</strong>，传输一个1KB的数据分组，链路的利用率有多少？吞吐率是多少？</p><ul><li>传输时延 = L/R = 8 kbit ÷ 10<sup>9</sup> bit/s =8 μs</li><li>利用率=传输时延 / (往返时延+传输时延)<br>=传输时延/(2 <em> 端到端时延+传输时延)<br>=0.008÷(2 </em> 15+0.008)<br>=0.00027  </li><li>意味着：每30ms传输1KB的数据，在1G的链路上只有33kB的吞吐量</li></ul><p><code>流水线</code>：发送方发送一个数据分组之后，在对方确认之前，可以继续发其他分组。</p><blockquote><p>成倍地提高网络的通信效率<br>但需要考虑流水线中如何实现差错控制(分组丢失、损坏或延时后如何重传？)</p></blockquote><ul><li>必须增加序号范围</li><li>协议的发送方和接收方两端可能需要缓存多个分组(以备重传)</li><li>所需序号范围和对缓存的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。</li></ul><h5 id="回退N步-GBN-滑动窗口协议"><a href="#回退N步-GBN-滑动窗口协议" class="headerlink" title="回退N步(GBN)/滑动窗口协议"></a>回退N步(GBN)/滑动窗口协议</h5><p>发送方：</p><ul><li>允许发送方发送多个分组，而不需等待确认</li><li>未确认的分组数 &lt; N (窗口长度)<ul><li>发送方的缓存容量是有限度的</li><li>不能让发送方“肆无忌惮”地发数据，否则跟UDP没太大区别</li><li><code>流控制</code>的需要：发送速率不能大于接收速率</li><li><code>拥塞控制</code>的需要：不要擅自给网络添堵</li></ul></li><li>发送方设置<code>定时器</code>：用于处理丢失重传问题<ul><li>定时器数目多多益善，但注意定时器也耗费资源!</li></ul></li></ul><p>接收方：</p><ul><li>接收方没有缓存(降低成本)</li><li>只接收有序的分组(向上提交)，会丢弃失序的分组</li><li>接收方确认分组：<ul><li><code>分组丢失—数据失序</code> 接收方丢弃失序分组</li><li><code>确认丢失—累积确认</code> ack3 ：小于等于序号3的分组都被确认收到</li><li><code>分组出错—重复确认</code> 接收方重复确认，发送方可在超时之前就重传</li></ul></li></ul><p><strong>滑动窗口</strong>(slide window)：窗口长度是固定的：N<br> <img src="https://i.loli.net/2018/06/06/5b174116e50a3.png" width="60%" height="60%"></p><h5 id="选择重传SR"><a href="#选择重传SR" class="headerlink" title="选择重传SR"></a>选择重传SR</h5><p>发送方：</p><ul><li>发送方有缓存(滑动窗口)</li><li>允许发送方发送多个分组，而不需等待确认</li><li>发送方有选择地重传：哪个分组的ack没收到，就重传那个分组</li></ul><p>接收方：</p><ul><li>接收方有缓存(滑动窗口)</li><li>分组失序：把分组缓存，向上层有序提交分组</li><li>接收方确认分组：<ul><li><code>分组丢失—数据失序</code> 接收方：缓存失序分组，逐个确认正确收到的分组</li><li><code>确认丢失—超时事件</code> 发送方重传</li><li><code>分组出错—重复确认</code> 接收方重复确认，发送方可在超时之前就重传(果断处之)<br><img src="https://i.loli.net/2018/06/06/5b174858862aa.png" width="80%" height="80%"></li></ul></li></ul><h4 id="实现可靠传输的基础构件"><a href="#实现可靠传输的基础构件" class="headerlink" title="实现可靠传输的基础构件"></a>实现可靠传输的基础构件</h4><ul><li>检验和</li><li>定时器</li><li>序号: 序号空间</li><li>确认: 确认序号/累积确认/重复确认/逐一确认(/否定确认）</li><li>窗口、流水线：窗口尺寸N、窗口变量：base， nextsqnum<h3 id="3-5-面向连接的运输：TCP"><a href="#3-5-面向连接的运输：TCP" class="headerlink" title="3.5 面向连接的运输：TCP"></a>3.5 面向连接的运输：TCP</h3><h4 id="TCP协议概述"><a href="#TCP协议概述" class="headerlink" title="TCP协议概述"></a>TCP协议概述</h4></li><li>因特网中最复杂的协议之一</li><li>端到端协议：一个发送方，一个接收方(不会广播)</li><li>可靠传输：<ul><li>有序的字节流传输：无损坏、无间隔、非冗余、按序交付。(差错检验、重传、累积确认、定时器、序号、确认号)</li><li>流水线协议：提供流控制和拥塞控制</li></ul></li><li>TCP是全双工协议<ul><li>在一个TCP连接中，数据流是双向的，发送方/接收方 可以发送数据，也可以接收数据</li><li>MSS最大报文段长度：实际指报文段应用层数据的最大长度，不包括TCP首部长度。</li></ul></li><li>TCP是面向连接的协议<ul><li>通过“握手”(交换控制信息)，初始化发送方和接收方的状态</li><li>连接状态完全保留在两个端系统中，TCP协议只在端系统中运行。中间的网络元素不会维持TCP的连接状态。P155</li></ul></li><li>TCP可实现流控制<ul><li>发送方的发送速度不能超过接收方的接收速度</li></ul></li></ul><h4 id="TCP可靠运输"><a href="#TCP可靠运输" class="headerlink" title="TCP可靠运输"></a>TCP可靠运输</h4><h5 id="TCP的序号、确认号"><a href="#TCP的序号、确认号" class="headerlink" title="TCP的序号、确认号"></a>TCP的序号、确认号</h5><ul><li>序号空间：[0—2<sup>32</sup>]</li><li>序号规则：<ul><li>面向<strong>字节流</strong>编序号：报文段的编号是该报文段数据中第一个字节的编号<br>Seq<sub>(i+1)</sub> == Seq<sub>(i)</sub> + L<sub>segment(i)</sub>  </li><li>不是对报文段编号</li></ul></li><li><code>确认号</code>ACK：期望的下一个报文段 <ul><li>ACK<sub>(0)</sub> == 0 </li><li>ACK<sub>(i)</sub> == Seq<sub>(i)</sub>+ 1</li></ul></li></ul><p><img src="https://i.loli.net/2018/06/06/5b175013a695c.png" width="70%" height="70%"></p><h5 id="TCP的确认和重传机制"><a href="#TCP的确认和重传机制" class="headerlink" title="TCP的确认和重传机制"></a>TCP的确认和重传机制</h5><ul><li>流水线协议</li><li>GBN和SR的混合体</li><li>此外，接收端也有定时器  </li></ul><table><thead><tr><th></th><th>事件</th><th>TCP接收方的动作</th></tr></thead><tbody><tr><td>延迟确认</td><td>期望序号的报文段按序到达，之前的报文段都已经被确认</td><td>延迟500ms确认新到的分组(为累积确认做准备)</td></tr><tr><td>累积确认</td><td>期望序号的报文段按序到达，另一个按序报文等待确认</td><td>立即发送单个累积确认，确认两个按序报文段</td></tr><tr><td>冗余确认</td><td>比期望序号大的报文段到达。检测出间隔</td><td>立即发送冗余确认(<strong>重复确认</strong>)，指示下一个期待字节的序号</td></tr><tr><td>立即确认</td><td>失序后最低望序号的报文段到达</td><td>立即发送确认(不延迟500ms)</td></tr><tr><td>快速重传</td><td>发送方收到3个冗余确认</td><td>超时之前重发报文段，避免无谓的等待</td></tr><tr><td>加倍超时</td><td>发送方产生一次超时重传</td><td>发送方加倍超时间隔。是一种有限形式的<code>拥塞控制</code></td></tr></tbody></table><blockquote><p>累积确认还可以解决<strong>确认丢失的问题</strong>: 发送方不会重传分组</p></blockquote><h4 id="往返时间估计"><a href="#往返时间估计" class="headerlink" title="往返时间估计"></a>往返时间估计</h4><p>TCP往返时间估计是为了解决<code>TCP协议的发送方如何设置定时器的时间间隔</code>的问题。<br><code>超时时间间隔</code>应大于RTT(往返时间)，但由于路由器的拥塞和端系统负载的变化，RTT总是在波动。</p><ul><li>超时时间间隔过小：累积确认到达之前，会产生不必要的重传！</li><li>超时时间间隔过大：对分组丢失的反映迟钝，降低了传输效率。累积确认、快速重传可以解决一些问题，但还是需要充分估计RTT。</li></ul><p><strong>估计RTT</strong><br>SampleRTT:<strong>某个</strong>报文段被发出，到收到确认的时间间隔。</p><blockquote><p>TCP仅在某个时刻做一次SampleRTT测量，SampleRTT的值也会波动。因此需要统计学意义上的测量和估计</p></blockquote><p><code>指数加权移动平均(EWMA)</code> <strong>EstimatedRTT</strong> = ( 1 - &alpha; ) <em> EstimatedRTT + &alpha; </em> SampleRTT<br><code>RFC 6298</code>: &alpha; = 0.125</p><p><code>估计RTT偏差</code> <strong>DevRTT</strong> = ( 1 -     &beta; ) <em> DevRTT + &beta; </em> | SampleRTT - EstimatedRTT |<br><code>RFC 6298</code>: &beta; = 0.25</p><p><code>设置超时时间间隔</code> <strong>TimeoutInterval</strong> = EstimatedRTT + 4 * DevRTT</p><h4 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h4><p><img src="https://i.loli.net/2018/06/06/5b175bfd35763.png" width="50%" height="50%">  </p><ul><li>源端口和目的端口(各占 2 字节)：是运输层与应用层的服务接口，实现对运输层的复用和分解。</li><li>序号(4 字节)：TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是<strong>本报文段所发送的数据的第一个字节的序号。</strong></li><li>确认号(4 字节)：是期望收到对方的下一个报文段的数据的第一个字节的序号。 </li><li>数据偏移/首部长度( 4 bit )：指示了以32 bit(4 字节为计算单位)的字为单位的TCP首部长度。若无选项字段，TCP长度固定为20字节。</li><li>保留字段( 6 bit )：保留为今后使用，目前均置为 0。</li><li>6个比特位 <ul><li><code>URG</code> 紧急比特位( 1 bit )：当 URG 为1时，告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。 </li><li><code>ACK</code> 确认比特位( 1 bit )：只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。 </li><li><code>PSH</code> 推送比特位( 1 bit )：接收推送比特位置 1 的报文段，接收方就应立即将数据交给上层，而不需缓存该报文段。 </li><li><code>RST</code> 复位比特位( 1 bit )：当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。 </li><li><code>SYN</code> 同步比特位( 1 bit )：同步比特 SYN = 1，就表示这是一个连接请求或确认连接的报文段。 </li><li><code>FIN</code> 终止比特位( 1 bit )：用来释放一个连接。当FIN = 1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 </li></ul></li><li>接收窗口( 2 字节 )：用于流量控制。TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限</li><li>检验和( 2 字节 )：检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。 </li><li>紧急指针( 2 字节 )：紧急指针指出在本报文段中的紧急数据的最后一个字节的序号。  </li><li>选项字段( 长度可变 )：目前只规定了一种选项，即最大报文段长度 MSS ；告诉对方 TCP“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。” </li><li>填充字段( 长度可变 )：使整个首部长度是 4 字节的整数倍。 </li></ul><h4 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h4><ul><li>目标：速度匹配 - &gt; 发送速度不能大于接收速度</li><li>原因：接收方的缓存空间有限，接收方提交数据的速度有限</li><li>机制：<ul><li>接收窗口：接收缓存中的剩余空间</li><li>接收方在向发送方确认时，随时告诉对方自己接收窗口的大小</li></ul></li></ul><p><img src="https://i.loli.net/2018/06/06/5b176f56448b8.png" width="50%" height="50%">  </p><h4 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h4><p>TCP是“面向连接”的运输协议</p><ul><li>运输之前，要先建立“逻辑连接”</li><li>初始化TCP的参数：序号、缓存</li><li>客户端发起连接：Socket clientSocket = new Socket(“hostname”, “port#”);</li><li>服务器端等待连接：Socket connectionSocket = welcomeSocket.accept();</li><li>通过三次握手建立连接<br><img src="https://i.loli.net/2018/06/06/5b17723a41cfa.png" width="70%" height="70%">  </li><li>关闭连接<br><img src="https://i.loli.net/2018/06/06/5b17712a0c33b.png" width="70%" height="70%">  </li></ul><h3 id="3-6-拥塞控制原理"><a href="#3-6-拥塞控制原理" class="headerlink" title="3.6 拥塞控制原理"></a>3.6 拥塞控制原理</h3><h4 id="网络拥塞"><a href="#网络拥塞" class="headerlink" title="网络拥塞"></a>网络拥塞</h4><ul><li>通俗地讲：由于过多的端点高速发送大量的数据，导致网络(路由器)难以胜任数据的转发</li><li>不同于流控制是匹配发送端和接收端的速度</li><li>拥塞的表现：<strong>分组重传作为网络拥塞的征兆</strong><ul><li>数据分组的丢失(路由器的缓存溢出)</li><li>产生较长的时延(在路由器缓存排队)</li></ul></li><li>拥塞控制是网络中的关键问题  </li></ul><p>通过对<strong>异步传递方式</strong>(ATM)网络中<strong>可用比特率</strong>(ABR)服务中的拥塞控制的讨论来总结本节</p><p><strong>拥塞情况1</strong>: 两个发送方和一台具有<strong>无限缓存</strong>的路由器</p><ul><li>链路的带宽：R </li><li>没有重传、流控制和拥塞控制</li></ul><p><strong>拥塞情况2</strong>:两个发送方和一台具有<strong>有限缓存</strong>的路由器</p><ul><li>链路的带宽：R</li><li>有分组重传控制:<br>应用层：(初始数据)λ<sub>in</sub> = (吞吐率)λ<sub>out</sub><br>运输层：(供给载荷)λ´<sub>in</sub> ≥ λ<sub>in</sub>  (λ´in包括了重传的数据分组)</li></ul><p><strong>拥塞情况3</strong> ：四发送方和一台具有有限缓存的多台路由器和多条路径<br>新的拥塞代价: 一个路由器将分组丢失，这个路径上先前的路由器也做了无用功</p><table><thead><tr><th>理想情况</th><th>拥塞情况1</th><th>拥塞情况2</th></tr></thead><tbody><tr><td>发送方”神知”路由器是否有可用缓存空间</td><td>路由器缓存溢出，丢失分组</td><td>路由器缓存中出现转发队列</td></tr><tr><td>只在路由器有缓存空间的情况下才发数据</td><td>发送方只在分组丢失的情况下重传</td><td>发送方产生超时事件</td></tr><tr><td>结果：不会丢失分组 λ´<sub>in</sub> = λ <sub>in</sub></td><td>代价：发送方会重传丢失的分组 λ´<sub>in</sub> &gt; λ<sub>in</sub></td><td>代价：发送方会重传延时的分组 λ´<sub>in</sub> &gt; λ<sub>in</sub></td></tr></tbody></table><blockquote><p>吞吐量、时延与主机发送速率的函数关系</p></blockquote><h4 id="拥塞控制的方法"><a href="#拥塞控制的方法" class="headerlink" title="拥塞控制的方法"></a>拥塞控制的方法</h4><ul><li>端到端拥塞控制:<ul><li>网络层不提供显式拥塞反馈</li><li>端点通过<strong>超时和冗余确认</strong>来感知是否发生了拥塞</li><li><strong>工作在运输层</strong>：通过TCP实现拥塞控制</li></ul></li><li>网络辅助的拥塞控制:<ul><li>路由器会告知端点产生了拥塞</li><li>使用特殊的分组来告知阻塞</li><li><strong>工作在链路层</strong><h3 id="3-7-TCP拥塞控制"><a href="#3-7-TCP拥塞控制" class="headerlink" title="3.7 TCP拥塞控制"></a>3.7 TCP拥塞控制</h3></li></ul></li><li>发送方感知网络的拥塞程度，来限制发送速度<ul><li>感知网络拥塞：发送方产生超时事件 / 收到接收方的3个冗余确认</li><li>控制拥塞：发送方设计一个动态调节的“阀门”——<strong>拥塞窗口</strong></li></ul></li></ul><h5 id="拥塞窗口-cwnd"><a href="#拥塞窗口-cwnd" class="headerlink" title="拥塞窗口(cwnd)"></a>拥塞窗口(cwnd)</h5><ul><li>发送端的一个<strong>动态参数</strong>，用于控制发送速度，初始值为1MSS(最大报文段长度)</li><li>拥塞窗口的工作机制<ul><li>限制向网络中传输的数据: LastByteSent-LastByteAcked &le; cwnd</li><li>TCP传输速率也是动态的<br>粗略地估计，在一个RTT内可以传输cwnd个字节: rate ≈ cwnd / RTT bytes/sec<br><img src="https://i.loli.net/2018/06/06/5b177b0688cc6.png" width="40%" height="40%"> </li></ul></li></ul><p><strong>拥塞窗口的动态调节策略</strong></p><ul><li>在拥塞产生之前，保守地增加拥塞窗口的大小<ul><li><code>加性增</code>: 每次增加1MSS个字节，直到检测到丢包事件</li></ul></li><li>在感知到拥塞后，迅速地减小拥塞窗口的大小<ul><li><code>乘性减</code>: 发生丢包事件后，拥塞窗口马上缩小一半</li></ul></li></ul><p><strong>TCP拥塞控制算法</strong><br>缓慢启动</p><ul><li>连接开始，速率翻倍提高，直到发生第一个丢包事件<ul><li>拥塞窗口初始值为1MSS</li><li>每经历1RTT，拥塞窗口翻倍(*2)</li><li>收到ACK后便进行更新</li></ul></li><li>初始速度很低，然后指数增长</li><li>产生超时事件：拥塞窗口重设为1MSS，重新慢启动</li><li>收到3个冗余确认：拥塞窗口减半，然后线性增长</li></ul><p>拥塞避免(提前采取措施)</p><ul><li>设定一个门限(阈yù值)</li><li>拥塞窗口达到门限值后，进入加性增长：每次增加1MSS</li><li>产生丢包事件后，收缩窗口、阈值<ul><li>阈值：缩减为拥塞窗口的一半</li><li>超时：拥塞窗口重新进入慢启动</li><li>三个冗余ACK：拥塞窗口从新的阈值开始加性增加</li></ul></li></ul><p>快速恢复：TCP的可选功能。<br><code>TCP Tahoe</code>：没有快速恢复，<code>TCP Reno</code>：综合了快速恢复</p><blockquote><p>TCP拥塞控制算法(慢启动、拥塞避免和快速恢复)的完整FSM描述</p></blockquote><p><img src="https://i.loli.net/2018/06/06/5b178146265e4.png" width="45%" height="45%"></p><p><strong>TCP吞吐量的宏观描述</strong><br>平均吞吐量是拥塞窗口和RTT的函数：<br>设W为丢包事件产生后的拥塞窗口大小，平均窗口大小约 3/4 W，平均吞吐量为3/4W per RTT<br>一条连接的平均吞吐量 = 0.75 * W / RTT<br><strong>经高带宽路径的TCP吞吐量</strong><br>网格和云计算需要高速的链路和吞吐量  </p><p>eg. 1500Bytes报文段, 100ms RTT, 为了获得10 Gbps的吞吐率<br>设平均拥塞窗口W = 83,333Bytes<br>考虑到丢包情况的吞吐率, 设丢包率为L [Mathis 1997]:<br>一条连接的平均吞吐量 = </p><blockquote><p>为了达到10Gbps的吞吐量，丢包率要非常低，小于L = 2·10-10!<br>针对高速的TCP设计，目前还在不断演化中</p></blockquote><p><strong>TCP的公平性</strong></p><ul><li>公平性的目标：<ul><li>如果 K个TCP连接共享一个带宽为R的链路</li><li>每个TCP连接拥有的平均传输率为 R/K</li><li>eg.设有两个相互竞争的连接，公平性的体现：两条连接实现的带宽最终将沿着平等带宽的共享曲线波动。它们最终会收敛该状态。</li><li>公平性和UPD、公平性和并行TCP连接</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络笔记02 应用层</title>
      <link href="/cn2/"/>
      <url>/cn2/</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-应用层协议原理"><a href="#2-1-应用层协议原理" class="headerlink" title="2.1 应用层协议原理"></a>2.1 应用层协议原理</h2><h4 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h4><p>应用程序研发很可能利用两种主流的体系结构之一:<br><strong><code>客户-服务端体系结构</code>:</strong></p><ul><li>服务器: <ul><li>持续地工作(365*24)  </li><li>固定的、周知的地址(<code>IP地址</code>)  </li><li>备有数据中心  <a id="more"></a> </li></ul></li><li>客户端:<ul><li>与服务器端通信  </li><li>间歇地工作  </li><li>可能更换地址  </li><li>客户端不直接通信(客户总能通过该服务器的IP地址<code>发送分组</code>来与其进行联系)  </li></ul></li></ul><p><strong><code>对等/P2P体系结构</code>:</strong></p><ul><li>没有常开的服务器</li><li>任意端系统之间直接通信  </li><li>端系统是对等的  </li><li>具有自扩展性  </li><li>间歇地工作  </li><li>管理起来比较复杂  </li><li>适用于流量密集型的应用，如文件共享、下载加速、IP电话、IPTV  </li></ul><h4 id="进程通信P59"><a href="#进程通信P59" class="headerlink" title="进程通信P59"></a>进程通信P59</h4><p><code>进程</code>：主机上运行的程序。<br><code>进程之间如何通信</code>：</p><ul><li>同一主机内部(操作系统)：<ul><li>管道、共享内存</li><li>由操作系统控制</li></ul></li><li>不同主机之间<ul><li>主机可能安装了不同的操作系统</li><li>使用<code>套接字(Socket)</code>机制，<code>API</code></li><li>通过网络建立通信</li></ul></li></ul><p><strong>客户和服务器进程</strong>：发起通信的进程被标识为客户，在会话开始时等待联系的进程是服务器。</p><p><strong>进程与计算机网络之间的接口<code>套接字</code></strong><br>是应用程序进程和运输层协议之间的接口, 类似于“门”的概念。通过套接字，不同端系统的进程可以进行网络通信。</p><blockquote><p>由于套接字也成为应用程序和网络之间的<strong>应用程序接口/API</strong>套接字是一种软件接口(API)</p></blockquote><p><strong>进程寻址</strong>：主机由<code>IP地址</code>标识。<code>目的地端口号</code>用于标识运行在接收主机上的接收进程/接收套接字。</p><h4 id="可供应用层使用的运输服务P61"><a href="#可供应用层使用的运输服务P61" class="headerlink" title="可供应用层使用的运输服务P61"></a>可供应用层使用的运输服务P61</h4><ul><li>可靠数据传输<ul><li>正确：数据差错检验</li><li>完整：分组丢失后重传</li><li>eg.需要可靠传输的应用：文件传输、邮件、远程访问..</li></ul></li><li><code>吞吐量</code>：可用吞吐量就是发送进程向接收进程交付比特的速率。<ul><li>越大当然越好</li><li>应用程序对吞吐量的需求不同</li><li><code>带宽敏感的应用</code>：带宽敏感，具有吞吐量要求的应用程序多媒体传输</li><li><code>弹性应用</code>：根据情况或多或少利用可供使用的吞吐量，如电子邮件、文件传输、Web传送…</li></ul></li><li>定时/实时性：<ul><li>保证较小的时间延迟，</li><li>eg.因特网电话、会议 </li></ul></li><li>安全<ul><li>数据不被非法读取、篡改、伪造等</li><li>提供加解密、认证、签名等机制(SSL／TLS)</li><li>eg.电子交易、保密通信</li></ul></li></ul><table><thead><tr><th style="text-align:center">应用</th><th style="text-align:center">数据丢失</th><th style="text-align:center">吞吐量(书上是带宽)</th><th style="text-align:center">时间敏感</th></tr></thead><tbody><tr><td style="text-align:center">文件传输</td><td style="text-align:center">不能丢失</td><td style="text-align:center">弹性</td><td style="text-align:center">no</td></tr><tr><td style="text-align:center">电子邮件</td><td style="text-align:center">不能丢失</td><td style="text-align:center">弹性</td><td style="text-align:center">no</td></tr><tr><td style="text-align:center">Web文档</td><td style="text-align:center">不能丢失</td><td style="text-align:center">弹性</td><td style="text-align:center">no</td></tr><tr><td style="text-align:center">实时媒体</td><td style="text-align:center">容忍丢失</td><td style="text-align:center">audio: 5kbps-1Mbps; video:10kbps-5Mbps</td></tr><tr><td style="text-align:center">yes, 100’s msec</td></tr><tr><td style="text-align:center">存储媒体</td><td style="text-align:center">容忍丢失</td><td style="text-align:center">同上</td><td style="text-align:center">yes, few secs</td></tr><tr><td style="text-align:center">交互式游戏</td><td style="text-align:center">容忍丢失</td><td style="text-align:center">few kbps up</td><td style="text-align:center">yes, 100’s msec</td></tr><tr><td style="text-align:center">即时通讯</td><td style="text-align:center">不能丢失</td><td style="text-align:center">弹性</td><td style="text-align:center">yes and no</td></tr></tbody></table><h4 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h4><p><strong>TCP：可靠传输服务</strong></p><ul><li>保障收发进程之间的可靠传输<ul><li>流控制: 发送速度不大于接收速度 </li><li>拥塞控制: 对发送速度进行调节</li><li>分组排序、丢失重传等</li></ul></li><li>是一种面向连接服务</li><li>但不能保障: <ul><li>带宽(吞吐量)</li><li>最低时延</li><li>安全性</li></ul></li></ul><p><strong>UDP：尽力交付服务</strong></p><ul><li>不保证收发进程的可靠传输<ul><li>没有流控制</li><li>没有拥塞控制</li><li>没有分组排序和重传机制</li></ul></li><li>是一种无连接服务 </li><li>也不能保障<ul><li>带宽(吞吐量)</li><li>最低时延</li><li>安全性</li></ul></li></ul><table><thead><tr><th>应用类别</th><th>应用层协议</th><th>依靠的传输协议</th></tr></thead><tbody><tr><td>电子邮件</td><td>SMTP [RFC 2821]</td><td>TCP</td></tr><tr><td>远程访问控制</td><td>Telnet [RFC 854]</td><td>TCP</td></tr><tr><td>Web</td><td>HTTP [RFC 2616]</td><td>TCP</td></tr><tr><td>文件传输</td><td>FTP [RFC 959]</td><td>TCP</td></tr><tr><td>流式多媒体</td><td>HTTP(如yotube)</td><td>TCP</td></tr><tr><td>因特网电话</td><td>SIP[RFC 3261]、RTP{RFC 3550]、或专用的(如Skype)</td><td>UDP/TCP</td></tr></tbody></table><h4 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h4><p><code>应用层协议</code>定义了运行在不同端系统上的应用程序进程如何相互传递报文。</p><ul><li>报文类别，如：request, response </li><li>报文格式(语法)：报文的字段有哪些；字段描述</li><li>报文语义: 报文的处理方法；报文的各个字段的含义</li><li>报文处理规则：请求和相应时如何发送报文；处理流程</li><li>通用协议如何规约<ul><li>通过RFC来定义标准化</li><li>允许互操作</li></ul></li><li>非标准化的专用协议：可由开发者自己定制，如：Skype</li></ul><p>应用层协议只是网络应用的一部分。如，Web的应用层协议为HTTP，但是Web应用的组成部分包括文档格式标准(HTML)，Web浏览器，Web服务器以及一个应用层协议HTTP。</p><h2 id="2-2-Web和HTTP"><a href="#2-2-Web和HTTP" class="headerlink" title="2.2 Web和HTTP"></a>2.2 Web和HTTP</h2><h4 id="WWW、HTTP"><a href="#WWW、HTTP" class="headerlink" title="WWW、HTTP"></a>WWW、HTTP</h4><p><code>World Wide Web</code>：万维网，因特网中最重要的应用<br><code>HTTP</code>：超文本传输协议，Web的应用层协议</p><h4 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h4><ul><li>client/server 模式<ul><li>client: 浏览器，请求，接收和， “现实” Web对象</li><li>server: Web服务器程序，响应客户端的请求，如返回Web对象</li></ul></li><li>依赖于TCP的传输服务:<ul><li>客户端初始化一个TCP连接 (创建TCP套接字)到服务器端, <strong>默认目标端口80</strong></li><li>服务器端接收TCP的连接请求</li><li>HTTP协议开始工作：客户端请求Web对象，服务器端响应</li><li>TCP连接终止</li></ul></li><li>HTTP是“无状态”协议:<ul><li>服务器不维持客户端的状态(历史)：不需要维护哪个客户端在什么时候做了什么</li><li>只要客户端请求即予以响应，来者不拒</li></ul></li><li>维持“状态”是一件复杂的事情：要记录历史数据，并保证一致性</li><li>可以让应用程序来处理，如开发Web应用程序、进行会话管理、记录流程、日志etc</li></ul><h4 id="HTTP的两种连接方式"><a href="#HTTP的两种连接方式" class="headerlink" title="HTTP的两种连接方式"></a>HTTP的两种连接方式</h4><ul><li>非持久性连接  HTTP/1.0：建立TCP连接后最多只能请求一个Web对象<ul><li>浏览器并发TCP/HTTP连接</li><li>为每一个请求的对象建立和维护全新的连接，需要分配TCP缓冲区和保持TCP变量(负担)</li><li>每一个对象经受两倍往返时间rrt的交付时延</li></ul></li><li>持久性连接  HTTP/1.1：在一个TCP连接期间可以请求多个Web对象<ul><li>HTTP/1.1默认使用的是带流水线方式的持久性连接，效率更高</li></ul></li></ul><h4 id="HTTP的报文格式"><a href="#HTTP的报文格式" class="headerlink" title="HTTP的报文格式"></a>HTTP的报文格式</h4><ul><li>报文编码：ASCII(人类可读)</li><li>报文类别：<ul><li>请求报文 (客户端发送，服务器端处理)</li><li>响应报文 (服务器端发送，客户端处理)</li></ul></li></ul><p><strong>请求报文</strong><br><img src="https://i.loli.net/2018/06/05/5b16313172444.png" width="60%" height="60%"></p><ul><li>请求方法<ul><li>GET: 获取Web对象，扩展URL(可提交数据)，实体体为空</li><li>POST: 提交Web表单，封装在实体数据</li><li>HEAD: 调试</li><li>PUT: 上传Web对象(HTTP/1.1)</li><li>DELETE: 删除Web对象(HTTP/1.1)</li></ul></li><li>URL<ul><li>Web路径：/folder </li><li>Web对象标识：/object.obj </li><li>Web对象?参数：/object.obj?p1&amp;p2 </li></ul></li></ul><p><strong>响应报文</strong><br><img src="https://i.loli.net/2018/06/05/5b163340844fb.png" width="60%" height="60%"></p><table><thead><tr><th>状态码</th><th>短语</th></tr></thead><tbody><tr><td>200</td><td>OK 请求成功</td></tr><tr><td>301</td><td>Moved Permanently 请求的对象已经被永久转移了</td></tr><tr><td>400</td><td>Bad Request 一个通用差错代码，指示该请求不能被服务器理解</td></tr><tr><td>404</td><td>Not Found 被请求的文档不再服务器上</td></tr><tr><td>505</td><td>HTTP Version Not Supported 服务器不支持请求报文使用的HTTP协议版本</td></tr><tr><td>304</td><td>Not Modified ，原来缓冲的文档还可以继续使用P77</td></tr></tbody></table><h4 id="用户与服务器的交互-cookie"><a href="#用户与服务器的交互-cookie" class="headerlink" title="用户与服务器的交互: cookie"></a>用户与服务器的交互: cookie</h4><ul><li>HTTP是无状态协议：如何让服务器知道用户先前做过什么？ Cookie<ul><li>在HTTP请求和响应的首部行设定cookie</li><li>客户端保存cookies</li><li>服务器端通过cookie与后台数据库关联</li></ul></li></ul><p><strong>P73 图2-10 跟踪用户状态</strong><br>cookie可以在无状态的HTTP之上建立一个用户会话层，主要用于：<strong>授权，购物车，推荐，用户会话状态管理，个性化推荐</strong></p><ul><li>怎样保持状态? <ul><li>协议：通过复杂的交互过程</li><li>cookies：让报文内容承载状态信息</li><li>应用程序：如会话管理</li></ul></li></ul><h4 id="Web缓存P74"><a href="#Web缓存P74" class="headerlink" title="Web缓存P74"></a>Web缓存P74</h4><ul><li>Web代理服务器<ul><li>用户可以通过代理服务器访问外部网站</li><li>既是客户端，又是服务器</li></ul></li><li>Web缓存的作用<ul><li>减少请求/响应时间</li><li>流量本地化</li><li>减少接入网络流量</li><li>更好地实现内容分发(eg.CDN)</li></ul></li></ul><p>#####实例分析：<br>假设：</p><ul><li>Web对象的平均长度: 1M bits</li><li>客户端的平均请求率:15个/sec</li><li>客户端的数据传输速率: 1.50 Mbps</li><li>从浏览器到服务器的往返时间: 2 sec</li><li>接入网络的带宽: 15 Mbps</li></ul><p>结果：</p><ul><li>局域网流量强度: 15%</li><li><strong>接入网流量强度 = 100%(!problem)</strong></li><li>total delay = Internet delay 2秒+ <strong>access delay 若干分钟(排队时延)</strong>+ LAN delay 若干微秒</li></ul><p>昂贵的改进方法——增加接入链路的速率<br>接入网络的带宽: 15 Mbps - &gt; 100 Mbps</p><ul><li>局域网流量强度: 15%</li><li><strong>接入网流量强度 = 15%</strong></li><li>total delay = Internet delay 2秒+ <strong>access delay 若干毫秒</strong>+ LAN delay 若干微秒</li></ul><p><img src="https://i.loli.net/2018/06/05/5b164472d62ae.png" width="40%" height="40%"><img src="https://i.loli.net/2018/06/05/5b1645e4f3442.png" width="35%" height="435%"></p><p>另一种改进方法：在机构网络中安装一个Web缓存器<br>如何计算设置缓存后的时延:</p><ul><li>设缓存中对象的命中率为 0.4<ul><li>40% 的请求可以在缓存中获取</li><li>60% 的请求在远程服务器获取 </li></ul></li><li>接入链路利用率: <ul><li>60% 的请求在远程服务器获取 </li><li>接入网络传输速度 = 0.6*15 Mbps = 9 Mbps </li><li>利用率= 9Mbps/15Mbps =60%</li></ul></li><li>平均时延(概率)<ul><li>= 0.6 <em> 服务器端时延 +0.4 </em> 缓存时延</li><li>= 0.6 (2.01) + 0.4 (~msecs) </li><li>= ~ 1.2 secs</li></ul></li></ul><h4 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h4><p>Web缓存的问题：如何保证缓存中的对象是最新的？<br><code>条件GET方法</code>：HTTP协议中的一种机制，允许缓存器证实它的对象是最新的</p><ul><li>目标: 如果缓存中的对象是新的，就没必要再去远程服务器获取<ul><li>减少时延</li><li>降低外部带宽利用率</li></ul></li><li>缓存: 为每个对象设置版本信息<ul><li>If-modified-since: <date></date></li></ul></li><li>服务器: 如果缓存的对象是最新的，服务器端不需再响应: <ul><li>HTTP/1.0 304 Not Modified</li></ul></li></ul><h3 id="2-3-FTP-文件传输协议"><a href="#2-3-FTP-文件传输协议" class="headerlink" title="2.3 FTP: 文件传输协议"></a>2.3 FTP: 文件传输协议</h3><ul><li>向远程服务器端收发文件</li><li>client/server 模式<ul><li>client: 初始化连接(任何时候都是从客户端发起)</li><li>server: 远程主机</li></ul></li><li>ftp server: port 21，20<ul><li>服务器端默认<code>端口号21</code> 用于对客户端认证</li><li>服务器会在接收到文件传输请求时，打开<code>端口号20</code>的端口来进行传输数据文件。</li></ul></li></ul><p>FTP客户端连接服务器端使用TCP提供可靠传输服务有两类连接：控制、传输 </p><ul><li>控制连接：<ul><li>服务器端默认端口号：21</li><li>建立控制连接时需要对客户端验证</li><li>客户端向服务器端发送交互式命令</li><li>是有状态的协议，可控制客户端的最近登录验证、历史信息等</li><li>控制连接是<strong>持久性</strong>的</li></ul></li><li>传输连接：<ul><li>服务器端接收到文件传输的请求时，会打开传输连接(20端口)用于文件传输</li><li>当这个文件传输结束后，第二个连接会被服务器端关闭</li><li>传输连接是<strong>非持久性</strong>的</li><li>“带外传输”</li></ul></li></ul><p>一些常用命令P79:</p><ul><li>sent as ASCII text over control channel</li><li>USER username：用于向服务器传送用户标识</li><li>PASS password：用于向服务器发送用户口令</li><li>LIST return list of file in current directory</li><li>RETR filename retrieves (gets) file</li><li>STOR filename stores (puts) file onto remote host</li></ul><p>常见的服务器响应代码：</p><ul><li>status code and phrase (as in HTTP)</li><li>331 Username OK, password required(用户名OK，需要口令)</li><li>125 data connection already open; transfer starting(数据连接已经打开，开始传送)</li><li>425 Can’t open data connection(无法打开数据连接)</li><li>452 Error writing file(写文件差错)</li></ul><h3 id="2-4-因特网中的电子邮件"><a href="#2-4-因特网中的电子邮件" class="headerlink" title="2.4 因特网中的电子邮件"></a>2.4 因特网中的电子邮件</h3><p><strong>三个主要组件</strong></p><ul><li>用户代理：即：邮件收发读写软件<ul><li>eg.Outlook, Foxmail, Thundbird</li></ul></li><li>邮件服务器：发送、接收邮件</li><li>邮件协议<ul><li>发送协议：SMTP </li><li>接收协议：PoP3、IMAP</li><li>报文协议：MIME</li></ul></li></ul><h4 id="简单邮件传输协议-SMTP"><a href="#简单邮件传输协议-SMTP" class="headerlink" title="简单邮件传输协议:SMTP"></a>简单邮件传输协议:SMTP</h4><ul><li>使用TCP的可靠传输服务,</li><li>端口号：25</li><li>直接传输: 从发送端的服务器到接收端的服务器</li><li>传输的三个阶段:握手(greeting)、报文传输、结束</li><li>使用交互式命令<ul><li>commands: ASCII text</li><li>response: status code and phrase</li></ul></li><li>报文编码格式：7-bit ASCII</li></ul><p><img src="https://i.loli.net/2018/06/05/5b164b692f1ea.png" width="80%" height="80%"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> S: 220 hamburger.edu  C: HELO crepes.fr  S: 250  Hello crepes.fr, pleased to meet you  C: MAIL FROM: &lt;alice@crepes.fr&gt;  S: 250 alice@crepes.fr... Sender ok  C: RCPT TO: &lt;bob@hamburger.edu&gt;  S: 250 bob@hamburger.edu ... Recipient ok  C: DATA  S: 354 Enter mail, end with &quot;.&quot; on a line by itself  C: Do you like ketchup?  C: How about pickles?  C: .  S: 250 Message accepted for delivery  C: QUIT  S: 221 hamburger.edu closing connection</span><br><span class="line">```- SMTP：持久性连接 - 在一个连接中可以进行多次操作 - 可以发送多个邮件、群发邮件 - 通过退出(Quit)来关闭连接- SMTP：报文都是7bit ASCII编码- SMTP：使用 crlf.crlf 作为报文结束符|SMTP|HTTP|</span><br><span class="line">|---|----|</span><br><span class="line">|推协议(push):向服务器端发送|拉协议(pull)：向服务器端请求||使用ASCII对报文进行编码|使用ASCII对报文进行编码|</span><br><span class="line">|报文可以封装**多个对象**(email附件)|每个响应报文只能封装1个web对象|- RFC 822: 用于定义邮件的格式: - 首部行</span><br></pre></td></tr></table></figure><p> From: alice&amp;crepes.fr<br> To: <a href="mailto:bob@hamburger.edh" target="_blank" rel="noopener">bob@hamburger.edh</a><br> Subject: Searching for the meaning of life</p><pre><code> - Body: 邮件正文(ASCII characters only，BASE 64编码)#### 邮件访问协议(接收方) - POP: Post Office Protocol [RFC 1939] - 认证(agent &lt;--&gt;server)和下载 - IMAP: Internet Mail Access Protocol [RFC 1730] - 更多的功能(更复杂) - 可在服务器端操作邮件- HTTP: Hotmail , Yahoo! Mail, etc.**POP3**- 认证阶段 - 客户端命令:</code></pre><p> user: declare username<br> pass: password</p><pre><code>- 服务器端响应:</code></pre><p>+OK<br>-ERR<br><code>`</code></p><ul><li>传输阶段, 客户端的命令:<ul><li>list: 列出邮件的索引</li><li>retr: 根据编号接收邮件</li><li>dele: 删除某个编号的邮件</li><li>quit</li></ul></li></ul><table><thead><tr><th>POP3</th><th>IMAP</th></tr></thead><tbody><tr><td>download and delete 在其他客户端无法读取</td><td>报文都在服务器端存储</td></tr><tr><td>download-and-keep 客户端和服务器端双份</td><td>允许用户创建文件夹</td></tr><tr><td>POP3是无状态的协议</td><td>在会话周期内维护用户的状态</td></tr></tbody></table><h3 id="2-5-因特网的目录服务"><a href="#2-5-因特网的目录服务" class="headerlink" title="2.5 因特网的目录服务"></a>2.5 因特网的目录服务</h3><p>因特网中标识一个主机：</p><ul><li>主机名：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>, mail.cqu.edu.cn ……  </li></ul><blockquote><p>人容易记住某个主机的名字，而不是IP地址<br>主机别名：一个主机也会有很多别名<br><strong><code>域名</code></strong>：.edu .cn .uk</p></blockquote><ul><li>IP地址：32bit 编码 (点分十进制表示：202.202.0.35)<ul><li>机器之间相互识别</li><li>路由器通过IP地址对分组进行路由、转发</li></ul></li></ul><h4 id="DNS-因特网的目录服务"><a href="#DNS-因特网的目录服务" class="headerlink" title="DNS 因特网的目录服务"></a>DNS 因特网的目录服务</h4><p><strong>DNS提供的服务</strong>(因特网中的一个核心服务)：</p><ul><li>将主机名映射为IP地址</li><li>可对服务器的负载进行均衡</li><li>获得主机别名对应的规范化主机名及主机的IP地址</li><li>邮件服务器别名</li></ul><h4 id="DNS工作机理概述"><a href="#DNS工作机理概述" class="headerlink" title="DNS工作机理概述"></a>DNS工作机理概述</h4><ul><li>DNS工作在应用层：<ul><li>DNS服务不直接与用户打交道</li><li>不封装用户的应用数据报文</li><li>只协助源主机查询出目标主机的IP地址</li><li>DNS是一个分布式的数据库系统：</li></ul></li><li>DNS是一个分布式的数据库系统：<ul><li>通过<strong>层级化</strong>的域名服务器进行工作</li></ul></li><li>DNS的分布式查询方式: <ul><li><code>迭代查询</code></li><li><code>递归查询</code></li></ul></li></ul><p><img src="https://i.loli.net/2018/06/05/5b1684e9b46fa.png" width="40%" height="40%"><img src="https://i.loli.net/2018/06/05/5b1684ea021d6.png" width="40%" height="40%"></p><ul><li>DNS的缓存机制<ul><li>作用：改善时延、减少DNS报文数量</li><li>服务器查询到映射关系后，将会缓存此映射关系</li><li>每个缓存的映射关系具有一定的生命周期（如2天）</li><li>顶级DNS服务器一般缓存本地DNS服务器的映射关系（减少根服务器的负担）</li><li>由IETF制定并维护标准 RFC 2136</li><li>本地主机上面也有缓存</li></ul></li></ul><blockquote><p><strong>层级化的域名服务器</strong></p></blockquote><ul><li>根DNS服务器：用于查询顶级DNS服务器的地址</li><li>顶级DNS服务器：用于查询下一级或权威DNS服务器的地址<ul><li>提供了权威的主机名和IP地址映射，由组织机构或服务提供商来维护</li><li>eg. .net/.edu/.org/.com/.uk/.cn</li></ul></li><li>权威DNS服务器：组织机构自身的DNS服务器<ul><li>提供了权威的主机名和IP地址映射，由组织机构或服务提供商来维护</li></ul></li><li>本地DNS服务器：<ul><li>不属于严格意义上层级DNS体系</li><li>每个本地ISP、公司、大学都会部署</li><li>主机的DNS查询都会先提交给本地DNS服务器</li><li>具有缓存和代理的功能</li></ul></li></ul><blockquote><p><strong>为什么要分布式、层级化？而不是集中化？</strong></p></blockquote><p>集中化的问题：</p><ul><li>单点故障：会导致全局失效</li><li>通信容量：会导致拥塞</li><li>远距离的集中式数据库：增大时延</li><li>维护困难</li><li>难于扩展</li></ul><h4 id="DNS记录"><a href="#DNS记录" class="headerlink" title="DNS记录"></a>DNS记录</h4><ul><li>使用分布式的数据库来存储资源记录</li><li>资源记录格式：四元组<ul><li>RR format: (name, value, type, ttl)</li></ul></li><li>name：主机名或域名</li><li>value：主机名映射的IP地址或DNS服务器名</li><li>type：记录类型<ul><li>Type=A，value是该主机名对应的IP地址；(<a href="http://www.cqu.edu.cn" target="_blank" rel="noopener">www.cqu.edu.cn</a>, 202.202.0.35, A)</li><li>Type=NS， value是该域名中的DNS服务器；(cqu.edu.cn, dns.cqu.edu.cn, NS)</li><li>Type=CNAME，value是该主机名对应的规范主机名</li><li>Type=MX， value是该邮件服务器名对应的规范主机名</li></ul></li><li>ttl：记录的生存周期(time to live)</li></ul><h4 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h4><p><img src="https://i.loli.net/2018/06/06/5b17294ee77f3.png" width="65%" height="65%"><br>查询报文、回答报文：两者格式相同</p><ul><li>报文首部(12 bytes)</li><li>标识符(16bit)：匹配查询和回答</li><li>标志位(16bit)：是查询 还是 回答；是否权威的回答；希望递归；递归可用</li><li>问题：name, type</li><li>回答：name, value, type, ttl，可能有多个记录</li><li>权威</li><li>附加</li></ul><h4 id="向DNS数据库中插入记录"><a href="#向DNS数据库中插入记录" class="headerlink" title="向DNS数据库中插入记录"></a>向DNS数据库中插入记录</h4><ul><li>机构注册：向权威机构注册本机构的DNS信息<ul><li>向相关机构注册本机构的域名</li><li>向上级DNS服务器注册本机构的权威DNS服务器<br>Type=NS：该域中的权威DNS服务器是哪个主机(networkutopia.com,dns1.networkutopia.com, NS)<br>Type=A：权威DNS服务器的IP地址是多少(dns1.networkutopia.com,212.212.212.1, A)</li></ul></li><li>权威DNS服务器中的记录更新<ul><li>对组织机构内部的主机、地址映射信息进行维护：<code>静态配置</code>、<code>动态更新</code></li></ul></li></ul><h3 id="2-6-P2P应用"><a href="#2-6-P2P应用" class="headerlink" title="2.6 P2P应用"></a>2.6 P2P应用</h3><h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><ul><li>纯P2P架构<ul><li>没有Sever</li><li>任意端系统可以直连</li><li>端点间歇连接</li><li>可能会更换IP地址</li></ul></li><li>典型应用<ul><li>文件分发：BitTorrent</li><li>流媒体传输：Kankan</li><li>因特网电话：Skype</li></ul></li><li>混合架构<ul><li>Server：追踪器、帐户管理等</li></ul></li></ul><h4 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h4><ul><li>一台服务器S向N个主机(peers)分发一个大文件(大小为F bits)<ul><li>服务器的<strong>上载</strong>能力u<sub>s</sub>；</li><li>端点i的<strong>上载</strong>和<strong>下载</strong>能力分别为u<sub>i</sub>和d<sub>i</sub>；</li></ul></li></ul><h5 id="1-使用C-S模式进行分发"><a href="#1-使用C-S模式进行分发" class="headerlink" title="1.使用C/S模式进行分发"></a>1.使用C/S模式进行分发</h5><ul><li>服务器端：<ul><li>S必须向每个客户端上载1个拷贝</li><li>发送1个拷贝的时间：t=F/u<sub>s</sub></li><li>发送N个拷贝的时间：t<sub>total</sub>=NF/u<sub>s</sub></li></ul></li><li>客户端<ul><li>每个端点必须获得一个拷贝</li><li>设dmin=客户端的最低下载速率</li><li>客户端的最长下载时间：F/d<sub>min</sub></li><li>文件分发时间：D<sub>c/s</sub>≥max{NF/u<sub>s</sub>, F/d<sub>min</sub>}，随着N的增加，时间线性增长</li></ul></li></ul><h5 id="2-使用P2P进行分发"><a href="#2-使用P2P进行分发" class="headerlink" title="2.使用P2P进行分发"></a>2.使用P2P进行分发</h5><ul><li>服务器端<ul><li>S必须上载至少1个拷贝</li><li>所需上载时间：t<sub>u=</sub>F/u<sub>s</sub></li></ul></li><li>客户端<ul><li>每个端点必须获得一个拷贝：td=F/d<sub>min</sub></li></ul></li><li>客户群<ul><li>必须下载N个拷贝，总体上载速率为u<sub>s</sub>+∑u<sub>i</sub></li></ul></li><li>文件分发时间：Dp2p≥max{F/u<sub>s</sub>, F/d<sub>min</sub>, NF/(u<sub>s</sub>+ ∑u<sub>i</sub>)}</li></ul><p><img src="https://i.loli.net/2018/06/05/5b168eccad419.png" width="50%" height="50%"><img src="https://i.loli.net/2018/06/05/5b168ec27b402.png" width="40%" height="40%"></p><h4 id="BitTorrent文件分发协议"><a href="#BitTorrent文件分发协议" class="headerlink" title="BitTorrent文件分发协议"></a>BitTorrent文件分发协议</h4><ul><li>文件被分为大小为256Kb的块</li><li>洪流中的端点发送和接收这些文件块</li></ul><p><img src="https://i.loli.net/2018/06/05/5b1690647bcfa.png" width="40%" height="40%"></p><ul><li>请求文件块：最稀缺优先<ul><li>在某一时刻：不同的端点，文件块集也不同</li><li>在某段时间：Alice周期性地向邻居索问他们的文件块索引，随后请求这些所需的文件块</li><li>最稀缺优先原则</li><li>所有邻居中某个块的数量最少，则先请求这个块。Why?</li></ul></li><li>响应文件块：礼尚往来<ul><li>疏通：确定给自己发送块最快的几个对等方</li><li>tit-for-tat：看谁对我好(给我传的快)，我也对他好(给她/他传得也快)</li></ul></li></ul><h4 id="分布式哈希表DHT"><a href="#分布式哈希表DHT" class="headerlink" title="分布式哈希表DHT"></a>分布式哈希表DHT</h4><ul><li>基于P2P模式的分布式数据库</li><li>数据库的基本思想：键值对<ul><li>键：账号，值：口令(eg. 键：学号，值：成绩)</li></ul></li><li>集中式数据库<ul><li>C/S架构</li></ul></li><li>分布式数据库<ul><li>P2P架构</li><li>在大量的peer上面存储键值对</li><li>分布式哈希表DHT </li></ul></li></ul><p>DHT的应用：一个peer通过键来查询，获得这个键对应的值</p><blockquote><p>应用场景：<br>键：”Logen” ；Alice通过这个键来查询谁有这个影片<br>值：拥有这个影片副本的peer(IP地址)</p></blockquote><h5 id="如何创建分布式哈希表？"><a href="#如何创建分布式哈希表？" class="headerlink" title="如何创建分布式哈希表？"></a>如何创建分布式哈希表？</h5><ul><li>核心问题：怎么把键值对分配到peer中?</li><li>基本思想：<ul><li>把每个键都通过Hash变成整数，并为每个peer进行<strong>整数标识</strong></li><li>把键值对插入到<strong>与这个整数最接近的端点</strong>中</li></ul></li><li>具体操作：<ul><li>用n bit的整数(如n=64),可表示的整数区间为[0, 2n-1]</li><li>把每个键都用整数表示：Key=hash(“Logen”)=20161858，所以称之为分布式hash表 </li></ul></li><li>插入键值：<ul><li>规则：把键值插入到与peer ID最接近的peer上</li><li>与这个整数相等的节点，或与这个整数最临近的后继节点</li></ul></li></ul><h5 id="怎样查找出键值对"><a href="#怎样查找出键值对" class="headerlink" title="怎样查找出键值对"></a>怎样查找出键值对</h5><table><thead><tr><th>环状DHT，覆盖网络</th><th>具有捷径的环状DHT</th></tr></thead><tbody><tr><td>每个节点只知道它的邻居(前驱、后继)</td><td>每个节点知道它的邻居以及它的两个捷径</td></tr><tr><td>算法复杂度(最差情况): O(N)</td><td>算法复杂度: O(log N)</td></tr></tbody></table><ul><li>对等方扰动: 等同于链表中删除一个节点<ul><li>Peer记住它的两个后继定时检查两个后继是否存在(Ping一下)</li><li>若直接后继退离，将第二后继设为直接后继</li></ul></li><li>Peer可能随时加入：<ul><li>查询：先问一下DHT自己的前驱和后继是谁</li><li>通知：向前驱和后继发送报文</li><li>更新：本节点、前驱和后继均要更新</li></ul></li></ul><h3 id="2-7-TCP套接字编程"><a href="#2-7-TCP套接字编程" class="headerlink" title="2.7 TCP套接字编程"></a>2.7 TCP套接字编程</h3><p><code>套接字</code>：在主机端、由应用进程创建、由操作系统控制的接口，一个应用进程可以向另一个进程发送或接收报文。<br><code>套接字编程</code>：对应于传输层的服务，有两种类型的套接字</p><ul><li><code>四元组</code>TCP：可靠的，面向字节流的传输，封装为报文段(segment)</li><li><code>二元组</code>UDP：不可靠的传输，封装为用户数据报(user datagram)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络笔记01 计算机网络和因特网</title>
      <link href="/cn1/"/>
      <url>/cn1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-什么是因特网"><a href="#1-1-什么是因特网" class="headerlink" title="1.1 什么是因特网"></a>1.1 什么是因特网</h2><h3 id="具体构成描述-硬件和软件组成"><a href="#具体构成描述-硬件和软件组成" class="headerlink" title="具体构成描述(硬件和软件组成)"></a>具体构成描述(硬件和软件组成)</h3><p><strong>因特网</strong>是网络的网络，是一个世界范围的计算机网络。 </p><blockquote><ol><li>连接数以亿计的设备: <code>主机/端系统</code>通过服务提供商(ISP)接入因特网进行互联。 <code>运行各种网络应用</code>  </li><li><code>主机/端系统</code>通过通信链路和分组交换机连接到一起</li><li>通信链路:<br>&ensp;&ensp; <code>传输媒介</code>: 同轴电缆、铜线、光线、无线电<br>&ensp;&ensp; <code>传输速率</code>: 带宽  </li><li>交换设备: <code>路由器</code> <code>链路层交换机</code><a id="more"></a> </li></ol></blockquote><p><strong>协议</strong>是对因特网中消息的发送和接收进行控制。</p><p>因特网中最主要的协议统称为<code>TCP/IP</code>。</p><blockquote><p>TCP: 传输控制协议<br>IP: 网络协议，定义了在路由器端系统之间发送和接收的分组格式<br>HTTP, Skype(Skype的通讯协议是不公开的)</p></blockquote><p><strong>因特网标准</strong>是指关于互联网相关的技术与方法论的技术规范，由互联网工程任务组（IETF）创建与发布。</p><blockquote><p>RFC<code>请求评论</code>: 定义了TCP，IP，HTTP和SMTP等协议。<br>其他组织: IEEE 802 LAN/MAN标准华委员会制定了<code>以太网</code>和<code>无线WiFi</code>的标准</p></blockquote><h3 id="服务描述-基础设施向分布式应用程序提供的服务"><a href="#服务描述-基础设施向分布式应用程序提供的服务" class="headerlink" title="服务描述(基础设施向分布式应用程序提供的服务)"></a>服务描述(基础设施向分布式应用程序提供的服务)</h3><p><strong>服务描述:</strong><code>因特网</code>是为应用程序提供服务的基础设施。因特网应用程序运行在<code>端系统</code>上</p><blockquote><p>为各种应用提供通信服务Web, VoIP, email, 在线游戏, 电子商务, 社会网络<br>提供应用程序编程接口(API)</p></blockquote><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>一个协议定义了在两个或多个实体之间交换的<code>报文格式</code>和<code>次序</code>，以及报文发送和/或接收一条报文或其他事件所采取的<code>动作</code>。</p><blockquote><p>机器之间的通信，所有通信都遵照某种协议  </p></blockquote><ul><li>语法: 定义数据格式、编码等  </li><li>语义: 定义控制信息  </li><li>同步: 定义速度和排序等信息</li></ul><h2 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h2><p><strong>端系统=主机</strong>位于因特网的边缘，运行应用程序。</p><blockquote><p>client/server模式: 主机有时被划分为客户和服务器这两类。<br>P2P模式</p></blockquote><h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><p>接入网：是将端系统连接到其边缘路由器的<code>物理链路</code>。</p><ol><li>家庭接入: <ul><li><code>DSL</code>数据用户线路：以电话线为传输介质的传输技术组合<br>，利用本地电话公司现有的电话线路连接到DSL中心局。</li><li><code>电缆因特网接入</code>：利用有线电视公司现有的有线电视基础设施。频分复用: 按照频段分成不用的信道</li><li>FTTH, 拨号, 卫星</li></ul></li><li>企业(和家庭)接入:以太网, WiFi</li><li>广域无线接入:3G, LTE</li></ol><p><strong>物理媒体</strong>: 被<em>传输器-接收器</em>跨越传播电磁波或光脉冲来发送比特。</p><blockquote><p><strong>引导型媒体</strong><br>双绞线:五类:100-1000Mbps;六类:10Gbp<br>同轴电缆:10-100Mbps<br>光纤:抗干扰性强<br><strong>非引导型媒体</strong><br>陆地无线电信道<br>卫星无线电信道: 同步卫星(时延),近地卫星(需要解决覆盖问题)</p></blockquote><h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h2><p><code>网络核心</code>即由互联因特网段系统的分组交换机和链路构成的网状结构。<br>数据在网络中的传输方式：</p><p><strong>分组交换</strong>: 报文被分成小的数据库: 分组</p><blockquote><p>每个分组占用全部宽带，用户可以共享网络通信资源。</p></blockquote><p>它是一种存储——转发交换方式，即将到达交换机的分组先送到存储器暂时存储和处理，等到相应的输出电路有空闲时再送出。    </p><blockquote><p>由于数据进入交换节点后要经历存储转发这一过程，从而引起的<code>转发时延</code>（包括接受分组、检验正确性、排队、发送时间等），而且网络的通信量越大，造成的时延就越大，<code>实时性较差</code>。<br>分组丢失(丢包): 缓存空间大小有限，一个到达的分组可能发现缓存被充满，到达的分组或已排队的分组之一将被丢弃。<br>可能出现失序，丢失或重复分组，分组到达目的节点时，对分组按编号进行排序等工作，增加了麻烦。</p></blockquote><p><strong>分组交换的两种方法<code>网络层</code></strong></p><ul><li>数据报网络(现在网络更多使用这一类)  </li></ul><blockquote><p>目标地址确定下一站<br>数据包路径不一定相同</p></blockquote><ul><li>虚电路网络(对延时有要求，即时)</li></ul><blockquote><p>虚电路编号来确定路径<br>数据包的路径相同</p></blockquote><p><strong>电路交换</strong>: 是一种”面向连接”的方式，通过<code>频分复用</code>或<code>时分复用</code>来实现的。  </p><blockquote><p>在通信的全部时间内，通话的两个用户始终占用端到端的固定传输带宽<br>使用电路交换来传输计算机数据时，线路的传输效率往往很低<br>通信资源被划分成小片</p></blockquote><p><code>频分复用FMD</code>: 将用于传输信道的总带宽划分成若干个子频带，每一个子信道传输1路信号。为保证各子信带中所传输的信号互不干扰，在各子信道之间设立隔离带。(收音机频道)<br><code>时分复用TMD</code>: 时间被划分为固定区间的帧(非常短的时间)，每帧又被划分为固定数量的时隙。   </p><table><thead><tr><th style="text-align:left">电路交换</th><th style="text-align:left">分组交换</th></tr></thead><tbody><tr><td style="text-align:left">面向连接</td><td style="text-align:left">无连接</td></tr><tr><td style="text-align:left">电路交换需要先建立连接，所以有时间开销</td><td style="text-align:left">无需建立连接，省掉了一部分时间开销。</td></tr><tr><td style="text-align:left">占用通信链路直到整段报文传输结束链接断开，<code>通信链路利用率低。</code></td><td style="text-align:left">报文被分割成小的分组，通信链路只在传输一个分组的时候被占用，传输结束链路继续被使用，<code>利用率较高。</code>允许用户的“突发式”传输。</td></tr><tr><td style="text-align:left">建立连接，数据传输<code>稳定</code>，快速，适用于系统间高质量的大数据传输情况。</td><td style="text-align:left">传输大数据时效率偏低，且容易<code>丢失数据。</code></td></tr></tbody></table><p><strong>网络中的网络</strong><br>端系统通过ISP(因特网服务提供商)接入互联网</p><blockquote><p>家庭<br>公司或高校</p></blockquote><p>接入的ISP直接必须互联<br>互联的网络非常复杂</p><p>分层思想: 去中心， 一个中心容易出现单点故障<br>经济和国家策略: 不能一家独享，需要多个ISP来竞争</p><blockquote><ol><li>全球承载ISP  </li><li>区域ISP    </li><li>对等连接</li><li>因特网交换点IXP: 允许不同的因特网服务提供商(ISPs)在它们的自动系统之间通过对等协议来交换因特网通信。是一个汇合点，多个ISP在这里共同对等  </li><li>内容提供商网络(如Google): 减少了向顶层ISP支付的费用</li></ol></blockquote><h2 id="1-4-延迟、丢包和吞吐量"><a href="#1-4-延迟、丢包和吞吐量" class="headerlink" title="1.4 延迟、丢包和吞吐量"></a>1.4 延迟、丢包和吞吐量</h2><p><strong>时延</strong>是数据（一个报文/分组/甚至比特）从网络或链路的一端传送到另一端所需的时间.<br><code>节点处理时延</code>包括选择输出链路，差错检验等因素。取决于节点的处理性能，一般在毫秒数量级。<br><code>排队时延</code> 是排队等待接点的输出链路发送数据分组所需的时间。取决于节点的拥塞情况。 </p><blockquote><p>排队时延与分组丢失(丢包): 缓存空间大小有限，一个到达的分组可能发现缓存被充满，到达的分组或已排队的分组之一将被丢弃</p></blockquote><p><code>传输时延</code> 设输出链路带宽为R，将长度为L的分组发送到链路中所需的时间d<sub>trans</sub>=L/R<br><code>传播时延</code>分组在链路上”奔跑”完全程所需的时间。设链路长度d，传播速度s，d<sub>prop</sub>=d/s  </p><p><strong>端到端的时延</strong><br>假设源主机和目的主机之间有N-1台路由器，并且该网络是<code>无拥塞</code>的。那么端到端时延为：d<sub>end-end</sub>=N(d<sub>proc</sub>+d<sub>trans</sub>+d<sub>prop</sub>)</p><p><strong>吞吐量</strong>是网络的发送和接收端传输数据的速率。</p><blockquote><p>瞬时吞吐量: 某个时间间隔内<br>平均吞吐量: 一段较长时间内<br>瓶颈链路: 约束着整个端到端的链路吞吐量</p></blockquote><p>因特网的实际情况: 主干网的速度很高，连接的瓶颈在于接入网。<br>当没有其他干扰流量时，吞吐量近似为沿着源和目的地之间路径的最小传输速率。</p><h2 id="1-5-协议层次和服务模型"><a href="#1-5-协议层次和服务模型" class="headerlink" title="1.5 协议层次和服务模型"></a>1.5 协议层次和服务模型</h2><p><strong>分层</strong>: 将复杂问题分成小问题，分而治之<br><strong>协议分层</strong>   </p><ol><li>应用层: 网络应用程序机器应用层协议留存的地方(HTTP/SMTP/FTP..) </li><li>运输层: 提供应用成端点之间传送应用层报文的服务(TCP/UDP)  </li><li>网络层: 将<code>数据报</code>的网络层分组从一台主机移动到另一台主机(IP协议/路由选择协议..)  </li><li>链路层: 将整个<code>帧</code>(链路层分组)从一个网络元素移动到临近的网络元素,一个数据报从源到目的地,可能经过不同链路上不同链路层协议处理, 提供的服务取决于应用于该链路的特定链路层协议.(以太网/WiFi/PPP)  </li><li>物理层: 将帧一个一个比特从一个节点移动到下一个节点</li></ol><blockquote><p>实际因特网协议栈比ISO/OSI参考模型少了两层协议: <code>会话层</code>(数据交换的定界和同步)和<code>表示层</code>(数据压缩/加密/描述),原因是这两层协议由开发者决定是否重要来进行设计。</p></blockquote><p><strong>封装</strong><br>在每一层，一个分组具有两种类型的字段: 首部字段喝有效载荷子段。有效载荷子段通常是来自上一层的分组。</p><p><img src="https://i.loli.net/2018/04/24/5adee3f813667.png" width="70%" height="70%"> </p><p><strong>TCP/IP协议族</strong></p><p><img src="https://i.loli.net/2018/04/24/5adea8a4111be.png" width="70%" height="70%"> </p><h2 id="1-6面对攻击的网络"><a href="#1-6面对攻击的网络" class="headerlink" title="1.6面对攻击的网络"></a>1.6面对攻击的网络</h2><p><strong>被放入计算机的有害程序</strong><br>恶意软件: 多数恶意软件是自我复制的。</p><blockquote><p>以病毒形式扩散: 需要某种形式的用户交互来感染用户设备的恶意软件<br>以蠕虫形势扩散: 无需任何明显用户交互就能进入设备的恶意软件</p></blockquote><p><strong>攻击服务器和网络基础设施</strong><br><code>拒绝服务攻击</code>(Denial-of-Service/DoS attack)<br>大多数因特网DOS攻击属于下列三种类型之一:</p><blockquote><p>弱点攻击<br>带宽洪泛<br>连接洪泛  </p></blockquote><p>相比于来自单一主机的Dos攻击，分布式DoS(Distributed DoS/DDoS)更加难以检测和防范。  </p><p><strong>嗅探分组</strong><br>在无线传输设备的附近放一台被动的接收机，该接受机就能得到传输的每个分组的副本。这些分组包含了各种敏感信息，包括口令和隐秘的个人信息等。  </p><blockquote><p>记录每个流经的分组副本的被动接受机称为<code>分组嗅探器</code><br>分组嗅探软件如Wireshark等可以对嗅探到的分组进行离线分析，就能得出敏感信息  </p></blockquote><p><strong>伪装用户</strong><br><code>IP哄骗</code>: 将具有虚假源地址的分组注入因特网的能力</p><blockquote><p>生成具有任意源地址、分组内容和目的地址的分组，接收方执行分组内容的命令(eg.修改转发表)。</p></blockquote><p><code>端点鉴别</code>: 一种使我们能够确信一个报文源自我们认为它应当来自的地方的机制</p><blockquote><p>在相互信任的用户之间的通信是一种例外而不是规则</p></blockquote><h2 id="1-7-计算机网络和因特网的历史"><a href="#1-7-计算机网络和因特网的历史" class="headerlink" title="1.7 计算机网络和因特网的历史"></a>1.7 计算机网络和因特网的历史</h2><p><strong>分组交换的发展: 1961～1972</strong><br><strong>专用网络和网络互联: 1972～1980</strong><br><strong>网络的激增: 1980～1990</strong><br><strong>因特网爆炸: 20世纪90年代</strong><br><strong>最新发展</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理笔记C08 数据库系统的设计</title>
      <link href="/sql08/"/>
      <url>/sql08/</url>
      
        <content type="html"><![CDATA[<h2 id="8-1-数据库系统设计概述"><a href="#8-1-数据库系统设计概述" class="headerlink" title="8.1 数据库系统设计概述"></a>8.1 数据库系统设计概述</h2><ol><li>需求分析阶段：需求收集和分析，得到<code>数据字典</code>和<code>数据流图</code>。</li><li>概念结构设计阶段：对用户需求综合、归纳与抽象，形成概念模型，用<code>E-R图</code>表示。</li><li>逻辑结构设计阶段：将概念结构转换为某个DBMS所支持的<code>关系模型</code>/<code>数据模型</code>，对关系模型进行优化。</li><li>物理设计阶段：根据具体计算机系统(DBMS和硬件)的特点，为<strong>给定的数据库模型</strong>确定合理的<code>存储结构</code>和<code>存取方法</code>，并对物理结构进行评价。</li><li>数据库实施阶段：建立数据库，编制与调试应用程序，组织数据入库，程序试运行。</li><li>数据库运行和维护阶段：数据库应用系统投入运行后，需要进行备份和维护，对于出现的问题需要不断调整和修改，直到满足用户需求。<a id="more"></a></li></ol><h2 id="8-2-系统需求分析"><a href="#8-2-系统需求分析" class="headerlink" title="8.2 系统需求分析"></a>8.2 系统需求分析</h2><h3 id="需求分析的必要性"><a href="#需求分析的必要性" class="headerlink" title="需求分析的必要性"></a>需求分析的必要性</h3><p>需求分析的重点是调查、收集与分析用户在数据管理中的信息要求、处理要求、安全性与完整性要求。</p><h3 id="需求分析的方法"><a href="#需求分析的方法" class="headerlink" title="需求分析的方法"></a>需求分析的方法</h3><ol><li>调查组织机构情况。了解组织部门的组成情况，各部门的职责等。</li><li>调查各部门的业务活动情况。包括了解各个部门输入和使用什么数据、如何加工处理这些数据、输出什么信息、输出到什么部门、输出结果的格式是什么等。</li><li>在熟悉业务活动的基础上，协助用户明确对新系统的各种要求。</li></ol><h3 id="数据流图和数据字典"><a href="#数据流图和数据字典" class="headerlink" title="数据流图和数据字典"></a>数据流图和数据字典</h3><p>需求分析阶段收集到的基础数据用数据字典和一组DFD表达，它们是下一步进行概念设计的基础。</p><h2 id="8-3-概念结构的设计"><a href="#8-3-概念结构的设计" class="headerlink" title="8.3 概念结构的设计"></a>8.3 概念结构的设计</h2><p>概念结构设计的任务是在需求分析阶段产生的需求说明书的基础上，按照特定的方法，将其抽象为一个不依赖于任何具体机器的数据模型，即概念模型。概念模型又称概念结构，它可用 E-R图进行描述。</p><blockquote><p>目前还没确定数据库的类型(eg. 关系数据库..etc)</p></blockquote><h3 id="概念模型的特点、设计方法和步骤"><a href="#概念模型的特点、设计方法和步骤" class="headerlink" title="概念模型的特点、设计方法和步骤"></a>概念模型的特点、设计方法和步骤</h3><ul><li><p>概念模型的特点：</p><ul><li>能真实和充分反映现实设计；</li><li>能满足用户对数据处理的需求；</li><li>易于被用户理解，用户才可参与到数据库设计中；</li><li>易于更改，以满足用户需求的修改和扩充；易于向数据模型转换。</li></ul></li><li><p>概念模型的设计方法：</p><ul><li>自顶向下方法</li><li>自定向上方法</li><li>逐步扩张方法</li><li>混合策略方法 </li></ul></li></ul><h3 id="数据抽象与局部视图设计"><a href="#数据抽象与局部视图设计" class="headerlink" title="数据抽象与局部视图设计"></a>数据抽象与局部视图设计</h3><ul><li>数据抽象的三种方法<ul><li>分类</li><li>聚集</li><li>概括</li></ul></li><li>局部视图的设计<ul><li>明确局部应用的范围</li><li>设计分E-R图</li><li>确定实体之间的联系，产生局部模型</li></ul></li></ul><h3 id="视图的集成"><a href="#视图的集成" class="headerlink" title="视图的集成"></a>视图的集成</h3><ul><li>合并分E-R图，生成初步E-R图：分E-R图间的冲突主要由属性冲突、命名冲突和结构重提三种。</li><li>消除不必要的冗余，设计基本E-R图：用分析方法消除冗余；用规范化理论消除冗余。</li></ul><h2 id="8-4-数据库逻辑结构的设计"><a href="#8-4-数据库逻辑结构的设计" class="headerlink" title="8.4 数据库逻辑结构的设计"></a>8.4 数据库逻辑结构的设计</h2><p>数据库逻辑结构设计的主要任务：将概念模型转换为某一DBMS所支持的数据类型</p><p>###逻辑结构设计过程</p><ul><li>选择最合适的数据模型，并按转换规则将概念模型转换为选定的数据模型</li><li>从支持这种数据模型的DBMS中选出最佳的DBMS，并根据选定DBMS的特点和限制对数据模型进行优化</li><li>通过优化方法将其转换为优化的数据模型</li></ul><p>###概念模型转换为关系模型<br><strong>实体集的转换规则</strong><br>一个实体集转换为关系模型中的一个关系，实体的属性就是关系的属性，实体的标识符就是关系的键，关系的结果就是关系模式。  </p><p><strong>实体集间联系的转换规则</strong>   </p><ul><li>1 : 1 联系的转换方法 <ul><li>将一个 1 : 1 联系转换为一个独立的关系：与该联系相连的各实体集的键以及联系本身的属性转换为关系，且<strong>每个实体的键</strong>均是该关系的候选键。</li><li>将一个 1 : 1 联系与<strong>任意一端</strong>实体集所对应的关系合并：在被合并关系中增加属性，新增的属性为联系本身的属性和联系相关的另一个实体集的键。</li></ul></li><li>1 : n 联系的转换方法 <ul><li>将一个 1 : n 联系转换为一个独立的关系：与该联系相连的各实体集的键以及联系本身的属性转换为关系，且该关系的键为 <strong>n 端实体的键</strong>。</li><li>将一个 1 : n联系与 <strong>n 端</strong>实体集所对应的关系合并：在n端实体集增加新属性，新属性由联系对应的 1 端实体集的键和联系自身的属性构成，新增属性后原关系的键不变。</li></ul></li><li>m : n 联系的转换方法<ul><li>将一个 m : n 联系转换为一个关系：与该联系相连的各实体集的键以及联系本身的属性转换为关系的属性，新关系的键为两个相连实体键的组合。(<strong>该键为多属性构成的组合键</strong>)</li></ul></li></ul><h2 id="8-5-数据库物理结构的设计"><a href="#8-5-数据库物理结构的设计" class="headerlink" title="8.5 数据库物理结构的设计"></a>8.5 数据库物理结构的设计</h2><p>物理设计阶段：根据具体计算机系统(DBMS和硬件)的特点，为<strong>给定的数据库模型</strong>确定合理的<code>存储结构</code>和<code>存取方法</code>，并对物理结构进行评价。希望设计的物理数据库结构能够满足<strong>事务在数据库上</strong>：</p><ul><li>运行相应时间少</li><li>存储空间利用率高</li><li>事务吞吐量大</li></ul><p><strong>确定关系模式的存取方法</strong>：1.索引法 2.聚簇法<br><strong>确定关系模式的存储结构</strong>：确定数据的存放位置和结构。(启发性规则P257)</p><p><strong>评价物理结构</strong>：物理设计过程中需要对时间效率、空间效率、维护代价和各种用户要求进行权衡。评价方法<strong>完全依赖于所用的DBMS</strong>，主要从定量估算各种方案的存储结构、存储时间和维护代价入手，对估算结果进行权衡比较，取一个较优合理的物理结构。根据用户需求修改设计。</p><h2 id="8-6-数据库的实施和维护"><a href="#8-6-数据库的实施和维护" class="headerlink" title="8.6 数据库的实施和维护"></a>8.6 数据库的实施和维护</h2><h3 id="数据库的实施"><a href="#数据库的实施" class="headerlink" title="数据库的实施"></a>数据库的实施</h3><p>数据库的实施阶段任务：</p><ul><li>设计人员用DBMS提供的数据定义(DDL)语言和其他使用程序将数据库逻辑设计和物理设计结果严格描述出来，使数据模型成为DBMS可以接受的源代码</li><li>经过调试产生目标模式，完成建立定义数据库结构的工作</li><li><strong>组织数据入库</strong>，并运行应用程序进行调试</li></ul><blockquote><p>相当于软件工程中代码编写和调试的阶段<br>组织数据入是数据库实施阶段最主要的工作：手工逐条录入、数据录入子系统</p></blockquote><h3 id="数据库的试运行"><a href="#数据库的试运行" class="headerlink" title="数据库的试运行"></a>数据库的试运行</h3><ul><li>实际运行数据库应用程序，执行对数据库的各项操作，测试<strong>应用程序功能</strong>是否满足要求</li><li>测试系统的<strong>性能指标</strong>，分析是否符合设计目标</li></ul><blockquote><p>注意：(1)数据库的试运行操作应<strong>分步进行</strong> (2)数据库的实施和调试不可能一次完成</p></blockquote><h3 id="数据库的运行和维护"><a href="#数据库的运行和维护" class="headerlink" title="数据库的运行和维护"></a>数据库的运行和维护</h3><p>数据库的维护工作主要包括以下几方面：</p><ul><li>数据库的转储和恢复</li><li>对数据库的安全性和完整性进行控制</li><li>对数据库的性能进行监督、分析和改造</li><li>对数据库进行<strong>(部分)重组织和重构造</strong>(数据库运行一段时间后，由于记录不断增删改会使数据库的物理存储情况变坏)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理笔记C06 数据库保护</title>
      <link href="/sql06/"/>
      <url>/sql06/</url>
      
        <content type="html"><![CDATA[<h2 id="6-1-数据库完整性"><a href="#6-1-数据库完整性" class="headerlink" title="6.1 数据库完整性"></a>6.1 数据库完整性</h2><p>数据库的完整性是指保护数据库中数据的<strong>正确性</strong>、<strong>有效性</strong>和<strong>相容性</strong>，防止不合语义的数据进入数据库。</p><ul><li>正确性：数据的合法性。如年龄属于数值型数字，不能含字母或特殊字符。</li><li><p>相容性：表示同一事实的两个数据应相同，不一致就是不相容。如一个学生不能有两个学号。</p><a id="more"></a><p>数据库的完整性是有DBMS的完整性子系统实现的。完整性子系统的主要功能主要有以下两点：</p></li><li><p>监督事务(特别是更新事务)的执行，并测试是否违反完整性约束。</p></li><li>若有违反现象，则采取恰当的动作。(拒绝/报告违反情况/改正错误)</li></ul><h3 id="完整性规则"><a href="#完整性规则" class="headerlink" title="完整性规则"></a>完整性规则</h3><p>完整性规则用来检察数据库中的数据是否满足约束。主要由以下三个部分构成：</p><ul><li>触发条件</li><li>约束条件</li><li>违约响应</li></ul><p>在执行时间上可以分为立即执行约束和延迟执行约束。</p><ul><li>立即执行约束：在执行用户事务过程中，某一条语句执行完成后，系统立即进行完整性约束条件检查。若违背立即执行约束，则拒接该操作。</li><li>延迟执行约束：在整个事务执行结束后再对约束条件进行完整性检查，结果正确才能提交。若违背延迟执行约束，又不知道是哪个事务的操作破坏了完整性，则只能拒接整个事务，把数据库恢复到该事务执行前的状态。</li></ul><h3 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h3><ul><li>主键约束：要求表中所有元组都应该有一个唯一的标识符。体现了实体完整性。</li><li>外键约束：涉及的事一个表中的数据如何与另一个表中的数据相联系。体现了参照完整性。</li></ul><blockquote><ul><li>外键是否接受空值问题P157</li><li>在被参照关系中删除元组问题：级联删除、受限删除、置空值删除。<ul><li>级联删除：将参照关系中所有外键与被参照关系中被删除元组主键相同的元组一起删除。</li><li>受限删除：仅当参照关系中没有任何元组的外键与被参照关系中要删除元组的主键相同时才执行删除操作，否则拒绝执行。</li><li>置空值删除：若要删除被参照关系的元组，将参照关系中与被参照关系中被删除元组主键值相等的外键值置为空值。</li></ul></li></ul></blockquote><ul><li>属性约束：属性约束体现用户定义的完整性。属性约束主要限制某一属性的取值范围，可以分为以下几类：</li></ul><blockquote><ul><li>非空值约束</li><li>唯一值约束</li><li>基于属性的check约束</li></ul></blockquote><ul><li>域约束：域是某一列值可能取值的集合。SQL支持域的概念，用户可以定义域给定他的名字</li><li>断言约束：SQL支持断言的创建，断言是不与任何一个表相联系。</li></ul><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>我们希望在某个操作后，系统能自动根据条件转去执行某种操作，甚至执行与原操作无关的操作，则可以采用触发器机制实现。<br><code>触发器</code>：由事件、条件和动作三部分组成。</p><blockquote><ul><li>事件：对数据库的插入、删除、修改等操作。触发器在这些事件发生时，将开始工作。</li><li>条件：触发器将测试条件是否成立。如果成立则执行相应动作，否则什么也不做。</li><li>动作：如果触发器满足预定的条件，DBMS执行这些动作。</li></ul></blockquote><p>SQL中使用触发器的优点：</p><ol><li>触发器是自动的</li><li>触发器可以实现数据库中相关表的级联修改</li><li>实现比check约束定义的限制更复杂的限制。(与check约束的不同点：触发器可以引用其他表中的列)</li><li>比较数据库修改前后的数据状态。</li><li>维护非规范化数据。非规范数据通常指在表中派生的、冗余的数据值。可以使用触发器保证非规范数据库中的低级数据的完整性。P162</li></ol><h2 id="6-2数据库的安全性"><a href="#6-2数据库的安全性" class="headerlink" title="6.2数据库的安全性"></a>6.2数据库的安全性</h2><h3 id="安全性概述"><a href="#安全性概述" class="headerlink" title="安全性概述"></a>安全性概述</h3><p>数据库安全性：保护数据库，以防止非法使用所造成的数据泄漏、更改或破坏。</p><blockquote><ul><li>数据库的安全性和计算机的安全性是紧密联系和相互支持的。  </li><li>需要从以下几个层次采取相应的安全性措施：物理层、操作系统层、网络层、人员层、数据库系统层。</li><li>此处讨论的安全性是数据库系统层的安全性问题。</li></ul></blockquote><p><code>安全控制模型</code> P172 图6.4</p><h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><p>身份认证是系统提供的<strong>最外层</strong>安全保护措施，由系统提供一定的方法让用户标识自己的名字和身份。每次用户要求进入系统时，由系统进行核对，通过鉴定后才能获得机器的使用权。</p><blockquote><ul><li>用户名加口令</li><li>生物特征识别技术</li><li>基于USB Key的身份认证方法</li></ul></blockquote><h3 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h3><p>数据库安全最重要的一点就是确保只授权给有资格的用户访问数据库的权限，同时令所有未被授权的人员无法接近数据。数据库管理员必须能够为不同用户授予不同的数据库使用权。<br>主要包括以下两个方面：</p><ul><li>定义用户权限</li><li>检查存取权限</li></ul><p>DBMS主要提供两种方法来控制用户对数据的访问：自主存取控制和强制存取控制。</p><h3 id="自主存取控制"><a href="#自主存取控制" class="headerlink" title="自主存取控制"></a>自主存取控制</h3><ul><li>基于存取权限。用户对于不同的对象有不同的存取权限，不同的用户对同一对象也有不同的权限。</li><li>存在问题：A用户将自己所管理的部分数据的查看权限赋予B用户，其本意是只让B用户本人查看这些数据，但B用户一旦能够查看这些数据，就能对数据进行备份并<strong>获得自身权限内的副本</strong>，就能不征得A用户同意传播数据副本。</li><li>该机制仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记。</li></ul><h3 id="强制存取控制"><a href="#强制存取控制" class="headerlink" title="强制存取控制"></a>强制存取控制</h3><ul><li>基于系统策略。它不能由单个用户改变。</li><li>每一个数据库对象都被赋予一个安全级别，每个安全级别用户都被赋予一个许可证，并且一组规则会强加在用户要读写的数据库对象上。</li><li>对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体。</li><li>解决了自主存取控制存在的问题。</li></ul><h3 id="建立视图"><a href="#建立视图" class="headerlink" title="建立视图"></a>建立视图</h3><ul><li>视图可以隐藏用户不需要看见的数据。</li><li>视图隐藏数据的能力既可以简化系统的使用，又可以用于实现安全性。</li><li>通过视图机制可以将访问限制在基本表的子集内、列的子集内、符合多个基本表连接的行内…</li></ul><h3 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h3><ul><li>根据一定的算法将原始的数据变换为不可识别的格式，从而使得不知道解密算法的人无法获知数据的内容</li><li>数据加密标准DES是一种著名的对成加密方法。必须把密钥通过某种安全机制提供给授权用户，<strong>增大了密钥被窃取的概率</strong>。</li><li>RSA算法：一种著名的公共密钥加密方法。每个人都有一个公共密钥和私有密钥。所有人都知道公共密钥，但私有密钥只有自己知道。<strong>很安全，但计算代价很高</strong></li></ul><h3 id="审计跟踪"><a href="#审计跟踪" class="headerlink" title="审计跟踪"></a>审计跟踪</h3><ul><li>审计功能是一种监视措施，跟踪记录有关数据的访问活动。</li><li>对于某些高明感的保密数据，必须以审计作为预防手段。</li><li>通过审计功能，凡是与数据库安全性相关的操作均可被记录在<strong>审计日志</strong>中<ul><li>审计加强了数据的安全性</li><li>使用审计功能会大大增加系统的开销。DBMS通常将其作为可选特征。</li></ul></li></ul><h2 id="6-3-事务"><a href="#6-3-事务" class="headerlink" title="6.3 事务"></a>6.3 事务</h2><h3 id="事务的基本概念"><a href="#事务的基本概念" class="headerlink" title="事务的基本概念"></a>事务的基本概念</h3><p>事务是用户定义的数据库操作序列，这些操作是一个不可分割的<code>工作单元</code>。一个事务至少包含一条SQL语句，多条SQL语句可以组合在一起作为单个事务执行。事务是并发控制的基本单位。</p><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><ul><li>原子性：事务是数据库的逻辑工作单位。事务的所有操作在数据库中要么做，要么都不做。</li><li>一致性：事务单独执行时(没有和其他事务并发执行的情况下)，保持数据库的一致性。即，事务执行的结果必须是使数据库从一个一致性状态变成另一个一致性状态。</li><li>隔离性：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的事务之间不能互相干扰。</li><li>持久性：一个事务一旦提交成功，它对数据库中的数据的改变应该是永久的，即使是系统出现故障时也是如此。</li></ul><blockquote><ul><li>数据库的一致性：每个事务看到的都是一致的数据库实例。  </li><li>原子性、一致性、隔离线和持续性这4个特性也简称ACID特性。 </li><li>原子性是保证数据库一致性的前提，隔离性和原子性相互依存，持续性则是保证事务正确执行的必然要求。</li></ul></blockquote><h2 id="6-4-并发控制-多用户"><a href="#6-4-并发控制-多用户" class="headerlink" title="6.4 并发控制(多用户)"></a>6.4 并发控制(多用户)</h2><p>多用户并行地存取数据库系统，就会发生多个用户<strong>并发地存取同一数据</strong>的情况。如果对这些并发操作不加以控制，就会发生多个用户并发地存取同一数据的情况，<strong>破坏数据的一致性</strong>。</p><h3 id="事务的并发执行"><a href="#事务的并发执行" class="headerlink" title="事务的并发执行"></a>事务的并发执行</h3><p>事务可以一个一个串行执行，但是系统资源利用率很低。为了充分利用系统资源，发挥数据库共享资源的特点，事务处理系统应该允许多个事务并发执行，优点如下：</p><ol><li>提高吞吐量和资源利用率 </li><li>减少等待时间</li></ol><h3 id="并发操作与数据的不一致性"><a href="#并发操作与数据的不一致性" class="headerlink" title="并发操作与数据的不一致性"></a>并发操作与数据的不一致性</h3><p><strong>1. 丢失更新</strong>：当两个事务T<sub>1</sub>和T<sub>2</sub>读入同一数据并修改，并发执行时，T<sub>2</sub>提交的结果破坏了T<sub>1</sub>提交的结果。即，两个事务T<sub>1</sub>和T<sub>2</sub>读入同一数据并修改，T<sub>2</sub>提交的结果破坏了T<sub>1</sub>提交的结果，导致T<sub>3</sub>的修改被丢失。  </p><p><strong>2. 不可重复读</strong>：事务T<sub>1</sub>读取数据后，事务T<sub>2</sub>执行更新操作，使T<sub>1</sub>无法再现前一次读取结果。  </p><blockquote><ul><li>事务T<sub>1</sub>读取数据对象A，并仍在运行，事务T<sub>2</sub>执行更新操作，使T<sub>1</sub>无法再重复前一次的结果。</li><li>事务T<sub>1</sub>按一定条件从数据库中读取了某些记录后，事务T<sub>2</sub>删除了其中部分记录，使T<sub>1</sub>再次按照相同条件读取数据时，发现某记录不见了。(幻影现象)</li><li>事务T<sub>1</sub>按一定条件从数据库中读取了某些记录后，事务T<sub>2</sub>插入了一些记录，使T<sub>1</sub>再次按照相同条件读取数据时，发现多了一些记录。(幻影现象)</li></ul></blockquote><p><strong>3. 读“脏”数据</strong>：事务T<sub>1</sub>修改某一数据，并将其写回磁盘，事务T<sub>2</sub>读取同一数据后，T<sub>1</sub>由于某种原因被撤消，这时T<sub>1</sub>已修改过的数据恢复原值，T<sub>2</sub>读到的数据就与数据库中的数据不一致，则T<sub>2</sub>读到的数据就为”脏”数据，与数据库中的数据不一致。  </p><h3 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h3><p>实现并发控制的主要方法有两种：封锁技术和时标技术。此处只介绍封锁技术。<br><code>封锁</code>：事务T在对某个数据对象(如数据库、表、记录等)操作之前，首先向系统发出<code>加锁请求</code>以便获得对数据对象相应的控制；<br>在事务T<code>释放它所获得的锁</code>之前，其他事务不能更新此数据对象。</p><p><strong>1. 封锁类型</strong></p><ul><li>排它锁（写锁/独占锁）：若事务T对数据对象A加上X锁/排他锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。</li><li>共享锁（读锁）：若事务T对数据对象A加上S锁/共享锁，则事务T可以读A但不能修改A，其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。</li></ul><p>(P118 表6.4)：排他锁不相容，共享锁是相容的。任何时候，一个数据项上的共享锁可以同时被多个不同的事务拥有。如果一个事务申请一个数据项的排他锁，它必须等待该数据项上的所有锁被释放。</p><p><strong>2. 封锁协议</strong></p><ul><li>一级封锁协议：事务T在修改数据R之前必须先对其加X锁，<strong>直至事务结束</strong>。</li><li>二级封锁协议：在一级封锁协议的基础上，再加上事务T在对数据A进行读操作之前必须先对A加S锁，<strong>读完后立即释放</strong>S锁。</li><li>三级封锁协议：在一级封锁协议的基础上，再加上事务T在对数据A进行读操作之前必须先对A加S锁，<strong>直到事务结束才能释放</strong>加在A上的S锁。</li></ul><table><thead><tr><th></th><th>一级封锁协议</th><th>二级封锁协议</th><th>三级封锁协议</th></tr></thead><tbody><tr><td>丢失更新</td><td>&radic;</td><td>&radic;</td><td>&radic;</td></tr><tr><td>不可重复读</td><td>&times;</td><td>&times;</td><td>&radic;</td></tr><tr><td>读“脏”数据</td><td>&times;</td><td>&radic;</td><td>&radic;</td></tr></tbody></table><p><strong>3. 封锁粒度</strong></p><p>封锁对象的大小称为封锁粒度。封锁对象可以是这样一些逻辑单元：属性值、属性值的集合、元组、关系、索引项、整个索引项直至整个数据库等。<br>在实际应用中，选择封锁粒度时应同时考虑封锁机构和并发度两个因素，对系统开销进行权衡，以求得最优的效果。</p><table><thead><tr><th></th><th>封锁力度越小</th><th>封锁力度越大</th></tr></thead><tbody><tr><td>被封锁的对象</td><td>越多</td><td>越小</td></tr><tr><td>并发度</td><td>越大</td><td>越小</td></tr><tr><td>系统开销</td><td>越大</td><td>越小</td></tr></tbody></table><p><strong>4. 死锁和活锁</strong>P 191<br><code>活锁</code>：系统可能使某个事务永远处于等待状态，得不到封锁的机会。最简单的解决方法时先到先服务策略。<br><code>死锁</code>：系统中有两个或两个以上的事务都处于等待状态，并且每一个事务都在等待其中另一个事务解除封锁，它才能继续执行下去，结果造成任何一个事务都无法继续执行。  </p><blockquote><p>解决死锁的两种方法：死锁预防、死锁的诊断与解除</p></blockquote><p>死锁预防：</p><table><thead><tr><th></th><th>一次封锁法</th><th>顺序封锁法</th></tr></thead><tbody><tr><td>定义</td><td>要求每个事务必须一次将所有要使用的数据全部依次加锁，并要求加锁成功。否则就不能继续执行。</td><td>预先对所有可能加锁的数据对象规定一个加锁顺序，所有事务都按这个顺序实行加锁，释放时逆序。</td></tr><tr><td>问题</td><td>一次就将以后要用到的全部数据加锁，扩大了封锁的范围，从而降低了系统的并发度。</td><td>事务的封锁请求可以随着事务的执行而动态地决定，很难事先封锁对象，从而更难确定封锁顺序。</td></tr></tbody></table><p>死锁的诊断与解除：预防死锁常要付出很高的代价。一般情况下，在数据库系统中，可以允许发生死锁，在死锁发生后可以自动诊断并解除死锁。</p><blockquote><ul><li>等待图法P193：事务等待图动态地反映了<strong>所有事务的等待情况</strong>。并发控制子系统<strong>周期性地</strong>（比如每隔1分钟）检测事务等待图，如果发现<strong>图中存在回路</strong>，则表示系统中出现了死锁。</li><li>如果发生死锁，那么只能选取某个事务作为牺牲品，把它撤销，<strong>做回退操作</strong>解除它所有的封锁，恢复到该事务的初始状态。</li><li>通常采用的方法之一是选择一个<strong>处理死锁代价最小</strong>的事务，将其撤销。不重要的用户，取消其操作，释放封锁的数据，恢复对数据库所做的改变。</li></ul></blockquote><h3 id="事务调度与可串行化"><a href="#事务调度与可串行化" class="headerlink" title="事务调度与可串行化"></a>事务调度与可串行化</h3><p><strong>1. 事务的调度</strong>  </p><ul><li>事务的串行调度：多个事务依次执行</li><li>事务的并发/并行调度：利用分时的方法同时处理多个事务</li></ul><p><strong>2. 可串行化的调度</strong>  </p><ul><li>事务的并发执行可能导致不正确的运行结果。假设事务的执行是正确的，则串行调度一定能产生正确的运行结果。    </li><li>如果一个并发调度的执行结果与某一串行调度的执行结果等价，那么这个并发调度称为“<code>可串行化的调度</code>”。    </li><li>我们把可串行化的调度当作唯一能够<code>保证并发操作正确性</code>的调度策略。  </li><li>应当谨慎地使用锁(P195)：<ul><li>如果为了获得最大的并行性而过早地释放数据项的锁，就有可能进入不一致的皇台。</li><li>在申请其他锁之前不尽量地释放已有的锁，则可能导致死锁。</li></ul></li></ul><h3 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h3><p><code>两段锁协议</code>：所有事务必须分为两个阶段对数据项加锁和解锁。</p><ul><li>加锁阶段：在对任何数据进行读、写操作之前，事务首先要申请并获得对该数据的封锁。(事务开始运行后进入加锁阶段，申请获得<code>所需要的所有锁</code>)</li><li>解锁阶段：在释放一个封锁之后，事务不再申请和获得任何其他封锁。事务结束时，其所有用的所有锁都将释放。(即进入解锁阶段的事务不能再申请任何锁)</li></ul><ol><li>两段锁协议是可串行化调度的<strong>充分条件</strong>，但不是必要条件。</li><li>一次封锁发遵守两段锁协议，但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁。</li><li>两段锁协议可以保证并发事务的正确性，但可能发生死锁。</li></ol><h2 id="6-5-数据库的恢复"><a href="#6-5-数据库的恢复" class="headerlink" title="6.5 数据库的恢复"></a>6.5 数据库的恢复</h2><h3 id="故障的种类"><a href="#故障的种类" class="headerlink" title="故障的种类"></a>故障的种类</h3><ul><li>事务故障<br>（1）逻辑错误。事务由于某些<strong>内部条件</strong>而无法继续正常执行，如非法输入、找不到数据、运算溢出或超出资源限制。<br>（2）系统错误。系统进入一种不良状态(如死锁)，结果事务无法继续正常执行。</li><li>系统故障/软故障：引起系统停止运转随之要求重新启动的事件称为“系统故障”。P199</li><li>介质故障／硬故障：指外存故障，系统在运行过程中，由于某种硬件故障，如磁盘损坏、磁 头碰撞或由于操作系统的某种潜在的错误、瞬时磁场干扰，<strong>使存储在外存上的数据部分损失或全部损失</strong>。 </li><li>计算机病毒</li></ul><h3 id="故障恢复技术"><a href="#故障恢复技术" class="headerlink" title="故障恢复技术"></a>故障恢复技术</h3><ul><li>数据转储/数据备份：是指DBA定期将整个数据库复制到磁带或另一个磁盘上保存起来的过程。转储十分耗费时间和资源，不能频繁进行。从转储状态上，转储可分为静态转储和动态转储两种。P201</li><li>日志文件：系统运行时，数据库与事务状态都在不断交化，为了在故障发生后能恢复系统的正常状态，必须在系统正常运行时随时记录下它们的变化情况，这种记录数据库的更新操作的文件称为日志文件。</li></ul><blockquote><ul><li>利用日志，系统可以解决任何不造城非易失性存储器上的信息丢失的故障。故障发生时对已经提交的事务进行重做(REDO)处理，对未完成的事务进行撤销(UNDO)处理。</li><li>UNDO(T)将事务T所更新的所有数据项的值恢复成旧值。</li><li>REDO(T)将事务T所更新的所有数据项的值置为新值。(新值和旧值均可在日志中找到)</li></ul></blockquote><h3 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h3><p>系统出现故障时恢复子系统将根据事务的不同状态采取不同的恢复策略。一般DBMS产品自动实行检查点操作，无需人工干预。</p><h3 id="事务故障恢复"><a href="#事务故障恢复" class="headerlink" title="事务故障恢复"></a>事务故障恢复</h3><h3 id="系统与介质故障恢复"><a href="#系统与介质故障恢复" class="headerlink" title="系统与介质故障恢复"></a>系统与介质故障恢复</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理笔记C07 关系数据库理论</title>
      <link href="/sql07/"/>
      <url>/sql07/</url>
      
        <content type="html"><![CDATA[<h2 id="7-1-关系模式规范化的必要性"><a href="#7-1-关系模式规范化的必要性" class="headerlink" title="7.1 关系模式规范化的必要性"></a>7.1 关系模式规范化的必要性</h2><p>数据冗余一直是影响系统性能的大问题。“分解”是解决冗余的主要办法。<br>(1) 冗余存储<br>(2) 更新异常：重复信息的一个副本修改时，所有副本必须进行同样修改，否则造成不一致。<br>(3) 插入异常：只有当一些信息事先已经存储在数据库中时，另一些信息才能存入到数据库中。<br>(4) 删除异常：在删除某些信息时可能丢失其他信息。<br> <a id="more"></a></p><h2 id="7-2-函数依赖"><a href="#7-2-函数依赖" class="headerlink" title="7.2 函数依赖"></a>7.2 函数依赖</h2><p>关系模式中的各个属性之间相互联系、相互制约的联系称为数据依赖。数据依赖一般分为函数依赖、多值依赖和连接依赖。</p><h3 id="1-函数依赖的定义"><a href="#1-函数依赖的定义" class="headerlink" title="1. 函数依赖的定义"></a>1. 函数依赖的定义</h3><p>设R(U)是属性集U上的关系模式。X，Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称<strong>X函数确定Y</strong>或<strong>Y函数依赖于X</strong>，记作<strong>X → Y</strong>。 </p><h3 id="2-函数依赖的分类P217"><a href="#2-函数依赖的分类P217" class="headerlink" title="2. 函数依赖的分类P217"></a>2. 函数依赖的分类P217</h3><p> ”如果 Y&sube;X&sube;U， 则 X→Y。“称为平凡依赖。否则称为非平凡依赖，若无特别声明，我们总是讨论非平凡依赖。</p><ul><li>完全函数依赖：在关系模式R(U)中，X，Y是U的子集，X’是X的真子集，存在X→Y，但对<strong>每一个</strong>X’都有X’!→Y，则称Y完全函数依赖于X。</li><li>部分函数依赖：在关系模式R(U)中，X，Y是U的子集，存在X→Y，若X’是X的真子集，<strong>存在</strong>X’→Y，则称Y部分函数依赖于X。</li><li>传递函数依赖：在关系模式R(U)中，X，Y，Z是U的子集，存在X→Y(Y∉X)，Y !→X，Y→Z，则有X→Z，称Z传递函数依赖于X。</li></ul><blockquote><p>在此加上条件Y!→X，是因为如果X→Y，Y→X，则X↔Y，实际上就是X直接函数依赖于Z，而不是传递函数依赖。</p></blockquote><h3 id="3-函数依赖和键的联系"><a href="#3-函数依赖和键的联系" class="headerlink" title="3. 函数依赖和键的联系"></a>3. 函数依赖和键的联系</h3><p>函数依赖是键的推广</p><ul><li>设关系模式R的属性集是U，K为U的一个子集。如果K→U在R上成立，则称K为R的一个超键。</li><li>如果K→U在R上成立，但对于K的任一真子集K’都有K’→U不成立，那么称K是R上的一个候选键。</li><li>关系模式R中的属性或属性组X并非R的主键，但X是另外一个关系模式S的主键，则称X是R的外键。</li></ul><h3 id="4-函数依赖的逻辑蕴含"><a href="#4-函数依赖的逻辑蕴含" class="headerlink" title="4. 函数依赖的逻辑蕴含"></a>4. 函数依赖的逻辑蕴含</h3><p>仅仅考虑函数依赖集是不够的，需要考虑模式上成立的锁于函数依赖。对于给定的函数依赖集F，可以推导出其他一些未知的函数依赖，称这些函数依赖被F“逻辑蕴含”。  </p><blockquote><p>设F是在关系模式R上成立的函数依赖的集合，X→Y是一个函数依赖。如果对于R的每个满足F的关系r也满足X→Y(即r中的任意两个元组t，s，若t<sub>1</sub>[X]=t<sub>2</sub>[X]，则t<sub>1</sub>[Y]=t<sub>2</sub>[Y])，则称F逻辑蕴含X→Y。</p></blockquote><h3 id="5-函数依赖的推理规则"><a href="#5-函数依赖的推理规则" class="headerlink" title="5. 函数依赖的推理规则"></a>5. 函数依赖的推理规则</h3><ul><li><p>阿姆斯特朗公理</p><ul><li>自反律/包含规则: 如果 Y&sube;X&sube;U， 则 X→Y。(X→Y 是平凡依赖)</li><li>增广律: 如果 X → Y， 且Z&sube;X，则 XZ → YZ。</li><li>传递率: 如果 X → Y 且 Y → Z, 则 X → Z</li></ul></li><li><p>阿姆斯特朗公理的推理</p><ul><li>合并规则: 如果 X→Y 且 X→Z, 那么 X→YZ.</li><li>分解规则: 如果 X → YZ,且 X → Y 且 X → Z.</li><li>伪传递: 如果 X→Y 且 WY→Z, 那么 XW → Z.</li><li>集合累积规则: 如果 X → YZ 且 Z→W, 那么 X → YZW. </li></ul></li><li>阿姆斯特朗公理是有效的和完备的<ul><li>有效性：在F中根据阿姆斯特朗公理推导出的每一个函数议定为F所逻辑蕴含。</li><li>完备性：F所逻辑蕴含的每一个函数，必定可以可以由F出发根据阿姆斯特朗公理推导出来。</li></ul></li></ul><h3 id="6-函数依赖集的闭包和属性集的闭包-概念，不考怎么计算F的闭包"><a href="#6-函数依赖集的闭包和属性集的闭包-概念，不考怎么计算F的闭包" class="headerlink" title="6. 函数依赖集的闭包和属性集的闭包(概念，不考怎么计算F的闭包)"></a>6. 函数依赖集的闭包和属性集的闭包(概念，不考怎么计算F的闭包)</h3><ul><li>函数依赖集的闭包：F是函数依赖集，F的闭包(closure)是指被F逻辑蕴涵的所有函数依赖的集合，记做F <sup>+</sup> 。</li><li>属性集的闭包：设F为属性集U上的一组函数依赖，X是U的子集，那么属性集X的闭包用X <sup>+</sup> 表示，它是一个从函数依赖集使用FD(函数依赖)推理规则推出的所有满足X→A的属性A的集合：<br>X <sup>+</sup> = { A | X → A 在 F <sup>+</sup> 中} </li></ul><h3 id="7-函数依赖的最小依赖集"><a href="#7-函数依赖的最小依赖集" class="headerlink" title="7. 函数依赖的最小依赖集"></a>7. 函数依赖的最小依赖集</h3><ul><li>如果G <sup>+</sup> = F <sup>+</sup>，就说函数依赖集F覆盖G(F是G的覆盖，G是F的覆盖)，F与G等价。</li><li>如果函数依赖集F满足以下条件，则称F为最小函数依赖集或最小覆盖。<ul><li>F中任一函数依赖的右部仅含一个属性。</li><li>F中不存在这样的函数依赖X → A，使得 F与F -｛X → A｝等价。</li><li>F中不存在这样的函数依赖 X → A，X有真子集 Z 使得 F-｛ X → A｝ ∪ ｛ Z → A｝与 F等价。(左边没有多余)</li></ul></li></ul><blockquote><p>每个依赖都尽可能的小，左边的属性没有多余，右边为单属性，且其中的每个依赖都是必要的。</p></blockquote><h2 id="7-3-关系模式的分解"><a href="#7-3-关系模式的分解" class="headerlink" title="7.3 关系模式的分解"></a>7.3 关系模式的分解</h2><h3 id="模式分解的规则"><a href="#模式分解的规则" class="headerlink" title="模式分解的规则"></a>模式分解的规则</h3><p>设关系模式R(U)，R<sub>1</sub>, R<sub>2</sub>…, R<sub>k</sub>都是R的子集(这里把关系模式看成是属性的集合)，R＝R<sub>1</sub> ∪ R<sub>2</sub> ∪ … ∪ R<sub>k</sub>，关系模式R<sub>1</sub>, R<sub>2</sub>…, R<sub>k</sub>的集合用ρ表示，ρ={R<sub>1</sub>, R<sub>2</sub>…, R<sub>k</sub>}。用ρ代替R的过程称为关系模式的分解。这里称为R的一个分解，也成为数据库模式。</p><h3 id="无损连接分解"><a href="#无损连接分解" class="headerlink" title="无损连接分解"></a>无损连接分解</h3><p>设R是一个关系模式，F是R上的一个函数依赖集合。R的一个分解是一个关系集合ρ={R<sub>1</sub>, R<sub>2</sub>…, R<sub>k</sub>}，如果对R中满足F的每一个关系r，有：r = π<sub>R<sub>1</sub></sub>(r) ⋈ π<sub>R<sub>2</sub></sub>(r) ⋈ … ⋈  π<sub>R<sub>k</sub></sub>(r)，那么称分解ρ相当于F是<code>无损连接分解</code>；否则，称为<code>有损连接分解</code>。</p><blockquote><p>其中 π<sub>R<sub>i</sub></sub>(r) 表示关系 r 在模式 R<sub>i</sub> 属性上的投影。</p></blockquote><p>(考试：给出分解，用定理判断)<br>如果R为一个关系模式，F是R上的函数依赖集。令R<sub>1</sub> 和R<sub>2</sub>为R的分解。该分解为R的无损连接分解的条件是：F<sup>+</sup>中至少存在如下函数依赖中的一个</p><ul><li>R<sub>1</sub> ∩ R<sub>2</sub> → R<sub>1</sub></li><li>R<sub>1</sub> ∩ R<sub>2</sub> → R<sub>2</sub></li></ul><p>即，R<sub>1</sub> 和 R<sub>2</sub> 的公有属性能确定R<sub>1</sub>或R<sub>2</sub>。<br>换句话说，R<sub>1</sub> ∩ R<sub>2</sub>是R<sub>1</sub>或R<sub>2</sub>的<strong>超键</strong>，R上的分解就是无损分解。我们可以用属性闭包的方法来有效的检验<strong>超键</strong>。P225 例7.16</p><h3 id="保持函数依赖的分解"><a href="#保持函数依赖的分解" class="headerlink" title="保持函数依赖的分解"></a>保持函数依赖的分解</h3><p>设R是具有属性U和函数依赖集合F的关系模式，ρ={R<sub>1</sub>, R<sub>2</sub>…, R<sub>k</sub>}为R的一个分解，如果π<sub>R<sub>i</sub></sub>(F)(i = 1, 2, …, k)的并集逻辑蕴含F中的全部函数依赖，则称分解ρ具有函数依赖保持性。</p><p>设关系模式R(A, B, C, D)，函数依赖集F = {A → B, B → C, B → D, C → A}，分解为ρ = { R<sub>1</sub>(AB), R<sub>2</sub>(ACD) }。检验分解的无损连接性和分解的函数依赖保持性。</p><blockquote><p>由于R<sub>1</sub> ∩ R<sub>2</sub> = AB ∩ ABC = A，根据A → B，得到A → AB，即R<sub>1</sub> ∩ R<sub>2</sub> → R<sub>1</sub>，所以分解ρ是无损分解。<br>F<sub>1</sub> = π<sub>R<sub>1</sub></sub>(F) = { A → B, B → A }<br>F<sub>2</sub> = π<sub>R<sub>2</sub></sub>(F) = { A → C, C → A, A → D }<br>F<sub>1</sub> ∪ F<sub>2</sub> = {A → B, B → A, A → C, C → A, A → D } = {A → B, B → C, B → D, C → A} = F，所以分解ρ是保持函数依赖分解。</p></blockquote><p>模式分解的无损分解与保持函数依赖的分解两个特性之间没有必然的联系。</p><h2 id="7-4-关系模式的范式"><a href="#7-4-关系模式的范式" class="headerlink" title="7.4 关系模式的范式"></a>7.4 关系模式的范式</h2><p>范式以函数依赖为基础，有第一范式(1NF)，第二范式(2NF)，第三范式(3NF),BC范式(BCNF)。其他类型范式：4NF和5NF不详述。各范式之间存在下面的关系：<br>1NF &sup; 2NF &sup; 3NF &sup; BCNF &sup; 4NF &sup; 5NF</p><h3 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a>第一范式(1NF)</h3><p>设R是一个关系模式，如果R的每个属性的值域是不可分的(原子的)数据项集合，则称这个关系模式R为第一范式，简称1NF，记作R &in; 1NF。</p><h3 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式(2NF)"></a>第二范式(2NF)</h3><p>若关系模式R &in; 1NF，且每一个非主属性完全函数依赖于键，则R &in; 2NF。[在1NF基础上消除非主属性对键的部分函数依赖]</p><blockquote><p>第二范式（2NF）要求实体的属性完全依赖于(候选)键。所谓完全依赖是指不能存在仅依赖键一部分的属性，如果存在，那么这个属性和键的这一部分应该分离出来形成一个新的实体。</p></blockquote><h3 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式(3NF)"></a>第三范式(3NF)</h3><p>关系模式R &in; 2NF，且它的任何一个非主属性都不传递依赖于任何候选键，则R &in; 3NF。[在2NF基础上消除非主属性对键的传递函数依赖]</p><blockquote><p>即不能存在：非主属性 A 依赖于非主属性 B，非主属性 B 依赖于键的情况。</p></blockquote><p>2NF：非主属性是否<strong>完全依赖</strong>于键，还是依赖于键的一部分。<br>3NF：非主键列是<strong>直接依赖</strong>于键，还是直接依赖于非主属性列。</p><h3 id="BC范式-BCNF"><a href="#BC范式-BCNF" class="headerlink" title="BC范式(BCNF)"></a>BC范式(BCNF)</h3><p>设关系模式R(U, F) &in; 1NF, 如果对于R的每个函数依赖X → Y (Y &notin; X)，X必包含键，则R &in; BCNF，又称修正/扩充的第三范式。[在3NF的基础上消除了主属性之间的函数依赖]</p><ul><li>所有非主属性都完全依赖于每个候选键</li><li>所有主属性都完全函数依赖于每个不包含它的候选键</li><li>没有任何属性完全函数依赖于非键的人和一组属性</li></ul><blockquote><p>只要属性或属性组A能够决定任何一个属性B，则A的子集中必须有候选键。<br>BCNF范式排除了任何属性(不光是非主属性，2NF和3NF所限制的都是非主属性)对候选键的传递依赖与部分依赖。</p></blockquote><h3 id="规范化小结"><a href="#规范化小结" class="headerlink" title="规范化小结"></a>规范化小结</h3><p>关系模式在分解时应该保持“等价”。无损连接分解和保持函数依赖分解没有必然联系。</p><ul><li><code>数据等价</code>用无损连接分解来衡量：能保持关系经过自然连接以后仍能恢复回来</li><li><code>语义等价</code>用保持函数依赖费解来衡量：能保证数据在投影或连接中其语义不会发生变化。</li></ul><p>范式是衡量关系模式优劣的标准，范式表达了模式中数据依赖之间应满足的联系。范式级别越高，其数据冗余和操作异常现象越少。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理笔记C03 关系模型</title>
      <link href="/sql03/"/>
      <url>/sql03/</url>
      
        <content type="html"><![CDATA[<h2 id="3-1-关系数据库的结构"><a href="#3-1-关系数据库的结构" class="headerlink" title="3.1 关系数据库的结构"></a>3.1 关系数据库的结构</h2><p>关系模型的数据结构的逻辑形势是一张二维表，这个<code>二维表</code>就叫做<code>关系</code>。</p><h3 id="关系模型的基本术语"><a href="#关系模型的基本术语" class="headerlink" title="关系模型的基本术语"></a>关系模型的基本术语</h3><ul><li>关系/表：一个关系就是一张二维表</li><li>元组/行：表中的一行就是一个元组</li><li>属性/列：表中的一列就是一个属性</li><li>值域：关系中的<code>每个属性</code>都有一个取值范围，这个取值范围称为属性的值域<a id="more"></a></li><li>分量：元组的某一个属性值就是一个分量</li><li>关系模式：关系模式是对关系的结构性描述</li><li>表的内容：指表的元组的集合</li><li>基数：关系中元组的个属叫做技术</li><li>度数/元数：关系中属性的个属叫做元数</li><li>关系数据库：是表或者关系的集合</li><li>空值(NULL)：是指未知的活着尚未定义的属性值</li></ul><h3 id="关系的键"><a href="#关系的键" class="headerlink" title="关系的键"></a>关系的键</h3><ul><li>超键：在一个关系中，某一个属性或属性集合的值可唯一地标识元组。</li><li>候选键：一个属性或属性集合的值能唯一标识一个关系的元组而又不含有多余的属性。<ul><li>主属性：构成候选键的诸属性。</li><li>非主属性：不包含在任意候选键中的属性。 </li></ul></li><li>全键：关系的全部属性构成关系的候选键。</li><li>主键：有时一个关系中有多个侯选键，此时可以选择一个作为插入，删除或检索元组的操作变量。被选用的候选键称为主键。每一个关系都有且只有一个主键。</li><li>外键：是指关系R中的属性A不是关系R的主键，但A是另一个关系S的主键，则属性A就是关系R的外键。其中R是<code>参照关系</code>，S是<code>被参照关系</code>。<ul><li>外键在关系R中的取值有两种可能：或为空值，或必须是被参照关系S中已有的属性值。</li><li>外键值是否允许为空值，主要依赖于应用环境的语义。</li></ul></li></ul><h3 id="基于集合论的关系定义"><a href="#基于集合论的关系定义" class="headerlink" title="基于集合论的关系定义"></a>基于集合论的关系定义</h3><p>笛卡尔乘积的运算符号定义为 × ，是一个定义在集合之上的代数系统运算符。它的算子是单个的集合。</p><blockquote><p>两个数据域的笛卡尔乘积即：左边数据域的每一个元素去组合右边数据域的每一个元素，形成一个元组的集合。<br>当被处理的各个关系之间毫无联系的时候，可以通过笛卡尔积来实现我们的目标。</p></blockquote><p>P36 关系的度</p><h3 id="关系规则"><a href="#关系规则" class="headerlink" title="关系规则"></a>关系规则</h3><ul><li><p>第一范式规则: 关系数据库中表的每一分量都是不可分割的基本数据项，同一分量中不能有多个值。即关系模型不允许含有<code>多值属性</code>，并且属性的类型必须是<code>简单类型</code>。</p><blockquote><ul><li>家庭住址包括省市接街道，不是简单类型  </li><li>家庭成员值可能有多个，是多值属性</li></ul></blockquote></li><li><p>实体完整性规则: 定义关系中主键的取值不能为空值。 </p></li><li>参照完整性规则: 若属性或属性组F是关系R的外键，它与关系S的主键K<sub>s</sub>相对应，则对于R中每个元组在F上的值或者取空值，或者等于S中某个元组的主键值。<blockquote><ul><li>定义了外键和主键之间的引用规则，是数据库<strong>一致性</strong>和<strong>准确性</strong>的保证。</li></ul></blockquote></li><li>用户定义的完整性规则: 针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求。</li><li>关系的其他规则：<ol><li>表中同一属性的数据具有同质性，即同一列中的分量是同一类型的数据，来自同一个域。</li></ol><ul><li>同一关系的属性名具有不能重复性，即不同的属性要定义不同的属性名，同一关系中不同属性的数据可出自同一个域。</li><li>关系中的元组位置具有顺序无关性，即关系元组的顺序可以任意交换。</li><li>关系中的列位置具有顺序无关性，即关系中的属性顺序不影响使用，属性的次序可以任意交换。</li></ul></li></ul><h3 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h3><p>常用的关系操作：包括查询操作和更新操作。</p><blockquote><p>查询操作：选择、投影、连接、除、并、差等操作<br>更新操作：增加、删除、修改等操作</p></blockquote><p>关系操作的表示方式：</p><blockquote><ol><li>关系代数：抽象的查询语言，用代数运算来表达关系的查询要求和条件，是关系数据库运算的基础。</li></ol><ul><li>关系演算：抽象的查询语言，用谓词来表达关系查询要求和条件。</li><li>结构化查询语言(SQL)：兼用关系代数和关系演算来表达关系的查询要求和条件。</li></ul></blockquote><h2 id="3-2-关系代数"><a href="#3-2-关系代数" class="headerlink" title="3.2 关系代数"></a>3.2 关系代数</h2><h3 id="传统的集合运算P42"><a href="#传统的集合运算P42" class="headerlink" title="传统的集合运算P42"></a>传统的集合运算P42</h3><table><thead><tr><th>名称</th><th>符号</th><th>实例</th></tr></thead><tbody><tr><td>并</td><td>∪</td><td>R∪S</td></tr><tr><td>交</td><td>∩</td><td>R∩S</td></tr><tr><td>差</td><td>−</td><td>R-S</td></tr><tr><td>广义笛卡尔积</td><td>×</td><td>R×S</td></tr></tbody></table><p>广义笛卡尔积: 两个度分别为 n 元和 m 元的关系 R 和 S 的笛卡尔是一个 (n+m) 列的元组的集合。组的前 n 列是关系 R 的一个元组，后 m 列是关系 S 的一个元组，记作 R × S。</p><h3 id="自然关系运算"><a href="#自然关系运算" class="headerlink" title="自然关系运算"></a>自然关系运算</h3><table><thead><tr><th>名称</th><th>符号</th><th>实例</th></tr></thead><tbody><tr><td>投影</td><td>π<sub>A</sub>(R)</td><td>π<sub>cid</sub>(R)</td></tr><tr><td>选择</td><td>σ<sub>F</sub></td><td>σ<sub>sno=’301’</sub>(R)</td></tr><tr><td>连接/θ连接</td><td>⋈</td><td>R ⋈ S</td></tr><tr><td>除法</td><td>÷</td><td>R ÷ S</td></tr></tbody></table><blockquote><p>不等于可以表达为 ‘&lt;&gt;’</p></blockquote><p><code>选择</code>：(关系的水平方向)是从关系 R 中选择满足给定条件的元组，记作 σ<sub>F</sub>(R)。<br><code>投影</code>：(关系的垂直方向)在关系 R 中选出所需要的属性列 A 组成新的关系，记作 π<sub>A</sub>(R)。<br><code>连接</code>：从 R 与 S的笛卡尔积中选取属性间满足一定条件的元组，可由基本的关系运算笛卡尔积和选取运算导出，表示为：R⋈<sub>AθB</sub>S=σ<sub>AθB</sub>(R×S)<br><code>等值连接</code>：当 θ 为「=」时，称之为等值链接，记为： R⋈<sub>A=B</sub>S<br><code>自然连接</code>：自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量<strong>必须是相同的属性组</strong>，并且在结果集中将<strong>重复的属性列去掉</strong>，记为： R⋈S</p><blockquote><p>以后如无特殊说明，则连接均指自然连接</p></blockquote><p><code>除法</code>：求 R÷S，取关系R中有的但S中没有的属性组，如：A，取唯一A属性组值的象集，对比S可知，关系S存在于 a <sub>[i]</sub> 象集中。P48，P49例3.19</p><h3 id="关系代数的综合实例"><a href="#关系代数的综合实例" class="headerlink" title="关系代数的综合实例"></a>关系代数的综合实例</h3><h3 id="扩展的关系代数运算"><a href="#扩展的关系代数运算" class="headerlink" title="扩展的关系代数运算"></a>扩展的关系代数运算</h3><p>外连接是自然连接的扩展/特例，可以处理缺失的信息。</p><table><thead><tr><th>名称</th><th>符号</th><th>实例</th></tr></thead><tbody><tr><td>外连接</td><td>⋈<sub>O</sub></td><td>R ⋈<sub>O</sub> S</td></tr><tr><td>左外连接</td><td>⋈<sub>LO</sub></td><td>R ⋈<sub>LO</sub> S</td></tr><tr><td>右外连接</td><td>⋈<sub>RO</sub></td><td>R ⋈<sub>RO</sub> S</td></tr></tbody></table><ol><li>左外连接＝内连接＋左边表中失配的元组</li><li>右外连接＝内连接＋右边表中失配的元组</li><li>全外连接＝内连接＋左边表中失配的元组＋右边表中失配的元组</li></ol><h2 id="3-3-关系演算"><a href="#3-3-关系演算" class="headerlink" title="3.3 关系演算"></a>3.3 关系演算</h2><p><code>关系演算</code>：在关系运算中，用数理逻辑中的<strong>谓词公式</strong>来表达查询的要求的方式。关系演算是一种非过程化的语言。根据谓词变量对象的不同，分为元组关系演算和域关系演算。<br>关系代数和关系演算的表达式可以相互等价转换。<br>「域关系演算、元组关系演算、关系代数三者的表达能力是一样的。」</p><h3 id="元组关系演算"><a href="#元组关系演算" class="headerlink" title="元组关系演算"></a>元组关系演算</h3><p>元组关系演算：用<code>元组集</code>表示关系运算的结果，表达形式一般为{ t | P(t) }，它是使所有P(t)为真的所有元组t构成的集合。</p><blockquote><p>t是元组变量，P(t)是公式，它由原子公式和运算符组成。</p></blockquote><h3 id="域关系演算"><a href="#域关系演算" class="headerlink" title="域关系演算"></a>域关系演算</h3><p>域关系演算：用<code>元组变量的分量</code>表示关系运算的结果，表达形式一般为{ ( t <sub>1</sub> , t <sub>2</sub> ,…,t <sub>k</sub> ) | P( t <sub>1</sub>, t <sub>2</sub>,…, t <sub>k</sub>) }，它是使P( t <sub>1</sub>, t <sub>2</sub>,…, t <sub>k</sub>)为真的那些域变量(元组分量的变量) t <sub>1</sub> , t <sub>2</sub> ,…,t <sub>k</sub> 组成的元组的集合。</p><blockquote><ul><li>t <sub>1</sub> , t <sub>2</sub> ,…,t <sub>k</sub> 是元组分量的变量，P(t)是公式，它由原子公式和运算符组成。  </li><li>域关系演算和元组关系演算是类似的，不同之处是用域变量代替元组变量的每一个分量，域变量的变化范围是某个值域而不是一个关系。</li></ul></blockquote><h2 id="3-4-关系代数表达式的优化"><a href="#3-4-关系代数表达式的优化" class="headerlink" title="3.4 关系代数表达式的优化"></a>3.4 关系代数表达式的优化</h2><h3 id="查询优化步骤"><a href="#查询优化步骤" class="headerlink" title="查询优化步骤"></a>查询优化步骤</h3><ol><li>将查询需求转换成某种内部表示，通常是语法树。</li><li>根据一定的等价变换规则把语法树转换成标准/优化形式。</li><li>选择低层的操作算法。</li><li>生成查询计划。</li></ol><h3 id="查询优化策略"><a href="#查询优化策略" class="headerlink" title="查询优化策略"></a>查询优化策略</h3><ol><li>选择运算应尽早执行。</li><li>把投影运算和选择运算同时进行。</li><li>把投影操作与它前面或者后面的一个双目运算结合起来，不必为投影专门扫描一遍关系。</li><li>在执行连接运算之前，可对需要连接的关系进行适当的预处理，如建索引或者排序。</li><li>把笛卡尔乘积和其后面的选择运算合并成连接运算。</li><li>存储公用子代表式(重复出现的子表达式)。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理笔记C02 信息的三种世界与数据模型</title>
      <link href="/sql02/"/>
      <url>/sql02/</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-信息的三种世界"><a href="#2-1-信息的三种世界" class="headerlink" title="2.1 信息的三种世界"></a>2.1 信息的三种世界</h2><h3 id="现实世界"><a href="#现实世界" class="headerlink" title="现实世界"></a>现实世界</h3><p>存在于人脑海之外的客观世界。包括各种事物、事物之间的相互联系以及事物的发生、发展和变化过程等。</p><blockquote><p>房子、车子、河流..<br>计算机无法直接处理，需要将这些事物的特性数据化。以人为例，常选用姓名、籍贯和性别等描述一个人的特征。<br> <a id="more"></a></p></blockquote><h3 id="信息世界"><a href="#信息世界" class="headerlink" title="信息世界"></a>信息世界</h3><p>现实世界中的事物及其联系被分析、归纳、抽象，形成信息。对这些信息进行记录、整理、归类和格式化后，就构成了信息世界。</p><blockquote><p>实体: 客观存在可以且可以相互区别的事物，同一类实体的集合称为实体集。<br>属性: 用来描述实体某一方面的特性<br>联系: 实体集之间的对应关系 </p></blockquote><h3 id="机器世界"><a href="#机器世界" class="headerlink" title="机器世界"></a>机器世界</h3><p>信息世界的信息被整理后以<code>数据的形式</code>存储到计算机中，信息存储的地方就是机器世界。</p><blockquote><p>记录: 实体的数据表示称为记录<br>字段: 实体某个属性的数据表示称为字段，也称为数据项<br>文件: 实体集的数据表示称为文件，它是同类记录的集合<br>记录型: 实体型的数据表示称为记录型  </p></blockquote><h3 id="客观对象的抽象过程—两步抽象"><a href="#客观对象的抽象过程—两步抽象" class="headerlink" title="客观对象的抽象过程—两步抽象"></a>客观对象的抽象过程—两步抽象</h3><ol><li><p>现实世界中的客观对象抽象为概念模型</p><blockquote><p>将现实世界抽象为信息世界</p></blockquote></li><li><p>把概念模型转换为某一数据库管理系统支持的数据模型。</p><blockquote><p>将信息世界转换为机器世界</p></blockquote></li></ol><h2 id="2-2-数据模型"><a href="#2-2-数据模型" class="headerlink" title="2.2 数据模型"></a>2.2 数据模型</h2><h3 id="数据模型的内容"><a href="#数据模型的内容" class="headerlink" title="数据模型的内容"></a>数据模型的内容</h3><p><code>数据结构</code>: 描述数据的类型、内容、性质以及数据间的联系。是数据模型的基础，数据操作和完整性约束建立在数据结构之上。<br><code>数据操作</code>: 描述在相应的数据结构上被允许执行的操作类型和操作方式。主要有检索和更新两大类。数据操作是对系统动态特性的描述。<br><code>完整性约束</code>: 描述数据结构内数据间的语法、词义联系、它们之间的制约和依存关系，以及数据动态变化的规则，以保证数据的正确、有效和相容。</p><h3 id="数据模型的分类"><a href="#数据模型的分类" class="headerlink" title="数据模型的分类"></a>数据模型的分类</h3><p><code>概念模型</code>: 也称信息模型,它是按用户的观点来对数据和信息建模,用于数据库设计。<br><code>逻辑模型</code>: 主要包括网状模型、层次模型、关系模型、面向对象数据模型等。按计算机系统的观点对数据建模，主要用于DBMS实现。<br><code>物理(数据)模型</code>: 针对计算机物理表示的模型，描述了数据在存储介质上的组织结构。除了与具体的DBMS有关，还与操作系统和硬件有关。  </p><h3 id="E-R-实体联系模型-概念模型中最为著名的常用模型"><a href="#E-R-实体联系模型-概念模型中最为著名的常用模型" class="headerlink" title="E-R 实体联系模型(概念模型中最为著名的常用模型)"></a>E-R 实体联系模型(概念模型中最为著名的常用模型)</h3><h4 id="E-R模型中的基本概念"><a href="#E-R模型中的基本概念" class="headerlink" title="E-R模型中的基本概念"></a>E-R模型中的基本概念</h4><p><code>实体</code>:客观存在并可相互区别的事物。可以是具体的人、事、物或抽象的概念。<br><code>属性</code>: 实体所具有的某一特性。一个实体可以由若干个属性来刻画。<br><code>实体型</code>: 用实体名及描述它的各属性名表示,可以刻画出全部同质实 体的共同特征和性质。例如，学生(学号、姓名、年龄、性别、学院、年级)<br><code>键</code>/<code>实体标识符</code>/<code>码</code>: 能唯一地标识实体的属性或属性集。<br><code>域</code>:属性的取值范围。<br><code>实体集</code>:性质相同的同类实体的集合称为实体集。</p><p> <strong>三种联系</strong>  </p><ul><li>一对一联系( 1 : 1 )</li><li>一对多联系( 1 : n ) eg.学校的学员和学生之间的联系</li><li>多对多联系( m : n ) eg.学生和课程之间的联系</li></ul><h4 id="E-R图绘制"><a href="#E-R图绘制" class="headerlink" title="E-R图绘制"></a>E-R图绘制</h4><ol><li>实体集：矩形,矩形框内写明实体名。</li><li>属性：椭圆形,并用无向边将其与相应的实体连接起来。</li><li>联系：菱形,菱形框内写明联系名，并用无向边分别与有关实体<br>连接起来,同时在无向边旁标上联系的类型(1:1、1:n或m:n)。</li></ol><blockquote><p>联系也可以有属性。如果一个联系具有属性，则这些属性也要用无向边<br>与该联系连接起来。</p></blockquote><p><strong>E-R图绘制的两种方法</strong>(考试: 画二元联系E-R图，但要理解三元联系)<br><code>集成法</code>: 将实体、实体属性、实体与实体之间的联系全部画在一张图上，构成一个完整的E-R图。适合规模不大的问题。<br><code>分离法</code>: 先画实体及其属性图，然后画实体联系图，适合规模较大的问题。</p><h3 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h3><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>数据模型简单，操作容易</td><td>不适合于表示非层次性的联系</td></tr><tr><td>查询效率高,性能优于关系模型,不低于网状模型</td><td>对插入和删除操作的限制多</td></tr><tr><td>提供了良好的完整性支持</td><td>查询子女结点必须通过双亲结点</td></tr></tbody></table><blockquote><p>记录之间的联系通过指针实现，查询效率较高。但只能表示1:N的联系。</p></blockquote><h3 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h3><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>能够更为直接地描述现实世界</td><td>其数据定义语言DDL复杂</td></tr><tr><td>具有良好的性能，存储效率高</td><td>数据独立性较差</td></tr></tbody></table><blockquote><p>记录之间的联系通过指针实现,M:N联系容易实现,查询效率较高。但 编写应用程序较复杂,程序员必须熟悉数据库的逻辑结构。</p></blockquote><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>以关系模型为基础的关系数据库是当前应用的主流。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理笔记C01 数据库基础知识</title>
      <link href="/sql01/"/>
      <url>/sql01/</url>
      
        <content type="html"><![CDATA[<h2 id="1-2-基本概念"><a href="#1-2-基本概念" class="headerlink" title="1.2 基本概念"></a>1.2 基本概念</h2><h3 id="数据和信息"><a href="#数据和信息" class="headerlink" title="数据和信息"></a>数据和信息</h3><p><code>数据</code>是数据库中存储的基本对象  </p><ul><li>定义: 描述事物的符号记录    </li><li>种类: 数字、文字、图形、图像、音频、视频、学生的档案记录等  </li></ul><blockquote><p>数据本身(李明, 男, 199712, 江苏南京市, 计算机系, 2016)并不能完全表达内容<br>需要经过语义解释(李明是个大学生，1997年12月出生，江苏南京市人，2016年考入计算机系)。</p></blockquote><p><code>信息</code>通常定义为经过加工处理后的数据。</p><blockquote><p>信息以数据的形式表示，数据是信息的载体，信息则是数据加工的结果，是对数据的解释。<br> <a id="more"></a></p></blockquote><h3 id="数据处理和数据管理"><a href="#数据处理和数据管理" class="headerlink" title="数据处理和数据管理"></a>数据处理和数据管理</h3><p><code>数据处理</code>是指将数据转换成信息的过程。<br><code>数据管理</code>在数据处理的一系列活动中，对数据进行分类、组织、编码、存储、检索和维护等操作的统称。  </p><p><code>数据库</code>(DB)是<strong>长期储存</strong>在计算机内、<strong>有组织</strong>的、<strong>可共享</strong>的<strong>大量</strong>数据的集合。<br>基本特征:</p><ul><li>数据按一定的数据模型组织、描述和储存</li><li>可为各种用户共享</li><li>冗余度较小</li><li>数据独立性较高</li><li>易扩展</li></ul><p><code>数据库管理系统</code>(DBMS)是位于用户与操作系统之间的一层数据管理软件， 是基础软件，是一个大型复杂的软件系统。  </p><blockquote><p>用途: 科学地组织和存储数据、高效地获取和维护数据<br>eg. SQL Server、Oracle、MySQL</p></blockquote><p><code>数据库管理员</code>(DBA)是指负责数据库的建立、使用和维护的专门人员。<br><code>数据库用户</code>是指与数据库系统打交道的人员，主要包括应用程序猿鹤最终用户。<br><code>数据库系统</code>(DBS)是指在计算机系统中引入数据库后的系统构成，一般由<strong>数据库</strong>、操作系统、<strong>数据库管理工具</strong>、应用开发工具、应用系统、<strong>数据库管理员</strong>和<strong>用户</strong>构成。(P3 图1.2)</p><h2 id="1-3-数据管理的发展P10"><a href="#1-3-数据管理的发展P10" class="headerlink" title="1.3 数据管理的发展P10"></a>1.3 数据管理的发展P10</h2><h3 id="人工管理阶段"><a href="#人工管理阶段" class="headerlink" title="人工管理阶段"></a>人工管理阶段</h3><ol><li>数据不能长期保存</li><li>数据和程序不具有独立性</li><li>没有文件的概念</li><li>数据是面向应用程序的</li></ol><h3 id="文件管理系统"><a href="#文件管理系统" class="headerlink" title="文件管理系统"></a>文件管理系统</h3><ol><li>数据可以长期保存在存储设备上供用户使用</li><li>数据和程序之间具有<strong>一定的</strong>独立性</li><li>实时处理</li></ol><blockquote><ul><li>数据独立性不足</li><li>数据冗余度大且容易产生数据不一致</li><li>数据整体没有结构</li><li>数据不是集中管理，安全性、完整性得不到可靠保证</li></ul></blockquote><h3 id="数据库技术管理"><a href="#数据库技术管理" class="headerlink" title="数据库技术管理"></a>数据库技术管理</h3><ol><li>采用一定的<code>数据模型</code>实现数据结构化。数据的用数据模型描述，无需应用程序定义。</li><li>应用程序与数据具有<strong>较高</strong>独立性(逻辑独立性、物理独立性)，由数据库管理系统的<code>二级映像</code>来保证。</li><li><p>支持数据共享。数据面向整个系统，可以被多个用户、多个应用共享使用。</p><blockquote><ul><li>减少数据冗余,节约存储空间</li><li>避免数据之间的不相容性与不一致性</li><li>使系统易于扩充</li></ul></blockquote></li><li><p>数据安全性较高</p><blockquote><ul><li>DBMS设置了安全与授权子系统</li><li>DBMS设置了数据完整性控制机制，保证数据的正确性、有效性和相容性。</li><li>DBMS设置了数据库备份和恢复机制</li><li>并发控制，对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果。</li></ul></blockquote></li></ol><h2 id="1-4-数据库的体系结构"><a href="#1-4-数据库的体系结构" class="headerlink" title="1.4 数据库的体系结构"></a>1.4 数据库的体系结构</h2><h3 id="数据库系统的三级模式结构"><a href="#数据库系统的三级模式结构" class="headerlink" title="数据库系统的三级模式结构"></a>数据库系统的三级模式结构</h3><p>数据库系统由外模式、模式和内模式三级构成。<br>数据库系统的主要目的之一，为用户提供一个数据的抽象视图，隐藏数据的存储结构和存储方法等细节。   </p><p>数据 &rarr; 文件(内模式) &rarr; 表(模式) &rarr; 导出表/视图(概念模式)  </p><p><code>内模式</code>(存储模式): 数据的<strong>物理结构</strong>和<strong>存储结构</strong>的描述，是数据在<code>数据库内部</code>的表示方式。</p><blockquote><p>顺序存储、B树结构存储、Hash存储、索引，数据压缩加密。</p></blockquote><p><code>概念模式</code>(逻辑模式/模式/结构模式): 数据库中全体数据的<strong>逻辑结构</strong>和特征的描述。</p><blockquote><p>记录数据项构成、数据项名字、类型、取值范围等。<br>安全性、完整性约束，定义联系。</p></blockquote><p><code>外模式</code>(用户模式): 用户看见和使用的<strong>局部</strong>数据的<strong>逻辑结构</strong>和特征的描述。</p><h3 id="数据库系统的二层映像结构"><a href="#数据库系统的二层映像结构" class="headerlink" title="数据库系统的二层映像结构"></a>数据库系统的二层映像结构</h3><p><img src="/sql01/1.png" width="70%" height="70%"></p><p>外模式/模式映像: 保证了数据和程序之间的逻辑独立性。<br>模式/内模式映像: 保证了数据和程序之间的物理独立性。</p><h3 id="数据库系统的应用框架"><a href="#数据库系统的应用框架" class="headerlink" title="数据库系统的应用框架"></a>数据库系统的应用框架</h3><ol><li>单用户(的数据库系统)</li><li>主从式/集中式   <ul><li>由一个主机连接多个终端用户的结构</li><li>多个用户可以同时并发地存储数据，能够共享数据。</li></ul></li><li>分布式结构  <ul><li>分布结构的数据库中数据在逻辑上是一个整体, 物理上在网络的不同节点上。</li><li>当用户需要经常访问远程数据时，系统效率会明显地收到网络通信的制约。</li></ul></li><li>客户机/服务器结构(C/S)  <ul><li>基于局域网的网络，需要安装专门的客户端软件。  </li><li>降低了系统的通信开销。</li></ul></li><li>浏览器/服务器结构(B/S)  <ul><li>基于网络和浏览器/Web服务器，需要考虑浏览器的兼容性。  </li><li>客户端零维护，系统的扩展非常容易，但应用服务器端负荷较重。</li></ul></li></ol><h2 id="1-5-数据库管理系统"><a href="#1-5-数据库管理系统" class="headerlink" title="1.5 数据库管理系统"></a>1.5 数据库管理系统</h2><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li>数据定义</li><li>数据操纵</li><li>数据库运行管理</li><li>数据组织、存储和管理</li><li>数据库的建立和维护</li><li>数据通信接口</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li>数据定义语言及其翻译处理程序</li><li>数据操纵语言及其翻译解释程序</li><li>数据运行控制程序</li><li>实用程序</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>德丽莎是不会输的！</title>
      <link href="/20180506/"/>
      <url>/20180506/</url>
      
        <content type="html"><![CDATA[<h3 id="最后一门课"><a href="#最后一门课" class="headerlink" title="最后一门课"></a>最后一门课</h3><p>上周五，大学本科阶段最后一门<code>通识课</code>结课啦。挺开心的。以后就算是选修也是专业选修课了，不能再像这种公共通识课一样滑水啦。<br>周四下午，大学本科阶段最后一门<code>体育课</code>考试通过啦。<br><del>本来是今天的， 写着写着就过零点了</del><br> <a id="more"></a><br>选的是体育舞蹈，因为考试要自带舞伴，所以在上这个课之前就和室友约好搭档啦。嗯…我当然是帅气的男步QvQ<br>考试的时候音乐一响，脑子里习惯性一片空白。刚开始的某个小节就走神啦，还好被室友顺手带了回来，表面上一切正常，实际内心慌得要死QAQ<br>幸亏每周都有和室友在走廊勤奋练习，所以就算是神游状态考试也顺利通过~  </p><h3 id="每天在相同时间入睡和起床"><a href="#每天在相同时间入睡和起床" class="headerlink" title="每天在相同时间入睡和起床"></a>每天在相同时间入睡和起床</h3><blockquote><p>每天在相同时间入睡和起床是健康睡眠的关键。</p></blockquote><p>这句话，是在手机时钟的就寝页里瞧见的。其实我想说，每天在相同时间入睡和起床，是一件很奢侈又很幸福的事情。<br>不知道是一直以来潜在的个人差异，还是高中时期累积的焦虑症和神经衰弱的毛病，如果不是绝对安静或者是有一定频率的噪音环境下，我总是难以入睡。<br>就算是有幸入睡了也睡得很浅，一点点动静就会醒过来，然后陷入神经紧绷的状态。</p><p>以前高中住校的时候，舍友的生活规律并不会有太大的差异。所以也能勉强应对。大学里的每个人却有着丰富多彩的生活(规律)。当然啦，每个人都有选择自己生活的自由，可惜这种自由我却很难享受。晚上不能早早入睡倒也无碍，但若是学习紧张的情况下，躺在床上的时候实在有些焦虑第二天的状态是否能勉强应对繁重的学习任务。  </p>]]></content>
      
      
      <categories>
          
          <category> DAIの日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理笔记C05 关系数据库标准语言—SQL</title>
      <link href="/sql05/"/>
      <url>/sql05/</url>
      
        <content type="html"><![CDATA[<h2 id="5-1SQL概述"><a href="#5-1SQL概述" class="headerlink" title="5.1SQL概述"></a>5.1SQL概述</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1.综合统一</p><blockquote><p>DQL(Data Query Language )<br>DML(Data Manipulation Language)<br>DDL(Data Definition Language)<br>DCL(Data Control Language )  </p></blockquote><p>2.高度非过程化</p><blockquote><p>用户只需要提出”做什么”,而不用指明”怎么做”。减轻了用户负担，提高了数据独立性。<br> <a id="more"></a><br>3.面向集合的操作方式<br>支持关系型数据库，操作对象和结果都是元组的集合。</p></blockquote><p>4.提供交互式和嵌入式</p><blockquote><p>作为交互式语言独立使用，或作为子语言嵌入到高级语言程序中。</p></blockquote><p>5.语言简洁</p><table><thead><tr><th>SQL功能</th><th>动词</th></tr></thead><tbody><tr><td>数据查询</td><td>select</td></tr><tr><td>数据定义</td><td>create, drop, alter</td></tr><tr><td>数据操纵</td><td>insert, update, delete</td></tr><tr><td>数据控制</td><td>grant, revoke</td></tr></tbody></table><h3 id="T-SQL"><a href="#T-SQL" class="headerlink" title="T-SQL"></a>T-SQL</h3><ol><li>Transact-SQL (T-SQL)语言是<code>微软公司</code>对标准SQL语言的<code>扩展</code></li><li>T-SQL是<code>SQL Server</code>与应用程序之间的语言 ,是SQL Server对应用程序开发的应用程序开发接口。 </li><li>T-SQL<code>增强</code>了SQL语言的功能,同时<code>兼容</code>SQL标准。</li></ol><h3 id="SQL语言的基本概念"><a href="#SQL语言的基本概念" class="headerlink" title="SQL语言的基本概念"></a>SQL语言的基本概念</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>1.系统数据类型  </p><blockquote><table><thead><tr><th>类别</th><th>数据类型定义符</th></tr></thead><tbody><tr><td>精确数字</td><td>bigint、int、smallint、tinyint、bit、decimal、numeric、money、 smallmoney</td></tr><tr><td>近似数字</td><td>float、real</td></tr><tr><td>日期和时间</td><td>dateime、smalldatetime、date、datetime2、datetimeoffset、time</td></tr><tr><td>字符串</td><td>char、varchar、text</td></tr><tr><td>Unicode 字符串</td><td>nchar、nvarchar、ntex</td></tr><tr><td>二进制字符串</td><td>binary、varbinary、image</td></tr><tr><td>其他数据类型</td><td>cursor、sql_variant、table、timestamp、uniqueidentifier、xml、 hierarchyid</td></tr></tbody></table><p><a href="">课本P86</a><br><a href="http://www.w3school.com.cn/sql/sql_datatypes.asp" target="_blank" rel="noopener">W3School参考资料</a></p></blockquote><p>2.用户自定义数据类型  </p><blockquote><ul><li>其定义基于SQL Server中提供的数据类型。  </li><li>当几个表中必须存储同一种数据类型并且为保证这些列具有相同的数据类型、长度和可空性时,可以使用用户自定义数据类型。  </li><li>例如,用于限定邮政编码的数据类型,可定义 postal_code,基于char数据类型。  </li></ul></blockquote><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><ul><li>表达式是标识符、值和运算符的组合,在应用时可以对其求值以获取结果。</li><li>表达式可以是常量、函数、列名、变量、子查询,或用运算符对这些实体进行组合以生成表达式。</li><li>eg. (price * 1.5) /  (price + sales_tax)</li></ul><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>运算符是一种符号,用来指定要在一个或多 个表达式中执行的操作。</p><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>算术运算符</td><td>+(加)、-(减)、*(乘)、/(除)、%(取模)</td></tr><tr><td>比较运算符</td><td>=、&gt;、&lt;、&gt;=、&lt;=、&lt;&gt;、!=、!&lt;、!&gt;</td></tr><tr><td>赋值运算符</td><td>=</td></tr><tr><td>逻辑运算符</td><td>AND、OR、NOT</td></tr></tbody></table><h4 id="SQL语法规则与规定"><a href="#SQL语法规则与规定" class="headerlink" title="SQL语法规则与规定"></a>SQL语法规则与规定</h4><table><thead><tr><th>约定</th><th>用于</th></tr></thead><tbody><tr><td>下划线</td><td>指示当语句中省略了包含带下划线的值的子句时应用的默认值。</td></tr><tr><td>｜ 竖线</td><td>分隔括号或大括号中的语法项。只能使用其中一项。</td></tr><tr><td>[ ] 方括号</td><td><code>可选</code>语法项。不要键入方括号。</td></tr><tr><td>{ } 大括号</td><td><code>必选</code>语法项。不要键入大括号。</td></tr><tr><td>[,…n]</td><td>指示前面的项可以重复 n 次。各项之间以逗号分隔。</td></tr><tr><td>[…n]</td><td>指示前面的项可以重复 n 次。每一项由空格分隔。</td></tr><tr><td>;</td><td>SQL语句终止符，可省略。</td></tr><tr><td><code>&lt;label&gt;</code>::=</td><td>语法块的名称。此约定用于对可在语句中的多个位置使用的过长语法段或语法单元进行分组和标记。可使用语法块的每个位置由括在尖括号内的标签指示: &lt;标签&gt;</td></tr></tbody></table><h2 id="5-2-SQL数据定义"><a href="#5-2-SQL数据定义" class="headerlink" title="5.2 SQL数据定义"></a>5.2 SQL数据定义</h2><h3 id="SQL的数据定义语句"><a href="#SQL的数据定义语句" class="headerlink" title="SQL的数据定义语句"></a>SQL的数据定义语句</h3><table><thead><tr><th>操作对象</th><th>创建</th><th>修改</th><th>删除</th></tr></thead><tbody><tr><td>数据库</td><td>create database</td><td>alter database</td><td>drop database</td></tr><tr><td>表</td><td>create table</td><td>alter table</td><td>drop table</td></tr><tr><td>视图</td><td>create view</td><td><code>转换为对基本表的更新</code></td><td>drop view</td></tr><tr><td>索引</td><td>create index</td><td>null</td><td>drop index</td></tr></tbody></table><h3 id="数据库的创建和删除"><a href="#数据库的创建和删除" class="headerlink" title="数据库的创建和删除"></a>数据库的创建和删除</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库名</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> 数据库名</span><br></pre></td></tr></table></figure><ul><li><p>数据库名称必须遵循标识符命名规则。有两类标识符: 常规标识符和分隔标识符</p><blockquote><p>SELECT <em><br>FROM [TableX]         –分隔符是可选的.<br>SELECT </em><br>FROM [My Table]      –分隔符必须使用。Identifier contains a space and uses a reserved keyword.</p></blockquote></li><li><p>创建数据库的用户将成为该数据库的所有者,拥有该数据库的所有权限。</p></li><li>有三种文件类型可用于存储数据库: 主数据文件，次要数据文件，事务日志。  </li></ul><h3 id="基本表的创建、复制、修改、删除"><a href="#基本表的创建、复制、修改、删除" class="headerlink" title="基本表的创建、复制、修改、删除"></a>基本表的创建、复制、修改、删除</h3><h4 id="基本表的创建"><a href="#基本表的创建" class="headerlink" title="基本表的创建"></a>基本表的创建</h4><p><code>基本表</code>(Base Table)是实际独立存放在数据库中的表，是实表。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">列名称<span class="number">1</span> 数据类型 列级完整性约束条件,</span><br><span class="line">列名称<span class="number">2</span> 数据类型,</span><br><span class="line">....</span><br><span class="line">表级完整性约束条件,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><table><thead><tr><th>完整性约束条件</th><th>含义</th></tr></thead><tbody><tr><td>primary key</td><td>定义主键</td></tr><tr><td>not null</td><td>定义的属性不能取空值</td></tr><tr><td>unique</td><td>定义的属性值必须唯一</td></tr><tr><td>foreign key(属性名 1)references 表名[(属性名 2)]</td><td>定义外键</td></tr><tr><td>check (条件表达式)</td><td>定义的属性值必须满足check中的条件</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*主键的两种定义方式*/</span></span><br><span class="line">cid nvarchar(255) not null primary key,<span class="comment">--列级完整性约束</span></span><br><span class="line">primary key(cid), <span class="comment">--表级完整性约束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*外键的定义方式orders表*/</span></span><br><span class="line">pid nvarchar(255) not null foreign key references products(pid),<span class="comment">--表级完整性约束</span></span><br><span class="line">foreign key(pid) references products(pid), <span class="comment">--表级完整性约束</span></span><br></pre></td></tr></table></figure><h4 id="基本表的复制"><a href="#基本表的复制" class="headerlink" title="基本表的复制"></a>基本表的复制</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*复制表的结构为一个新表*/</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">into</span> 新表 <span class="keyword">from</span> 旧表 <span class="keyword">where</span> <span class="number">1</span>=<span class="number">2</span></span><br><span class="line"><span class="comment">/*复制表的结构和数据到新表*/</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">into</span> 新表 <span class="keyword">from</span> 旧表</span><br><span class="line"><span class="comment">/*复制表的某一部分内容为一个新表*/</span></span><br><span class="line"><span class="keyword">select</span> *<span class="keyword">into</span> test2 <span class="keyword">from</span> reader <span class="keyword">where</span> Rsex = <span class="string">'男'</span></span><br></pre></td></tr></table></figure><h4 id="基本表的修改"><a href="#基本表的修改" class="headerlink" title="基本表的修改"></a>基本表的修改</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*如果添加的列不允许空值,则只有在指定了默认值或表为空的情况下,才能用alter table语句添加该列。*/</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称</span><br><span class="line"><span class="keyword">add</span> 新列名 数据类型 完整性约束 <span class="comment">-- 添加列和新的完整性约束条件</span></span><br><span class="line"><span class="keyword">drop</span> 完整性约束名 <span class="comment">--删除完整性约束</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">column</span> 列名 <span class="comment">--删除列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">column</span> 列名 数据类型 <span class="comment">-- 修改原有的列定义，包括修改列名和数据类型</span></span><br></pre></td></tr></table></figure><h4 id="基本表的删除"><a href="#基本表的删除" class="headerlink" title="基本表的删除"></a>基本表的删除</h4><p>restrict: 确保只有不存在相关视图和完整性约束的表才能删除。<br>cascade: 任何相关视图和完整性约束一并被删。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名 [restrict|<span class="keyword">cascade</span>]</span><br><span class="line"><span class="comment">/* []表示可选语法项，使用的时候不要键入方括号*/</span></span><br></pre></td></tr></table></figure><h2 id="5-3-SQL数据查询"><a href="#5-3-SQL数据查询" class="headerlink" title="5.3 SQL数据查询"></a>5.3 SQL数据查询</h2><h3 id="查询语句的基本结构"><a href="#查询语句的基本结构" class="headerlink" title="查询语句的基本结构"></a>查询语句的基本结构</h3><p>π<sub>A<sub>1</sub>,A<sub>2</sub>,…,A<sub>n</sub></sub>(σ<sub>F</sub>(R<sub>1</sub> X R<sub>2</sub> X … X R<sub>m</sub>))<br>对应的SQL语句为:<br>select A<sub>1</sub>,A<sub>2</sub>,…,A<sub>n</sub><br>from R<sub>1</sub>,R<sub>2</sub>,… ,R<sub>m</sub><br>where F</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> [*|all|<span class="keyword">distinct</span>]</span><br><span class="line">[&lt;目标表达式[[<span class="keyword">as</span>]列别名]&gt;[,&lt;目标列表达式[[<span class="keyword">as</span>]列别名]&gt;[,...n]］</span><br><span class="line"><span class="keyword">from</span> &lt;表名或视图名[[<span class="keyword">as</span>]表别名]&gt;[,&lt;表名或视图名[[<span class="keyword">as</span>]表别名]&gt;] [,...n]</span><br><span class="line">[<span class="keyword">where</span> &lt;条件表达式&gt;]</span><br><span class="line">[<span class="keyword">group</span> <span class="keyword">by</span>&lt;列名<span class="number">1</span>&gt;[<span class="keyword">having</span>&lt;条件表达式&gt;]]</span><br><span class="line">[<span class="keyword">order</span> <span class="keyword">by</span>&lt;列名<span class="number">2</span>&gt;[<span class="keyword">asc</span>|dese]];</span><br></pre></td></tr></table></figure><p><strong>执行顺序</strong></p><blockquote><p>对from子句中所有表作关系乘法<br>删除where子句中条件不为真的元组<br>根据group by子句中指定的列对剩余元组分组<br>删除having子句中条件不为真的元组<br>计算select子句选择列表中目标列表大事的值–投影<br>如果存在distinct关键字，则删除重复的元组<br>如果有order by子句，则对所有选出的元组按照其后列值进行排序  </p></blockquote><ul><li>select不是一个单独的语句，from是必选子句，where, group by, having, order by子句是可选字句。</li><li><code>*</code>表示输出结果包含在表的所有字段<code>all</code>表示显示所有行，包括重复的行<code>distinct</code>禁止在输出结果中包含重复的行</li><li>from 后面指定数据的来源。一张表为单表查询或简单查询；多张表之间用逗号分隔，为连接查询</li></ul><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><h4 id="选择列表中的列-消除取值重复行"><a href="#选择列表中的列-消除取值重复行" class="headerlink" title="选择列表中的列/消除取值重复行"></a>选择列表中的列/消除取值重复行</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> customers <span class="comment">--选择列表中的列</span></span><br><span class="line"><span class="keyword">select</span> pid <span class="keyword">from</span> orders</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> pid <span class="keyword">from</span> orders <span class="comment">-- 消除取值重复的行</span></span><br></pre></td></tr></table></figure><h4 id="查询经过计算的值"><a href="#查询经过计算的值" class="headerlink" title="查询经过计算的值"></a>查询经过计算的值</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> pname, quantity* price totalqty <span class="comment">--查询经过计算的值</span></span><br></pre></td></tr></table></figure><blockquote><p>quantity* price不是列名，而是一个计算表达式。totalqty是别名，作为查询结果中总金额的列标题</p></blockquote><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><table><thead><tr><th>查询条件</th><th>谓词</th></tr></thead><tbody><tr><td>比较</td><td>=(等于),&lt; (小于),&gt; (大于),&gt;= (大于等于),&lt;= (小于等于),!=或&lt;&gt; (不等于)</td></tr><tr><td>确定范围</td><td>between and(介于两者之间), not between and(不介于两者之间)</td></tr><tr><td>确定集合</td><td>in(在其中), not in(不在其中)</td></tr><tr><td>存在</td><td>exists, not exists</td></tr><tr><td>量化比较</td><td>any, all</td></tr><tr><td>字符匹配</td><td>like(匹配), not like(不匹配)</td></tr><tr><td>空值</td><td>is null(是空值), is not null(不是空值)</td></tr><tr><td>多重条件</td><td>and(与), or(或), not(非)</td></tr></tbody></table><blockquote><p>如果处理字段为NULL值，则条件表达式返回为unknown</p></blockquote><table><thead><tr><th>原值</th><th>ture</th><th>false</th><th>unknown</th></tr></thead><tbody><tr><td>not非运算结果</td><td>false</td><td>true</td><td>unknown</td></tr></tbody></table><table><thead><tr><th>and</th><th>true</th><th>false</th><th>unknown</th></tr></thead><tbody><tr><td>unknown</td><td>unknown</td><td>false</td><td>unknown</td></tr></tbody></table><table><thead><tr><th>or</th><th>ture</th><th>false</th><th>unknown</th></tr></thead><tbody><tr><td>unknown</td><td>true</td><td>unknown</td><td>unknown</td></tr></tbody></table><ul><li>单个/多重条件查询</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> aid,aname <span class="keyword">from</span> agents </span><br><span class="line"><span class="keyword">where</span> city=<span class="string">'new york'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> aid,aname <span class="keyword">from</span> agents </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> (city=<span class="string">'new york'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*和第一个查询结果相同*/</span><span class="keyword">select</span> aid,aname <span class="keyword">from</span> agents</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span>(<span class="keyword">not</span> (city=<span class="string">'new york'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*多重条件查询*/</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> products<span class="keyword">where</span> price&gt;<span class="number">5</span> <span class="keyword">and</span> price&lt;<span class="number">8</span></span><br></pre></td></tr></table></figure><blockquote><p>city列值为字符串常量，应包含在单引号内<br>如果单引号中的字符串包含有一个嵌入的引号，可以使用两个单引号表示嵌入的单引号</p></blockquote><ul><li>确定范围查询</li></ul><p>表达式[not]between 最小值 and 最大值  </p><blockquote><p>最小值 ≤ 表达式 and 表达式 ≤ 最大值<br>not: 最小值 &gt; 表达式 or 表达式 &gt; 最大值</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> pname,price<span class="keyword">from</span> products<span class="keyword">where</span> price <span class="keyword">between</span> <span class="number">5</span> <span class="keyword">and</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><ul><li>模糊查询<br>精确查询: 对查询字段有准确的描述。在实际应用中，只知道字符串的一部分，希望可以找到与之匹配的整个字符串，采用模糊查询。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*查询姓名(cname)以字母“A”开始的顾客 */</span><span class="keyword">select</span> * <span class="keyword">from</span> customers <span class="keyword">where</span> cname <span class="keyword">like</span> ‘A%<span class="string">';</span></span><br></pre></td></tr></table></figure><ul><li>空值的处理<br><code>is null</code> 或<code>is not null</code>不能用 = ／ != 来代替</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> customers </span><br><span class="line"><span class="keyword">where</span> city <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><ul><li>聚合函数  </li></ul><table><thead><tr><th>函数</th><th>格式</th><th>对象</th></tr></thead><tbody><tr><td>count</td><td>count({ [ [all &#124; distinct] expression ] &#124;  * } )</td><td>统计行数，与列的数据类型无关</td></tr><tr><td>sum</td><td>sum([all &#124; distinct] expression)</td><td>返回值的和，只能用于数字列。</td></tr><tr><td>avg</td><td>avg([all &#124; distinct] expression)</td><td>返回平均值，只能用于数字列</td></tr><tr><td>max</td><td>max([all &#124; distinct] expression)</td><td>求列值的最大值</td></tr><tr><td>min</td><td>min([all &#124; distinct] expression)</td><td>求列值的最大值</td></tr></tbody></table><blockquote><p>除了count以外，聚合函数都会忽略空值<br>聚合函数只能在以下位置作为表达式使用:<br>select语句的选择列表(子查询或外部查询)<br>having字句;compute/compute by子句</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> city) <span class="keyword">from</span> customers <span class="comment">--查询所有顾客居住城市数目</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(dollars) <span class="keyword">as</span> totaldollars <span class="keyword">from</span> orders <span class="comment">--查询所有订货交易的总金额</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(price) <span class="keyword">as</span> avgprice <span class="keyword">from</span> products <span class="comment">--查询所有产品的平均价格</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(dollars) <span class="keyword">from</span> orders <span class="comment">--查询订购表中最高的订购总价</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">min</span>([<span class="keyword">percent</span>]) <span class="keyword">from</span> agents <span class="comment">--查询代理商表中最低的代理佣金</span></span><br></pre></td></tr></table></figure><ul><li><p>查询结果排序<br>升序排列<code>asc</code>表示，降序排列<code>desc</code>表示。默认为升序排列。</p></li><li><p>查询结果分组<br><code>group by</code> 子句将表中的元组按某一列或多列值分组。值相等的为一组。  </p><blockquote><p>对分组的结果再进行筛选，可以在<code>group by</code>子句后面使用<code>having</code>语句。<code>where</code>子句用于在分组之前筛选数据，<code>having</code>子句用于在分组后筛选数据。</p></blockquote></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*查询所有的借阅记录，按照读者编号(Rno)升序排列，读者编号相同的，按照借阅时间(BorrowDate)降序排列*/</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> Borrow</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Rno <span class="keyword">asc</span>, BorrowDate <span class="keyword">desc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*查询至少被两个顾客订购的所欲产品的pid值*/</span></span><br><span class="line"><span class="keyword">select</span> pid <span class="keyword">from</span> orders</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> pid</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> cid)&gt;=<span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 列名<span class="number">1</span>, 列名<span class="number">2</span>, ...</span><br><span class="line"><span class="keyword">from</span> 表名<span class="number">1</span>, 表名<span class="number">2</span>, ...</span><br><span class="line"><span class="keyword">where</span> 连接条件<span class="number">1</span> <span class="keyword">and</span> 连接条件<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*连接条件的格式*/</span></span><br><span class="line">[&lt;表名<span class="number">1</span>&gt;] &lt;列名<span class="number">1</span>&gt; &lt;比较运算符&gt; [&lt;表名<span class="number">2</span>&gt;] &lt;列名<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>等值连接与非等值连接查询<br>当连接运算符为<code>=</code>时，成为等值连接，使用其他连接运算符则成为称为非等值连接。<blockquote><p>比较运算符主要用=, &gt;, &lt;,  &gt;=, &lt;=, !=</p></blockquote></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*查询既订购了产品p01又订购了产品p07的顾客的cid值*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> x.cid <span class="keyword">from</span> orders x ,orders y</span><br><span class="line"><span class="keyword">where</span> x.pid=<span class="string">'p01'</span> <span class="keyword">and</span> x.cid=y.cid <span class="keyword">and</span> y.pid=<span class="string">'p07'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*查询至少订购了一件价格低于$0.60商品的所有顾客名字*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> cname</span><br><span class="line"><span class="keyword">from</span>((orders o <span class="keyword">join</span>(<span class="keyword">select</span> pid <span class="keyword">from</span> products <span class="keyword">where</span> price&lt;<span class="number">0.60</span>)p <span class="keyword">on</span> pid = p.pid) <span class="keyword">join</span> customers c <span class="keyword">on</span> o.cid = c.cid)</span><br></pre></td></tr></table></figure><ul><li><p>内连接<br>可以通过<code>(inner) join</code>来建立表之间的连接。只有满足连接条件的元组才能作为结果输出。</p></li><li><p>外连接  </p><ul><li>左外连接: <code>left (outer) join</code> 以<code>join</code>左边的表为主表进行连接</li><li>右外连接: <code>right (outer) join</code>以<code>join</code>右边的表为主表进行连接</li></ul></li></ul><p>左/右外连接的结果集包括LEFT  OUTER子句中指定的左/右表的所有行，而不仅仅是连接列所匹配的行。</p><blockquote><p>如果左/右表的某行在右/左表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 列名<span class="number">1</span>, 列名<span class="number">2.</span>..</span><br><span class="line"><span class="keyword">from</span> 表名<span class="number">1</span> <span class="keyword">join</span> 表名<span class="number">2</span></span><br><span class="line"><span class="keyword">on</span> 连接条件<span class="number">1</span></span><br><span class="line"><span class="keyword">join</span> 表名<span class="number">3</span> </span><br><span class="line"><span class="keyword">on</span> 连接条件<span class="number">2</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查询所有满足条件"顾客通过代理商订了货"的顾客-代理商姓名组合*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> customers.cname,agents.aname</span><br><span class="line"><span class="keyword">from</span> customers <span class="keyword">join</span> orders<span class="keyword">on</span> customers.cid=orders.cid<span class="keyword">join</span> agents <span class="keyword">on</span> orders.aid=agents.aid</span><br><span class="line"></span><br><span class="line"><span class="comment">/*为了书写方便，可以用别名代替表名*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> c.cname,a.aname<span class="keyword">from</span> customers c <span class="keyword">join</span> orders o<span class="keyword">on</span> c.cid=o.cid <span class="keyword">join</span> agents a <span class="keyword">on</span> o.aid=a.aid</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查询所欲顾客的顾客号，姓名，订购的产品号以及数量。没有订购信息的顾客显示为NULL*/</span></span><br><span class="line"><span class="keyword">select</span> c.cid,c.cname,o.pid,o.qty </span><br><span class="line"><span class="keyword">from</span> customers c <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> orders o </span><br><span class="line"><span class="keyword">on</span> c.cid=o.cid</span><br></pre></td></tr></table></figure><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><ul><li>在SQL语言中，一个<code>select-from-where语句</code>称为一个<code>查询块</code>。</li><li>将一个查询块嵌套在另一个查询块的<code>where子句</code>或<code>having短语</code>的条件中的查询称为嵌套查询。</li><li>嵌套在<code>where子句</code>或<code>having短语条件</code>中的下层查询块又称为<code>内层查询块</code>或<code>子查询块</code>。</li><li>它的上层<code>select-from-where查询块</code>又称为<code>外层查询</code>或<code>父查询</code>或<code>主查询</code>。</li><li>SQL语言允许多层嵌套查询。</li></ul><h4 id="带有in谓词的子查询"><a href="#带有in谓词的子查询" class="headerlink" title="带有in谓词的子查询"></a>带有in谓词的子查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">表达式 [not] in  (子查询)| 表达式 [not] in  (常量1 &#123;,常量2……&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查询通过居住在Duluth或Dallas的代理商订了货的所有顾客的cid值*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> cid <span class="keyword">from</span> orders <span class="keyword">where</span> aid <span class="keyword">in</span> (<span class="keyword">select</span> aid <span class="keyword">from</span> agents <span class="keyword">where</span> city = <span class="string">'duluth'</span><span class="keyword">or</span> city = <span class="string">'dallas'</span>)</span><br></pre></td></tr></table></figure><p>用于判断某个属性列值是否在子查询结果中或者由多个常量组成的集合中。</p><ul><li>in谓词表示如果计算之后表达式的值<code>至少</code>与子查询结果中的<code>一个值相同</code>时，或者与常量构成的集合中的一个值相同时，返回true，否则返回false。  </li><li>not in谓词表示如果计算之后表达式的值与子查询结果中的所有值都不相同时，或者与常量构成的集合中的所有值<code>都不相同</code>时，返回true，否则返回false。</li><li>不相关子查询: 子查询的查询条件不依赖于外层父查询，独立于外部查询。</li></ul><h4 id="带有比较运算符的子查询"><a href="#带有比较运算符的子查询" class="headerlink" title="带有比较运算符的子查询"></a>带有比较运算符的子查询</h4><p>当确切知道内层查询返回的是单值时，可以用比较运算符。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*查询至少被两个顾客订购的产品*/</span></span><br><span class="line"><span class="comment">--相关子查询</span><span class="keyword">select</span> pid <span class="keyword">from</span> products p <span class="keyword">where</span> <span class="number">2</span> &lt;= (<span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> cid) <span class="keyword">from</span> orders <span class="keyword">where</span> pid = p.pid)</span><br></pre></td></tr></table></figure><h4 id="带有量化比较谓词的子查询"><a href="#带有量化比较谓词的子查询" class="headerlink" title="带有量化比较谓词的子查询"></a>带有量化比较谓词的子查询</h4><table><thead><tr><th>量化比较谓词</th><th>含义</th><th>量化比较谓词</th><th>含义</th></tr></thead><tbody><tr><td>&gt;(=)any/some</td><td>大于(等于)子查询结果中的某一个值</td><td>&gt;(=)all</td><td>大于(等于)子查询结果中的所有值</td></tr><tr><td>&lt;(=)any/some</td><td>小于(等于)子查询结果中的某一个值</td><td>&lt;(=)all</td><td>小于(等于)子查询结果中的所有值</td></tr><tr><td>=any/some</td><td>等于子查询结果中的某一个值</td><td>=all</td><td>等于子查询结果中的所有值</td></tr><tr><td>!=/&lt;&gt; any/some</td><td>不等于子查询结果中的某一个值</td><td>!=/&lt;&gt; all</td><td>不等于子查询结果中的任何一个值</td></tr></tbody></table><p>某些情况下，子查询返回多个值，可以使用量化比较谓词将表达式的值和子查询的结果进行比较。 </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">表达式θ&#123;some|any|all&#125;(子查询)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查询佣金百分率最小的代理商的aid值*/</span><span class="keyword">select</span> aid <span class="keyword">from</span> agents <span class="keyword">where</span>  [<span class="keyword">percent</span>]&lt;=all (<span class="keyword">select</span> [<span class="keyword">percent</span>] <span class="keyword">from</span> agents)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查询与居住在Dallas 或Boston 的顾客拥有相同折扣的所有顾客的cid，cname*/</span><span class="keyword">select</span> cid,cname <span class="keyword">from</span> customers <span class="keyword">where</span> discnt =<span class="keyword">some</span>(<span class="keyword">select</span> discnt <span class="keyword">from</span> customers<span class="keyword">where</span> city=<span class="string">'dallas'</span> <span class="keyword">or</span> city=<span class="string">'boston'</span>)</span><br></pre></td></tr></table></figure><h4 id="带有exists谓词的子查询"><a href="#带有exists谓词的子查询" class="headerlink" title="带有exists谓词的子查询"></a>带有exists谓词的子查询</h4><p>带有<code>exists</code>谓词的子查询不返回任何实数据，它只产生逻辑值true/false。<br>exists后面的子查询，目标列表达式通常都用<code>*</code>，因为只返回逻辑值，给出列名无意义。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[not] exists(子查询)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查询既订购了产品p01又订购了产品p07的顾客的cid*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> cid <span class="keyword">from</span> orders x <span class="keyword">where</span> pid=<span class="string">'p01'</span> <span class="keyword">and</span> <span class="keyword">exists</span> (<span class="keyword">select</span> * <span class="keyword">from</span> orders<span class="keyword">where</span> cid=x.cid <span class="keyword">and</span> pid=<span class="string">'p07'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查询没有通过代理商a05订货的所有顾客的名字*/</span><span class="keyword">select</span> <span class="keyword">distinct</span> c.cname <span class="keyword">from</span> customers c <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> * <span class="keyword">from</span> orders x<span class="keyword">where</span>  c.cid=x.cid <span class="keyword">and</span> x.aid=<span class="string">'a05'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>相关子查询:子查询的查询条件依赖于外层父查询的表属性。<br>所有带有in谓词、比较运算符、any/all谓词的子查询都能用带exists谓词的子查询等价替换。但是一些带有[not] exists谓词的子查询却不能被其他形式的子查询等价替换。</p></blockquote><h3 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h3><p><code>相容的表</code>: 列和列的顺序必须相同，对应项的数据类型也相同。<br>进行并(union)、交(intersect)、差(except)操作的子查询结果表必须是相容的表。</p><ul><li><code>union</code>: 并操作，将两个或多个查询结果合并为单过结果集。</li><li><code>intersect</code>: 交操作，返回两个或多个查询结果中都具有的非重复行。</li><li><code>except</code>: 差操作，从左查询中返回有右查询没有找到的所有非重复值。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">子查询1 union [all] 子查询2</span><br><span class="line"><span class="comment">/*未指定all，则删除重复行指定all,则将全部行并入结果，包括重复行*/</span></span><br><span class="line">子查询1 intersect 子查询2</span><br><span class="line">子查询1 except 子查询2</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查询顾客所居住的城市、代理商所在城市或者两者皆在的城市*/</span><span class="keyword">select</span> city  <span class="keyword">from</span> customers <span class="keyword">union</span> <span class="keyword">select</span> city <span class="keyword">from</span> agents</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查询既订购了产品p01又订购了产品p07的顾客的cid值*/</span><span class="keyword">select</span> cid <span class="keyword">from</span> orders <span class="keyword">where</span> pid=<span class="string">'p01'</span> <span class="keyword">intersect</span> <span class="keyword">select</span> cid <span class="keyword">from</span> orders <span class="keyword">where</span> pid=<span class="string">'p07'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*查询没有通过代理商a05定货的所有顾客的名字*/</span><span class="keyword">select</span> c.cname  <span class="keyword">from</span> customers c <span class="keyword">except</span> <span class="keyword">select</span> c.cname <span class="keyword">from</span> customers c,orders x <span class="keyword">where</span> (c.cid=x.cid <span class="keyword">and</span> x.aid=<span class="string">'a05'</span>)</span><br></pre></td></tr></table></figure><h3 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h3><p>因为SQL中没有与除法运算等价的运算符，所以必须利用复杂查询将除法运算符转换为等价的形式。转换成SQL语句的一般形式为: </p><p><code>`</code>sql<br>select ……<br>where not exists<br>    (select…… where not exists<br>        (select……<br>        where……))；<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">对于“订购了所有产品的顾客”，可以等价于“没有一个产品该顾客没有订购”。  </span><br><span class="line">(&amp;forall;x)P &amp;equiv; &amp;not; (&amp;exist;x(&amp;not;P))</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">select c.cid from customers c where not exists(select pid from orders x where not exists  (select * from orders y where x.pid = y.pid and y.cid = c.cid))</span><br></pre></td></tr></table></figure></p><h2 id="5-4-SQL数据操纵"><a href="#5-4-SQL数据操纵" class="headerlink" title="5.4 SQL数据操纵"></a>5.4 SQL数据操纵</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>向一个表中插入数据，使用<code>insert into</code>，指定列名的顺序可以和表定义顺序不同，<code>values</code>子句值的列顺序必须和指定列名顺序相同。</p><h4 id="插入单个记录"><a href="#插入单个记录" class="headerlink" title="插入单个记录"></a>插入单个记录</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> &lt;表名&gt;[ (&lt;属性列<span class="number">1</span>&gt;[，&lt;属性列<span class="number">2</span>&gt;] [ ,...n ]) ]</span><br><span class="line"><span class="keyword">values</span>(&lt;属性值<span class="number">1</span>&gt;[，&lt;属性值<span class="number">2</span>&gt;] [ ,...n ])</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> agents <span class="keyword">values</span> (<span class="string">'a13'</span>, <span class="string">'sam'</span>, <span class="literal">null</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">/*null才是空值，''是空字符串*/</span></span><br></pre></td></tr></table></figure><h4 id="插入子查询的结果"><a href="#插入子查询的结果" class="headerlink" title="插入子查询的结果"></a>插入子查询的结果</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span>&lt;表名&gt;[(&lt;属性列<span class="number">1</span>&gt;[，&lt;属性列<span class="number">2</span>&gt;] [ ,...n ]) ] 子查询语句</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设数据库中已有一个关系cust1，其关系模式与customers完全一样，</span></span><br><span class="line"><span class="comment">将关系customers中的所有元组插入到关系cust1中去*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> cust1<span class="keyword">select</span> * <span class="keyword">from</span> customers</span><br></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>修改记录中的一个或多个属性的值，使用<code>update</code>,如果省略where子句，则修改表中所有的记录。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span>&lt;表名&gt;</span><br><span class="line"><span class="keyword">set</span>&lt;列名<span class="number">1</span>&gt;=&lt;表达式<span class="number">1</span>&gt;[，&lt;列名<span class="number">2</span>&gt;=&lt;表达式<span class="number">2</span>&gt;][ ,...n ][<span class="keyword">where</span>&lt;条件&gt;]</span><br><span class="line"><span class="comment">/* 将所有订货总金额超过2000的顾客的折扣率增加10% */</span><span class="keyword">update</span> customers <span class="keyword">set</span> discnt=discnt*<span class="number">1.1</span> <span class="keyword">where</span> cid <span class="keyword">in</span> (<span class="keyword">select</span> cid <span class="keyword">from</span> orders <span class="keyword">group</span> <span class="keyword">by</span> cid <span class="keyword">having</span> <span class="keyword">sum</span>(dollars)&gt;<span class="number">2000</span>)</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>从一个表中删除一条记录，使用<code>delete</code>，如果省略where子句，则删除全部表中的数据，但是表的定义仍在。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span>&lt;表名&gt;</span><br><span class="line">[<span class="keyword">where</span>&lt;表名&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除所有没有人订购的产品*/</span><span class="keyword">delete</span> <span class="keyword">from</span> products<span class="keyword">where</span> pid <span class="keyword">not</span> <span class="keyword">in</span>(<span class="keyword">select</span> pid <span class="keyword">from</span> orders)</span><br></pre></td></tr></table></figure><h2 id="5-5-视图"><a href="#5-5-视图" class="headerlink" title="5.5 视图"></a>5.5 视图</h2><h3 id="视图的概念及特点"><a href="#视图的概念及特点" class="headerlink" title="视图的概念及特点"></a>视图的概念及特点</h3><p><code>视图</code>(view):是从一个或几个基本表(或视图)导出的一个虚拟表，数据库中只存放视图的定义，视图对应的数据仍然存储在原来的基本表中，基本表中的数据发生了改变，视图中查询出的数据也会发生改变。视图对增删改操作有一定限制。<br>使用视图的优点:</p><ul><li>提高安全性</li><li>简化操作</li><li>增强数据逻辑独立性</li></ul><h3 id="视图的创建和使用"><a href="#视图的创建和使用" class="headerlink" title="视图的创建和使用"></a>视图的创建和使用</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> &lt;视图名&gt;[(&lt;列名&gt;[,&lt;列名&gt;][ ,...n ])</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">&lt;子查询语句&gt;[<span class="keyword">with</span> <span class="keyword">check</span> <span class="keyword">option</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个视图custp01，列出订购了产品p01的顾客编号、姓名、产品编号、产品数量和总金额 */</span><span class="keyword">create</span> <span class="keyword">view</span> custp01 <span class="keyword">as</span><span class="keyword">select</span> c.cid,cname,pid,qty,dollars<span class="keyword">from</span> customers c, orders o<span class="keyword">where</span> c.cid = o.cid <span class="keyword">and</span> o.pid =<span class="string">'p01'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*视图定义后，用户可以像查询基本表一样使用视图*/</span></span><br><span class="line"><span class="keyword">select</span> *<span class="keyword">from</span> custp01</span><br><span class="line"><span class="comment">/*视图嵌套*/</span><span class="keyword">create</span> <span class="keyword">view</span> custp01_1 <span class="keyword">as</span><span class="keyword">select</span> cid,cname<span class="keyword">from</span> custp01<span class="keyword">where</span> dollars&gt;<span class="number">2000</span></span><br></pre></td></tr></table></figure><ul><li>子查询语句可以任意复杂，但是通常不允许含有<code>order by</code>子句和<code>distinct</code>子句。</li><li><code>with check option</code>表示对视图进行更新操作时要保证更新的行满足视图查询语句中的条件表达式。</li><li>如果指定了视图名，省略了组成视图的属性列名，则默认该视图由子查询中select子句目标列中的字段组成。</li><li>视图可以嵌套，视图可以在基本表/视图的基础上创建。</li></ul><h3 id="视图的更新"><a href="#视图的更新" class="headerlink" title="视图的更新"></a>视图的更新</h3><p>更新视图包括更新<code>update</code>，插入<code>insert</code>，删除<code>delete</code><br>格式: </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span>&lt;视图名&gt;</span><br><span class="line"><span class="keyword">set</span> &lt;列名&gt;=*&lt;表达式&gt;*</span><br><span class="line">[<span class="keyword">where</span> 条件]；</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> &lt;视图名&gt;</span><br><span class="line"><span class="keyword">values</span>(&lt;列名&gt;[,&lt;列名&gt;][ ,...n ])</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> &lt;表名&gt;</span><br><span class="line">[<span class="keyword">where</span> &lt;条件&gt;]</span><br></pre></td></tr></table></figure><p>举例: </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*建立一个视图，查询折扣率小于15的顾客信息*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> cust<span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> customers <span class="keyword">where</span> discnt&lt;=<span class="number">15</span> [<span class="keyword">with</span> <span class="keyword">check</span> <span class="keyword">option</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*修改增加折扣率，在原来的基础上+4*/</span></span><br><span class="line"><span class="comment">/*with check option只有在+4之后都满足discnt&lt;=15才能执行成功*/</span></span><br><span class="line"><span class="keyword">update</span> cust <span class="keyword">set</span> discnt=discnt+<span class="number">4</span><span class="comment">/*插入信息*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> cust<span class="keyword">values</span>(<span class="string">'c009'</span>,<span class="string">'mary'</span>,<span class="string">'dallas'</span>,<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建agentsales视图，包含所有下过订单的代理商的aid值以及他们的销售总额*/</span><span class="keyword">create</span> <span class="keyword">view</span> agentsales(aid,totsales) <span class="keyword">as</span><span class="keyword">select</span> aid,<span class="keyword">sum</span>(dollars)<span class="keyword">from</span> orders <span class="keyword">group</span> <span class="keyword">by</span> aid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用了聚合函数，无法进行更新*/</span></span><br><span class="line"><span class="keyword">update</span> agentsales <span class="keyword">set</span> totsales=totsales+<span class="number">1000</span></span><br></pre></td></tr></table></figure><ul><li><code>with check option</code>: 所有在该视图上执行的数据修改语句都必须符合定义视图的<code>select</code>语句。</li><li>以下几种情况不允许更新视图:<ul><li>若视图是由两个以上基本表导出的，则视图不允许更新。</li><li>若视图的字段来自表达式或常数，则不允许对此视图执行插入和更新操作，但允许删除。</li><li>若视图定义中含有group by子句，则此视图不允许更新。</li><li>若视图的属性列来自聚集函数，则此视图不允许更新。</li></ul></li></ul><h3 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> &lt;视图名&gt;</span><br></pre></td></tr></table></figure><h2 id="5-6-索引"><a href="#5-6-索引" class="headerlink" title="5.6 索引"></a>5.6 索引</h2><h3 id="索引的概念及作用"><a href="#索引的概念及作用" class="headerlink" title="索引的概念及作用"></a>索引的概念及作用</h3><p>索引是对数据库表中一列或者多列的值进行排序的一种结构。通常只有当经常查询索引列中的数据时，才在<code>基本表</code>的基础上创建索引。</p><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>加快数据的检索速度</td><td>占据物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间</td></tr><tr><td>创建唯一性索引，保证数据库表中每一行数据的唯一性</td><td>创建索引和维护索引要耗费时间</td></tr><tr><td>加速表和表之间的连接</td><td>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度</td></tr><tr><td>使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间</td></tr></tbody></table><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><ul><li>聚集索引<ul><li>基于聚集索引键对存储表或视图的数据行按照顺序排序</li><li>每个表只能有一个聚集索引</li><li>能提高多行检索的速度</li></ul></li><li>非聚集索引<ul><li>包含非聚集索引键值和行定位符。</li><li>定位符指向聚集索引或堆中包含该键值的数据行</li><li>对单行检索很快</li></ul></li><li>唯一性索引<ul><li>保证数据库表中每一行数据的唯一性 </li></ul></li></ul><blockquote><p>聚集索引和非聚集索引都可是唯一性索引</p></blockquote><h3 id="索引的创建及删除"><a href="#索引的创建及删除" class="headerlink" title="索引的创建及删除"></a>索引的创建及删除</h3><h4 id="索引的创建"><a href="#索引的创建" class="headerlink" title="索引的创建"></a>索引的创建</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>][clustered | nonclustered]<span class="keyword">index</span> &lt;索引名&gt;</span><br><span class="line"><span class="keyword">on</span> &lt;表名&gt; (&lt;列名&gt;[&lt;<span class="keyword">asc</span> | des&gt;][,n...]）</span><br><span class="line"></span><br><span class="line"><span class="comment">/*为表agents创建一个索引，保证每一行都有唯一的aid*/</span><span class="keyword">create</span> <span class="keyword">unique</span> clustered <span class="keyword">index</span> aidx <span class="keyword">on</span> agents(aid)</span><br></pre></td></tr></table></figure><p><code>unique</code>表示唯一性索引，<code>clustered</code>表示聚集索引，<code>nonclustered</code>表示非聚集索引。默认非聚集索引。默认<code>asc</code>升序。</p><h4 id="索引的删除"><a href="#索引的删除" class="headerlink" title="索引的删除"></a>索引的删除</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span>&lt;索引名&gt;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> &lt;表名&gt;.&lt;索引名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除索引aidx*/</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> agents.aidx</span><br></pre></td></tr></table></figure><table><thead><tr><th>索引的使用情况</th><th>不应该创建索引的情况</th></tr></thead><tbody><tr><td>经常需要搜索的列</td><td>在查询中很少使用或参考的列</td></tr><tr><td>作为主键的列</td><td>只有很少数据值的列</td></tr><tr><td>经常用于连接的列</td><td>定义为text,image和bit数据类型的列</td></tr><tr><td>经常需要根据范围搜索的列</td><td>修改性能远远大于检索性能</td></tr><tr><td>经常需要排序的列</td><td></td></tr><tr><td>经常使用在where子句中的列</td></tr></tbody></table><h2 id="5-7-SQL数据控制语言-DCL"><a href="#5-7-SQL数据控制语言-DCL" class="headerlink" title="5.7 SQL数据控制语言(DCL)"></a>5.7 SQL数据控制语言(DCL)</h2><p>DBMS提供的数据库安全保护常用措施有: </p><ul><li>用户标识和鉴定</li><li>存取权限控制</li><li>视图</li><li>跟踪审查</li><li>数据加密存储</li></ul><h3 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h3><p><code>存取权限控制</code>: DBMS提供的内部安全性措施保护措施。</p><ul><li>确保只授权给有资格的用户访问DB的权限。</li><li>存取控制机制的组成<ul><li>定义存取权限</li><li>检查存取权限(确保用户只能执行合法操作)</li></ul></li><li>存取权限控制机制主要包括用户权限定义和合法权检查机制两部分。</li></ul><p>SQL语言用grant语句将对指定操作对象的指定操作权限授予指定的用户</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span>&lt;权限&gt;[,&lt;权限&gt;][,...n]</span><br><span class="line">[<span class="keyword">on</span>&lt;对象类型&gt;&lt;对象名&gt;]</span><br><span class="line"><span class="keyword">to</span>&lt;用户&gt;[,&lt;用户&gt;],[,...n]</span><br><span class="line">[<span class="keyword">with</span> <span class="keyword">grant</span> <span class="keyword">option</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*授予用户wintest对数据库sales的agents表的插入、更新权限*/</span><span class="keyword">grant</span> <span class="keyword">insert</span>,<span class="keyword">update</span> <span class="keyword">on</span> agents <span class="keyword">to</span> wintest</span><br></pre></td></tr></table></figure><h3 id="收回权限"><a href="#收回权限" class="headerlink" title="收回权限"></a>收回权限</h3><p>授予的权限可以由DBA或其他授权着用revoke语句收回</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">revoke</span>&lt;权限&gt;[,&lt;权限&gt;][,...n]</span><br><span class="line">[<span class="keyword">on</span>&lt;对象类型&gt;&lt;对象名&gt;]</span><br><span class="line"><span class="keyword">from</span>&lt;用户&gt;[,&lt;用户&gt;],[,...n]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*把用户sqltest对agents表的插入、更新权限收回*/</span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">insert</span>, <span class="keyword">update</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">table</span> agents</span><br><span class="line"><span class="keyword">from</span> sqltest</span><br><span class="line"></span><br><span class="line"><span class="comment">/*收回所有用户对视图cust1的查询权限*/</span></span><br><span class="line"><span class="keyword">revoke</span> s elect</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">view</span>  cust1</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">public</span></span><br></pre></td></tr></table></figure><blockquote><p>public 角色是一个特殊的数据库角色，每个数据库用户都属于它。</p></blockquote><h3 id="视图机制保证安全性"><a href="#视图机制保证安全性" class="headerlink" title="视图机制保证安全性"></a>视图机制保证安全性</h3><ul><li>视图把需要保密的数据对无权存取这些数据的用户隐藏起来</li><li>实际应用中，通常把视图机制与授权机制配合使用: 首先使用视图机制屏蔽掉一些保密数据，然后在视图上再进一步定义其存取权限</li></ul><h2 id="5-8-存储过程"><a href="#5-8-存储过程" class="headerlink" title="5.8 存储过程"></a>5.8 存储过程</h2><h3 id="存储过程简介"><a href="#存储过程简介" class="headerlink" title="存储过程简介"></a>存储过程简介</h3><ul><li>存储过程是 SQL 语句和可选控制流语句的预编译集合，以一个名称存储并作为一个单元处理。</li><li>存储过程可包含程序流、逻辑以及对数据库的查询。可以接受参数、输出参数、返回单个或多个结果集。</li><li>存储过程可以嵌套，即一个存储过程可以调用另一个存储过程。</li></ul><p><strong>优点:</strong></p><ul><li>重复使用。存储过程可以重复使用。从而可以减少数据库开发人员的工作量。</li><li>提高性能。存储过程在创建的时候就进行了变异，将来使用的时候不用再重新编译。</li><li>减少网络流量。</li><li>安全性。可以将grant、deny以及revoke权限应用于存储过程。</li></ul><p>###存储过程的创建与执行<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span>[拥有者.]存储过程名[;程序编号]</span><br><span class="line">[(参数#1,...，参数#n)]</span><br><span class="line">[with</span><br><span class="line">&#123;recompile|encryption|recomplie,encryption&#125;</span><br><span class="line">]</span><br><span class="line">[for replication]</span><br><span class="line">as 程序行</span><br><span class="line"></span><br><span class="line"><span class="comment">/*执行存储过程*/</span></span><br><span class="line">exec&lt;存储过程名&gt;[(参数表)]</span><br></pre></td></tr></table></figure></p><p>###存储过程的修改<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">procedure</span>&lt;存储过程名&gt;［(参数表)］</span><br><span class="line"><span class="keyword">as</span> 程序行</span><br></pre></td></tr></table></figure></p><p>###重新编译存储过程</p><p>###存储过程的删除<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span>&lt;存储过程名&gt;</span><br></pre></td></tr></table></figure></p><p>###使用存储功能的注意事项<br>使用存储过程的目的是为了提高应用系统的运行效率，增强系统的可维护性，保证数据的完整性和一致性。在使用存储过程时要注意以下几个方面: </p><ul><li>避免潜逃的、递归的存储过程的使用</li><li><p>在删除存储过程之前，需确定存储过程是否分组</p><h3 id="使用存储功能的注意事项"><a href="#使用存储功能的注意事项" class="headerlink" title="使用存储功能的注意事项"></a>使用存储功能的注意事项</h3><p>使用存储过程的目的是为了提高应用系统的运行效率，增强系统的可维护性，保证数据的完整性和一致性。在使用存储过程时要注意以下几个方面: </p></li><li><p>避免潜逃的、递归的存储过程的使用</p></li><li>在删除存储过程之前，需确定存储过程是否分组</li></ul><h2 id="5-9-函数"><a href="#5-9-函数" class="headerlink" title="5.9 函数"></a>5.9 函数</h2><h3 id="函数的概念及优点"><a href="#函数的概念及优点" class="headerlink" title="函数的概念及优点"></a>函数的概念及优点</h3><p><code>函数</code>是由一个或多个 Transact-SQL 语句组成的子程序，可用于封装代码以便重新使用。<br><strong>优点:</strong>  </p><ul><li>允许模块化程序设计</li><li>执行速度更快。使用用户定义函数时无需重新解析和重新优化，从而缩短了执行时间</li><li>减少网络流量</li><li>使用灵活，能实现复杂约束</li></ul><p><strong>存储过程和函数的区别</strong></p><ul><li>存储过程可以返回<code>参数</code>，而函数只能返回<code>值</code>或者<code>表对象</code>。</li><li>存储过程一般是作为一个<code>独立的部分</code>来执行，而函数可以作为<code>查询语句的一个部分</code>来调用，由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面。</li><li>函数在<code>系统启动时</code>就进行编译并加载，存储过程在<code>调用时</code>才加载。</li><li>一般来说，存储过程实现的功能要复杂一点，而函数实现的功能针对性更强。</li></ul><h3 id="函数的创建与使用"><a href="#函数的创建与使用" class="headerlink" title="函数的创建与使用"></a>函数的创建与使用</h3><ul><li>内置函数<ul><li>聚合函数(<code>count</code>, <code>avg</code>, <code>sum</code>, <code>max</code>, <code>min</code>…)</li><li>配置函数</li><li>日期和时间函数 </li><li>数学函数</li><li>元数据函数</li></ul></li><li>用户自定义函数<ul><li>标量函数</li><li>内嵌表函数</li><li>多语句表值函数</li></ul></li></ul><h3 id="函数的修改"><a href="#函数的修改" class="headerlink" title="函数的修改"></a>函数的修改</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">function</span> &lt;函数名&gt;[(参数表)]</span><br><span class="line"><span class="keyword">as</span> 程序行</span><br></pre></td></tr></table></figure><h3 id="函数的删除"><a href="#函数的删除" class="headerlink" title="函数的删除"></a>函数的删除</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">function</span> &lt;函数名&gt;</span><br></pre></td></tr></table></figure><h2 id="5-10-T-SQL的流程控制语句"><a href="#5-10-T-SQL的流程控制语句" class="headerlink" title="5.10 T-SQL的流程控制语句"></a>5.10 T-SQL的流程控制语句</h2><h3 id="begin…end语句"><a href="#begin…end语句" class="headerlink" title="begin…end语句"></a>begin…end语句</h3><p>begin…end语句作为一对表示符包括多条T-SQL语句，将其组合为一个具有逻辑性的语句块整体。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">&#123;</span><br><span class="line">sql_statement | statement_block</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="if…else语句"><a href="#if…else语句" class="headerlink" title="if…else语句"></a>if…else语句</h3><p>if…else语句是单条件判断语句</p><h3 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h3><p>case语句是多条件判断语句</p><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>while语句是一个循环语句</p><h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><p>goto语句将执行流更改到标签处</p><h3 id="waitfor语句"><a href="#waitfor语句" class="headerlink" title="waitfor语句"></a>waitfor语句</h3><p>waitfor语句主要用于以下两个方面:</p><ul><li>暂停执行程序一段时间后再继续执行</li><li>暂停执行程序到指定时间后再继续执行</li></ul><h3 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h3><p>return语句能够无条件地终止一个查询</p><h3 id="try-catch语句"><a href="#try-catch语句" class="headerlink" title="try/catch语句"></a>try/catch语句</h3><h2 id="5-12-嵌入式SQL"><a href="#5-12-嵌入式SQL" class="headerlink" title="5.12 嵌入式SQL"></a>5.12 嵌入式SQL</h2><h3 id="嵌入式SQL的定义及实现"><a href="#嵌入式SQL的定义及实现" class="headerlink" title="嵌入式SQL的定义及实现"></a>嵌入式SQL的定义及实现</h3><p><code>嵌入式SQL</code>就是将SQL语言直接嵌入到高级程序设计语言的源代码中，利用高级语言的过程性结构来弥补SQL语言实现复杂应用方面的不足。</p><p>嵌入式SQL的实现，有两种方法：</p><ul><li>修改和扩充宿主语言的编译程序，使之能处理SQL语句；</li><li>预处理方式（常用）: <ul><li>将具有前缀的语句，用SQL预处理器转换成宿主语言的函数调用语句</li><li>由宿主语言的编译器生成目标程序</li></ul></li></ul><h3 id="SQL和宿主语言的接口"><a href="#SQL和宿主语言的接口" class="headerlink" title="SQL和宿主语言的接口"></a>SQL和宿主语言的接口</h3><p>SQL语言是<strong>面向集合</strong>的，一条SQL语句可以产生或处理一条或多条记录，主语言是面向记录的，一组主变量一次只能存法一条记录。<br>如果SQL语句产生的是<strong>单行结果</strong>，可以使用select into语句；如果SQL语句产生的是<strong>多行结果</strong>，则必须使用游标来解决SQL语句和主语言处理方式的矛盾。</p><ul><li>游标：是计算机系统为用户开设的一个数据缓存区，用于存放SQL语句的结果数据集，每个游标区都有一个名字。</li><li>用户可以通过游标逐一读取数据记录，然后赋值给主变量，再交给主语言程序作进一步处理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECS搭建Typecho博客</title>
      <link href="/typechostart/"/>
      <url>/typechostart/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最开始了解搭建个人博客的时候，在<code>Wordpress</code>和<code>Hexo+github</code>中选择了成本更低(几乎木有成本)、更简单的<code>Hexo</code>。<br>由于是刚入坑的咸鱼，在搭建的过程和配置个性化主题的过程中<code>踩了无数次坑</code>，虽然搭建起来的博客也看得过去，但是最终因为一个改了很久+查了很久解决方法无果后的BUG而选择弃坑..也就是在这个时候，接触了<code>Typecho</code>。<br> <a id="more"></a> </p><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p><code>阿里云ECS</code>: 仗着学生优惠买的..(贫穷又不失礼貌的微笑)</p><blockquote><p>Ubuntu 16.04 32位</p></blockquote><p><code>万网域名</code>: 已备案，耗时15天<br><code>操作终端</code>: Mac OS X 10.11.6 Terminal</p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>阿里云控制台的<code>域名解析</code>设置中添加两条解析:</p><table><thead><tr><th style="text-align:left">记录类型</th><th style="text-align:left">主机记录</th><th style="text-align:left">解析路线(isp）</th><th style="text-align:left">记录值</th></tr></thead><tbody><tr><td style="text-align:left">A</td><td style="text-align:left">@</td><td style="text-align:left">默认</td><td style="text-align:left"><code>你的ECS的公网ip</code></td></tr><tr><td style="text-align:left">A</td><td style="text-align:left">www</td><td style="text-align:left">默认</td><td style="text-align:left"><code>你的ECS的公网ip</code></td></tr></tbody></table><h2 id="配置LAMP-Typecho环境"><a href="#配置LAMP-Typecho环境" class="headerlink" title="配置LAMP+Typecho环境"></a>配置LAMP+Typecho环境</h2><h3 id="配置LAMP"><a href="#配置LAMP" class="headerlink" title="配置LAMP"></a>配置LAMP</h3><p>在Mac的终端进行ssh操作:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ssh your ECS&apos;s ip</span><br></pre></td></tr></table></figure></p><p>会提示输入密码，然后再输入ECS密码</p><blockquote><p>首次进行ssh操作需要先在阿里云ESC实例重置密码，并重启  </p></blockquote><p>更新安装包的源:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>安装apache:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apache2</span><br></pre></td></tr></table></figure><p>安装php: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install php</span><br></pre></td></tr></table></figure><p>安装Mysql: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure><p>关联php和mysql</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install php-mysql</span><br></pre></td></tr></table></figure><p>关联Apache和php: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libapache2-mod-php</span><br></pre></td></tr></table></figure><p>到这里，LAMP的环境搭建就结束了。<br>是不是觉得很简单?<br>不用担心！前面的一堆坑等着你跳哪(~不要问我为什么知道~)<br>此时访问你的域名，会出现Appache的默认主页。</p><h3 id="配置Typecho"><a href="#配置Typecho" class="headerlink" title="配置Typecho"></a>配置Typecho</h3><p>在<a href="http://typecho.org/download" target="_blank" rel="noopener">Typecho官网</a>下载下来Typecho的压缩包  </p><blockquote><p>我下载的是1.1正式版(2018-4-17)</p></blockquote><p>在本地执行命令上传到服务器上:<br>scp  -P 22 /yourpath/1.1-17.10.30-release.tar.gz root@yourip:/var/www/html/1.1-17.10.30-release.tar.gz</p><blockquote><p>端口一般默认是22</p></blockquote><p>再次通过ssh连接服务器:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ssh yourip</span><br></pre></td></tr></table></figure><p>进入Apache的站点默认目录，解压Typecho压缩包，是一个build文件夹: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /var/www/html/</span><br><span class="line">tar xzf 1.1-17.10.30-release.tar.gz</span><br></pre></td></tr></table></figure><p>将build文件夹的所有文件移动到站点根目录:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv build/*  /var/www/html/</span><br></pre></td></tr></table></figure><p>删除apache默认的主页:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -f index.html</span><br></pre></td></tr></table></figure><p>对站点文件夹授权777:</p><blockquote><p>以便后面typecho可以自行创建config.inc.php文件</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod -R 777 /var/www/html</span><br></pre></td></tr></table></figure><p>此时打开你的域名，是一个typecho博客的创建页面，但是别急…数据库还需要手动创建:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p   //输入刚才安装数据库的时候设置的密码，进入mysql</span><br><span class="line">create database typecho; //创建typecho的数据库，不要忘记打分号</span><br><span class="line">show databases;//除了默认的几个数据库，typecho数据库也被创建</span><br><span class="line">quit //退出mysql</span><br></pre></td></tr></table></figure><p>然后就可以在typecho的创建页面进行配置，设置管理员账号等操作了。</p><h3 id="可能出现的错误"><a href="#可能出现的错误" class="headerlink" title="可能出现的错误"></a>可能出现的错误</h3><ul><li>配置好typecho后进入后台，但是点开主页报错</li></ul><blockquote><p>因为php缺少包导致，在服务器执行:<strong>sudo apt-get install php7.0-xml</strong></p></blockquote><h2 id="Typecho博客配置永久链接"><a href="#Typecho博客配置永久链接" class="headerlink" title="Typecho博客配置永久链接"></a>Typecho博客配置永久链接</h2><p>后台-管理-永久链接,但是点击保存的时候会显示出错。这是因为typecho无法在你的网站根目录上新建.htaccess文件。</p><blockquote><p>解决办法：手动创建就好啦</p></blockquote><h3 id="创建-htaccess"><a href="#创建-htaccess" class="headerlink" title="创建.htaccess"></a>创建.htaccess</h3><p>进入网站根目录并创建.htaccess文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /var/www/html</span><br><span class="line">vi .htaccess</span><br></pre></td></tr></table></figure><p>.htaccess文件内容如下:</p><blockquote><p>在谷歌解决办法的时候，搜索到一些不同写法的.htaccess，都试了一下，我只有这一个文件内容会成功配置永久链接。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">RewriteEngine On</span><br><span class="line">RewriteBase /</span><br><span class="line">RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line">RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</span><br><span class="line">RewriteRule ^(.*)$ index.php [L,E=PATH_INFO:$1]</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure><blockquote><p>此时查看该文件夹的文件，不会显示.htaccess，因为这个文件只有类型，没有名称。但实际上这个文件已经存在了。</p></blockquote><h3 id="修改apahce-conf"><a href="#修改apahce-conf" class="headerlink" title="修改apahce.conf"></a>修改apahce.conf</h3><p>路径一般为<code>/etc/apache2</code>，找到如下内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Directory /var/www/&gt;</span><br><span class="line">        Options Indexes FollowSymLinks</span><br><span class="line">        AllowOverride None</span><br><span class="line">        Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure><p>将<code>None</code>修改为<code>ALL</code><br>启用重写功能，最后再重启apache:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo a2enmod rewrite</span><br><span class="line">sudo /etc/init.d/apache2 restart</span><br></pre></td></tr></table></figure><blockquote><p>在博客后台设置永久链接仍然会报错，直接忽略错误强制保存即可。</p></blockquote><h2 id="在阿里云申请并配置SSL证书"><a href="#在阿里云申请并配置SSL证书" class="headerlink" title="在阿里云申请并配置SSL证书"></a>在阿里云申请并配置SSL证书</h2><h3 id="在控制台申请云盾证书"><a href="#在控制台申请云盾证书" class="headerlink" title="在控制台申请云盾证书"></a>在控制台申请云盾证书</h3><p>因为我的域名是在万网购买的，所以直接在阿里云申请的免费的一年SSL证书。</p><ul><li>免费型DV SSL</li><li>保护类型:1个域名</li><li>选择品牌: Symantec</li></ul><blockquote><p>刚进入购买页面是默认没有免费型DV SSL的，先选择1个域名，再选择Symantec，就会出现免费型SSL。</p></blockquote><p>购买成功后，阿里云控制台-左侧安全(云盾)－CA证书服务补全信息</p><h3 id="在服务器配置SSL证书"><a href="#在服务器配置SSL证书" class="headerlink" title="在服务器配置SSL证书"></a>在服务器配置SSL证书</h3><p>阿里云控制台 - 左侧安全(云盾) － CA证书服务 - 选择对应的证书 - <code>下载</code><br>在apache根目录<code>/etc/apache2</code>创建名为cert的文件夹</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir cert</span><br></pre></td></tr></table></figure><p>将下载的压缩包上传到该目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp  -P 22 /本地路径/证书压缩包.zip root@101.132.127.63:/etc/apache2/cert/证书压缩包.zip</span><br></pre></td></tr></table></figure><p>连接服务器，解压该压缩包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip 证书压缩包.zip</span><br></pre></td></tr></table></figure><p>开启ssl: <figure class="highlight plain"><figcaption><span>a2enmod ssl```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">修改default-ssl.conf文件</span><br><span class="line"></span><br><span class="line">```vi /etc/apache2/sites-available/default-ssl.conf</span><br></pre></td></tr></table></figure></p><p>找到如下内容并修改路径:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SSLCertificateFile      /etc/apache2/cert/public.pem</span><br><span class="line">               SSLCertificateKeyFile /etc/apache2/cert/你的证书.key</span><br><span class="line"></span><br><span class="line">               #   Server Certificate Chain:</span><br><span class="line">               #   Point SSLCertificateChainFile at a file containing the</span><br><span class="line">               #   concatenation of PEM encoded CA certificates which form the</span><br><span class="line">               #   certificate chain for the server certificate. Alternatively</span><br><span class="line">               #   the referenced file can be the same as SSLCertificateFile</span><br><span class="line">               #   when the CA certificates are directly appended to the server</span><br><span class="line">               #   certificate for convinience.</span><br><span class="line">               SSLCertificateChainFile /etc/apache2/cert/chain.pem</span><br></pre></td></tr></table></figure><blockquote><p>去掉SSLCertificateChainFile前面的#号</p></blockquote><p>修改default-ssl.conf文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/apache2/mods-available/ssl.conf</span><br></pre></td></tr></table></figure><p>找到如下内容并修改:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SSLCipherSuite HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUM </span><br><span class="line"></span><br><span class="line">        # SSL server cipher order preference:</span><br><span class="line">        # Use server priorities for cipher algorithm choice.</span><br><span class="line">        # Clients may prefer lower grade encryption.  You should enable this</span><br><span class="line">        # option if you want to enforce stronger encryption, and can afford</span><br><span class="line">        # the CPU cost, and did not override SSLCipherSuite in a way that puts</span><br><span class="line">        # insecure ciphers first.</span><br><span class="line">        # Default: Off</span><br><span class="line">        SSLHonorCipherOrder on </span><br><span class="line">        </span><br><span class="line">        #   The protocols to enable.</span><br><span class="line">        #   Available values: all, SSLv3, TLSv1, TLSv1.1, TLSv1.2</span><br><span class="line">        #   SSL v2  is no longer supported</span><br><span class="line">        SSLProtocol all -SSLv3 ／／没有添加SSLv2 因为上面的注释说不再支持了</span><br></pre></td></tr></table></figure><p>最后重启Apache2</p><blockquote><p>此时访问https://你的域名 显示小绿锁即成功。<br>必须全站https才会有小绿锁，如果你的图片外链是http，会显示警告。</p></blockquote><h2 id="Http重定向到Https"><a href="#Http重定向到Https" class="headerlink" title="Http重定向到Https"></a>Http重定向到Https</h2><h3 id="博客后台管理修改站点地址"><a href="#博客后台管理修改站点地址" class="headerlink" title="博客后台管理修改站点地址"></a>博客后台管理修改站点地址</h3><p>将站点地址的http修改为https  </p><h3 id="服务器端修改-htaccess"><a href="#服务器端修改-htaccess" class="headerlink" title="服务器端修改.htaccess"></a>服务器端修改.htaccess</h3><p>在站点根目录修改<code>.htaccess</code>如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line"></span><br><span class="line">RewriteEngine On</span><br><span class="line">RewriteCond %&#123;http_host&#125; ^www.qwqmiao.com$ [NC] </span><br><span class="line">RewriteRule ^(.*)$ https://qwqmiao.com/$1 [R=301,L] </span><br><span class="line"></span><br><span class="line">RewriteCond %&#123;SERVER_PORT&#125; !^443$</span><br><span class="line">RewriteRule ^(.*)?$ https://%&#123;SERVER_NAME&#125;/$1 [L,R]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RewriteEngine On</span><br><span class="line">RewriteBase /</span><br><span class="line">RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line">RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</span><br><span class="line">RewriteRule ^(.*)$ index.php [L,E=PATH_INFO:$1]</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DAIの折腾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typecho </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Typecho &amp; Hexo Still</title>
      <link href="/newblog/"/>
      <url>/newblog/</url>
      
        <content type="html"><![CDATA[<h3 id="新的博客站点已经就绪"><a href="#新的博客站点已经就绪" class="headerlink" title="新的博客站点已经就绪"></a>新的博客站点已经就绪</h3><p>(ฅ´ω`ฅ)希望你们喜欢<br><del><a href="https://qwqmiao.com/" target="_blank" rel="noopener">呆月酱的喵窝</a></del>已弃用<br> <a id="more"></a> </p><h3 id="必要的说明"><a href="#必要的说明" class="headerlink" title="必要的说明"></a>必要的说明</h3><ul><li>依旧很喜欢hexo框架，准备一年阿里云到期后继续折腾hexo</li><li>Typecho可以了解很多php相关的知识&amp;服务器站点配置(~踩了无数坑的我~)</li><li>Hexo博客会同步Typecho更新</li><li>Progrmmiao.me域名将保留</li><li>计划研究Hexo博客主题+Typecho主题，学习前端相关知识(或许还有点后端吧qwq)</li></ul>]]></content>
      
      
      <categories>
          
          <category> DAIの日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Typecho </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个正常的通知</title>
      <link href="/attention/"/>
      <url>/attention/</url>
      
        <content type="html"><![CDATA[<h3 id="一个新的开始：网站“重建”"><a href="#一个新的开始：网站“重建”" class="headerlink" title="一个新的开始：网站“重建”"></a>一个新的开始：网站“重建”</h3><ul><li>从某种意义上来说也不算是重建，因为这一个基于hexo+github的博客我将会一直保留并更新下去(<del>毕竟只是一个域名的成本</del>）</li><li>已经在三天前展开了新网站的部署，将基于阿里云ESC+typecho模式构建新站</li><li>进度条：万网域名备案中，服务器环境基本就绪<a id="more"></a> <h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3></li><li>有一篇名为<code>SQL Sever的安装和基本操作</code>中的几段代码无论如何调整在首页上都会格式错乱，文字和代码重叠，尝试无数次修改方法无果。（现在已经被我移除首页）</li><li>确认markdown语法无误(因为在简书和typecho博客页面测试没有任何问题！)，这个小插曲浪费了我很多心力..</li><li>以后注定是要以有代码的博客为主，又懒得再去尝试和修改其他的hexo博客主题，故脑子一热做出这样的决定。</li><li>很开心，因为这个决定让我拥有了自己的第一台服务器</li></ul><p><code>希望可以一直努力地折腾，直到死去。</code></p>]]></content>
      
      
      <categories>
          
          <category> DAIの日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL Sever安装及数据库基本操作</title>
      <link href="/sqllib/"/>
      <url>/sqllib/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL-Sever-SSMS的安装"><a href="#SQL-Sever-SSMS的安装" class="headerlink" title="SQL Sever+SSMS的安装"></a>SQL Sever+SSMS的安装</h2><h3 id="安装环境：Win-10专业版（Mac-OS-X-gt-PD虚拟机）"><a href="#安装环境：Win-10专业版（Mac-OS-X-gt-PD虚拟机）" class="headerlink" title="安装环境：Win 10专业版（Mac OS X -&gt; PD虚拟机）"></a>安装环境：Win 10专业版（Mac OS X -&gt; PD虚拟机）</h3><h3 id="安装包下载地址"><a href="#安装包下载地址" class="headerlink" title="安装包下载地址:"></a>安装包下载地址:</h3><ul><li><a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">SQL Sever 2014 Express</a><ul><li>服务器-&gt;SQL Sever 2014-&gt;中文简体-&gt;SQL Server 2014 Express (x64)-&gt;复制已勾选中内容-&gt;迅雷新建下载  </li></ul></li><li><a href="https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms" target="_blank" rel="noopener">SSMS</a><a id="more"></a></li></ul><h3 id="安装过程："><a href="#安装过程：" class="headerlink" title="安装过程："></a>安装过程：</h3><ul><li>SQL Sever 2014：双击安装包文件夹中的setup.exe, 按照提示一步一步走，注意：  <ul><li>安装规则中的每一项都要通过  </li><li>实例配置选择默认实例即可   </li><li>身份验证模式选择混合模式，并两次输入相同密码  </li></ul></li><li>SSMS：安装有点费时间，其他木有什喵特别要说的。</li></ul><h2 id="数据库基本操作"><a href="#数据库基本操作" class="headerlink" title="数据库基本操作"></a>数据库基本操作</h2><h3 id="使用-SQL-Server-Management-Studio的图形界面创建数据库："><a href="#使用-SQL-Server-Management-Studio的图形界面创建数据库：" class="headerlink" title="使用 SQL Server Management Studio的图形界面创建数据库："></a>使用 SQL Server Management Studio的图形界面创建数据库：</h3><p>数据库名称为Library，设置初始大小为6MB，把数据库Library文件增长参数设置为2MB，文件最大大小参数设置为20MB </p><h3 id="使用T-SQL分离Library数据库"><a href="#使用T-SQL分离Library数据库" class="headerlink" title="使用T-SQL分离Library数据库"></a>使用T-SQL分离Library数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">master</span>  </span><br><span class="line">exec sp_detach_db <span class="keyword">Library</span>,<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="分离数据库后，将数据库Library文件拷贝到C-lab1"><a href="#分离数据库后，将数据库Library文件拷贝到C-lab1" class="headerlink" title="分离数据库后，将数据库Library文件拷贝到C:\lab1\"></a>分离数据库后，将数据库Library文件拷贝到C:\lab1\</h3><h3 id="使用T-SQL附加Library数据库"><a href="#使用T-SQL附加Library数据库" class="headerlink" title="使用T-SQL附加Library数据库"></a>使用T-SQL附加Library数据库</h3><ul><li>错误：无法打开物理文件 XXX.mdf”。操作系统错误 5:”5(拒绝访问。)”。 (Microsoft SQL Server，错误: 5120     <ul><li>解决方法：找到该文件，右键选择属性－安全－编辑权限勾选完全权限   </li></ul></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">master</span>  </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">Library</span>  </span><br><span class="line"><span class="keyword">on</span>(filename = <span class="string">'C:\lab1\Library.mdf'</span>)  </span><br><span class="line"><span class="keyword">for</span> attach;  </span><br><span class="line">go</span><br></pre></td></tr></table></figure><h3 id="使用T-SQL完整备份数据库Library"><a href="#使用T-SQL完整备份数据库Library" class="headerlink" title="使用T-SQL完整备份数据库Library"></a>使用T-SQL完整备份数据库Library</h3><ul><li>完整备份：对整个数据库进行备份，包括特定数据库(或一组特定的文件组或文件)中的所有数据以及可以恢复这些数据的足够的日志<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">backup</span> <span class="keyword">database</span> <span class="keyword">Library</span>   </span><br><span class="line"><span class="keyword">to</span> disk = <span class="string">'C:\lab1\Librarybak'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用T-SQL差异备份数据库Library"><a href="#使用T-SQL差异备份数据库Library" class="headerlink" title="使用T-SQL差异备份数据库Library"></a>使用T-SQL差异备份数据库Library</h3><ul><li>只记录上次自完整备份后更改的数据 <ul><li>备份更快</li><li>备份数据量更小</li><li>因此能缩短备份时间</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">backup</span> <span class="keyword">database</span> <span class="keyword">Library</span></span><br><span class="line"><span class="keyword">to</span> disk = <span class="string">'C:\lab1\Librarybak'</span><span class="keyword">with</span> differential</span><br></pre></td></tr></table></figure><h3 id="使用T-SQL对数据库Library进行事务日志备份"><a href="#使用T-SQL对数据库Library进行事务日志备份" class="headerlink" title="使用T-SQL对数据库Library进行事务日志备份"></a>使用T-SQL对数据库Library进行事务日志备份</h3><ul><li>仅适用于使用完整恢复模式或大容量日志恢复模式</li><li>错误1: BACKUP 无法处理数据库 ‘Library’，因为它正由此会话使用。建议在执行此操作时使用 master 数据库。  <ul><li>解决方法：加上use master  </li></ul></li><li>错误2：当恢复模式为 SIMPLE 时，不允许使用 BACKUP LOG 语句。请使用 BACKUP DATABASE 或用 ALTER DATABASE 更改恢复模式。  <ul><li>解决方法：选择相应的数据库实体,点击右键选择”属性”,选择”选项”标签页，故障还原模型”简单”－&gt;”大容量日志记录的”,然后重新备份一下。</li></ul></li></ul><pre><code class="sql"><span class="keyword">backup</span> <span class="keyword">log</span> <span class="keyword">Library</span><span class="keyword">to</span> disk = <span class="string">'C:\lab1\Librarybak'</span><span class="keyword">with</span> norecovery</code></pre><h3 id="使用SQL-Server-Management-Studio的图形界面还原数据库Library的内容到Library-1"><a href="#使用SQL-Server-Management-Studio的图形界面还原数据库Library的内容到Library-1" class="headerlink" title="使用SQL Server Management Studio的图形界面还原数据库Library的内容到Library_1"></a>使用SQL Server Management Studio的图形界面还原数据库Library的内容到Library_1</h3><ul><li>存在的问题 “_”会被认为是非法符号，暂时没找到替代方法，最后用图形化界面完成的。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">restore</span> <span class="keyword">database</span> Library_1 <span class="keyword">from</span> disk = <span class="string">'C:\lab1\Librarybak'</span></span><br></pre></td></tr></table></figure><h3 id="使用T-SQL删除数据库Library"><a href="#使用T-SQL删除数据库Library" class="headerlink" title="使用T-SQL删除数据库Library"></a>使用T-SQL删除数据库Library</h3><ul><li>与分离不同的是，.mdf也一同删除</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">master</span>  </span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="keyword">Library</span></span><br></pre></td></tr></table></figure><h3 id="使用T-SQL创建表"><a href="#使用T-SQL创建表" class="headerlink" title="使用T-SQL创建表"></a>使用T-SQL创建表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//创建Book表,并设置Bno为主键</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">Library</span><span class="keyword">create</span> <span class="keyword">table</span> book(Bno <span class="keyword">nchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span>,Btitle <span class="keyword">nvarchar</span>(<span class="number">100</span>),Bauthor <span class="keyword">nvarchar</span>(<span class="number">50</span>),Bprice <span class="built_in">float</span>primary <span class="keyword">key</span>(Bno))</span><br><span class="line">//创建Borrow表，并设置Borrnum为主</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">Library</span><span class="keyword">create</span> <span class="keyword">table</span> borrow(Borrnum <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Rno <span class="keyword">nchar</span>(<span class="number">10</span>),</span><br><span class="line">Bno <span class="keyword">nchar</span>(<span class="number">10</span>),</span><br><span class="line">BorrowDate <span class="built_in">date</span>,</span><br><span class="line">ReturnDate <span class="built_in">date</span></span><br><span class="line">primary <span class="keyword">key</span>(Borrnum))</span><br></pre></td></tr></table></figure><h3 id="使用T-SQL复制"><a href="#使用T-SQL复制" class="headerlink" title="使用T-SQL复制"></a>使用T-SQL复制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//复制reader表＝readcopy表</span><br><span class="line">use Libraryselect * into readcopy from reader where 1 = 2</span><br></pre></td></tr></table></figure><h3 id="使用T-SQL向表中添加、修改、删除列"><a href="#使用T-SQL向表中添加、修改、删除列" class="headerlink" title="使用T-SQL向表中添加、修改、删除列"></a>使用T-SQL向表中添加、修改、删除列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//在reader表添加Email列</span><br><span class="line">use Library</span><br><span class="line">alter table reader</span><br><span class="line">add Email char(40) not null</span><br><span class="line"></span><br><span class="line">//在reader表修改Email列</span><br><span class="line">use Libraryalter table readeralter column Email char(20) not null</span><br><span class="line"></span><br><span class="line">//在reader表删除Email列</span><br><span class="line">use Libraryalter table readerdrop column Email</span><br></pre></td></tr></table></figure><h3 id="使用T-SQL删除表"><a href="#使用T-SQL删除表" class="headerlink" title="使用T-SQL删除表"></a>使用T-SQL删除表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use Librarygodrop table readcopy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新年快乐！</title>
      <link href="/happynew2018/"/>
      <url>/happynew2018/</url>
      
        <content type="html"><![CDATA[<h3 id="ʕ•ᴥ•ʔ汪！新年快乐～"><a href="#ʕ•ᴥ•ʔ汪！新年快乐～" class="headerlink" title="ʕ•ᴥ•ʔ汪！新年快乐～"></a>ʕ•ᴥ•ʔ汪！新年快乐～</h3><p>两个月半啦，许久不见，别来无恙呀。</p><p>除夕将至，新春快乐～<br> <a id="more"></a><br>希望新的一年里，亲爱的父母亲平安健康，可爱的朋友们都能得偿所愿。</p><p>其实在建这个博客之前，就想好了寒假建一个更加自定义式的博客来覆盖现在这个基于github+hexo的伪博客小站，可是一回家整天就被床粘住了，它先动手的！QWQ…现在还来得及吧！做不完是小狗（ ᶘ ᵒᴥᵒᶅ <del>喵喵喵？</del>汪汪汪？)  </p><h3 id="有趣的List"><a href="#有趣的List" class="headerlink" title="有趣的List"></a>有趣的List</h3><p>赶在除夕夜之前在家里进行了小型除尘作战行动！顺带将高中时期的旧物翻了个遍，复习了记忆里很多有趣的朋友和有趣的东西。</p><ul><li><p>印有史努比图案的卡通算盘：似乎上小学之前这个东西就在身边了，母亲说是为了我小学的课程准备的，因为在父母亲他们时代是有学习算盘的课程的，于是我心里一直存有一个小期待，等着哪天数学老师叫我们带上算盘去上学。可惜时代进步得太快，我自然也没有等到这一天。  </p></li><li><p>自行车篮子里小土狗：也是上小学的事，母亲每日早起骑车去买菜，然后回家，做饭。我也习以为常。只是有一天母亲回家的时候，车篮子里多了一只可爱的毛茸茸的小土狗，灰黄色，十分可爱。只可惜与它相处的时间不长，我们便与它走散了。</p></li><li><p>南京地铁单程票：圆圆的，深蓝色，像是一枚塑料硬币。因为见多了重庆的地铁票，便觉得所有的地铁票都应是一张小卡牌。比起那年春节的夫子庙灯会，我还是更喜欢重庆江边随便一处的夜景。但是南京那家川菜馆的凉面是真的好吃哇，虽然价格又贵分量又少。</p></li><li><p>两份高中时期奇怪的契约？？？：事情经过如下：”我要在高二下期结束前做完这本五三！”————“看你这么有斗志，来签订契约吧少女！” “什么，你居然偷我的化学笔记本出去复印了！还想借？(…思索…）借你可以，来签订契约吧少年！如果你不叫我叫我的名字，那你就叫错一次，给我吃一块％@＃¥*(好吃的QWQ）”最后…契约是真的。事情经过我瞎编的23333~</p></li><li><p>写有两个WOW账号的小说复印稿：高三的时候，语文老师突发奇想让我们写一篇小说的Chapter one，于是我便改写了一个贴吧大神复读的故事，体现的正好是WOW游戏情怀和高考之间的矛盾，那个大神的故事本就很催人泪下，改写的时候我更是一把鼻涕一把泪。可能有两个调皮的男同学在语文老师那里偷看了我的小说初稿，居然留下了他们各自的详细游戏区账号…</p></li><li><p>高考完的ToDoList：好几个本子都写有当时对高考完的安排和对大学的幻想，有高一高二写的，也有高三写的。可是现在的我只能说一声对不起，我好像让自己失望了。但是我不会丢掉当时的那颗初心的，我向你保证。</p></li><li><p>一沓信与明信片：有身边好友的，也有从未见过面的好友的，从初中开始到高中，百无聊赖的学习生活有等信的念头，倒也十分开心呢。非常感谢很久没见的你们和素未谋面的你们！</p></li></ul><h3 id="祝君以酒"><a href="#祝君以酒" class="headerlink" title="祝君以酒"></a>祝君以酒</h3><p>因为期待，总有无奈。<br>因为无奈，所以总是期待。  </p>]]></content>
      
      
      <categories>
          
          <category> DAIの日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17年的最后一月的第一天</title>
      <link href="/thefirstday/"/>
      <url>/thefirstday/</url>
      
        <content type="html"><![CDATA[<p>转眼间离上一篇文字已过去一月多，想来自己还是免不了做事情三分钟热度的坏性子。<br>这段时间里，发生了很多事情，什么事情也没有发生。<br> <a id="more"></a><br>计组结课了，昨天刚考完期末考试。老师真的没骗我们，他上课的过程就是透题的过程。考完出教学楼已是傍晚，十一月的月末，黄昏时刻，总让人有些留念又莫名地开心。<br>趁着双十一的时候买了餐具和简单的食材，在宿舍吃着自己做的早餐、午餐、晚餐，总是怨念着自己怎么才大二，好想早点毕业去工作去敲代码，然后买一套小房子，最重要的是，要配有一个可爱的厨房。等以后赚的钱多了，就配两个厨房。<br>清晨签完到，买上一杯冲调奶茶到图书馆自习大概是上个月最留恋的时刻，就想着，早起没睡醒也好，被重庆的雾气冻得要死也好，一段时间见不到自家的喵也好，考试压力很大也好，什么都好，就算是在冬天，生活也要充满希望才好。(当然..如果不长胖就更好了..最近吃不饱又饿得快简直让我怀疑自己还在长身体ORZ)<br>最难忘的，还是上个月的某天出门前，一时兴起想修一下刘海，然后把刘海抓到一起，咔嚓，嗯，大概也就眉毛上那么一截吧，剪得又短又参差不齐，但最近越看越顺眼了呢QWQ<br>这段日子里东忙西忙，忙得最多的就是实验报告了吧…数据结构，数学实验，汇编语言，计算机组成，而我现在手头还有两个报告QAQ<br>调代码的时候，若是它不安分，后面的所有计划都会被延期或者打乱，若是在晚上调试，挣扎着入睡，在梦中终于把这个BUG解决掉了，第二天一打开笔记本，大哥你怎么还在！<br>其实我都快记不得博客没有在线的日子发生了些什么了，是它们提醒了我，比如，手机里的照片，备忘录，电脑里多出来的文档，留下的就这么点，那些时刻心里想说的话只能一闪而过了吧。<br>即使每一天都过得很普通，我也有想要把它们都回忆起来，记录下来的冲动。因为这都是自己认真度过的平凡的生活啊。等自己老了以后，才不至于，对自己如何走过这一生的一无所知。<br>回到刚才，去食堂的窗口买蛋挞，无奈校园卡怎么也刷不上，<br>“那…算了吧，不好意思呀。”<br>“送给你吃吧~”<br>“啊？”<br>食堂小哥你是上帝派来助我长胖的恶魔吗!<br>(吃完蛋挞)<br>谢谢食堂小哥！你真是天使QWQ</p>]]></content>
      
      
      <categories>
          
          <category> DAIの日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拾月清单</title>
      <link href="/the-list/"/>
      <url>/the-list/</url>
      
        <content type="html"><![CDATA[<h3 id="有趣的事情"><a href="#有趣的事情" class="headerlink" title="有趣的事情"></a>有趣的事情</h3><ul><li>集齐重新装修的一食堂的所有窗口的食物</li><li>打卡考研单词(虽然并不准备考研OvO)</li><li>每年秋天收集一片金黄色的银杏叶</li><li>写一个预购清单，等以后工作挣钱啦买买买~<a id="more"></a> </li></ul><h3 id="专业知识"><a href="#专业知识" class="headerlink" title="专业知识"></a>专业知识</h3><ul><li>计算机网络</li><li>数据结构和算法分析*</li><li>操作系统</li><li>数据库系统</li><li>概率论和数理统计</li><li>精通两门编程语言(c/c++，java，python,php)</li><li>前端html，css，jquery</li><li>CNN &amp; Tensorflow</li></ul><h3 id="想努力完成的事情"><a href="#想努力完成的事情" class="headerlink" title="想努力完成的事情"></a>想努力完成的事情</h3><ul><li>初步了解、确定自己的工作岗位意向</li><li>学习如何写一份个人简历</li><li>给自己的简历添加筹码</li><li>大二/大三暑假实习岗位的申请 (2018/2019 Mar-May)</li><li>学化妆…ORZ</li></ul>]]></content>
      
      
      <categories>
          
          <category> DAIの日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>要开始认真起来了！</title>
      <link href="/workhard/"/>
      <url>/workhard/</url>
      
        <content type="html"><![CDATA[<h3 id="初来乍到的一食堂"><a href="#初来乍到的一食堂" class="headerlink" title="初来乍到的一食堂"></a>初来乍到的一食堂</h3><p>感觉一食堂重新装修了，还是不错的OvO<br>(除了烤肉饭的烤肉少了很多<br> <a id="more"></a> </p><h3 id="数据结构的大长腿老师"><a href="#数据结构的大长腿老师" class="headerlink" title="数据结构的大长腿老师"></a>数据结构的大长腿老师</h3><p>今天一早醒来，下着大雨，刮着冷风。<br>什么时候秋分一过，也轮到重庆遍变秋天啦。<br>被窝暖和得，真是让人忍不住生出翘掉第一节课、多睡会的念头呢。<br>第一节课是数据结构，刚开始上课，老师就说:“我先来确认一下，上次没来上课的同学，这次来了没有。就不点全班了。”<br>关键之处在于，这位大长腿老师上课缺勤扣分，是按照n^n分扣的，第三次没来扣27分，基本就离重修不远了。<br>因为大长腿老师的家在D区，其他两位数据结构课的老师都不在这边住，所以补考也是他负责。<br>于是一位十分有勇气的同学，听到这里便悄悄溜走，提前搭上了国庆回家的动车。<br>课间过后，“我们来点一次名吧。”  </p><h3 id="要开始认真起来了！"><a href="#要开始认真起来了！" class="headerlink" title="要开始认真起来了！"></a>要开始认真起来了！</h3><p>嗯，先立个flag在这里，国庆节就算图书馆闭馆也要早睡早起好好学习唷~</p>]]></content>
      
      
      <categories>
          
          <category> DAIの日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在mac平台上搭建汇编语言的开发环境</title>
      <link href="/mac-assembly/"/>
      <url>/mac-assembly/</url>
      
        <content type="html"><![CDATA[<h3 id="搭建前准备"><a href="#搭建前准备" class="headerlink" title="搭建前准备"></a>搭建前准备</h3><ul><li><a href="http://www.dosbox.com/" title="DOSBox" target="_blank" rel="noopener">DOSBox</a>（进入下载页后选择Mac OS X版本）</li><li><a href="http://www.masm32.com/" title="masm.exe" target="_blank" rel="noopener">masm.exe</a></li><li>debug.exe</li><li>link.exe  </li><li>etc…</li></ul> <a id="more"></a> <h3 id="安装DOSBox"><a href="#安装DOSBox" class="headerlink" title="安装DOSBox"></a>安装DOSBox</h3><p>解压下载好的DOSBox安装包，自选一个路径（为了方便，我直接在用户目录下新建一个文件夹名为“Debug”）<br>将DOSBox图标拖入Finder中的Application<br>将安装包的内容，以及准备好的各种.exe 放入该文件夹中</p><h3 id="DOSBox-Debug进行汇编语言的编写"><a href="#DOSBox-Debug进行汇编语言的编写" class="headerlink" title="DOSBox+Debug进行汇编语言的编写"></a>DOSBox+Debug进行汇编语言的编写</h3><p>打开DOSBox，输入mount c Debug文件夹所在路径:<br><code>mount c /Users/你的用户名/Debug</code><br>  回车<br><code>Drive C is mounted as local directory /Users/你的用户名/Debug</code><br>接着输入：<br><code>c：</code><br><code>dir</code><br>显示该文件夹的所有文件，选择:<br><code>DEBUG</code><br>至此，就可以开始进行汇编语言的编写啦。</p>]]></content>
      
      
      <categories>
          
          <category> Mac OS X </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未完待续 </title>
      <link href="/to-be-continued%20/"/>
      <url>/to-be-continued%20/</url>
      
        <content type="html"><![CDATA[<h3 id="银杏叶的前世今生"><a href="#银杏叶的前世今生" class="headerlink" title="银杏叶的前世今生"></a>银杏叶的前世今生</h3><p>高三的时候，秋季，每次在食堂用完餐，总会绕路从那两棵银杏叶树下走回教室。银杏叶的金黄色总让人觉得很温暖，像是…向日葵，又或者是，那位葵光少年。<br>晴天，忍不住被它们吸引，又生怕自己把它们踩坏了，所以总是脚步放得很轻地走过去。可以闻到银杏叶的气息，嗯…是太阳的味道。<br> <a id="more"></a><br>雨天，脚踩上去，啪嗒啪嗒地响。雨让它们腐烂在潮湿的泥土里，是来送它们离开的。又或者是将它们洗净，以最温暖的颜色。<br>恰逢一位友人十八岁生日，在写给他的信中，夹了两片银杏叶，漂洋过海，随之寄去。</p><p>去年秋季，CQU的银杏叶落满了整整两条大道，壮观极了，会让人充满斗志，觉得，秋天也是满怀希望的季节呢。<br>好几次想捡起一片银杏叶，把秋天的气息封存，结果等到自己再想去捡的时候，它们已经离开了呢,真是遗憾。<br>幸运的是，那位友人在我生日的时候，将高三那年的银杏叶又寄还于我٩( ˃̶͈̀௰˂̶͈́ )و可以说是非常幸运啦<br>想来也并不奇怪，高中母校银杏树的数量全然不敌大学，但是那时候的经历与感受，却重过太多。嗯…明白这只是人类的通病，回忆总感觉比现在的生活要美好，不过我想说，现在的生活也非常美好呢。<br>对了，CQU的银杏又快变成温暖的颜色了，欢迎来玩~<br><img src="http://www.z4a.net/images/2017/09/17/9172.jpg" alt=""></p><p>高中语文课上:”你们最向往的生活是怎样的生活？”<br>“现在的生活。因为它，刚刚好。”</p><h3 id="准程序员的生活"><a href="#准程序员的生活" class="headerlink" title="准程序员的生活"></a>准程序员的生活</h3><p>唔…今天早上爬起来，完善了博客网页的部分功能。<br>经过了非常艰难的努力…终于将gitment的评论功能添加上了，但还有点小问题(不登录github帐号无法查看评论)。不过我已经非常满足啦。<br>添加了leancloud的文章阅读次数统计功能( &gt; &lt;虽然这是一个除了自己没人看的博客）  </p><p>想起数据结构课上老师提到的那个悖论:一个由所有集合的组成集合，感觉可以默默记很久…虽然我觉得我更应该记住的是课本上的知识ORZ</p>]]></content>
      
      
      <categories>
          
          <category> DAIの日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的定义</title>
      <link href="/theprogrammer/"/>
      <url>/theprogrammer/</url>
      
        <content type="html"><![CDATA[<p>昨天的数据结构课上，因某些原因，来了一位代课的老师。<br>还没上课的时候，他就和大家说起话来。他的头发已经白去好多，但整个人的精神状态却是很好。可以感觉到，他年轻时候一定是一位更加认真的老师。<br> <a id="more"></a><br>上课的内容是链表，有些枯燥无聊。<br>昏昏欲睡的时候，听老师无意中提起，在汶川大地震时候他正在睡觉，被震醒，醒来的第一反应是下床拿着电脑和移动硬盘跑出去。他说，那些数据就是他的生命，不能丢。<br>程序员的定义吗，好像比较简单，又不那么简单。</p>]]></content>
      
      
      <categories>
          
          <category> DAIの日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Programmiao</title>
      <link href="/Hello-Programmiao/"/>
      <url>/Hello-Programmiao/</url>
      
        <content type="html"><![CDATA[<p>从搭建个人博客的想法萌生到建成，历时两天，终于初步完工啦。<br> <a id="more"></a><br>往后的日子里会用心学习编程，也会好好管理它，这是来自一个准程序员的承诺。</p>]]></content>
      
      
      <categories>
          
          <category> DAIの日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂念 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<ul><li>前端</li><li>计算机基础<ul><li>计算机网络</li><li>操作系统</li></ul></li><li>软件工程</li><li>编程语言</li><li>大数据分析</li><li>Mac OS X</li><li>DAIの日常</li><li>DAIの折腾</li><li>DAIの实验室</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<ul><li>note</li><li>hexo</li><li>Typecho</li><li>Web</li><li>机器学习</li><li>图形学</li><li>杂念</li><li>配置环境</li><li>leetcode</li><li>hadoop</li><li>大数据</li><li>Docker</li><li>hive</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>About me</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<ul><li>软件工程在读</li><li>超会写bug的程序miao</li><li>邮箱: <a href="mailto:daisine@outlook.com" target="_blank" rel="noopener">daisine@outlook.com</a>   </li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>List</title>
      <link href="/list/index.html"/>
      <url>/list/index.html</url>
      
        <content type="html"><![CDATA[<h4 id="大三-上-课程日历"><a href="#大三-上-课程日历" class="headerlink" title="大三 上 课程日历"></a>大三 上 课程日历</h4><table><thead><tr><th>课程</th><th>开课日期</th></tr></thead><tbody><tr><td>信息安全导论</td><td><del><code>第1周周一</code> 9/3</del></td></tr><tr><td>计算机图形学</td><td><del><code>第1周周一</code> 9/3</del></td></tr><tr><td>面向对象与UML</td><td><del><code>第1周周二</code> 9/4</del></td></tr><tr><td>机器学习与模式识别</td><td><del><code>第1周周三</code> 9/5</del></td></tr><tr><td>web开发技术</td><td><del><code>第1周周三</code> 9/5</del></td></tr><tr><td>软件需求分析</td><td><code>第11周周二</code> 11/13</td></tr><tr><td>多媒体技术</td><td><code>第12周周一</code> 11/19</td></tr><tr><td>大数据与软件工程导论</td><td><code>第12周周二</code> 11/20</td></tr><tr><td>DirectX图形程序设计</td><td><code>第13周周一</code> 11/26</td></tr></tbody></table><h4 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h4><div class="tip"> 挣扎月：“Make something better today!” </div><ul><li><del>逛宜家 建新窝</del></li><li><del>UML原型Demo</del></li><li><del>计算机图形学实验</del></li><li><strong>机器学习项目(latex)</strong></li><li><strong>web实验+笔记</strong></li><li>练硬笔字 </li><li>python 基础</li><li>html &amp; CSS基础</li><li>程序设计算法</li><li>英语语法.md</li><li>背单词</li><li>买烤箱，厨房置物架</li></ul><h4 id="大二-下-课程日历"><a href="#大二-下-课程日历" class="headerlink" title="大二 下 课程日历"></a>大二 下 课程日历</h4><table><thead><tr><th>课程</th><th>考试日期</th></tr></thead><tbody><tr><td><del>数据库原理</del></td><td><del><code>第13周周四</code> 5/31 10:30-12:30</del></td></tr><tr><td><del>计算机网络与通信</del></td><td><del><code>第14周周四</code> 6/7 15:50-17:50</del></td></tr><tr><td><del>软件工程导论</del></td><td><del><code>第15周周四</code> 6/14 10:30-12:30</del></td></tr><tr><td><del>操作系统原理</del></td><td><del><code>第16周周四</code> 6/21 15:50-17:50</del></td></tr><tr><td><del>马克思主义基本原理</del></td><td><del><code>第17周周日</code> 7/1 9:00-10:30</del></td></tr><tr><td><del>Java</del></td><td><del><code>第18周周四</code> 7/5 10:30-12:30</del></td></tr></tbody></table><h4 id="暑假月清单"><a href="#暑假月清单" class="headerlink" title="暑假月清单"></a>暑假月清单</h4><div class="tip"> 暑假月：“ 每天认真吃饭，早睡早起！”</div><ul><li><del>C++ &amp; C基本语法</del></li><li>程序设计算法</li><li>买个小烤箱嘻嘻嘻 <code>不买啦，没钱也没位置放(~~借口~~)</code></li></ul><h4 id="清单-1"><a href="#清单-1" class="headerlink" title="清单"></a>清单</h4><div class="tip"> 咸鱼月：“ 期末月要注意作息和情绪调节喵！”</div><ul><li><del>计网.md</del></li><li><del>软工复习.md</del></li><li><del>操作系统.md</del></li><li><del>Java基础</del></li><li><del>数据库课程设计 <code>DDL: 7/2</code></del></li><li><del>周末在家做一顿好吃的饭</del></li><li><del>英语诗歌论文</del></li><li>把以前的代码整理到<code>github</code>上</li><li>读一本闲书</li></ul><div class="tip">卡莲 · 第六夜想曲: “ 你的心，就由我收下了~”</div><ul><li><del>软工需求+设计</del></li><li><del>数据库原理.md</del></li><li><del>数据库实验</del></li><li><del>计网实验</del></li><li><del>操作系统实验</del></li><li>整理C语言.md</li><li>swift启动~</li><li><del>趁天气好的时候溜出去晒太阳！</del></li></ul>]]></content>
      
    </entry>
    
    
  
</search>
