<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="计算机图形学笔记及练习"><meta name="keywords" content="note,图形学"><meta name="author" content="Dai Sine"><meta name="copyright" content="Dai Sine"><title>计算机图形学笔记及练习 | Hi, Dai</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-117497526-4', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-计算机图形学概述"><span class="toc-text">1. 计算机图形学概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-研究内容"><span class="toc-text">1.1 研究内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-计算机图形学的发展历史"><span class="toc-text">1.2 计算机图形学的发展历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-图形软件发展及软件标准的形成"><span class="toc-text">1.3 图形软件发展及软件标准的形成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-当前研究热点"><span class="toc-text">1.4 当前研究热点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-图形系统"><span class="toc-text">1.5 图形系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#图形输入设备"><span class="toc-text">图形输入设备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#图形处理器-显卡"><span class="toc-text">图形处理器(显卡)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#图形显示设备"><span class="toc-text">图形显示设备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#阴极射线管-CRT-P9"><span class="toc-text">阴极射线管(CRT) P9</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#彩色阴极射线管"><span class="toc-text">彩色阴极射线管</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#射线穿透法"><span class="toc-text">射线穿透法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#影孔板法-P10"><span class="toc-text">影孔板法 P10</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#栅线式-vs-点阵式"><span class="toc-text">栅线式 vs 点阵式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#荫罩式显示器的固有缺陷"><span class="toc-text">荫罩式显示器的固有缺陷</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#随机扫描显示系统特点"><span class="toc-text">随机扫描显示系统特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#光栅扫描的显示系统特点"><span class="toc-text">光栅扫描的显示系统特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#光栅图形显示系统"><span class="toc-text">光栅图形显示系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#帧缓存与显示器分辨率的关系"><span class="toc-text">帧缓存与显示器分辨率的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#显存问题"><span class="toc-text">显存问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#带宽问题"><span class="toc-text">带宽问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#光栅显示系统的特点"><span class="toc-text">光栅显示系统的特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LCD显示器"><span class="toc-text">LCD显示器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-计算机图形学的应用及研究前沿"><span class="toc-text">1.6 计算机图形学的应用及研究前沿</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-基本图形的生成算法"><span class="toc-text">2.基本图形的生成算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-直线绘制算法"><span class="toc-text">2.1 直线绘制算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#直线段的扫描转换"><span class="toc-text">直线段的扫描转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数值微分-DDA-算法"><span class="toc-text">数值微分(DDA)算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#中点算法"><span class="toc-text">中点算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#增量法改进："><span class="toc-text">增量法改进：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Bresenham算法"><span class="toc-text">Bresenham算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#改进的Bresenham算法"><span class="toc-text">改进的Bresenham算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-圆的生成"><span class="toc-text">2.2 圆的生成</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#中点画圆法"><span class="toc-text">中点画圆法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#增量算法避免重复计算"><span class="toc-text">增量算法避免重复计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#中点算法小结"><span class="toc-text">中点算法小结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#生成圆弧的Bresenham法"><span class="toc-text">生成圆弧的Bresenham法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-椭圆的生成"><span class="toc-text">2.3 椭圆的生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-多边形的扫描转换"><span class="toc-text">2.4 多边形的扫描转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-实区域填充算法"><span class="toc-text">1. 实区域填充算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-多边形种类"><span class="toc-text">2. 多边形种类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-如何表示多边形"><span class="toc-text">3. 如何表示多边形</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-多边形的扫描转换-扫描线算法-多边形的有序边表法"><span class="toc-text">4. 多边形的扫描转换 / 扫描线算法 / 多边形的有序边表法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#扫描线算法步骤"><span class="toc-text">扫描线算法步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#边填充算法"><span class="toc-text">边填充算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#边界标志法-P27"><span class="toc-text">边界标志法 P27</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-区域-种子-填充算法"><span class="toc-text">2.5  区域(种子)填充算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#区域填充"><span class="toc-text">区域填充</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#种子填充的一种非递归-栈-算法"><span class="toc-text">种子填充的一种非递归(栈)算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#种子填充的扫描线算法"><span class="toc-text">种子填充的扫描线算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#多边形扫描转换-A-与区域填充方法-B-比较"><span class="toc-text">多边形扫描转换(A)与区域填充方法(B)比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-字符"><span class="toc-text">2.6 字符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#字符的表示和输出"><span class="toc-text">字符的表示和输出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-反走样"><span class="toc-text">2.7 反走样</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-三维图形的剪裁"><span class="toc-text">3. 三维图形的剪裁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-直线段裁剪"><span class="toc-text">3.1 直线段裁剪</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Cohen-Sutherland算法"><span class="toc-text">Cohen-Sutherland算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#中点分割剪裁算法"><span class="toc-text">中点分割剪裁算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-多边形裁剪"><span class="toc-text">3.2 多边形裁剪</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Sutlerland-Hodgman算法-逐边裁剪算法"><span class="toc-text">Sutlerland-Hodgman算法 / 逐边裁剪算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Weiler-Atherton算法"><span class="toc-text">Weiler-Atherton算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-字符裁剪"><span class="toc-text">3.3 字符裁剪</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-图形的变换"><span class="toc-text">4. 图形的变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-图形变换的数学基础"><span class="toc-text">4.1 图形变换的数学基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-二维几何变换"><span class="toc-text">4.2 二维几何变换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#齐次坐标"><span class="toc-text">齐次坐标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#几何变换"><span class="toc-text">几何变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#复杂变换"><span class="toc-text">复杂变换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-窗口到视区的变换"><span class="toc-text">4.3 窗口到视区的变换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#基本概念"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#窗口到视区变换"><span class="toc-text">窗口到视区变换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-三维几何变换"><span class="toc-text">4.4 三维几何变换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#三维齐次坐标"><span class="toc-text">三维齐次坐标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#三维几何变换"><span class="toc-text">三维几何变换</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-投影"><span class="toc-text">5. 投影</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-三维图形显示的基本问题"><span class="toc-text">5.1 三维图形显示的基本问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#三维图形显示的基本研究内容"><span class="toc-text">三维图形显示的基本研究内容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-平面几何投影"><span class="toc-text">5.2 平面几何投影</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#透视投影"><span class="toc-text">透视投影</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#平行投影"><span class="toc-text">平行投影</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#斜投影"><span class="toc-text">斜投影</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#投影总结"><span class="toc-text">投影总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-投影变换-amp-投影举例"><span class="toc-text">5.3 投影变换 &amp; 投影举例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#建立观察坐标系"><span class="toc-text">建立观察坐标系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#用户坐标到观察坐标的变换"><span class="toc-text">用户坐标到观察坐标的变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#视见体-View-Port"><span class="toc-text">视见体(View Port)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#透视投影变换"><span class="toc-text">透视投影变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#斜平行投影"><span class="toc-text">斜平行投影</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#从世界坐标系到观察坐标系的变换"><span class="toc-text">从世界坐标系到观察坐标系的变换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-规范视见体变换-规范裁剪空间"><span class="toc-text">5.4 规范视见体变换 / 规范裁剪空间</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#何时裁剪"><span class="toc-text">何时裁剪</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-隐藏面的消除"><span class="toc-text">6. 隐藏面的消除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-基本概念"><span class="toc-text">6.1 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-提高消隐算法效率的常见方法"><span class="toc-text">6.2 提高消隐算法效率的常见方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#包含消隐的三维图形显示流程图："><span class="toc-text">包含消隐的三维图形显示流程图：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#消隐的基本-核心-问题-排序"><span class="toc-text">消隐的基本(核心)问题:排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-画家算法"><span class="toc-text">6.3 画家算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-Z缓冲器算法"><span class="toc-text">6.4 Z缓冲器算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-扫描线Z缓冲器算法"><span class="toc-text">6.5 扫描线Z缓冲器算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-区间扫描线算法"><span class="toc-text">6.6 区间扫描线算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-区域子分割算法"><span class="toc-text">6.7 区域子分割算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-光线投射算法"><span class="toc-text">6.8 光线投射算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-真实感图形的生成"><span class="toc-text">7. 真实感图形的生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-简单光照明模型"><span class="toc-text">7.1 简单光照明模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Phong光照明模型"><span class="toc-text">Phong光照明模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-多边形表示的明暗处理"><span class="toc-text">7.2 多边形表示的明暗处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Gouraud明暗处理-双线性光强插值"><span class="toc-text">Gouraud明暗处理(双线性光强插值)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Phong明暗处理-双线性法向插值"><span class="toc-text">Phong明暗处理 (双线性法向插值)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#阴影的生成"><span class="toc-text">阴影的生成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-透明"><span class="toc-text">7.3 透明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Whitted光透射模型"><span class="toc-text">Whitted光透射模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Hall光透射模型"><span class="toc-text">Hall光透射模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-整体光照明模型"><span class="toc-text">7.4 整体光照明模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-光线跟踪算法-P149"><span class="toc-text">7.5 光线跟踪算法 P149</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#递归终止条件"><span class="toc-text">递归终止条件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-纹理"><span class="toc-text">7.6 纹理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图形学题目"><span class="toc-text">图形学题目</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Dai Sine</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">50</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">8</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2019/05/10/5cd525fea97ac.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Hi, Dai</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">计算机图形学笔记及练习</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-21</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/计算机基础/">计算机基础</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="1-计算机图形学概述"><a href="#1-计算机图形学概述" class="headerlink" title="1. 计算机图形学概述"></a>1. 计算机图形学概述</h2><h3 id="1-1-研究内容"><a href="#1-1-研究内容" class="headerlink" title="1.1 研究内容"></a>1.1 研究内容</h3><ul>
<li><code>图形</code>含有几何属性，或者说更强调场景的集合表示，是由场景的几何模型和警务的物理属性共同组成。（矢量/参数）</li>
<li><code>图像</code>是指计算机内以位图形式存在的灰度信息。（位图）</li>
<li><code>计算机图形学</code>：利用计算机研究一系列原理、方法与技术的学科。<a id="more"></a> 
<ul>
<li>图形的表示和生成：如何对数据建模，并将数据转换为图像？</li>
<li>图形的处理和显示：如何在专门的显示设备上显示图形？</li>
</ul>
</li>
<li>一个完整的图形处理过程包括：<ul>
<li>图形的输入</li>
<li>图形的处理</li>
<li>图形的输出</li>
</ul>
</li>
</ul>
<h3 id="1-2-计算机图形学的发展历史"><a href="#1-2-计算机图形学的发展历史" class="headerlink" title="1.2 计算机图形学的发展历史"></a>1.2 计算机图形学的发展历史</h3><ul>
<li>50年代，CTR的出现为计算机生成和显示图形提供了可能。</li>
<li>50年代末期，MIT的林肯实验室在“旋风”计算机上开发SAGE空中防御体系，通过光笔在屏幕上指点与系统交互，<strong>标志着交互式图形技术的诞生。</strong></li>
<li>60年代<ul>
<li>MIT林肯实验室的<strong>I. E. Sutherland</strong>发表了一片题为“<strong>Sketchpad：一个人机交互通信的图形系统</strong>”的博士论文，确定了交互图形学作为一个学科分支。</li>
<li>法国雷诺汽车公司的工程师Pierre Bezier提出 Bezier曲线、曲面的理论，而称为计算机辅助几何设计(CAGD)的先驱。</li>
<li>MIT的教书 Steven A. Coons提出了超限插值的新思想，通过插值四条任意便捷的曲线来构造曲面，</li>
</ul>
</li>
<li>70年代<ul>
<li>光栅图形学迅速发展</li>
<li>图形软件标准化：ISO发布CGI、CGM、GKS、PHIGS</li>
<li>真实感图形学和实体造型技术：(1970)Bouknight提出第一个光反射模型；(1971)Gourand提出“漫反射模型 + 插值”的思想，被称为Gourand明暗处理；(1975)Phong提出著名的简单光照模型-Phong模型。</li>
</ul>
</li>
</ul>
<h3 id="1-3-图形软件发展及软件标准的形成"><a href="#1-3-图形软件发展及软件标准的形成" class="headerlink" title="1.3 图形软件发展及软件标准的形成"></a>1.3 图形软件发展及软件标准的形成</h3><ul>
<li>近二十年，国际标准化组织ISO已经批准和正在讨论的与计算机图形有关的标准有：<ul>
<li>GKS、GKS-3D、PHIGS、CGM、CGI、IGES、STEP</li>
</ul>
</li>
<li>事实标准<ul>
<li>SGI的OpenGL，微软的Direct X，Adobe的Postscript等。  </li>
</ul>
</li>
</ul>
<h3 id="1-4-当前研究热点"><a href="#1-4-当前研究热点" class="headerlink" title="1.4 当前研究热点"></a>1.4 当前研究热点</h3><ul>
<li>造型技术</li>
<li>真实感图形绘制技术</li>
<li>人机交互技术</li>
<li>与计算机网络技术的紧密结合<ul>
<li>远程导航与维修</li>
<li>远程教育</li>
</ul>
</li>
<li>图像生成技术与图像处理的结合</li>
<li>虚拟现实技术</li>
</ul>
<h3 id="1-5-图形系统"><a href="#1-5-图形系统" class="headerlink" title="1.5 图形系统"></a>1.5 图形系统</h3><p>一个图形系统通常由：图形处理器、图形输入设备和图形输出设备构成。</p>
<h5 id="图形输入设备"><a href="#图形输入设备" class="headerlink" title="图形输入设备"></a>图形输入设备</h5><ul>
<li>鼠标</li>
<li>键盘：输入控制命令，利用光标指示对象与位置。</li>
<li>光笔：一种检测光的装置。P13 <strong>考核原理，判断正误</strong></li>
<li>数字化仪：数控板/手写板</li>
<li>扫描仪：直接把图形和图像扫描到计算机中以像素信息进行存储的设备。 <ul>
<li>光学信号 -&gt; 模拟信号 -&gt; 数字信号</li>
</ul>
</li>
<li>触摸屏，3D图形输入设备</li>
</ul>
<h5 id="图形处理器-显卡"><a href="#图形处理器-显卡" class="headerlink" title="图形处理器(显卡)"></a>图形处理器(显卡)</h5><ul>
<li>显示主芯片是显卡的核心，俗称GPU</li>
<li>显存用于存储将要现实的图形信息及保存图形运算的中间数据。</li>
</ul>
<h5 id="图形显示设备"><a href="#图形显示设备" class="headerlink" title="图形显示设备"></a>图形显示设备</h5><ul>
<li>图形输出包括图形的显示和图形的绘制<ul>
<li><code>图形显示</code>指的是在屏幕上输出图形。</li>
<li><code>图形绘制</code>通常指把图形画在纸上(硬拷贝)，如打印机和绘图仪</li>
</ul>
</li>
<li>显示器分类：<ul>
<li>CRT显示器</li>
<li>平板显示器</li>
</ul>
</li>
</ul>
<h5 id="阴极射线管-CRT-P9"><a href="#阴极射线管-CRT-P9" class="headerlink" title="阴极射线管(CRT) P9"></a>阴极射线管(CRT) P9</h5><ul>
<li>CRT显示器分类<ul>
<li>视觉属性：单色CRT，彩色CRT</li>
<li>偏转系统：偏转电场式，偏转磁场式</li>
<li>扫描方式：随机扫描，光栅扫描  </li>
</ul>
</li>
<li>组成：<ul>
<li>电子枪</li>
<li>聚焦系统</li>
<li>加速电极</li>
<li>偏转系统</li>
<li>荧光屏</li>
</ul>
</li>
<li>工作原理<ul>
<li>电子枪发射电子束</li>
<li>经过聚焦系统、加速电极、偏转系统，轰击到荧光屏的不同部位，被其表面的荧光物质吸收，发光产生可见的图形。</li>
<li>为要保持一幅稳定的画面，必须不断地发射电子束(<strong>不断刷新</strong>)，以抵消亮度的衰减。 </li>
</ul>
</li>
<li>电子枪 <ul>
<li>阴极：电流通过，灯丝加热，发出电子束。</li>
<li>控制栅：通过调节负电压来控制电子数量，即控制荧光屏上相应点的亮度。</li>
</ul>
</li>
<li>聚焦系统：通过电场和磁场控制电子束变细，保证亮点足够小，提高分辨率。</li>
<li>加速电极：加正的高电压(几万伏)，使电子达到轰击激发荧光屏应有的速度</li>
<li>偏转系统<ul>
<li>控制静电场或磁场，使电子束偏转。</li>
<li>最大的偏转角是系统性能的最重要的指标，显示器长短与此有关。</li>
<li>CRT显示器屏幕越大，整个显像管就越长。</li>
</ul>
</li>
<li>荧光屏<ul>
<li>荧光物质：吸收电子束而发光</li>
<li>余辉时间：持续发光时间。电子束离开某点后，该点的亮度值衰减到初始值。</li>
<li>刷新：为了让荧光物质保持在一个稳定的亮度值。</li>
<li>刷新频率：每秒重绘屏幕次数，显示器更新图像的速率。  </li>
<li>光点：电子束打在荧光屏上，显示器能显示的最小的发光点。</li>
<li>像素：构成屏幕的最小元素。</li>
<li>图形显示在屏幕上时，按当前的图形显示分辨率所能提供的最小元素点。像素点可看做光点的集合，其最小尺寸等于光点。</li>
<li>屏幕分辨率/光栅分辨率：是物理分辨率，CRT在水平或者竖直方向单位长度上能识别的最大像素个数，单位通常为dip。</li>
<li>显示分辨率：计算机显示控制器所提供的显示模式分辨率。</li>
</ul>
</li>
</ul>
<blockquote>
<p>P9 <strong>考点</strong> 假设荧光物质的持续发光时间为40ms 则，CRT产生稳定图像所需要的<strong>最小刷新频率 = 1秒/荧光物质的持续发光时间= 1000/40ms = 25 Hz</strong><br>只有刷新频率高达一定值后，图像才能稳定显示，约为每秒60帧(60Hz)。一般必须要有85Hz以上的刷新频率。</p>
</blockquote>
<h5 id="彩色阴极射线管"><a href="#彩色阴极射线管" class="headerlink" title="彩色阴极射线管"></a>彩色阴极射线管</h5><ul>
<li>彩色CRT：通过将能发不同颜色的光的荧光物质进行组合而产生彩色。<ul>
<li><strong>渗透性 - 射线穿透法</strong>：常用于随机扫描显示器。</li>
<li><strong>多枪型 - 影孔板法</strong>：常用于光栅扫描显示器。</li>
</ul>
</li>
</ul>
<h5 id="射线穿透法"><a href="#射线穿透法" class="headerlink" title="射线穿透法"></a>射线穿透法</h5><ul>
<li>屏幕内表面涂有两层荧光涂层。红色光和绿色光两种发光物质，不同速度电子束穿透荧光层的深浅，决定所产生的颜色。</li>
<li>应用：主要用于画线显示器</li>
<li>优点：成本低</li>
<li>缺点：只能产生有限几种颜色</li>
</ul>
<h5 id="影孔板法-P10"><a href="#影孔板法-P10" class="headerlink" title="影孔板法 P10"></a>影孔板法 P10</h5><ul>
<li>影孔板被安装在荧光屏的内表面，用于精确定位像素的位置。</li>
<li>分类： <ul>
<li><strong>点阵式</strong>：球面显像管。</li>
<li><strong>栅线式</strong>：柱面显像管，如日本索尼公司的特丽珑管，三菱公司的钻石龙管。</li>
<li><strong>栅格式/沟槽式</strong>：LG的未来窗显像管。</li>
</ul>
</li>
<li>工作原理：<ul>
<li>三基色(红绿蓝)，三色荧光点，三只电子枪。</li>
<li>电子枪、影孔板中的一个小孔和对应的荧光点呈一直线。</li>
<li>每个小孔与一个像素（即三个荧光点）对应。</li>
<li>调节各电子枪发生的电子束中所含电子的数目，即可控制各色光点亮度。<br><img src="/CG/影孔板.png" width="30%"></li>
</ul>
</li>
<li>显示器能同时显示的颜色个数：如果每支电子枪发出的电子束的强度有256个等级，则显示 器能同时显示<code>256*256*256=16M</code>种颜色，称为真彩系统。</li>
</ul>
<h5 id="栅线式-vs-点阵式"><a href="#栅线式-vs-点阵式" class="headerlink" title="栅线式 vs 点阵式"></a>栅线式 vs 点阵式</h5><ul>
<li>原理的区别：光线的选择方式和荧光点的排列不同</li>
<li>点阵式的缺点：<ul>
<li>用于球面荧光屏，几何失真大。</li>
<li>三角形的荧光点排列，即使很密很细也不会特别清晰。</li>
</ul>
</li>
<li>栅线式的优点：<ul>
<li>亮度更高，色彩也更鲜艳。</li>
<li>用于高分辨率的柱面和平面显示器。</li>
<li>电子束通过率有很大的提高。 </li>
</ul>
</li>
</ul>
<h5 id="荫罩式显示器的固有缺陷"><a href="#荫罩式显示器的固有缺陷" class="headerlink" title="荫罩式显示器的固有缺陷"></a>荫罩式显示器的固有缺陷</h5><ul>
<li>由合金钢板制成的荫罩<strong>易磁化</strong></li>
<li>受热受冲击时<strong>易变形</strong><ul>
<li>显像管内射向荧光屏的电子束中有75% 以上被荫罩阻挡，转变成热量浪费了</li>
</ul>
</li>
<li>屏幕尺寸越大或清晰度越高，就越难制造， <strong>生产成本高</strong>，成品率偏低，价格过高</li>
<li>制约彩色显像管<strong>清晰度</strong>提高的技术<strong>瓶颈</strong>是彩色显像管中的荫罩</li>
</ul>
<h5 id="随机扫描显示系统特点"><a href="#随机扫描显示系统特点" class="headerlink" title="随机扫描显示系统特点"></a>随机扫描显示系统特点</h5><ul>
<li>数据表示：矢量表示，只有端点信息，无线段中间点</li>
<li>扫描方式：电子束像一支快速移动的画笔，在任意方向上自由移动，<br>按照显示命令用画线的方式绘出图形</li>
<li>显示图形：几何属性为主，线框图形</li>
<li>别称：矢量扫描显示器，画线显示器</li>
<li>优点：扫描速度快，分辨率高，线条质量好，易修改，交互性好，<br>动态性能好</li>
<li>缺点：价格贵，只能显示线框图形，应用于军事、CAD领域</li>
</ul>
<h5 id="光栅扫描的显示系统特点"><a href="#光栅扫描的显示系统特点" class="headerlink" title="光栅扫描的显示系统特点"></a>光栅扫描的显示系统特点</h5><ul>
<li>数据表示：像素矩阵，像素数组</li>
<li>扫描方式：从上到下，从左到右，与电视工作原理类似</li>
<li>显示图形：几何属性＋视觉属性(Visual attribute) , 真实<br>感图形</li>
</ul>
<h5 id="光栅图形显示系统"><a href="#光栅图形显示系统" class="headerlink" title="光栅图形显示系统"></a>光栅图形显示系统</h5><ul>
<li>显示处理器：主要任务是将应用程序定义为一组像素强度值，存放在帧缓冲存储器中。</li>
<li>帧缓冲存储器：俗称<strong>显存</strong>，保存了对应屏幕所有亮点的亮度值。</li>
<li>视频控制器：建立帧缓存与屏幕像素之间一一对应，负责刷新。</li>
<li>CRT显示器</li>
</ul>
<p><img src="/CG/光栅图形.png" width="50%"></p>
<h5 id="帧缓存与显示器分辨率的关系"><a href="#帧缓存与显示器分辨率的关系" class="headerlink" title="帧缓存与显示器分辨率的关系"></a>帧缓存与显示器分辨率的关系</h5><ul>
<li>帧缓存的大小 =  显示器分辨率的大小 * 帧缓存的位平面数 / 8</li>
<li>eg. 分辨率为640x480、1280x1024、1024x1024的显示器各需要多少字节位平面数为24的帧缓存？ans: 分辨率*24/8</li>
</ul>
<h5 id="显存问题"><a href="#显存问题" class="headerlink" title="显存问题"></a>显存问题</h5><ul>
<li>高分辨率和真彩要求有大的显存：1024x1024真彩模式需要3M字节显存。</li>
<li>解决办法：<ul>
<li>采用<strong>查色表</strong>或者称彩色表机制。</li>
<li>采用<strong>隔行扫描</strong>的方法。</li>
</ul>
</li>
</ul>
<h5 id="带宽问题"><a href="#带宽问题" class="headerlink" title="带宽问题"></a>带宽问题</h5><ul>
<li>带宽T与分辨率(M<em>N)、帧频(刷新频率)F的关系：`T &gt;= M </em> N * F`</li>
<li>高分辨率和高刷新频率要求高带宽</li>
<li>解决办法：<ul>
<li>隔行扫描(现在一般用逐行扫描)</li>
<li>对Z缓冲期内容进行压缩和快速清除。</li>
</ul>
</li>
</ul>
<h5 id="光栅显示系统的特点"><a href="#光栅显示系统的特点" class="headerlink" title="光栅显示系统的特点"></a>光栅显示系统的特点</h5><ul>
<li>优点<ul>
<li>成本低</li>
<li>易于绘制填充图形</li>
<li>色彩丰富</li>
<li>刷新频率一定，与图形的复杂度无关</li>
<li>易于修改图形</li>
</ul>
</li>
<li>缺点<ul>
<li>需要扫描转换</li>
<li>扫描转换速度偏低，交互操作响应慢</li>
<li>分辨率偏低，有阶梯效应，会产生走样  </li>
</ul>
</li>
</ul>
<h5 id="LCD显示器"><a href="#LCD显示器" class="headerlink" title="LCD显示器"></a>LCD显示器</h5><ul>
<li>优点<ul>
<li>外观小巧精致，厚度只有6.5-Bcm左右</li>
<li>响应速度快、无闪烁、无干扰</li>
<li>工作电压低，功耗小，省电</li>
<li>没有电磁辐射，对人体健康没有任何影响</li>
</ul>
</li>
<li>缺点<ul>
<li>成品率偏低导致成本偏高，冷阴极荧光灯的使用寿命井不算太长，可<br>视角度有限</li>
</ul>
</li>
</ul>
<h3 id="1-6-计算机图形学的应用及研究前沿"><a href="#1-6-计算机图形学的应用及研究前沿" class="headerlink" title="1.6 计算机图形学的应用及研究前沿"></a>1.6 计算机图形学的应用及研究前沿</h3><ul>
<li>计算机辅助设计与制造</li>
<li>可视化</li>
<li>真实感图形实时绘制与自然景物仿真 </li>
<li>计算机动画</li>
<li>用户接口</li>
<li>计算机艺术</li>
</ul>
<h2 id="2-基本图形的生成算法"><a href="#2-基本图形的生成算法" class="headerlink" title="2.基本图形的生成算法"></a>2.基本图形的生成算法</h2><p><img src="/CG/基本图形.png" width="60%"></p>
<h3 id="2-1-直线绘制算法"><a href="#2-1-直线绘制算法" class="headerlink" title="2.1 直线绘制算法"></a>2.1 直线绘制算法</h3><ul>
<li>光栅平面的显示图形<ul>
<li>在光栅显示平面上，我们只能用二维光栅网格上<strong>尽可能靠近</strong>这条直线的象素集合来表示它。</li>
<li>每个象素具有一定的尺寸，是显示平面上可被访问的最小单位，</li>
<li>它的<strong>坐标x和y只能是整数</strong>，也就是说相邻象素的坐标值是阶跃的而不是连续的。</li>
</ul>
</li>
</ul>
<h5 id="直线段的扫描转换"><a href="#直线段的扫描转换" class="headerlink" title="直线段的扫描转换"></a>直线段的扫描转换</h5><ul>
<li>两点确定一条直线</li>
<li>通过直线的两个点的坐标计算出斜率和截距，确定直线方程。</li>
<li>通过x值确定每一个y的值，并舍入y的值。</li>
</ul>
<h5 id="数值微分-DDA-算法"><a href="#数值微分-DDA-算法" class="headerlink" title="数值微分(DDA)算法"></a>数值微分(DDA)算法</h5><ul>
<li>基本思想： <ul>
<li>假设直线段的宽度为1,直线段的斜率: |k| ≤ 1</li>
<li>已知过端点P<sub>0</sub>(x<sub>0</sub>, y<sub>0</sub>), P<sub>1</sub>(x<sub>1</sub>, y<sub>1</sub>)的直线L：y = kx + b。</li>
<li>直线斜率 k = (y<sub>1</sub> - y<sub>0</sub>) / (x<sub>0</sub> - x<sub>0</sub>)</li>
<li>当x的增量D<sub>x</sub> = 1， y<sub>i+1</sub> = y<sub>i</sub> + k</li>
</ul>
</li>
<li>当x每递增1，y递增k(即直线斜率)；取象素点(x, round(y))作为当前点的坐标。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DDALine(x0,y0,x1,y1,color) </span><br><span class="line"><span class="keyword">int</span> x0,y0,x1,y1,color;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> x</span><br><span class="line">	<span class="keyword">float</span> dx,dy,k,y</span><br><span class="line">	dx=x1-x0; dy=y1-y0; </span><br><span class="line">	k=dy/dx;</span><br><span class="line">	y=y0;</span><br><span class="line">	<span class="keyword">for</span>(x=x0;x&lt;=x1;x++)</span><br><span class="line">	&#123;</span><br><span class="line">		drawpixel(x,<span class="keyword">int</span>(y+<span class="number">0.5</span>),color); </span><br><span class="line">		y=y+k;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：<ul>
<li>当|k| ≤ 1时，x每增加1，y最多变化1。</li>
<li>当|k| &gt; 1时，必须把x与y的地位互换。</li>
</ul>
</li>
<li><strong>DDA算法的特点</strong> 以|k| ≤ 1为例<ul>
<li>y与k必须用浮点数表示</li>
<li>每一步都要对y进行四舍五入后取整</li>
<li>不利于硬件实现</li>
</ul>
</li>
</ul>
<h5 id="中点算法"><a href="#中点算法" class="headerlink" title="中点算法"></a>中点算法</h5><ul>
<li>基本原理<ul>
<li>通过在每列(行)象素中确定与理想直线最接近的象素来进行扫描转换</li>
<li>考虑直线斜率k在0~1之间</li>
<li>当前象素点为P（x<sub>p</sub>,y<sub>p</sub>），则下一个象素点有两种可选择点<br>P<sub>1</sub>（x<sub>p</sub>+1,y<sub>p</sub>）, P<sub>2</sub>（x<sub>p</sub>+1,y<sub>p+1</sub>）</li>
<li>P1与P2的中点（x<sub>p</sub>+1,y<sub>p</sub>+0.5）称为M</li>
<li>Q为理想直线与x = x<sub>p</sub>+1垂线的交点<br>当M在Q的下方时，则取P<sub>2</sub>应为下一个象素点<br>当M在Q的上方时，则取P<sub>1</sub>为下一个象素点<br><img src="/CG/中点算法.png" width="40%"> </li>
</ul>
</li>
<li>算法实现<ul>
<li>过点(x<sub>0</sub>,y<sub>0</sub>)、(x<sub>1</sub>, y<sub>1</sub>)的直线段L的方程式为：F(x, y)=ax+by+c=0</li>
<li><strong>其中，a = y<sub>0</sub> - y<sub>1</sub>, b = x<sub>1</sub> - x<sub>0</sub>, c = x<sub>0</sub>y<sub>1</sub> - x<sub>1</sub>y<sub>0</sub></strong></li>
<li>欲判断中点M在交点Q点的上方还是下方，只要把M代入F（x，y），并判断它的符号即可</li>
<li>构造判别式：d=F(M)=F(x<sub>p</sub>+1, yp+0.5)=a(x<sub>p</sub>+1)+b(y<sub>p</sub>+0.5)+c    </li>
<li>当d&lt;0时，M在L(Q点)下方，取P2为下一个象素        </li>
<li>当d&gt;0时，M在L(Q点)上方，取P1为下一个象素      </li>
<li>当d=0时，选P1或P2均可，约定取P1为下一个象素  </li>
</ul>
</li>
</ul>
<h5 id="增量法改进："><a href="#增量法改进：" class="headerlink" title="增量法改进："></a>增量法改进：</h5><ul>
<li>注意到d是x<sub>p</sub>, y<sub>p</sub>的线性函数，可采用增量计算，提高运算效率 <ul>
<li>d = F(M)=F(x<sub>p</sub>+1, y<sub>p</sub>+0.5) = a(x<sub>p</sub>+1)+b(y<sub>p</sub>+0.5)+c </li>
</ul>
</li>
<li>若当前象素（P的下一个像素）处于d≥0情况，则取P的正右方象素P1(x<sub>p</sub>+1, y<sub>p</sub>)，再下一个象素位置的判别式：<ul>
<li>d<sub>1</sub> = F(x<sub>p</sub>+2, y<sub>p</sub>+0.5) = a(x<sub>p</sub>+2)+b(y<sub>p</sub>+0.5)+c = d+a</li>
<li><strong>增量为a</strong></li>
</ul>
</li>
<li>若当前象素（P的下一个像素） d&lt;0时，则取右上方象素P2(x<sub>p</sub>+1, y<sub>p</sub>+1)，再下一个像素位置的判别式：<ul>
<li>d<sub>2</sub> = F(x<sub>p</sub>+2, y<sub>p</sub>+1.5) = a(x<sub>p</sub>+2)+b(y<sub>p</sub>+1.5)+c = d+a+b</li>
<li><strong>增量为a＋b</strong></li>
</ul>
</li>
<li><strong>初值计算</strong><ul>
<li>画线从(x<sub>0</sub>, y<sub>0</sub>)开始， F(x<sub>0</sub>, y<sub>0</sub>) = 0</li>
<li>d的初值：起始点(x0, y0) 下一个像素的判别式：</li>
<li>d<sub>0</sub> = F(x<sub>0</sub>+1, y<sub>0</sub>+0.5)+c = F(x<sub>0</sub>, y<sub>0</sub>)+a+0.5b = 0 + a+0.5b = a+0.5b</li>
</ul>
</li>
<li><strong>摆脱小数计算</strong><ul>
<li>我们使用的只是d的符号</li>
<li>d的增量都是整数，只是初始值包含小数</li>
<li>可以用2d代替d来摆脱小数</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> Midpoint <span class="title">Line</span> <span class="params">(<span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> x1, <span class="keyword">int</span> y1,<span class="keyword">int</span> color)</span></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> a, b, d1, d2, d, x, y;	a=y0-y1； b=x1-x0；d=<span class="number">2</span>*a+b; <span class="comment">//初值</span>	d1=<span class="number">2</span>*a； d2=<span class="number">2</span>* (a+b);	x=x0；y=y0;	drawpixel(x, y, color);	<span class="keyword">while</span> (x&lt;x1)	&#123; </span><br><span class="line">		<span class="keyword">if</span> (d&lt;<span class="number">0</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			x++;</span><br><span class="line">			y++；;</span><br><span class="line">			d+=d2; </span><br><span class="line">		&#125;		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			x++;</span><br><span class="line">			d+=d1;</span><br><span class="line">		&#125;		drawpixel (x, y, color);	&#125; &#125;</span><br></pre></td></tr></table></figure>
<h5 id="Bresenham算法"><a href="#Bresenham算法" class="headerlink" title="Bresenham算法"></a>Bresenham算法</h5><ul>
<li>基本思想：<ul>
<li>过各行各列象素中心构造一组虚拟网格线</li>
<li>按直线从起点到终点的顺序计算直线与各垂直网格线的<strong>交点</strong></li>
<li>然后根据<strong>误差项的符号</strong>确定该列象素中与此交点最近的象素</li>
<li>采用<strong>增量计算</strong>，使得对于每一列，只要检查一个误差项的<strong>符号</strong>，就<br>可以确定该列的所求象素<br><img src="/CG/Bresenham.png" width="30%"></li>
</ul>
</li>
<li>算法实现<ul>
<li>先考虑斜率k=dy/dx≤1的直线，直线方程可以表示为</li>
<li>假设当前像素的x坐标已经确定为x<sub>i</sub>，其y坐标为y<sub>i</sub></li>
<li>由于坐标(x<sub>i</sub>, y<sub>i</sub>)只能取整数，下一个像素的x坐标为</li>
<li>而y<sub>i</sub>＋1的坐标有两种可能：保持不变，即y<sub>i</sub>＋1＝y<sub>i</sub>；y坐标递增1，即y<sub>i</sub>＋1＝y<sub>i</sub>＋1<br><img src="/CG/Bresenham1.png" width="20%"></li>
<li>设A为CD边的中点，若B点在A点上方，选择D点； 否则，选C点。</li>
</ul>
</li>
<li>具体实现<ul>
<li>如果直线的<strong>起始点在象素中心</strong>，所以误差项d的初值<strong>d<sub>0</sub>＝0</strong>。</li>
<li>x下标每增加1，d的值相应递增直线的斜率值k，<strong>即d＝d＋k</strong>。</li>
<li>一旦d≥1，就把它减去1，这样<strong>保证d在0与1之间</strong>。<br>①当d≥0.5时，最接近于当前象素的右上方象素（x<sub>i</sub>+1, y<sub>i</sub>+1）<br>②当d&lt;0.5时，更接近于右下方象素（x<sub>i</sub>+1, y<sub>i</sub>）</li>
<li>为方便计算，<strong>令e＝d-0.5</strong></li>
<li>e的初值为-0.5 (d0 = 0)，增量为k<br>①当e≥0时，最接近于当前象素的右上方象素（x<sub>i</sub>+1, y<sub>i</sub>+1）<br>②当e&lt;0时，更接近于右方象素（x<sub>i</sub>+1, y<sub>i</sub>）</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bresenhamline</span> <span class="params">(<span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> x1, <span class="keyword">int</span> y1,<span class="keyword">int</span> color)</span></span>&#123;	<span class="keyword">int</span> x, y, dx, dy;	<span class="keyword">float</span> k, e;	dx = x1-x0, dy = y1- y0, k=dy/dx;	e=<span class="number">-0.5</span>, x=x0, y=y0;	<span class="keyword">for</span> (i=<span class="number">0</span>; i≤dx; i++)	&#123;		drawpixel (x, y, color);		x=x+<span class="number">1</span>, e=e+k;		<span class="keyword">if</span> (e≥<span class="number">0</span>)		&#123; </span><br><span class="line">			y++, e=e<span class="number">-1</span>;</span><br><span class="line">		&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Bresenham画线算法优点</strong>：<ul>
<li>快速增量算法</li>
<li>仅使用整数计算</li>
<li>效率高，易于用硬件实现</li>
</ul>
</li>
<li>与DDA算法相比，DDA算法的问题：<ul>
<li>误差的累积会使直线远离真实的结果</li>
<li>四舍五入运算和浮点运算耗时</li>
</ul>
</li>
</ul>
<h5 id="改进的Bresenham算法"><a href="#改进的Bresenham算法" class="headerlink" title="改进的Bresenham算法"></a>改进的Bresenham算法</h5><ul>
<li>可以改用整数以避免除法。由于算法中只用到误差项的符号，因此可作如下替换：<ul>
<li>e’ = 2 <em> e </em> dx 即用2 <em> dx </em> e代替原有的e。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InterBresenhamline</span> <span class="params">(<span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> x1, <span class="keyword">int</span> y1,<span class="keyword">int</span> color)</span></span>&#123;	dx = x1-x0, dy = y1- y0；	e=-dx; x=x0; y=y0;	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;dx; i++)	&#123;		drawpixel (x, y, color）		x++； e=e+<span class="number">2</span>*dy;		<span class="keyword">if</span> (e&gt;=<span class="number">0</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			 y++; </span><br><span class="line">			 e=e<span class="number">-2</span>*dx;</span><br><span class="line">		&#125;	&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-圆的生成"><a href="#2-2-圆的生成" class="headerlink" title="2.2 圆的生成"></a>2.2 圆的生成</h3><ul>
<li>八等分圆：可以同时绘制八分对称的点。<br><img src="/CG/八等分.png" width="30%"> <ul>
<li>八分对称性同时解决了“绘制点稀疏”的问题。</li>
<li>只需绘制右上八分之一的圆弧。</li>
<li>①切线斜率|dy/dx| ≤ 1 ②y的变化慢于x ③x每递增1，y最多最多改变一个像素单位 ④不会产生像素空隙 ⑤会有更多的像素拟合圆弧 ⑥使圆弧拟合更精确。</li>
</ul>
</li>
</ul>
<h5 id="中点画圆法"><a href="#中点画圆法" class="headerlink" title="中点画圆法"></a>中点画圆法</h5><ul>
<li>构造判别式(圆方程)：F(x, y) = x<sup>2</sup> + y<sup>2</sup> - R<sup>2</sup></li>
<li>判断点在圆内(F &lt; 0)、圆上(F = 0)、圆外(F &gt; 0)</li>
<li>M(x<sub>p</sub> + 1,y<sub>p</sub> - 0.5)是P1和P2的中点</li>
<li>d = F(M) = F(x<sub>p</sub> + 1,y<sub>p</sub> - 0.5) = (x<sub>p</sub> + 1)<sup>2</sup> + (y<sub>p</sub> - 0.5)<sup>2</sup> - R<sup>2</sup><br><img src="/CG/中点画圆.png" width="30%"> <ul>
<li>八分之一圆弧（如半径R=20），初始象素坐标(0, R)</li>
<li>下一个像素的绘制位置(1, R) 或(1, R-1)</li>
<li>得到中点坐标(1, R-0.5)</li>
<li>构造判别式d<sub>0</sub> = F(M) -&gt; d<sub>1</sub>, d<sub>2</sub>…</li>
</ul>
</li>
</ul>
<h5 id="增量算法避免重复计算"><a href="#增量算法避免重复计算" class="headerlink" title="增量算法避免重复计算"></a>增量算法避免重复计算</h5><p><img src="/CG/中点画圆增量.png" width="60%"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MidPointCircle(<span class="keyword">int</span> R <span class="keyword">int</span> color)&#123;	<span class="keyword">int</span> x,y;	<span class="keyword">float</span> d;	x=<span class="number">0</span>; y=R; d=<span class="number">1.25</span>-R;	CirclePoints (x,y,color); <span class="comment">//显示圆弧上的八个对称点</span>	<span class="keyword">while</span>(x&lt;=y)	&#123;		<span class="keyword">if</span>(d&lt;<span class="number">0</span>) </span><br><span class="line">			d+=<span class="number">2</span>*x+<span class="number">3</span>;		<span class="keyword">else</span> </span><br><span class="line">		&#123; </span><br><span class="line">			d+=<span class="number">2</span>*(x-y)+<span class="number">5</span>; </span><br><span class="line">			y--; </span><br><span class="line">		&#125;		x++;		CirclePoints(x,y,color); <span class="comment">//显示圆弧上的八个对称点</span>	&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>为了进一步提高算法的效率，可以将上面的算法中的浮点数改写成整数，将乘法运算改成加法运算，即仅用整数实现中点画<br>圆法。</li>
<li>初始化运算使用 Q:为什么可以去掉0.25？<ul>
<li>d’= d - 0.25 = 1.25 – R – 0.25 = 1 – R 代替 d = 1.25 - R</li>
</ul>
</li>
</ul>
<h5 id="中点算法小结"><a href="#中点算法小结" class="headerlink" title="中点算法小结"></a>中点算法小结</h5><ul>
<li>圆弧各点切线斜率绝对值<1 -=""> 从x扫描至x+1，y的备选绘制点为y, y-1</1></li>
<li>适当利用对称性提高效率<ul>
<li>利用圆的八分对称性 -&gt; 只需绘制圆右上八分之一圆弧</li>
</ul>
</li>
<li>利用中点判别法选择绘制点<ul>
<li>联合圆方程 + 每一步的两个备选绘图点的中点 -&gt; 构造判别式</li>
</ul>
</li>
<li>设计增量算法 -&gt; 避免重复计算</li>
<li>符号判别 -&gt; 简化浮点运算为整数运算</li>
</ul>
<h5 id="生成圆弧的Bresenham法"><a href="#生成圆弧的Bresenham法" class="headerlink" title="生成圆弧的Bresenham法"></a>生成圆弧的Bresenham法</h5><ul>
<li>以点(0, R) 为起点按顺时针方向生成圆，则在第一象限内（四分之一圆弧）y是x的单调递减函的单调递减函。</li>
<li>假设圆心和起点均精确地落在像素中心上。如果已经知道圆弧上的一点 (x<sub>i</sub>,y<sub>i</sub> )，下一像素的选取有三种可能：<br>①正右方像素H ②右下角像素D ③正下方像素V<br><img src="/CG/圆弧.png" width="20%"></li>
<li>构造函数：F(x<sub>p</sub> + 1,y<sub>p</sub> - 0.5) = (x<sub>p</sub> + 1)<sup>2</sup> + (y<sub>p</sub> - 0.5)<sup>2</sup> - R<sup>2</sup>  </li>
<li>这三个像素的偏差的平方为：<br><img src="/CG/偏差.png" width="20%"><br><img src="/CG/偏差2.png" width="50%"><img src="/CG/偏差3.png" width="50%"><br><img src="/CG/偏差4.png" width="55%"></li>
</ul>
<h3 id="2-3-椭圆的生成"><a href="#2-3-椭圆的生成" class="headerlink" title="2.3 椭圆的生成"></a>2.3 椭圆的生成</h3><ul>
<li>F(x,y) = b<sup>2</sup>x<sup>2</sup>+a<sup>2</sup>y<sup>2</sup>-a<sup>2</sup>b<sup>2</sup>=0</li>
<li>椭圆的对称性：<ul>
<li>只考虑第一象限椭圆弧生成 只考虑第一象限椭圆弧生成 ，分上下两部分</li>
<li><strong>以切线斜率为-1的点作为分界的点。</strong></li>
</ul>
</li>
<li>椭圆上一点处的法向量：N(x,y) = (F)’ x i+(F)’ y j = 2b<sup>2</sup>x i+2a<sup>2</sup>y j<ul>
<li>在上部分，法向量的y向分量较大，斜率K满足 |k|&lt; 1,|△x| ＞|△y| ，所以 x方向为主位移方向。</li>
<li>在下部分，法向量的x向分量较大，斜率K满足 |k|&gt; 1,|△y| ＞|△x| ，所以 y方向为主位移方向。</li>
</ul>
</li>
<li>与圆弧中点算法类似：确定一个象素后，接着在两个候选象素的中点计算一个判别式的值，由判别式的符号确定更近的点。</li>
<li>先讨论椭圆弧的上部分：<ul>
<li>(x<sub>p</sub>, y<sub>p</sub>)的中点(x<sub>p</sub> + 1, y<sub>p</sub> - 0.5)</li>
<li>d<sub>1</sub> = F(x<sub>p</sub> + 1, y<sub>p</sub> - 0.5)<br><img src="/CG/椭圆.png" width="75%"><br><img src="/CG/椭圆2.png" width="60%"><br><img src="/CG/椭圆3.png" width="50%"><br><img src="/CG/椭圆4.png" width="50%"> <img src="/CG/椭圆5.png" width="50%"> </li>
</ul>
</li>
<li>算法步骤：<ol>
<li>输入椭圆的长半轴 a 和短半轴 b。</li>
<li>计算初始值 d=b<sup>2</sup>+a<sup>2</sup>(-b+ 0.25 )，x= 0，y=b 。</li>
<li>绘制点 (x, y )及其在四分象限上的另外三个对称点。</li>
<li>判断 d 的符号。若d≤ 0，则先将d更新为d+b<sup>2</sup>(2x + 3)，再将 ( x, y)更新为 (x+ 1,y)；否则先将d更新为 d+b<sup>2</sup>(2x + 3) + a<sup>2</sup>(-2y + 2)，再将 ( x, y )更新为 (x + 1, y - 1)。</li>
<li>当b<sup>2</sup>(x+1) &lt; a<sup>2</sup>(y - 0.5)时，重复步骤 3 和 4 。否则转到步骤 6 。</li>
<li>用上半部分计算的最后点 ( x, y )来计算下半部分中d的初值：d = b<sup>2</sup>(x + 0.5)<sup>2</sup> + a<sup>2</sup> (y - 1)<sup>2</sup> - a<sup>2</sup> b<sup>2</sup></li>
</ol>
</li>
</ul>
<h3 id="2-4-多边形的扫描转换"><a href="#2-4-多边形的扫描转换" class="headerlink" title="2.4 多边形的扫描转换"></a>2.4 多边形的扫描转换</h3><h5 id="1-实区域填充算法"><a href="#1-实区域填充算法" class="headerlink" title="1. 实区域填充算法"></a>1. 实区域填充算法</h5><ul>
<li>点在多边形内的包含性检验<ul>
<li><strong>检验夹角之和</strong>：若夹角和为0，则点p在多边形外；若夹角和为360°，则点p在多边形内。</li>
<li><strong>射线法检验交点数</strong>：交点数 = 偶数(包括0) -&gt; 点在多边形之外；交点数 = 奇数 -&gt; 点在多边形之内</li>
</ul>
</li>
<li>逐点测试：效率低不实用。 <ul>
<li>解决办法：<strong>包围盒法</strong>。</li>
</ul>
</li>
<li>分类<ul>
<li>扫描线填充算法：按扫描线顺序，测试点的连贯性</li>
<li>种子填充算法：从内部一个种子点出发，测试点的连贯性。</li>
</ul>
</li>
</ul>
<h5 id="2-多边形种类"><a href="#2-多边形种类" class="headerlink" title="2. 多边形种类"></a>2. 多边形种类</h5><ul>
<li>多边形 :由一系列首尾相连的直线段构成的图形称为多边形。 <ul>
<li><strong>凸多边形</strong>是指任意两顶点间的连线均在多边形内;</li>
<li><strong>凹多边形</strong>是指任意两顶点间的连线有不在多边形内的部分;</li>
<li><strong>含内环的多边形</strong>则是指多边形内再套有多边形，多边形内的多边形也叫内环，内环之间不能相交。</li>
</ul>
</li>
</ul>
<h5 id="3-如何表示多边形"><a href="#3-如何表示多边形" class="headerlink" title="3. 如何表示多边形"></a>3. 如何表示多边形</h5><ul>
<li><strong>顶点表示</strong>是用多边形的顶点序列来表示多边形。<ul>
<li>表示直观、几何意义强、占内存少，易于进行几何变换，被广泛用于各种几何造型系统中;</li>
</ul>
</li>
<li><strong>点阵表示</strong>是用位于多边形内的象素集合来刻画多边形。<ul>
<li>丢失了许多几何信息(如边界、顶点)，但它是光栅显示图形所需要的表示形式。</li>
</ul>
</li>
<li><strong>多边形的扫描转换处理对象</strong>：非自交多边形 (边与边之间除了顶点外无其它交点)</li>
</ul>
<h5 id="4-多边形的扫描转换-扫描线算法-多边形的有序边表法"><a href="#4-多边形的扫描转换-扫描线算法-多边形的有序边表法" class="headerlink" title="4. 多边形的扫描转换 / 扫描线算法 / 多边形的有序边表法"></a>4. 多边形的扫描转换 / 扫描线算法 / 多边形的有序边表法</h5><ul>
<li>4个基本步骤：<ul>
<li><strong>求交</strong>：计算扫描线与多边形各边的交点</li>
<li><strong>排序</strong>：把所有交点按x值递增顺序排序</li>
<li><strong>配对</strong>：将第一个与第二个、第三个与第四个等交点配对，每对交点代表扫描线与多边形的一个相交区间。</li>
<li><strong>填色</strong>：把相交区间内的像素置成多边形的颜色，相交区间外的颜色置成背景色。</li>
</ul>
</li>
<li><strong>顶点交点的计数问题：</strong><ul>
<li>思路1: 局部最高点和局部最低点：计偶数次交点</li>
<li>思路2: 检查交于该顶点的两条边的另外两个端点的y坐标值：大于该顶点y坐标值的个数</li>
</ul>
</li>
<li><strong>填充扩大化问题</strong> <ul>
<li>取中心扫描线 y+0.5<br>– 检查交点右方像素的中心是否落在区间内：x<sub>l</sub> ≤ x + 0.5 ≤ x<sub>r</sub></li>
</ul>
</li>
<li><strong>效率问题：</strong><ul>
<li>影响算法效率的因素：<strong>求交和交点排序</strong></li>
<li>把多边形所有边放在一个表中，按顺序取出，分别计算与当前扫描线求交点。</li>
<li>为了减少和简化求交点计算，对每条扫描线，建立一个<strong>活性边表</strong>：把所有与当前扫描线有交点的边放到一个表中存储。(活性边：仅与当前扫描线有交点的边)</li>
</ul>
</li>
<li><strong>活性边表 AET</strong>：<ul>
<li>结点信息：<br>① x:当前扫描线与边的交点<br>②△x:从当前扫描线到下一条扫描线之间的x增量<br>③ymax:边所交的最高扫描线号</li>
<li>活性边表的更新：<br>①结点信息的更新  <strong>x’ = x + △ x</strong><br>②旧边的删除<br>③新边的插入 </li>
</ul>
</li>
<li><strong>新边表 NET</strong><ul>
<li>为解决新边插入的问题，对每条扫描线建立一个新边表。</li>
<li>扫描线与边的交点应为扫描线与边的初始交点</li>
<li>结点信息<br>①x<sub>0</sub>:扫描线与边的初始交点。（若采用中心扫描线，则需将活性边的较低端点的x坐标值加上0.5△x作为x0）<br>②△x:从当前扫描线到下一条扫描线之间的x增量<br>③ymax:边所交的最高扫描线号<br><img src="/CG/扫描线.png" width="70%"></li>
</ul>
</li>
<li>优点: <ul>
<li>对每个像素只访问一次 </li>
<li>与设备无关</li>
</ul>
</li>
<li>缺点:<ul>
<li>数据结构复杂，表的维护、排序开销大</li>
<li>只适合软件实现</li>
</ul>
</li>
</ul>
<h5 id="扫描线算法步骤"><a href="#扫描线算法步骤" class="headerlink" title="扫描线算法步骤"></a>扫描线算法步骤</h5><ol>
<li>根据给出的多边形顶点坐标，建立NET表;<br>求出顶点坐标中最大y值ymax和最小y值ymin。</li>
<li>初始化AET表指针，使它为空。</li>
<li>执行下列步骤直至NET和AET都为空.<ol>
<li>如NET中的第y类非空，则将其中的所有边取出并插入AET中;</li>
<li>如果有新边插入AET，则对AET中各边排序;</li>
<li>对AET中的边两两配对，(1和2为一对，3和4为一对，…)，将每对边中x坐标按规则取整，获得有效的填充区段，再填充.</li>
<li>当前扫描线纵坐标y值递值1;</li>
<li>如果AET表中某记录的ymax=yj，则删除该记录(因为每条边被看作下闭上开的);</li>
<li>对AET中剩下的每一条边的x递增1/k，即x = x+ 1/k .</li>
</ol>
</li>
</ol>
<h5 id="边填充算法"><a href="#边填充算法" class="headerlink" title="边填充算法"></a>边填充算法</h5><ul>
<li>无需复杂的链表结构</li>
<li>涉及到屏幕像素的异或写操作<ul>
<li>第一次异或写操作，像素被置为前景色</li>
<li>第二次异或写操作，像素被置为背景色</li>
</ul>
</li>
<li>边填充算法的基本思想<ul>
<li>对每一条与多边形相交的中心扫描线</li>
<li>将像素中心位于交点右方的全部像素取补 (异或写)</li>
</ul>
</li>
<li>分类：<ul>
<li>算法1：<strong>以扫描线为中心</strong>的边缘填充算法</li>
<li>算法2：<strong>以边为中心</strong>的边缘填充算法</li>
</ul>
</li>
<li>边填充算法的优点:<ul>
<li>最适合于有帧缓存的显示器</li>
<li>可按任意顺序处理多边形的边</li>
<li>仅访问与该边有交点的扫描线上右方的像素，算法简单</li>
</ul>
</li>
<li>缺点: <ul>
<li>对复杂图形，每一像素可能被访问多次，输入/输出量大</li>
<li><strong>图形输出不能与扫描同步进行</strong>，只有全部画完才能打印</li>
</ul>
</li>
</ul>
<h5 id="边界标志法-P27"><a href="#边界标志法-P27" class="headerlink" title="边界标志法 P27"></a>边界标志法 P27</h5><ul>
<li>在帧缓冲器中对多边形的每条边进行<strong>直线扫描转换</strong>，亦即对多边形边界所经过的象素打上标志。</li>
<li>对每条与多边形相交的扫描线依从左到右的顺序，逐个访问该扫描线上的象素。</li>
<li>使用一个<strong>布尔量inside</strong>来指示当前点是否在多边形内的状态。<ul>
<li>Inside的初值为假，每当当前访问的象素为被打上边标志的点，就把inside取反。 </li>
<li>对未打标志的象素，inside不变。</li>
<li>若访问当前象素时，inside为真，说明该象素在多边形内，则把该象素置为填充颜色。</li>
</ul>
</li>
<li>用软件实现时，有序边表算法(扫描线算法)与边界标志算法的执行速度几乎相同。</li>
<li>但由于边界标志算法<strong>不必建立维护边表以及对它进行排序，所以边界标志算法更适合硬件实现</strong>，这时它的执行速度比有序边表算法快一至两个数量级。</li>
</ul>
<h3 id="2-5-区域-种子-填充算法"><a href="#2-5-区域-种子-填充算法" class="headerlink" title="2.5  区域(种子)填充算法"></a>2.5  区域(种子)填充算法</h3><h5 id="区域填充"><a href="#区域填充" class="headerlink" title="区域填充"></a>区域填充</h5><ul>
<li><strong>区域</strong>：指已经表示成<strong>点阵形式</strong>的填充图形，它是象素的集合。</li>
<li>表示方法: 内点表示、边界表示</li>
<li><strong>内点表示</strong><ul>
<li>枚举处区域内部的所有像素</li>
<li>内部的所有像素着同一个颜色</li>
<li>边界像素着与内部像素不同的颜色</li>
</ul>
</li>
<li><strong>边界表示</strong><ul>
<li>枚举出边界上所有的像素</li>
<li>边界上的所有像素着同一颜色</li>
<li>内部像素着与边界像素不同的颜色</li>
</ul>
</li>
<li>种子填充算法的另外一种思路: <ul>
<li>假设多边形区域内至少有一个像素已知 </li>
<li>由该像素出发找出区域内部的所有像素</li>
</ul>
</li>
<li><strong>区域连通方式</strong><ul>
<li>4连通区域(4个方向运动：上下左右)</li>
<li>8连通区域(8个方向运动)</li>
</ul>
</li>
</ul>
<h5 id="种子填充的一种非递归-栈-算法"><a href="#种子填充的一种非递归-栈-算法" class="headerlink" title="种子填充的一种非递归(栈)算法"></a>种子填充的一种非递归(栈)算法</h5><ul>
<li>以4连通边界为例</li>
<li>种子像素入栈</li>
<li>当栈非空时，重复以下步骤: <ul>
<li>栈顶像素出栈</li>
<li>将出栈象素置成填充色</li>
<li>按左、上、右、下顺序检查与出栈象素相邻的四象素，若其中某象素不在边界上且未被置成填充色，则将其入栈</li>
</ul>
</li>
<li>特点: 每个像素都需要压栈，耗内存，费时间<br><img src="/CG/种子.png" width="40%"></li>
</ul>
<h5 id="种子填充的扫描线算法"><a href="#种子填充的扫描线算法" class="headerlink" title="种子填充的扫描线算法"></a>种子填充的扫描线算法</h5><ul>
<li>基本思想:<ul>
<li>利用扫描线的连贯性，每次<strong>填充一行像素</strong></li>
<li>减少压入堆栈的像素数目</li>
</ul>
</li>
<li>种子像素入栈</li>
<li>当栈非空时，重复以下步骤:<ul>
<li>栈顶像素出栈</li>
<li>沿扫描线对出栈像素的左右像素进行填充，直到遇到边界像素为止</li>
<li>将上述区间内最左、最右像素记为x<sub>l</sub>,和x<sub>r</sub></li>
<li>在区间[x<sub>l</sub>,x<sub>r</sub>]中检查与当前扫描线相邻的上下两条扫描线是否全为边界像素、或已填充的像素，若为非边界、未填充的像素，则<strong>把每一区间的最右像素取为种子像素入栈</strong>。(后进先出)</li>
</ul>
</li>
<li><strong>扫描线种子填充算法的特点</strong><ul>
<li>适用于边界定义的区域</li>
<li>四连通边界定义的区域既可以是凸的，也可以是凹的，还可以是有孔的。</li>
<li>算法减少了每个像素的访问次数</li>
<li>所需堆栈深度较浅</li>
<li>每次递归填充一行像素，因而速度较快</li>
</ul>
</li>
</ul>
<h5 id="多边形扫描转换-A-与区域填充方法-B-比较"><a href="#多边形扫描转换-A-与区域填充方法-B-比较" class="headerlink" title="多边形扫描转换(A)与区域填充方法(B)比较"></a>多边形扫描转换(A)与区域填充方法(B)比较</h5><ul>
<li>都是光栅图形面着色， 用千真实感图形显示。</li>
<li>可相互转换。</li>
<li>不同点：</li>
</ul>
<ol>
<li>基本思想不同；<ul>
<li>A用于将顶点表示转换成点阵表示；</li>
<li>B只改变区域内填充颜色，没有改变表示方法。</li>
</ul>
</li>
<li>对边界的要求不同<ul>
<li>A：只要求扫描线与多边形边界交点个数为偶数。</li>
<li>B：区域封闭，防止递归填充跨界。</li>
</ul>
</li>
<li>基本的条件不同<ul>
<li>A：从边界顶点信息出发。</li>
<li>B：区域内种子点。</li>
</ul>
</li>
</ol>
<h3 id="2-6-字符"><a href="#2-6-字符" class="headerlink" title="2.6 字符"></a>2.6 字符</h3><h5 id="字符的表示和输出"><a href="#字符的表示和输出" class="headerlink" title="字符的表示和输出"></a>字符的表示和输出</h5><ul>
<li><strong>字符</strong>：数字、字母、汉字， 计算机中字符由一个数字编码唯一标识。</li>
<li><strong>字符集</strong>：<ul>
<li>ASCII码：美国信息交换标准代码。</li>
<li>ISO 8859：是国际标准化组织(ISO)及国际电工委员会(IEC)联合制定的一系列8位字符集的标准， 现时定义了15个字符集。增加、加192个字母及符号， 附加符号的拉丁字母语言</li>
<li>GB2312/GBK, 这就是汉字的国标码， 专门用来表示汉字， 是双字节编码，</li>
<li>Unicode可以用来表示所有语言的字符， 而且是定长双字节（也有四字节的）编码， 包括英文字母在内。</li>
<li>UTF可以用来表示所有语言的字符， utf编码是不定长编码， 每一个字符的长度从1-6个字节不等。另外， utf编码自带简单的校验功能。一般来讲， 英文字母都是用一个字节<br>表示， 而汉字使用三个字节。</li>
</ul>
</li>
<li><strong>字库</strong>：字库中存储了每个字符的形状信息，字库分为<strong>矢量和点阵型</strong>两种。</li>
<li><strong>点阵字符</strong>：<ul>
<li>在点阵表示中，每一个字符由一个点阵位图来表示。点阵字符的存储是<strong>按行或者按列进行编码</strong>。</li>
<li>显示时，形成字符的像素图案。</li>
</ul>
</li>
<li>矢量字符<ul>
<li>采用直线和曲线段来描述字符形状，矢量字符库中记录的是笔划信息(存的是<strong>顶点的位置信息</strong>)。</li>
<li>显示时，解释字符的每个笔划信息</li>
</ul>
</li>
</ul>
<h3 id="2-7-反走样"><a href="#2-7-反走样" class="headerlink" title="2.7 反走样"></a>2.7 反走样</h3><ul>
<li>什么是反走样?<ul>
<li>把<strong>由离散量表示连续量引起的失真</strong>称为走样;</li>
<li>把减少或克服走样效果的技术称为反走样技术，简称反走样。 </li>
</ul>
</li>
<li>光栅图形的走样有如下几种:<ul>
<li>产生阶梯或锯齿形;</li>
<li>狭小图形遗失;细节失真</li>
<li>实时动画忽隐忽现、闪烁跳跃。 </li>
</ul>
</li>
<li><strong>常用的反走样的主要方法</strong> <strong>P41</strong><ul>
<li>提高分辨率方法(硬件技术)</li>
<li>非加权区域采样：改变直线段的模型，由此产生算法。将直线段看作具有一定宽度的狭长矩形。<strong>缺点</strong>是直线离像素中心点越近，贡献越大。</li>
<li>加权区域采样：使相交区域对象亮度的贡献依赖于该区域与像素中心的距离。</li>
</ul>
</li>
</ul>
<h2 id="3-三维图形的剪裁"><a href="#3-三维图形的剪裁" class="headerlink" title="3. 三维图形的剪裁"></a>3. 三维图形的剪裁</h2><ul>
<li>场景由世界坐标中指定的对象集合组成</li>
<li>当我们显示场景时，仅显示特定窗口中的那些对象</li>
<li>因为将内容绘制到显示器需要时间，我们会剪切窗口外的所有内容</li>
<li>设窗口的边界为wx<sub>min</sub>, wy<sub>min</sub>, wx<sub>max</sub>, wy<sub>max</sub><ul>
<li>当一个点(x, y)满足：wx<sub>min</sub> &lt; x &lt; wx<sub>max</sub> &amp;&amp; wy<sub>min</sub> &lt; y &lt; wy<sub>max</sub> 则不需要被剪裁</li>
<li>否则被剪裁。</li>
</ul>
</li>
</ul>
<h3 id="3-1-直线段裁剪"><a href="#3-1-直线段裁剪" class="headerlink" title="3.1 直线段裁剪"></a>3.1 直线段裁剪</h3><h5 id="Cohen-Sutherland算法"><a href="#Cohen-Sutherland算法" class="headerlink" title="Cohen-Sutherland算法"></a>Cohen-Sutherland算法</h5><ul>
<li>优点：减少了必须计算的线与窗口的交点的数量。</li>
<li>世界空间根据窗口边界划分为区域：<ul>
<li>每个区域具有唯一的四位区域码。</li>
<li>区域码表<strong>示区域相对于窗口的位置</strong>。<br>&lt;img src = “区域码.png” width =50%”&gt;</li>
</ul>
</li>
<li>判别方法：设线段的两个端点为P1(x1，y1)和P2(x2，y2)， 根据上述规则，可以求出P1和P2所在区域的分区代码C1和C2。<ul>
<li>C1 = C2 = 0，表明两端点全在窗口内，因而整个线段也在窗内，应予保留。</li>
<li>C1 And C2 ≠ 0(两端点代码<strong>按位作逻辑乘</strong>不为0)，即C1和C2至少有某一位同时为1，表明两端点必定处于某一边界的同一外侧，因而整个线段全在窗外，应予舍弃。</li>
<li>不属于上面两种情况，均需要求交点。</li>
</ul>
</li>
<li>注意：求的交点可能是<strong>延长线上的交点</strong>。</li>
<li>求交点：<ul>
<li>使用直线的方程计算与窗口边界的交点</li>
<li>假设一条直线具有端点(x1, y1), (x2, y2)</li>
<li>与垂直窗口边界的交点坐标为 y = y<sub>1</sub> + m(x<sub>边界</sub> - x<sub>1</sub>), x<sub>边界</sub>可以为x<sub>min</sub>或者x<sub>max</sub></li>
<li>与水平窗口边界的交点坐标 x = x<sub>1</sub> + (y<sub>边界</sub> - x<sub>1</sub>) / m</li>
<li>m = (y<sub>2</sub> - y<sub>1</sub>) / (x<sub>2</sub> - x<sub>1</sub>)</li>
</ul>
</li>
</ul>
<h5 id="中点分割剪裁算法"><a href="#中点分割剪裁算法" class="headerlink" title="中点分割剪裁算法"></a>中点分割剪裁算法</h5><ul>
<li>注意：求的交点是<strong>真实的交点</strong>。</li>
<li><strong>基本思想</strong>：<ul>
<li>P( (x<sub>1</sub> + x<sub>2</sub>) / 2 , (y<sub>1</sub> + y<sub>2</sub>) / 2 )</li>
<li>如果P1与P同侧，移动P1点。即可能的交点只能出现在PP2段 <code>if((C1&amp;C)!=0) P1=P</code>;</li>
<li>如果P1与P不同侧，移动P2点。即可能的交点只能出现在P1P段 <code>if((C1&amp;C)= =0) P2=P</code>;<br>&lt;img src = “中点分割.png” width =22%”&gt;</li>
</ul>
</li>
<li><strong>算法步骤</strong>：<ul>
<li><strong>将直线的两端点P1、P2编码得：C1、C2。</strong></li>
<li><strong>根据C1和C2的具体值，可以有三种情况：</strong><br>①C1=C2=0，表明两端点全在窗口内，因而整个线段也在窗内，应予保留。<br>②C1&amp;C2≠0，表明两端点必定处于某一边界的同一外侧，因而整个线段全在窗外，应予舍弃。<br>③不属于上面两种情况，均需要求交点。</li>
<li><strong>求交点</strong><br>①令窗外端点为P1，如果窗外点不是P1，则P1和P2交换端点。保留窗内端点P2到暂存器里。<br>②对P1编码为C1，用中点公式求出中点 ，并编码得C。按照中点算法的求交规则：<br>若P1和P同侧，移动P1点<code>if((C1&amp;C)!=0) P1=P</code>; 否则，移动P2点 <code>else P2=P</code><br>③流程转②，直到P1和P2相差一个单位时:令交点为P2，取出暂存器的端点赋给P1，然后转向流程①</li>
</ul>
</li>
<li><strong>算法特点</strong>：<ul>
<li>求交点的次数(n)与线段长度(L)有关，其关系为: <strong>L = 2<sup>n</sup></strong> 例如：线段长度为256，则求交点的次数为8。</li>
<li>中点分割法求出的交点是<strong>边界上的有效交点</strong>，而不是边界及其延长线上的交点。而Cohen-Sutherland直线裁剪算法求出的则是<strong>边界上或者边界的延长线上的交点</strong>。</li>
</ul>
</li>
</ul>
<h3 id="3-2-多边形裁剪"><a href="#3-2-多边形裁剪" class="headerlink" title="3.2 多边形裁剪"></a>3.2 多边形裁剪</h3><h5 id="Sutlerland-Hodgman算法-逐边裁剪算法"><a href="#Sutlerland-Hodgman算法-逐边裁剪算法" class="headerlink" title="Sutlerland-Hodgman算法 / 逐边裁剪算法"></a>Sutlerland-Hodgman算法 / 逐边裁剪算法</h5><ul>
<li>窗口的一条边以及延长线构成的裁剪线该线把平面分成两个部分：可见一侧；不可见一侧。</li>
<li>简单地通过依次将多边形与每个边界进行比较来修剪多边形。</li>
<li>多边形的各条边的两端点S、P。它们与裁剪线的位置关系只有四种：<ul>
<li>S，P均在可见一侧 → 输出P</li>
<li>S，P均在不可见一侧 → 无输出</li>
<li>S可见，P不可见 → 输出SP与裁剪线的交点I</li>
<li>S不可见，P可见  → 输出SP与裁剪的交点I和P<br><img src="/CG/裁剪.jpeg" width="45%"></li>
</ul>
</li>
<li><strong>特点：</strong><ul>
<li>裁剪算法采用流水线方式， <strong>适合硬件实现。</strong></li>
<li>可推广到<strong>任意凸多边形裁剪窗口</strong></li>
</ul>
</li>
</ul>
<h5 id="Weiler-Atherton算法"><a href="#Weiler-Atherton算法" class="headerlink" title="Weiler-Atherton算法"></a>Weiler-Atherton算法</h5><ul>
<li><strong>特点：</strong><ul>
<li>裁剪窗口为<strong>任意多边形(凸、凹、带内环)</strong>的情况:</li>
</ul>
</li>
<li>内裁减与外裁剪：<ul>
<li>内裁剪: 即通常意义上的裁剪，取图元位于窗口之内的部分</li>
<li>外裁剪: 取图元位于窗口之外的部分。</li>
</ul>
</li>
<li>如果主多边形与裁剪多边形有交点，则<strong>交点成对出现</strong>。它们被分为如下两类:<ul>
<li>一类称“入”点。即被裁剪多边形由此点进入裁剪窗口，如图中a、c、e。</li>
<li>一类称“出”点。即被裁剪多边形由此点离开裁剪窗口，如图中b、d、f。</li>
</ul>
</li>
<li>Weiler-Atherton算法步骤<ol>
<li>建顶点表 </li>
<li>求交点</li>
<li>裁剪<br><img src="/CG/wa.png" width="75%"></li>
</ol>
</li>
<li><strong>详细步骤</strong><ol>
<li><strong>顺时针</strong>输入被裁剪多边形顶点序列 I 放入数组1中。</li>
<li><strong>顺时针</strong>输入裁剪窗口顶点序列II放入数组2中。</li>
<li>求出被裁剪多边形和裁剪窗口相交的所有交点，并给每个交点打上 “入”、“出”标记。 然后将交点按顺序插入序列I得到新的顶点序列 III ，并放入数组3中;同样也将交点按顺序插入序列II得到新的顶点序列 IV ，放入数组4中; </li>
<li>初始化输出数组Q，令数组Q为空。接着从数组3中寻找“入”点。如果“入”点没找到，程序结束。 </li>
<li>如果找到“入”点，则将“入”点放入S中暂存。</li>
<li>将“入”点录入到输出数组Q中。并从数组 3 中将该“入”点的“入” 点标记删去。 </li>
<li>沿数组 3 顺序取顶点: 如果顶点是“出点”，则将顶点录入到输出数组Q中，流程转第7步。否则，流程转第8步。</li>
<li>沿数组4顺序取顶点:如果顶点是“入点”，则将顶点录入到输出数组Q中，流程转第8步。 否则，流程转第9步。</li>
<li><strong>如果顶点不等于起始点S，流程转第6步，继续跟踪数组3</strong>。 否则，将数组Q输出。</li>
<li>流程转第4步，寻找可能存在的分裂多边形。 算法在第4步：满足“入”点没找到的条件时，算法结束。</li>
</ol>
</li>
<li><strong>交点的奇异情况处理</strong><ul>
<li>与裁剪多边形边重合的主多边形的边不参与求交点;</li>
<li>对于顶点落在裁剪多边形的边上的主多边形的边，如果落在该裁<br>剪边的内侧，将该顶点算作交点;而如果这条边落在该裁剪边<br>的外侧，将该顶点不看作交点。<br><img src="/CG/奇异.png" width="60%"></li>
</ul>
</li>
</ul>
<h3 id="3-3-字符裁剪"><a href="#3-3-字符裁剪" class="headerlink" title="3.3 字符裁剪"></a>3.3 字符裁剪</h3><ul>
<li><strong>基于字符串</strong>：将包围字符串的外接矩形对窗口作裁剪。当字符串外接矩形整个在 窗口内时予以显示，否则不显示。</li>
<li><strong>基于字符</strong>：将包围字符的外接矩形对窗口作<br>裁剪，如某个字符外接矩形整个落<br>在窗口内予以显示，否则不显示。</li>
<li><strong>基于构成字符的最小元素 / 像素</strong>：点阵字符：点裁剪 ；矢量字符：线裁剪<br><img src="/CG/字符.png" width="80%"></li>
</ul>
<h2 id="4-图形的变换"><a href="#4-图形的变换" class="headerlink" title="4. 图形的变换"></a>4. 图形的变换</h2><h3 id="4-1-图形变换的数学基础"><a href="#4-1-图形变换的数学基础" class="headerlink" title="4.1 图形变换的数学基础"></a>4.1 图形变换的数学基础</h3><ul>
<li><strong>图形几何变换</strong>：几何图形按照某种法则或规律变换成另一种几何图形的过程。</li>
<li>矩阵及其运算 P203</li>
</ul>
<h3 id="4-2-二维几何变换"><a href="#4-2-二维几何变换" class="headerlink" title="4.2 二维几何变换"></a>4.2 二维几何变换</h3><h5 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h5><ul>
<li>齐次坐标：所谓齐次坐标, 就是将一个原本是n维的向量用一个n+1 维向量来表示。<ul>
<li>例如, 向量(x<sub>1</sub>, x<sub>2</sub>, …, x<sub>n</sub>)的齐次坐标表示为<br>(H<sub>x<sub>1</sub></sub>, H<sub>x<sub>2</sub></sub>, …, H<sub>x<sub>n</sub></sub>, H), 其中H是一个不为0的实数。</li>
</ul>
</li>
<li>由点或向量的齐次坐标(H<sub>x<sub>1</sub></sub>, H<sub>x<sub>2</sub></sub>, …, H<sub>x<sub>n</sub></sub>, H)求它的<strong>规范化齐次坐标</strong>, 可根据如下公式求得：<ul>
<li>x<sub>1</sub> = H<sub>x<sub>1</sub></sub> / H, x<sub>2</sub> = H<sub>x<sub>2</sub></sub> / H, …, x<sub>n</sub> = H<sub>x<sub>n</sub></sub> / H</li>
</ul>
</li>
<li>齐次坐标表示不是唯一的，通常<strong>当h=1时</strong>，称为<strong>规格化齐次坐标</strong>， 在计算机图形学里面，我们常用的是规格化齐次坐标。</li>
<li>为什么需要引入齐次坐标？<ul>
<li>多个变换作用于多个目标</li>
<li>引入齐次坐标，变换的表示法统一</li>
</ul>
</li>
<li>图形变换具有统一表示形式的优点：<ul>
<li>便于变换合成 </li>
<li>便于硬件实现  </li>
</ul>
</li>
</ul>
<h5 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h5><ul>
<li><strong>平移、旋转、缩放变换</strong><br><img src="/CG/几何变换.jpg" width="100%"></li>
<li><strong>对称变换</strong>：<br><img src="/CG/对称.jpg" width="100%"></li>
<li><p><strong>错切变换</strong>： </p>
<ul>
<li>也称为剪切、错位变换，用于产生弹性物体的变形处理。</li>
<li>错切的变换矩阵<br><img src="/CG/错切.jpg" width="100%"></li>
<li>(a) 错切角 (b) 沿x方向错切 (c) 沿y方向错切<br><img src="/CG/错切3.png" width="50%"></li>
</ul>
</li>
<li><p><strong>仿射变换</strong></p>
<ul>
<li>变换的坐标x’和y’都是原始坐标x和y的线性函数。</li>
<li>仿射变换具有平行线转换成平行线和有限点映射到有限点的一般特性。</li>
<li><strong>平移、比例、旋转、对称和错切变换是二维仿射变换的特例</strong>，任何常用的二维仿射变换总可表示为这五种变换的组合。 </li>
</ul>
</li>
</ul>
<h5 id="复杂变换"><a href="#复杂变换" class="headerlink" title="复杂变换"></a>复杂变换</h5><ul>
<li>复合变换是指对图形进行一次以上的变换，变换的结果是 每次的变换矩阵相乘。</li>
<li>任何一组变换都可以表示成一个复合变换矩阵，只需要计算每一个单独<strong>变换矩阵</strong>，并求解出乘积。</li>
<li>从另一个方面讲，任何一个复杂的几何变换都可以看作基本几何变换的组合形式，也叫复合变换。</li>
</ul>
<h3 id="4-3-窗口到视区的变换"><a href="#4-3-窗口到视区的变换" class="headerlink" title="4.3 窗口到视区的变换"></a>4.3 窗口到视区的变换</h3><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ul>
<li><strong>坐标系</strong>：建立了图形与数之间的对应联系<ul>
<li><strong>世界坐标系</strong>：用户需要在图形独享所在的控件定义一个坐标系</li>
<li><strong>用户坐标系</strong>：用户按照自己习惯建立世界坐标系，所以世界坐标系有时也称用户坐标系。</li>
<li><strong>局部坐标系</strong>：简化图形对象的描述，相对于图形定义</li>
<li><strong>屏幕坐标系</strong>：屏幕上或绘图纸上定义一个二维直角坐标系，也称为设备坐标系。</li>
</ul>
</li>
<li><strong>窗口</strong>：在计算机图形学中，将在用户坐标系中需要进行观察和处理的一个坐标区域。</li>
<li><strong>视区</strong>：将窗口映射到显示设备上的坐标区域。 <ul>
<li>改变视区的位置，可以在输出设备的不同位置显示图形对象。</li>
<li>改变视区的大小和比例可以改变显示对象的大小和比例。 </li>
</ul>
</li>
<li><strong>裁剪在扫描转换之前</strong><br><img src="/CG/显示.png" width="60%"></li>
</ul>
<h5 id="窗口到视区变换"><a href="#窗口到视区变换" class="headerlink" title="窗口到视区变换"></a>窗口到视区变换</h5><ul>
<li>变换步骤：<ul>
<li>将窗口左下角点<strong>移至用户系统系的坐标原点</strong></li>
<li>针对原点进行<strong>比例变换</strong></li>
<li>进行<strong>反平移</strong></li>
</ul>
</li>
<li>两种情况：<ol>
<li>窗口区的边与坐标轴平行</li>
<li>窗口区的边与坐标轴不平行：将窗口左下角点<strong>移至用户系统系的坐标原点</strong>后需要旋转到与坐标轴平行。</li>
</ol>
</li>
</ul>
<h3 id="4-4-三维几何变换"><a href="#4-4-三维几何变换" class="headerlink" title="4.4 三维几何变换"></a>4.4 三维几何变换</h3><h5 id="三维齐次坐标"><a href="#三维齐次坐标" class="headerlink" title="三维齐次坐标"></a>三维齐次坐标</h5><ul>
<li>(x, y, z)对应的齐次坐标为(x<sub>h</sub>, y<sub>h</sub>, z<sub>h</sub>, h)<ul>
<li>标准齐次坐标(x,y,z,1) ==〉用来表示三维空间点(x, y, z)。</li>
</ul>
</li>
<li>使用<strong>右手坐标系</strong>(z轴正方向向外) </li>
</ul>
<h5 id="三维几何变换"><a href="#三维几何变换" class="headerlink" title="三维几何变换"></a>三维几何变换</h5><ul>
<li>三维平移变换、放缩变换</li>
<li>三维旋转变换<ul>
<li>是指给定的三维立体绕三维空间某个指定的坐标轴旋转θ角度。 </li>
<li>旋转后, 立体的空间位置将发生变化, 但形状不变。 </li>
<li><strong>θ角的正负按右手规则确定</strong>, 右手大姆指指向旋转轴的正向, 其余四个手指指向旋转角的正向。</li>
</ul>
</li>
</ul>
<p><img src="/CG/3d.jpg" width="100%"></p>
<ul>
<li>三维错切变换：是指三维立体在空间沿x、 y、 z三个方向实现错切变形, 三维错切是二维错切变换的一个扩充。</li>
<li>三维对称变换<br><img src="/CG/3d2.jpg" width="60%"></li>
</ul>
<h2 id="5-投影"><a href="#5-投影" class="headerlink" title="5. 投影"></a>5. 投影</h2><h3 id="5-1-三维图形显示的基本问题"><a href="#5-1-三维图形显示的基本问题" class="headerlink" title="5.1 三维图形显示的基本问题"></a>5.1 三维图形显示的基本问题</h3><ol>
<li><strong>在二维屏幕上如何显示三维物体?</strong><ul>
<li>显示器屏幕、绘图纸等是二维的，显示对象是三维的</li>
<li>解决方法：投影</li>
</ul>
</li>
<li><strong>如何表示三维物体?</strong><ul>
<li>二维形体的表示：直线段, 折线, 曲线段, 多边形区域</li>
<li>二维形体的输入：<strong>简单</strong>(图形显示设备与形体的维数一致)</li>
<li>三维形体的表示：空间直线段、折线、曲线段、多边形、曲面片 </li>
<li>三维形体的输入、运算、有效性保证<strong>(困难)</strong></li>
<li>解决方法：<strong>各种用于形体表示的理论、模型、方法</strong></li>
</ul>
</li>
<li><strong>如何反映遮挡关系?</strong><ul>
<li>物体之间或物体的不同部分之间存在相互遮挡关系</li>
<li>遮挡关系是空间位置关系的重要组成部分</li>
<li>解决方法：<strong>消除隐藏面与隐藏线</strong></li>
</ul>
</li>
<li><strong>如何产生真实感图形?</strong><ul>
<li>人们观察现实世界产生的真实感来源于<br>• 空间位置关系：近大远小的透视关系和遮挡关系<br>• 光线传播引起的物体表面颜色的自然分布</li>
<li>解决方法：<strong>建立光照明模型、开发真实感图形绘制方法</strong></li>
</ul>
</li>
</ol>
<h5 id="三维图形显示的基本研究内容"><a href="#三维图形显示的基本研究内容" class="headerlink" title="三维图形显示的基本研究内容"></a>三维图形显示的基本研究内容</h5><ul>
<li>投影</li>
<li>三维形体的表示</li>
<li>消除隐藏面与隐藏线</li>
<li>建立光照明模型、开发真实感图形绘制方法</li>
</ul>
<h3 id="5-2-平面几何投影"><a href="#5-2-平面几何投影" class="headerlink" title="5.2 平面几何投影"></a>5.2 平面几何投影</h3><ul>
<li>投影 — 照相机模型<ul>
<li>选定投影类型 → <strong>透视投影</strong>与<strong>平行投影</strong></li>
<li>设置投影参数 → 拍摄方向、距离等</li>
<li>三维裁剪 → 取景</li>
<li>投影和显示 → 成像</li>
</ul>
</li>
<li><strong>简单的三维图形显示流程图</strong><br><img src="/CG/3d流程.png" width="40%"> </li>
<li><strong>投影</strong>：将n维的点变换成小于n维的点。比如将3维的点变换成小于3维的点</li>
<li><strong>投影中心</strong>(COP: Center of Projection)<ul>
<li>eg. 视觉系统—观察点、视点; 电影放映机—光源</li>
</ul>
</li>
<li><strong>投影面</strong>：不经过投影中心的面<ul>
<li>eg. 平面–照相机底片; 曲面—球幕电影,视网膜</li>
</ul>
</li>
<li><strong>投影线：</strong>从投影中心向物体上各点发出的射线<ul>
<li>eg. 直线—光线; 曲线—喷绘</li>
</ul>
</li>
<li><strong>平面几何投影</strong>：投影面是平面，投影线为直线</li>
<li><strong>投影变换</strong>：投影过程，投影的数学表示</li>
<li>平面几何投影的分类<br><img src="/CG/投影.png" width="40%"> </li>
</ul>
<h5 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h5><ul>
<li>投影中心与投影平面之间的距离为有限</li>
<li>参数：投影中心、投影方向</li>
<li>eg. 室内白炽灯的投影，视觉系统</li>
<li><strong>灭点</strong>：不平行于投影平面的平行线，经过透视投影之后收敛于一点，称为灭点。</li>
<li><strong>主灭点</strong>：坐标轴方向的平行线在投影面上 形成的灭点称作主灭点。<ul>
<li>一点透视：表现范围广，纵深感强，适合表现庄重、严肃的室内空间或建筑物。比较呆板，与真实效果有一定的距离</li>
<li>两点透视为：构图画面增加动感，使画面结构丰富。</li>
<li>三点透视：一般用于超高层建筑俯瞰图或仰视图。<br><img src="/CG/透视.png" width="40%"> </li>
</ul>
</li>
<li><strong>特点</strong>：产生近大远小的视觉效果，由它产生的图形深度强，看起来更加真实。</li>
</ul>
<h5 id="平行投影"><a href="#平行投影" class="headerlink" title="平行投影"></a>平行投影</h5><ul>
<li>投影中心与投影平面之间的距离为无限</li>
<li>是透视投影的极限状态</li>
<li>分类:<ul>
<li>根据投影射线与投影平面的关系，平行投影可分为<strong>正投影和斜投影</strong>。<br><img src="/CG/平行投影.png" width="40%"> </li>
</ul>
</li>
<li>正投影：<ul>
<li>根据投影面和坐标轴的夹角可分为两类:三视图和正轴测图</li>
<li>当<strong>投影面与某一坐标轴垂直</strong>时，得到的投影为三视图，这时投影方向和这个坐标轴的方向一致。否则，得到的投影为正轴测图。<br><img src="/CG/正投影.png" width="40%"> </li>
</ul>
</li>
<li><strong>三视图</strong>: 包括<strong>主视图、侧视图和俯视图</strong>三种，投影面分别与X轴、Y轴和Z轴垂直</li>
<li>正轴侧：当投影平面与三个坐标轴都不垂直时。<ul>
<li>正轴侧又分为等轴侧、正二侧和正三侧。</li>
<li>当投影面与<strong>三个</strong>坐标轴之间的<strong>夹角都相等</strong>时为等轴测。</li>
<li>当投影面与<strong>两个</strong>坐标轴之间的<strong>夹角相等</strong>时为正二测。</li>
<li>当投影面与<strong>三个</strong>坐标轴之间的<strong>夹角都不相等</strong>时为正三测。</li>
</ul>
</li>
</ul>
<h5 id="斜投影"><a href="#斜投影" class="headerlink" title="斜投影"></a>斜投影</h5><ul>
<li><strong>投影方向不垂直于投影面</strong></li>
<li>分类：<ul>
<li>斜等侧投影:投影方向和投影面夹角α成45° </li>
<li>斜二侧投影:投影方向和投影面夹角α=arctan(2)</li>
</ul>
</li>
</ul>
<h5 id="投影总结"><a href="#投影总结" class="headerlink" title="投影总结"></a>投影总结</h5><ul>
<li>平行投影:投影中心与投影面间距离为无穷远。</li>
<li>正平行投影:投影方向和投影面垂直。</li>
<li>三视图:三个投影面和坐标轴相互垂直。</li>
<li>正轴侧:投影面和坐标轴呈一定的关系。 </li>
<li>斜平行投影:投影方向和投影面不垂直。</li>
<li>透视投影:投影中心与投影面间距离为有限。</li>
</ul>
<h3 id="5-3-投影变换-amp-投影举例"><a href="#5-3-投影变换-amp-投影举例" class="headerlink" title="5.3 投影变换 &amp; 投影举例"></a>5.3 投影变换 &amp; 投影举例</h3><ul>
<li><strong>三维观察变换</strong>所起的作用是完成从用户空间选取的一部分物体描述变换到 显示屏上指定的视窗中的图形描述。<ul>
<li>简单的三维观察流水线：<br><img src="/CG/流水线.png" width="40%"> </li>
</ul>
</li>
<li><strong>取景变换</strong>:完成从用户坐标系中的描述 -&gt; 观察坐标系中的描述的坐标变换。</li>
<li><strong>观察坐标系(VRC)</strong>:照相机所在的坐标系</li>
</ul>
<h5 id="建立观察坐标系"><a href="#建立观察坐标系" class="headerlink" title="建立观察坐标系"></a>建立观察坐标系</h5><ul>
<li>挑选一个用户坐标点称为观察参考点VRP(View Reference Point)， 即该点为观察坐标系的原点;</li>
<li>通过给定观察平面法向量来选择观察坐标系的 Zv轴和观察平面方向;</li>
<li>指定一观察向上向量，通过该向量来建立 观察坐标系的Yv轴;</li>
<li>确定观察点又称为投影中心(若为透视投影时) 或确定投影方向(若为平行投影时)</li>
</ul>
<h5 id="用户坐标到观察坐标的变换"><a href="#用户坐标到观察坐标的变换" class="headerlink" title="用户坐标到观察坐标的变换"></a>用户坐标到观察坐标的变换</h5><ul>
<li>在物体描述投影到观察平面之前，必须将其转换成观察坐标。该变换顺序是:    <ul>
<li>平移观察参考点VRP(x0,y0,z0)到用户坐标系原点; </li>
<li>进行旋转分别让Xv,Yv和Zv轴对应到用户坐标系的x、y、和z轴。 一旦景物中物体的用户坐标描述转换到观察坐标后，我们就可以将三维<br>物体投影到二维观察平面上。<br><img src="/CG/观察坐标.png" width="50%"> </li>
</ul>
</li>
<li>为使剪取处理简单和规范化(即单位化)，需要利用坐标变换将<strong>视见体规范化</strong>。</li>
</ul>
<h5 id="视见体-View-Port"><a href="#视见体-View-Port" class="headerlink" title="视见体(View Port)"></a>视见体(View Port)</h5><ul>
<li>视见体是三维裁剪窗口。</li>
<li>建立步骤：<ul>
<li>定义窗口 → 发出射线 → 形成观察空间 → 前后剪裁面 → 形成视见体</li>
</ul>
</li>
<li>需注意，对于透视投影，<strong>前截面必须在投影中心和后截面之间。</strong></li>
<li>投影参考点(PRP: Projection Reference Point)<br><img src="/CG/视见体.png" width="50%"> <ul>
<li>透视投影: COP==PRP;</li>
<li>平行投影: 投影方向DOP= CW-PRP</li>
<li>透视投影: 观察空间为四棱锥</li>
<li>平行投影: 观察空间为四棱柱</li>
</ul>
</li>
</ul>
<h5 id="透视投影变换"><a href="#透视投影变换" class="headerlink" title="透视投影变换"></a>透视投影变换</h5><ul>
<li>问题：在uvn中，投影平面为n=0，投影中心为(0，0，d)， 待投影点为P(u<sub>p</sub>，v<sub>p</sub>，n<sub>p</sub>)，求投影点Q (u<sub>Q</sub>，v<sub>Q</sub>，n<sub>Q</sub>)<br><img src="/CG/透视投影变换.png" width="25%"><br><img src="/CG/透视投影变换2.png" width="25%"></li>
<li>透视投影变换矩阵:作用就是将三维物体变换成二维透视投影。</li>
</ul>
<h5 id="斜平行投影"><a href="#斜平行投影" class="headerlink" title="斜平行投影"></a>斜平行投影</h5><ul>
<li>投影方向不垂直于投影平面的平行投影被称为斜平行投影。</li>
</ul>
<h5 id="从世界坐标系到观察坐标系的变换"><a href="#从世界坐标系到观察坐标系的变换" class="headerlink" title="从世界坐标系到观察坐标系的变换"></a>从世界坐标系到观察坐标系的变换</h5><p><img src="/CG/变换.png" width="25%"></p>
<h3 id="5-4-规范视见体变换-规范裁剪空间"><a href="#5-4-规范视见体变换-规范裁剪空间" class="headerlink" title="5.4 规范视见体变换 / 规范裁剪空间"></a>5.4 规范视见体变换 / 规范裁剪空间</h3><ul>
<li>为什么引入规范视见体?<ul>
<li>使裁剪算法非常容易、直观</li>
<li>有助于隐藏线和隐藏面的消除。</li>
</ul>
</li>
<li>规范化变换：将任意视见体变换成规范视见体的变换</li>
<li>三维图形的显示流程图<br><img src="/CG/2.png" width="45%"></li>
<li>采用视见体变换的三维图形显示流程图<br><img src="/CG/1.png" width="45%"><ul>
<li>观察变换：从世界坐标系到观察坐标系的变换</li>
</ul>
</li>
</ul>
<h5 id="何时裁剪"><a href="#何时裁剪" class="headerlink" title="何时裁剪"></a>何时裁剪</h5><ul>
<li><strong>投影之前裁剪 三维裁剪</strong><ul>
<li>优点：只对可见的物体进行投影变换</li>
<li>缺点：三维裁剪相对复杂</li>
</ul>
</li>
<li><strong>投影之后裁剪 二维裁剪</strong><ul>
<li>优点：二维裁剪相对容易</li>
<li>缺点：需要对所有的物体进行投影变换</li>
</ul>
</li>
<li>采用投影后裁剪的三维图形显示流程图<br><img src="/CG/3.png" width="45%"></li>
<li>在投影之前裁剪的理由<ul>
<li>三维物体的表面通常被离散表示成多边形或折线，而对这类简单图元，三维裁剪同样比较简单。</li>
<li>三维图形<strong>在显示过程中需要被消隐</strong>，做这个工作要有图形的深度信息，所以必须在投影之前完成。 消隐很费时，如果在此之前裁剪 (或部分裁剪)掉不可见的图形，可使需要消隐的图形减至最小。</li>
</ul>
</li>
</ul>
<h2 id="6-隐藏面的消除"><a href="#6-隐藏面的消除" class="headerlink" title="6. 隐藏面的消除"></a>6. 隐藏面的消除</h2><h3 id="6-1-基本概念"><a href="#6-1-基本概念" class="headerlink" title="6.1 基本概念"></a>6.1 基本概念</h3><ul>
<li>要画出确定的、立体感很强的三维图形，就必须将那些被不透明的面<br>(或物体)所遮挡的线段(或面)移去，这就是隐藏线或隐藏面的消隐处理。</li>
<li><strong>按消隐对象</strong>将三维物体消隐分为两类: <ul>
<li><strong><code>线消隐</code></strong>：其消隐对象是物体上的边, 消除的是<strong>物体上不可见的边</strong>，用于线框图。</li>
<li><strong><code>面消隐</code></strong>：其消隐对象是物体上的面, 消除的是<strong>物体上不可见的面</strong>，用于填色图。</li>
</ul>
</li>
<li><strong>根据消隐空间</strong>的不同，将消隐算法分为3类：<ul>
<li>物体空间的消隐算法：将场景中每一个面与其它每个面比较, 求出所有点、边、面的遮挡关系。算法精度较高。如<strong>光线投射</strong>等。</li>
<li>图像空间的消隐算法：对屏幕上每个像素进行判断, 决定哪个多边形在该像素可见。 如：<strong>Z-buffer、扫描线</strong>等。</li>
<li>物体空间和图像控件的消隐算法：在物体空间中预先计算面的可见性优先级, 再在图像空间中生成 消隐图。如：<strong>画家算法</strong>等。</li>
</ul>
</li>
</ul>
<h3 id="6-2-提高消隐算法效率的常见方法"><a href="#6-2-提高消隐算法效率的常见方法" class="headerlink" title="6.2 提高消隐算法效率的常见方法"></a>6.2 提高消隐算法效率的常见方法</h3><ol>
<li>利用连贯性<ul>
<li>物体的连贯性</li>
<li>面的连贯性</li>
<li>区域的连贯性 </li>
<li>扫描线的连贯性</li>
</ul>
</li>
<li>将透视投影转换成平行投影 <ul>
<li>消隐与投影方式有关 (消隐必须在投影之前完成)</li>
</ul>
</li>
</ol>
<ul>
<li>包围盒技术：包围目标的简单形体</li>
<li>背面剔除</li>
<li>空间分割技术</li>
<li>物体分层表示  </li>
</ul>
<h5 id="包含消隐的三维图形显示流程图："><a href="#包含消隐的三维图形显示流程图：" class="headerlink" title="包含消隐的三维图形显示流程图："></a>包含消隐的三维图形显示流程图：</h5><p><img src="/CG/4.png" width="45%"></p>
<h5 id="消隐的基本-核心-问题-排序"><a href="#消隐的基本-核心-问题-排序" class="headerlink" title="消隐的基本(核心)问题:排序"></a>消隐的基本(核心)问题:排序</h5><ul>
<li>整体排序: 画家算法</li>
<li>点排序: Z-Buffer算法、光线投射算法 </li>
<li>区间排序: 扫描线算法</li>
<li>区域排序: 区域子分算法</li>
</ul>
<h3 id="6-3-画家算法"><a href="#6-3-画家算法" class="headerlink" title="6.3 画家算法"></a>6.3 画家算法</h3><ul>
<li>基本思想 <ul>
<li>先将场景中的物体按其距观察点的远近进行排序，结果放在一张线性表中;</li>
<li>线性表构造:距观察点远的称优先级低，放在表头;距观察点近的称优先级高， 放在表尾。该表称为深度优先级表</li>
<li>然后按照从表头到表尾的顺序逐个绘制物体。</li>
</ul>
</li>
<li>基本步骤<ul>
<li>对场景中的多边形按深度进行排序，</li>
<li>形成深度优先级表;</li>
<li>按从远到近的顺序显示多边形;</li>
</ul>
</li>
<li>画家算法不能处理的情况<ul>
<li>多边形循环遮挡</li>
<li>多边形相互穿透</li>
</ul>
</li>
<li>解决办法: 沿多边形所在平面之间的交线循环地分割这些多边形，直至最终可建立确定的优先级表。</li>
</ul>
<h3 id="6-4-Z缓冲器算法"><a href="#6-4-Z缓冲器算法" class="headerlink" title="6.4 Z缓冲器算法"></a>6.4 Z缓冲器算法</h3><ul>
<li>基本思想<ul>
<li>先将Z缓冲器中个单元的初始值置为-1 (规范视见体的最小n值)。</li>
<li>当要改变某个像素的颜色值时，首先检查当前<strong>多边形的深度值</strong>是否大于该像素<br>原来的深度值(保存在该像素所对应的Z缓冲器的单元中);</li>
<li><strong>如果大于，说明当前多边形更靠近观察点</strong>，用它的颜色替换像素原来的颜色;</li>
<li>否则说明在当前像素处，当前多边形被前面所绘制的多边形遮挡了，是不可见的，像素的颜色值不改变。</li>
</ul>
</li>
<li><strong>优点</strong><ul>
<li>算法简单、稳定</li>
<li>便于硬件加速</li>
<li>不需要整个场景的几何数据</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>需要Z缓冲器 <strong>改进: 扫描线Z缓冲器算法</strong> </li>
<li>计算复杂度大 <strong>改进:区域子分算法</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p> 需要计算的像素深度值次数 = 多边形个数 * 多边形平均占据的像素个数</p>
</blockquote>
<h3 id="6-5-扫描线Z缓冲器算法"><a href="#6-5-扫描线Z缓冲器算法" class="headerlink" title="6.5 扫描线Z缓冲器算法"></a>6.5 扫描线Z缓冲器算法</h3><ul>
<li>改进一: 将窗口分割成扫描线<ul>
<li>缺点：在每一个被多边形覆盖像素处需要计算深度值；被多个多边形覆盖的像素需要多次计算深度值</li>
</ul>
</li>
<li>改进二：利用扫描线的连贯性计算深度 (增量法)</li>
<li>改进三：采用多边形分类表(PT)、活化多边形表 (APT)<strong>避免多边形与扫描线的盲目求交</strong></li>
<li>改进四：利用边、边的分类表(ET)、边对、活化边对表(AEPT)<strong>避免边与扫描线的盲目求交</strong></li>
</ul>
<h3 id="6-6-区间扫描线算法"><a href="#6-6-区间扫描线算法" class="headerlink" title="6.6 区间扫描线算法"></a>6.6 区间扫描线算法</h3><ul>
<li><strong>要求多边形不能相互贯穿</strong></li>
<li>该算法可以看作是边相关扫描线填充算法的延伸。</li>
<li>不同的是在消隐算法中处理的是多个面片，而多边形填充中是对单个多边形面进行填充。</li>
<li>它是把当前扫描线与各多边形在投影平面的投影的交点进行排序后，使扫描线分为若干子区间。因此，只要在区间任一点处找出在该 处z值最大的一个面，这个区间上的每一个象素就用这个面的颜色来显示。</li>
<li>改进：<ul>
<li>在一条扫描线上，以区间为单位确定多边形的可见性</li>
<li>不需要Z-Buffer</li>
</ul>
</li>
</ul>
<h3 id="6-7-区域子分割算法"><a href="#6-7-区域子分割算法" class="headerlink" title="6.7 区域子分割算法"></a>6.7 区域子分割算法</h3><ul>
<li>首先将场景中的多边形投影到绘图窗口内(假设它为边长为k的正方形)</li>
<li>判断窗口是否足够简单，若是则算法结束;</li>
<li>否则将窗口进一步分为四块(左上，右上，左下，右下)。</li>
<li>对此四个小窗口重复上述过程，直到窗口仅为一个像素大小。</li>
<li>此时可能有多个多边形覆盖了该像素，计算它们的深度值，以最近的颜色 显示该像素即可。</li>
</ul>
<h3 id="6-8-光线投射算法"><a href="#6-8-光线投射算法" class="headerlink" title="6.8 光线投射算法"></a>6.8 光线投射算法</h3><ul>
<li>考察<strong>由视点出发穿过观察屏幕</strong>的一像素而射入场景的一条射线,则可确定出场景中与该射线相交的物体。 </li>
<li>在计算出光线与物体表面的交点之后, 离像素最近的交点的所在面片的颜色为该像素的颜色; 如果没有交点, 说明没有多边形的投影覆盖此像素, 用背景色显示它即可。</li>
</ul>
<h2 id="7-真实感图形的生成"><a href="#7-真实感图形的生成" class="headerlink" title="7. 真实感图形的生成"></a>7. 真实感图形的生成</h2><ul>
<li>当光照射到物体表面时，光线可能被<strong>吸收</strong>、<strong>反射</strong>和<strong>透射</strong>。被物体吸收的部分转化为热，反射、透射的光进入 人的视觉系统，使我们能看见物体。</li>
<li>为模拟这一现象，我们建立一些数学模型来替代复杂的物理模型，这些模型就称为明暗效应模型或者光照明模型。三维形体的图形经过消隐后，再进行明暗效应的处 理，可以进一步提高图形的真实感。</li>
</ul>
<h3 id="7-1-简单光照明模型"><a href="#7-1-简单光照明模型" class="headerlink" title="7.1 简单光照明模型"></a>7.1 简单光照明模型</h3><ul>
<li>光照射到物体表面，主要发生:<ul>
<li>反射 </li>
<li>透射(对透明物体) </li>
<li>部分被吸收成热能 </li>
</ul>
</li>
<li>反射光和透射光的<strong>光谱分布</strong>——决定景物表面的<strong>颜色</strong></li>
<li>反射光和透射光的<strong>强弱</strong>——决定景物表面的<strong>明暗程度</strong></li>
<li><strong>环境光</strong>：在空间中近似均匀分布，即在任何位置、任何方向<br>上强度一样</li>
<li><strong>点光源</strong>:几何形状为一个点，位于空间中的某个位置，向周围所有的方向上辐射等强度的光。<ul>
<li>在物体的不同部分其亮度也不同，亮度的大小依赖于物体的朝向及它与点光源之间的距离。</li>
</ul>
</li>
<li><strong>漫反射</strong>：粗糙、无光泽物体(如粉笔，墙面)表面对光的反射<ul>
<li>各点反射光的强度只与①点光源强度、入射角 ②物体表面的反射系数  ③物体各表面的朝向 有关</li>
<li><strong>与观察者的观察方向无关</strong></li>
</ul>
</li>
<li><strong>镜面反射</strong>: 光滑物体(如金属或塑料)表面对光的反射<ul>
<li>n为镜面反射(高光)指数，n越大，则Is(镜面反射光强)随α的增大衰减的越快  </li>
<li><strong>n的取值与表面粗糙程度有关</strong><br>①n越大，表面越平滑(散射现象少，稍一偏离，明暗亮度急剧下降)<br>②n越小，表面越毛糙(散射现象严重)</li>
</ul>
</li>
<li>高光: 入射光在光滑物体表面形成的特别亮的区域</li>
</ul>
<h5 id="Phong光照明模型"><a href="#Phong光照明模型" class="headerlink" title="Phong光照明模型"></a>Phong光照明模型</h5><ul>
<li>由物体表面上一点P反射到视点的光强 I 为<strong>环境光的反射光强</strong> I<sub>e</sub>， <strong>理想漫反射光强</strong> I<sub>d</sub>，和<strong>镜面反射光</strong>I<sub>s</sub>的总和。</li>
<li>Phong光照明模型是真实感图形学中提出的第一个有影响的光照明模型</li>
<li>经验模型，Phong模型存在不足:<ul>
<li>显示出的物体象塑料，<strong>无质感变化</strong></li>
<li><strong>没有考虑物体间相互反射光</strong></li>
<li>镜面反射颜色与材质无关</li>
<li>镜面反射大入射角失真现象</li>
</ul>
</li>
</ul>
<h3 id="7-2-多边形表示的明暗处理"><a href="#7-2-多边形表示的明暗处理" class="headerlink" title="7.2 多边形表示的明暗处理"></a>7.2 多边形表示的明暗处理</h3><h5 id="Gouraud明暗处理-双线性光强插值"><a href="#Gouraud明暗处理-双线性光强插值" class="headerlink" title="Gouraud明暗处理(双线性光强插值)"></a>Gouraud明暗处理(双线性光强插值)</h5><ul>
<li>先计算物体表面多边形各顶点的光强, 然后用双线性插值, 求出多边形内部区域中各点的光强。</li>
<li><strong>基本算法描述</strong>:<ol>
<li>计算多边形顶点的平均法向;</li>
<li>计算顶点的平均光强;</li>
<li>插值计算离散边上的各点光强;</li>
<li>插值计算多边形内域中各点的光强。</li>
</ol>
</li>
<li><strong>优点</strong><ul>
<li>简单易行，计算量小</li>
<li>只需已知顶点的法向量 </li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li>只适用于简单的漫反射光照模型，不能正确模 拟镜面反射高光形状</li>
<li>用于动态显示物体时，物体表面明暗以不规则方式进行变化，高光显示问题</li>
<li>光亮度变化不连续的边界处出现过亮或过暗的条纹</li>
<li>公共顶点处颜色不连续，顶点方向不具代表性</li>
</ul>
</li>
<li><strong>在Gouraud提出明暗处理方法时，Phong模型还没有出现</strong></li>
</ul>
<h5 id="Phong明暗处理-双线性法向插值"><a href="#Phong明暗处理-双线性法向插值" class="headerlink" title="Phong明暗处理 (双线性法向插值)"></a>Phong明暗处理 (双线性法向插值)</h5><ul>
<li>与双线性光强插值相比, 该方法有如下特点:<ul>
<li>保留双线性插值, 对多边形边上的点和内域各点, 采用增量法。</li>
<li>对顶点的法向量进行插值, 而顶点的法向量, 用相邻的多边形的法向作平均。</li>
<li>由插值得到的法向, 计算每个像素的光亮度。</li>
<li>假定光源与视点均在无穷远处, 光强只是法向量的函数。</li>
</ul>
</li>
<li>优点<ul>
<li>Phong方法绘制的图形比Gouraud方法更真实</li>
</ul>
</li>
<li>缺点<ul>
<li>计算量远大于Gouraud方法</li>
</ul>
</li>
</ul>
<h5 id="阴影的生成"><a href="#阴影的生成" class="headerlink" title="阴影的生成"></a>阴影的生成</h5><ul>
<li>阴影<ul>
<li>光源不能直接照射的区域</li>
<li>对光源来说，不可见的面(隐藏面)</li>
</ul>
</li>
</ul>
<h3 id="7-3-透明"><a href="#7-3-透明" class="headerlink" title="7.3 透明"></a>7.3 透明</h3><ul>
<li>现实世界中有许多透明物体，如玻璃等。透过透明物体，可以观察到其后面的景物。</li>
<li>产生简单透明效果的方法<ul>
<li>插值透明方法</li>
<li>过滤透明方法</li>
</ul>
</li>
</ul>
<h5 id="Whitted光透射模型"><a href="#Whitted光透射模型" class="headerlink" title="Whitted光透射模型"></a>Whitted光透射模型</h5><ul>
<li>基于经验、理论，不是严格的物理模型。</li>
</ul>
<h5 id="Hall光透射模型"><a href="#Hall光透射模型" class="headerlink" title="Hall光透射模型"></a>Hall光透射模型</h5><ul>
<li>在Whitted光透射模型的基础上推广而来。<ul>
<li>加入光源引起的规则透射分量。</li>
<li>可以处理理想的漫透射。</li>
</ul>
</li>
</ul>
<h3 id="7-4-整体光照明模型"><a href="#7-4-整体光照明模型" class="headerlink" title="7.4 整体光照明模型"></a>7.4 整体光照明模型</h3><ul>
<li><strong>五个组成部分：</strong><ul>
<li></li>
</ul>
</li>
<li>简单光照模型是一种局部光照模型，不考虑周围环境对当前 景物表面的光照明影响，<strong>忽略了光在环境景物之间的传递</strong>，很难表现自然界复杂场景的高质量真实感图形。</li>
<li>基于简单光照明模型的<strong>光透射模型</strong>，虽然可以模拟光的折射，但是这种折射的计算范围很小，不能很好的模拟多个透明 体之间的复杂光照明现象。</li>
<li>对于上述的这些问题，就必须要有一个更精确的光照明模型。<strong>整体光照明模型</strong>就是这样的一种模型，它是相对于局部光照明模型而言的。</li>
</ul>
<h3 id="7-5-光线跟踪算法-P149"><a href="#7-5-光线跟踪算法-P149" class="headerlink" title="7.5 光线跟踪算法 P149"></a>7.5 光线跟踪算法 P149</h3><ul>
<li><strong>四种光线</strong><ul>
<li>视线：由视点与象素(x，y)发出的射线</li>
<li>阴影测试线：物体表面上点与光源的连线</li>
<li>反射光线 </li>
<li>折射光线</li>
</ul>
</li>
<li>无论是Gouraud还是Phong明暗绘制算法，都只能模拟局部光照明效果。</li>
<li>如果场景中存在<strong>光亮的镜面物体和透明物体，则光线会在物体之间反射和折射</strong>，这些都是上述算法所无法模拟的。还不能产生阴影效果。如果必须模拟这些效果，则我们可以采用光线跟踪算法或辐射度算法。</li>
<li><strong>自然界中光线的传播过程</strong>：光源 -&gt; 物体表面 -&gt; 物体表面 -&gt; 人眼</li>
<li><p>光线跟踪过程：<strong>光线传播的逆过程(视线跟踪)</strong></p>
<ul>
<li>光源发出光线，经反射与折射，只有很少部分可以进入人的眼睛。因此直接从光源出发，沿光的传播方向进行光 线跟踪是不现实的，也是不必要的。</li>
<li>实际上，<strong>光线跟踪算法的跟踪方向与光传播的方向是相反的，是视线跟踪</strong>。<br><img src="/CG/光线.png" width="45%"></li>
</ul>
</li>
<li><p><strong>优点</strong>: 能够方便的产生阴影，模拟镜面反射与折射现象。 </p>
</li>
<li><strong>缺点</strong>: 计算量大，每一条光线都要与场景中的物体进行求交、计算光照模型等。</li>
</ul>
<h5 id="递归终止条件"><a href="#递归终止条件" class="headerlink" title="递归终止条件"></a>递归终止条件</h5><ol>
<li>该光线未碰到任何物体。</li>
<li>该光线碰到了背景。</li>
<li>光线在经过许多次反射和折射以后，就会产生衰减，光线对于视点的光强贡献很小(小于某个设定值)。</li>
<li>光线反射或折射次数即跟踪深度大于一定值。</li>
</ol>
<h3 id="7-6-纹理"><a href="#7-6-纹理" class="headerlink" title="7.6 纹理"></a>7.6 纹理</h3><ul>
<li><strong>颜色纹理</strong>：光滑表面的花纹、图案。</li>
<li><strong>几何纹理</strong>：粗糙的表面(如桔子表面的皱纹), 是基于物体表面的微观几何形状的表面纹理。</li>
<li>两种方法来定义纹理:<ul>
<li>图像纹理</li>
<li>函数纹理</li>
</ul>
</li>
</ul>
<ol>
<li>分辨率为1024x1024的显示器各需要多少字节位平面<br>数为24的帧缓存？<br>A) 512KB ; B) 1 MB ; C) 2MB ; D) 3MB  </li>
<li>哪一个不是国际标准化组织(ISO)批准的图形标准？<br>A) GKS ; B) PHIGS ; C) CGM ; D) DXF</li>
<li>在计算机图形学的发展历史上，是谁确立了计算机图形学作为一门新学科的地位，他的哪些技术直到今天还在使用？</li>
<li>计算机图形系统的硬件设备有哪些？</li>
<li>光栅扫描显示器中，屏幕图形是依靠帧缓存进行刷新的，帧缓存里存放的是什么？</li>
<li>简述随机扫描显示器和光栅扫描显示器的简单工作原理和各自的特点。</li>
<li>用中点画线方法扫描转换连接两点P0（0,0）和P1（5,2）的直线段。<br>a = y0 - y1 = -2<br>b = x1 - x0 = 5<br>d0 = 2 <em> a + b = 1<br>d1 = 2 </em> a = -4<br>d2 = 2 * (a+b) = 6<br><img src="/CG/中点.png" width="45%"></li>
</ol>
<h2 id="图形学题目"><a href="#图形学题目" class="headerlink" title="图形学题目"></a>图形学题目</h2><ol>
<li>Breenham算法：<br><img src="/CG/bre.png" width="20%">  <img src="/CG/bre1.png" width="20%"></li>
<li>中点画圆算法<br><img src="/CG/中点画圆1.png" width="70%"></li>
<li><p>用边相关扫描线填充算法将顶点为P1 (2，2)，P2 (5，1)， P3(10，3)， P4(8，8)，P5(5，5)，P6(2，7)的多边形填充。请说明如何建立新边表NET和活动边表AET并写出该多边形填充的新边表NET和活动边表AET。<br><img src="/CG/扫描.png" width="60%"> </p>
</li>
<li><p>用数值微分DDA算法、中点算法和Bresenham算法扫描转换直线段(1,1)–(5,3)，<br>写出扫描转换的结果:写出每一步递推过程的x，y坐标及判别式d的值，图示计<br>算结果。</p>
</li>
<li>图中有两条圆弧A和B，假定当前取点为(xi，yi)，那么下一点只能是正<br>右方的 E(xi+1，yi)或右下方的SE(xi+1，yi-1)两者之一。 假设M是E和SE的中点，即，利用中点画圆算法，回答下列问题:<ul>
<li>当F(M) &lt; 0时，下一点应取哪个点? <strong>E点</strong> </li>
<li>当F(M) &gt; 0时，下一点应取哪个点? <strong>SE点</strong></li>
<li>当F(M) = 0时，下一点应取哪个点?  <strong>在E与SE之中随便取一个 即可，我们约定取SE点。</strong><br><img src="/CG/选点.png" width="30%"> </li>
</ul>
</li>
<li>裁剪的实质是什么?<ul>
<li>ans：裁剪的实质就是决定图形中哪些点、线段、文字、以及多边形在窗口之内。 </li>
</ul>
</li>
<li>已知窗口左下角坐标(50，50)，右上角坐标(400，400) 直线的端点坐标P1(40，100)和P2(500，420)， 试用Cohen-Sutherland直线编码裁剪算法，结合编码图示， 求出P1和P2所在区域的分区代码C1和C2。<ul>
<li>C1为0001; C2为1010 。 </li>
</ul>
</li>
<li>当线段与窗口边界有交点时，如果线段的长度为1024， 用中点分割算法求交点的次数是多少?<ul>
<li>10次。</li>
</ul>
</li>
<li>用Weiler-Atherton算法完成内裁剪和外裁剪。DCBA为裁剪窗口，dcba为要裁剪的多边形。<br><img src="/CG/wa题.png" width="50%"> </li>
<li>一个由顶点(10，20)，(20，20)和(15，30)所定义的三角形，让它相对于点Q(5，25)正向旋转30°，求其变换后的三角形。<br><img src="/CG/几何1.png" width="60%"> </li>
<li>推导以直线ax+by+c=0为对称轴的二维对称变换矩阵。<br><img src="/CG/几何2.png" width="70%"> </li>
<li>在坐标系oxyz中，求一个变换将P(1,1,1)Q(2,2,2)变换到z 轴上:P在坐标原点，Q在z轴正半轴。<br><img src="/CG/3dt.png" width="70%"> </li>
<li>如图所示三角形ABC，将其关于A点逆时针旋转90度，写 出其变换矩阵和变换后图形各点的规范化齐次坐标。<br><img src="/CG/3dti.png" width="40%"> </li>
<li>下列有关平面几何投影的叙述，错误的是( )<br>A)透视投影又可分为一点透视、二点透视、三点透视;<br>B)斜投影又可分为斜等测、斜二测;<br>C)正轴测又可分为正一测、正二测、正三测;<br>D)三视图又可分为正视图、侧视图、俯视图。</li>
<li>下列有关平面几何投影的叙述语句中，正确的论述为( )<br>A)在平面几何投影中，若投影中心移到距离投影面无穷远 处，则成为平行投影;<br>B)透视投影与平行投影相比，视觉效果更有真实感，而且 能真实地反映物体的精确的尺寸和形状;<br>C)透视投影变换中，一组平行线投影在与之平行的投影面 上，可以产生灭点;<br>D)在三维空间中的物体进行透视投影变换，可能产生三个 或者更多的主灭点。  </li>
<li>用下列二维图形变换矩阵:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;0&nbsp;1&nbsp;<br>T&nbsp;=&nbsp;0&nbsp;1&nbsp;1&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    0&nbsp;0&nbsp;1  &nbsp;<br>将产生变换的结果为( )<br>A) 图形放大2倍;<br>B) 图形放大2倍，同时沿X、Y坐标轴方向各移动1个绘图单位;<br>C) 沿X坐标轴方向各移动2个绘图单位;<br>D) 沿X坐标轴方向放大2倍，同时沿X、Y坐标轴方向各平移1个 绘图单位。</li>
<li>下列有关透视投影的叙述，错误的是( )<br>A)投影线从视点出发;<br>B)投影线不平行;<br>C)任何一束不平行于投影面的平行线的透视投影将汇成一点;<br>D)主灭点有无数个。  </li>
<li>请解释平面几何投影的含义。</li>
<li>何为“透视投影”?并说明“灭点”和“主灭点”是如何产生的?</li>
<li>什么是观察坐标系?为什么要建立观察坐标系?</li>
<li>已知投影面为xoy坐标平面，投影中心在z轴的正向、z=d的 位置上，求透视投影变换矩阵。</li>
<li>描述Z缓存器消隐算法的基本原理和算法实现;</li>
<li>光线跟踪算法的跟踪方向与光传播的方向是相同的，是视线 跟踪。( )</li>
<li>双线性法向插值算法先计算出曲面在各多边形顶点处的光强 ，然后再采用双线性插值方法确定在扫描线上每个像素处的 光强值，得到多边形的光滑颜色分布。( )</li>
<li>非理想镜面反射中，镜面反射指数n模拟镜面反射光在空间 中的汇聚程度，n越大，表面越粗糙( )。</li>
<li>粗糙的物体表面能够将反射光向各个方向散射， 称为( )。</li>
<li>比较Gouraud明暗处理算法和Phong明暗处理算法的优缺点。</li>
<li>何谓“光线跟踪算法”?请简要叙述光线跟踪算法的基本思想。</li>
</ol>
<ul>
<li>CRT的原理简单了解</li>
<li>光栅图形显示系统：4部分 每一部分具体是做什么用的 </li>
<li>中点算法增量法的改进 为什么可以摆脱小数计算</li>
<li>扫面线算法 四个步骤，交点的计数问题</li>
<li>字符的两种类型 和存储的信息分别是什么</li>
<li>Cyrus Beck Line Clipping 梁八子算法不作要求</li>
<li>消隐算法的分类 要能判断。画家算法 Z-Buffer及它的改进 要能描述清楚，其余的了解基本思想和优缺点</li>
<li>物体对光产生<strong>反射、投射</strong>和部分<strong>吸收</strong>成热能，填空</li>
<li>两种投影类型 正轴测投影的分类，透视投影变换要会推导</li>
<li>三维图像的显示流程（剪裁和投影的前后关系）</li>
<li>光线跟踪算法的递归终止条件 简答题</li>
<li>为什么引入齐次坐标 ？把加法变成乘法；统一的表达方式；无穷？？</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Dai Sine</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://daisine.me/CG/">http://daisine.me/CG/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/note/">note</a><a class="post-meta__tags" href="/tags/图形学/">图形学</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/ml/"><i class="fa fa-chevron-left">  </i><span>机器学习笔记</span></a></div><div class="next-post pull-right"><a href="/uml/"><span>UML</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://daisine.me/CG/';
  this.page.identifier = 'CG/';
  this.page.title = '计算机图形学笔记及练习';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'dasine' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2019/05/10/5cd525fea97ac.png)"><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2019 By Dai Sine</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>