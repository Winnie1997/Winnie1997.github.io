<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="UML"><meta name="keywords" content="note"><meta name="author" content="Dai Sine"><meta name="copyright" content="Dai Sine"><title>UML | Hi, Dai</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-117497526-4', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-面向对象技术概述"><span class="toc-text">1. 面向对象技术概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-软件危机及软件工程"><span class="toc-text">1.1 软件危机及软件工程　</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-对软件开发的基本认识"><span class="toc-text">1.2 对软件开发的基本认识　</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-软件的固有复杂性"><span class="toc-text">1.3 软件的固有复杂性　</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-控制软件复杂性的基本方法"><span class="toc-text">1.4 控制软件复杂性的基本方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-5-面向对象技术"><span class="toc-text">1.5 面向对象技术</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-6-面向对象领域中的基本概念"><span class="toc-text">1.6 面向对象领域中的基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-7-小结-P29"><span class="toc-text">1.7 小结 P29</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-UML概述"><span class="toc-text">2. UML概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-为什么要学习UML？"><span class="toc-text">2.1 为什么要学习UML？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-UML的历史"><span class="toc-text">2.2 UML的历史</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-UML的特点"><span class="toc-text">2.3 UML的特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-UML的构成"><span class="toc-text">2.4 UML的构成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-UML中的视图"><span class="toc-text">2.5 UML中的视图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-UML在系统开发各阶段的应用"><span class="toc-text">2.6 UML在系统开发各阶段的应用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-UML各种图简介"><span class="toc-text">3. UML各种图简介</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-类图与对象图"><span class="toc-text">3.1 类图与对象图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-用例图"><span class="toc-text">3.2 用例图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-状态图"><span class="toc-text">3.3 状态图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-顺序图"><span class="toc-text">3.4 顺序图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-活动图"><span class="toc-text">3.5 活动图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-协作图"><span class="toc-text">3.6 协作图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-7-构件图"><span class="toc-text">3.7 构件图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-8-部署图"><span class="toc-text">3.8 部署图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-9-其他特征"><span class="toc-text">3.9 其他特征</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-10-为什么需要这么多种图"><span class="toc-text">3.10 为什么需要这么多种图</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-关系"><span class="toc-text">4. 关系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-关联"><span class="toc-text">4.1 关联</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-多重性"><span class="toc-text">4.2 多重性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-限定关联"><span class="toc-text">4.3 限定关联</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-自身关联"><span class="toc-text">4.4 自身关联</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-继承与泛化"><span class="toc-text">4.5 继承与泛化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6-依赖"><span class="toc-text">4.6 依赖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-7-类图和对象图"><span class="toc-text">4.7 类图和对象图</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-聚集、组成、接口和实现"><span class="toc-text">5. 聚集、组成、接口和实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-聚集"><span class="toc-text">5.1 聚集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-组成"><span class="toc-text">5.2 组成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-组成结构图"><span class="toc-text">5.3 组成结构图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-接口和实现"><span class="toc-text">5.4 接口和实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-5-接口和端口"><span class="toc-text">5.5 接口和端口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-6-可见性"><span class="toc-text">5.6 可见性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-7-作用域"><span class="toc-text">5.7 作用域</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-用例图"><span class="toc-text">6. 用例图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-什么是用例"><span class="toc-text">6.1 什么是用例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-用例模型的表示法"><span class="toc-text">6.2 用例模型的表示法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-用例之间关系的可视化表示"><span class="toc-text">6.3 用例之间关系的可视化表示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4-运用用例模型的实例-P75"><span class="toc-text">6.4 运用用例模型的实例 P75</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-5-用例的一些特点"><span class="toc-text">6.5 用例的一些特点</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-顺序图"><span class="toc-text">7. 顺序图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-什么是顺序图"><span class="toc-text">7.1 什么是顺序图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-顺序图的组成部分"><span class="toc-text">7.2 顺序图的组成部分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#顺序图-汽车和车钥匙-P93"><span class="toc-text">顺序图 - 汽车和车钥匙 P93</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#顺序图-饮料销售机-P95"><span class="toc-text">顺序图 - 饮料销售机 P95</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#顺序图-一般顺序图-P97"><span class="toc-text">顺序图 - 一般顺序图 P97</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#顺序图-帧化顺序图-P100"><span class="toc-text">顺序图 - 帧化顺序图 P100</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-协作图"><span class="toc-text">8. 协作图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-协作图"><span class="toc-text">8.1 协作图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-协作图-饮料销售机-P111"><span class="toc-text">8.2 协作图 - 饮料销售机 P111</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-状态图"><span class="toc-text">9. 状态图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-什么是状态图"><span class="toc-text">9.1 什么是状态图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-子状态"><span class="toc-text">8.2 子状态</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-活动图"><span class="toc-text">9. 活动图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-什么是活动图"><span class="toc-text">9.1 什么是活动图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-2-活动图的组成"><span class="toc-text">9.2 活动图的组成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-3-活动图-银行系统分析"><span class="toc-text">9.3 活动图 - 银行系统分析</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-构件图"><span class="toc-text">10. 构件图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#10-1-什么是构件"><span class="toc-text">10.1 什么是构件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-2-构件的接口表示法"><span class="toc-text">10.2 构件的接口表示法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-部署图"><span class="toc-text">11. 部署图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#11-1-什么是部署图"><span class="toc-text">11.1 什么是部署图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-2节点与连接"><span class="toc-text">11.2节点与连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-3-应用部署图-P147"><span class="toc-text">11.3 应用部署图 P147</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-4-部署图建模风格"><span class="toc-text">11.4 部署图建模风格</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-在开发过程中运用UML"><span class="toc-text">12. 在开发过程中运用UML</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#12-1-开发过程方法学"><span class="toc-text">12.1 开发过程方法学</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-2-GRAPPLE-快速应用工程指导原则"><span class="toc-text">12.2 GRAPPLE 快速应用工程指导原则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-3-学习案例介绍-发现业务过程-P183"><span class="toc-text">12.3 学习案例介绍 - 发现业务过程 P183</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-领域分析"><span class="toc-text">13. 领域分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#13-1-分析业务过程会谈"><span class="toc-text">13.1 分析业务过程会谈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-2-开发初步类图-P195"><span class="toc-text">13.2 开发初步类图 P195</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-3-对类分组"><span class="toc-text">13.3 对类分组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-4-形成关联"><span class="toc-text">13.4 形成关联</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-5-形成聚集和组成"><span class="toc-text">13.5 形成聚集和组成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-6-填充类的信息"><span class="toc-text">13.6 填充类的信息</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-收集系统需求"><span class="toc-text">14. 收集系统需求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-开发用例"><span class="toc-text">15. 开发用例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#15-1-用例分析"><span class="toc-text">15.1 用例分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-2-Server包-P225"><span class="toc-text">15.2 Server包 P225</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-交互"><span class="toc-text">16. 交互</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#16-1-系统中的工作部件-P223"><span class="toc-text">16.1 系统中的工作部件 P223</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-设计外观、感觉和部署-P242"><span class="toc-text">17. 设计外观、感觉和部署 P242</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Dai Sine</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">48</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">8</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2019/05/10/5cd525fea97ac.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Hi, Dai</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">UML</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-13</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/软件工程/">软件工程</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="1-面向对象技术概述"><a href="#1-面向对象技术概述" class="headerlink" title="1. 面向对象技术概述"></a>1. 面向对象技术概述</h2><h5 id="1-1-软件危机及软件工程"><a href="#1-1-软件危机及软件工程" class="headerlink" title="1.1 软件危机及软件工程　"></a>1.1 软件危机及软件工程　</h5><ul>
<li><strong>软件危机，软件工程</strong>的提出<ul>
<li>软件危机是指落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。<a id="more"></a></li>
<li>软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。</li>
</ul>
</li>
<li><strong>软件工程的目的</strong>就是在规定的时间、规定的开发费用内开发出满足用户需求的高质量的软件系统。<ul>
<li>高质量不只是指错误率低，还包括好用、易用、可移植、易维护等。</li>
</ul>
</li>
</ul>
<h5 id="1-2-对软件开发的基本认识"><a href="#1-2-对软件开发的基本认识" class="headerlink" title="1.2 对软件开发的基本认识　"></a>1.2 对软件开发的基本认识　</h5><ul>
<li><strong>软件是一个逻辑部件</strong>，而不是一个物理部件，所以软件具有与硬件不同的特点：<ul>
<li>表现形式不同</li>
<li>生产方式不同</li>
<li>产品要求不同</li>
<li>维护方式不同</li>
</ul>
</li>
</ul>
<h5 id="1-3-软件的固有复杂性"><a href="#1-3-软件的固有复杂性" class="headerlink" title="1.3 软件的固有复杂性　"></a>1.3 软件的固有复杂性　</h5><ul>
<li>著名的计算机专家、被称之为IBM 360系列计算机之父的F. Brooks认为软件的复杂性是固有的，软件可能是人类所能制造出来的最复杂的实体。 </li>
<li>软件固有复杂性使得开发成员之间的通讯变得困难，开发费用超支、开发时间延期等；也导致产品有缺陷、不易理解、不可靠、难以使用、功能难以扩充等。</li>
<li><strong>软件的复杂性是固有的</strong>，即不能采用某种方法彻底消除软件的复杂性，因此软件危机只能是通过控制复杂性的方法解决。</li>
</ul>
<h5 id="1-4-控制软件复杂性的基本方法"><a href="#1-4-控制软件复杂性的基本方法" class="headerlink" title="1.4 控制软件复杂性的基本方法"></a>1.4 控制软件复杂性的基本方法</h5><ul>
<li><strong>分解</strong><ul>
<li>对复杂系统采用“各个击破”的策略</li>
</ul>
</li>
<li><strong>抽象</strong><ul>
<li>抽取系统中的基本特性而忽略非基本的部分</li>
</ul>
</li>
<li><strong>模块化</strong><ul>
<li>高内聚（cohesion），低耦合（coupling）</li>
<li>高内聚指的是在一个模块中应尽量多地汇集逻辑上相关的计算资源；低耦合指的是模块之间的相互作用应尽量少。</li>
</ul>
</li>
<li><strong>信息隐蔽</strong><ul>
<li>也称封装</li>
<li>模块内部的实现细节与外界隔离</li>
</ul>
</li>
</ul>
<h5 id="1-5-面向对象技术"><a href="#1-5-面向对象技术" class="headerlink" title="1.5 面向对象技术"></a>1.5 面向对象技术</h5><ul>
<li>对象（object）  行动或思考时作为目标的人或事物对象。</li>
<li>对象是系统中用来描述客观事物的一个实体，它是构成系统的一个基本单位。</li>
<li>一个对象由<strong>一组属性（特性）和对这组属性进行操作的一组操作（方法）</strong>组成。属性和操作合起来被称为特征（feature）</li>
<li><strong><code>类</code></strong>是具有相同属性和方法的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，其内部包括属性和方法两个主要部分。</li>
<li>对象是一个类（种类）的实例。类是用来创建对象的模板。</li>
</ul>
<h5 id="1-6-面向对象领域中的基本概念"><a href="#1-6-面向对象领域中的基本概念" class="headerlink" title="1.6 面向对象领域中的基本概念"></a>1.6 面向对象领域中的基本概念</h5><ul>
<li><strong>继承(子类，超类)</strong><ul>
<li>特殊类的对象拥有其一般类的全部属性与方法，称作特殊类对一般类的继承。</li>
<li>一般类/特殊类；父类/子类；超类/子类；基类/派生类等是相同的概念。</li>
<li>子类都继承了父类的特征。</li>
</ul>
</li>
<li><strong>多态性</strong><ul>
<li>在面向对象技术中，多态指的是使一个实体在不同的上下文条件下具有不同意义或用法的能力。</li>
<li>不同的类中可以有同名的操作，每个类中发生的操作各不相同。</li>
</ul>
</li>
<li><strong>封装 / 信息隐藏</strong><ul>
<li>把对象的属性和方法结合成一个独立的系统单位，并尽可能隐蔽对象的内部细节。</li>
</ul>
</li>
<li><strong>接口</strong></li>
<li><strong>消息传递</strong><ul>
<li><code>消息</code>：就是向对象发出的服务请求，它包含下述信息：提供服务的对象标识、服务（方法）标识、输入信息和回答信息。</li>
<li>对象之间的协作是通过相互发送消息。</li>
<li>一个对象发送一个操作消息（或请求）给另一个对象，接受消息的对象就执行这个操作。</li>
</ul>
</li>
<li><strong>关联</strong><ul>
<li>对象之间通常以某种方式发生关联。</li>
<li>对象之间有时能以多种方式发生关联</li>
<li>一个类可以和多个类关联。</li>
<li>多重性：用于说明在关联中一个类的对象可以对应另一个类的多少对象。</li>
</ul>
</li>
<li><strong>聚集</strong><ul>
<li>聚集的一种形式是聚集对象和它的组成对象之间具有强关联。<br>一个典型的计算机系统就是聚集的一个例子——它由许多不同类型的对象组合而成。</li>
<li>组成的关键特征是部分对象<strong>只能</strong>存在于组成对象之中。在组成体中，部分对象有时可能先于组成体消亡。<br>树叶可能先于树而消亡。衬衫是衬衫主体、衣领、衣袖、纽扣..的组成体。</li>
</ul>
</li>
</ul>
<h5 id="1-7-小结-P29"><a href="#1-7-小结-P29" class="headerlink" title="1.7 小结 P29"></a>1.7 小结 P29</h5><ul>
<li>面向对象是一种依赖于几个基本原则的思维方法。对象是类的实例。类是具有相同属性和操作的一类对象集。当你创建了一个对象后，对象的属性和操作数目由你所处理的问题域确定。</li>
<li><strong>继承</strong>是面向对象中的一个重要方面。对象继承了所属类的属性和操作。类同样也可以继承其它类的属性和操作。</li>
<li><strong>多态性</strong>是另一个重要的方面，它是指不同的类中可以有相同名字的操作，并且这个操作在每个类中都能以各自不同的方式执行。</li>
<li>对象对其他对象和外部世界隐藏了其操作的执行过程。每个对象都要提供一个让其他对象（和人）用来执行该对象中操作的接口。</li>
<li>对象通过相互之间的消息传递协同工作。消息是执行操作的请求。</li>
<li>对象通常要和其他对象发生关联。关联可以具有多种形式。一个类的对象可能和多个其他类的对象同时发生关联。</li>
<li><strong>聚集是关联的一种</strong>，聚集对象由部分构成。<strong>组成又是一种特殊的聚集</strong>。在一个组成对象中，部分对象只能作为组成对象的一部分与组成对象同时存在。</li>
</ul>
<h2 id="2-UML概述"><a href="#2-UML概述" class="headerlink" title="2. UML概述"></a>2. UML概述</h2><h5 id="2-1-为什么要学习UML？"><a href="#2-1-为什么要学习UML？" class="headerlink" title="2.1 为什么要学习UML？"></a>2.1 为什么要学习UML？</h5><ul>
<li>什么是UML？<ul>
<li>UML是Unified Modeling Language（统一建模语言）的简称。</li>
<li>UML是对软件密集型系统中的制品（软件开发过程中产生的各种各样的产物，如模型、源代码、测试用例等）进行可视化、详述、构造和文档化的语言。</li>
</ul>
</li>
<li>模型<ul>
<li>模型是用文字、图表、符号、关系式以及实体模样等描述所认识到的客观对象的一种简化表示形式。它是人们为了研究和解决客观世界中存在的各种问题而对客观现实经过思维抽象后得到的。简单地说，模型就是所描述客观对象的抽象表示。</li>
<li>一般来讲，模型都包含一个完整的概念集合、一套相应的表示方法以及必要的规则约束，它们为人们抽象地表达客观对象提供了一个参考性的框架环境。</li>
</ul>
</li>
<li>建立模型的优点<ul>
<li>使用模型可以更好地理解问题 </li>
<li>使用模型可以加强人员之间的沟通 </li>
<li>使用模型可以更早地发现错误或疏漏的地方 </li>
<li>使用模型可以获取设计结果 </li>
<li>模型为最后的代码生成提供依据 </li>
</ul>
</li>
</ul>
<h5 id="2-2-UML的历史"><a href="#2-2-UML的历史" class="headerlink" title="2.2 UML的历史"></a>2.2 UML的历史</h5><ul>
<li>UML是由世界著名的面向对象技术专家G. Booch, J. Rumbaugh 和 I. Jacobson发起，在Booch方法，OMT方法和OOSE方法的基础上，广泛征求意见，集众家之长，几经修改而完成的。</li>
<li>为什么UML能得到广泛的应用<ul>
<li>图形化的建模语言</li>
<li>开发者用来为面向对象系统建立模型</li>
<li>具有灵活性与可扩展性</li>
</ul>
</li>
<li>由Object Management Group (OMG)推荐成为国际标准。目前最新的UML规范说明是2003年3月发布的1.5版本（<a href="http://uml.org）" target="_blank" rel="noopener">http://uml.org）</a></li>
</ul>
<h5 id="2-3-UML的特点"><a href="#2-3-UML的特点" class="headerlink" title="2.3 UML的特点"></a>2.3 UML的特点</h5><ul>
<li>UML的主要特点： <ul>
<li>统一的标准：UML已被OMG接受为标准的建模语言</li>
<li>面向对象</li>
<li>可视化、表示能力强大</li>
<li>独立于过程</li>
<li>概念明确，建模表示法简洁，图形结构清晰，容易掌握使用</li>
</ul>
</li>
<li>UML和程序设计语言的关系<ul>
<li>用Java，C++ 等 programming language是用编码实现一个系统</li>
<li>用UML是对一个系统建立模型</li>
<li>一些软件工具可以根据 UML所建立的系统模型来产生Java, C++ 或其它程序设计语言代码框架。</li>
</ul>
</li>
</ul>
<h5 id="2-4-UML的构成"><a href="#2-4-UML的构成" class="headerlink" title="2.4 UML的构成"></a>2.4 UML的构成</h5><ul>
<li><strong><code>类图</code></strong></li>
<li>对象图</li>
<li><strong><code>用例图</code></strong></li>
<li><strong><code>顺序图</code></strong></li>
<li>协作图</li>
<li>状态图</li>
<li><strong><code>活动图</code></strong></li>
<li>构件图</li>
<li>配置图</li>
</ul>
<p><img src="/uml/图关系.png" width="60%"><img src="/uml/4+1.png" width="40%">  </p>
<h5 id="2-5-UML中的视图"><a href="#2-5-UML中的视图" class="headerlink" title="2.5 UML中的视图"></a>2.5 UML中的视图</h5><ul>
<li>UML中的视图包括：（这5个视图被称为“4+1”视图）<ul>
<li>用例视图</li>
<li>逻辑视图：用于表示系统的概念设计和子系统结构等。</li>
<li>实现视图：用于说明代码的结构。</li>
<li>进程视图：用于说明系统中并发执行和同步的情况。</li>
<li>部署视图：用于定义硬件节点的物理结构。</li>
</ul>
</li>
</ul>
<h5 id="2-6-UML在系统开发各阶段的应用"><a href="#2-6-UML在系统开发各阶段的应用" class="headerlink" title="2.6 UML在系统开发各阶段的应用"></a>2.6 UML在系统开发各阶段的应用</h5><ul>
<li>在<strong>分析阶段</strong>，用户的需求用UML模型来描述。</li>
<li>在<strong>设计阶段</strong>，引入定义软件系统中技术细节的类（如处理用户接口、数据库、通信和并行性等问题的类）。</li>
<li>在<strong>实现阶段</strong>，用面向对象程序设计语言将来自设计阶段的类转换成实际的代码。</li>
<li>UML模型还是<strong>测试阶段</strong>的依据<ul>
<li>单元测试使用类图和类规格说明。</li>
<li>集成测试使用构件图和协作图。</li>
<li>系统测试使用用例图来验证系统的行为。</li>
</ul>
</li>
</ul>
<h2 id="3-UML各种图简介"><a href="#3-UML各种图简介" class="headerlink" title="3. UML各种图简介"></a>3. UML各种图简介</h2><h5 id="3-1-类图与对象图"><a href="#3-1-类图与对象图" class="headerlink" title="3.1 类图与对象图"></a>3.1 类图与对象图</h5><ul>
<li>类是一类或者一组具有类似属性和共同行为的事物。</li>
<li>UML类图的特点：<ul>
<li>矩形方框</li>
<li>被分为三个区域：类名、类的属性、类的操作</li>
<li>类名由多个单词组成；每个单词的首字母要大写，单词之间不用空格</li>
<li>属性名和操作名也类似，但首字母不用大写 </li>
<li>每个操作名的后面都有一对括号<br><img src="/uml/类图标.png" width="22%">  <img src="/uml/对象图标.png" width="65%"> </li>
</ul>
</li>
<li>对象是一个类的实例，是具有具体属性值的一个具体事物。<ul>
<li>矩形方框</li>
<li>对象名首字母为小写，对象名下面要带下划线</li>
<li>冒号左边为实例名，冒号右边为类名；对象也可以是匿名</li>
</ul>
</li>
</ul>
<h5 id="3-2-用例图"><a href="#3-2-用例图" class="headerlink" title="3.2 用例图"></a>3.2 用例图</h5><ul>
<li>用例是从用户的观点对系统行为的一个描述；它是用来从用户的观察角度收集系统需求的主要技术。</li>
<li>用例图的特点：<ul>
<li>直立小人被称为参与者（actor）；参与者可以是一个人，也可以是另一个系统.</li>
<li>椭圆形代表用例。</li>
<li>矩形代表系统。<br><img src="/uml/用例图.png" width="35%">   <img src="/uml/状态图.png" width="20%"></li>
</ul>
</li>
</ul>
<h5 id="3-3-状态图"><a href="#3-3-状态图" class="headerlink" title="3.3 状态图"></a>3.3 状态图</h5><ul>
<li>在任一给定的时刻，一个对象总是处于某一特定的<strong>状态</strong>。</li>
<li>UML状态图的特点：<ul>
<li>圆角矩形</li>
<li>最顶端的符号（实心圆）代表起始状态，而最底端的符号（眼形圆）表示终止状态</li>
</ul>
</li>
</ul>
<h5 id="3-4-顺序图"><a href="#3-4-顺序图" class="headerlink" title="3.4 顺序图"></a>3.4 顺序图</h5><ul>
<li>顺序：类图和对象图表达的是系统的静态结构。在一个运行的系统中，对象之间要发生交互，并且这些交互要经历一定的时间。UML顺序图所表达的正是这种<strong>基于时间的动态交互</strong>。</li>
<li>顺序图的特点：<ul>
<li>横坐标为系统中的对象</li>
<li>每个对象都有一个或多个操作</li>
<li>对象间通过相互传递消息来协同工作</li>
<li>纵坐标为时间序列<br><img src="/uml/顺序图2.png" width="50%">  </li>
</ul>
</li>
</ul>
<h5 id="3-5-活动图"><a href="#3-5-活动图" class="headerlink" title="3.5 活动图"></a>3.5 活动图</h5><ul>
<li>活动即工作步骤。</li>
<li>活动图的特点：<ul>
<li>和流程图很接近</li>
<li>圆角矩形（比状态图更窄，更接近与椭圆）</li>
<li>箭头表示活动的转移 </li>
<li>实心圆代表起点，眼形圆代表终点<br><img src="/uml/活动图.png" width="35%">   <img src="/uml/协作图.png" width="50%"> </li>
</ul>
</li>
</ul>
<h5 id="3-6-协作图"><a href="#3-6-协作图" class="headerlink" title="3.6 协作图"></a>3.6 协作图</h5><ul>
<li>协作图用于展示对象之间的交互关系。<ul>
<li>对象图展示出对象之间的静态关系。协作图是对对象图的扩展。协作图除了展示对象之间的关联，还显示出对象之间的消息传递。</li>
</ul>
</li>
<li>协作图的特点：<ul>
<li>关联线附近的箭头线表示对象之间传递的消息，箭头指向消息接收对象</li>
<li>消息名称和消息序号附在箭头线附近</li>
<li>顺序图和协作图之间可以相互转换  </li>
</ul>
</li>
</ul>
<h5 id="3-7-构件图"><a href="#3-7-构件图" class="headerlink" title="3.7 构件图"></a>3.7 构件图</h5><ul>
<li>软件构件是软件系统的一个物理单元。在UML中，数据文件、表格、可执行文件、文档和动态链接库等都被定义为构件。</li>
<li>构件图和部署图与整个计算机系统密切相关。</li>
<li>构件图的特点：<ul>
<li>一个左侧附有两个小矩形的大矩形框。</li>
<li>也可以用一个顶部带关键字 &lt;<component>&gt;的矩形表示。<br><img src="/uml/构件图1.png" width="40%"> <img src="/uml/构件图2.png" width="30%"> </component></li>
</ul>
</li>
</ul>
<h5 id="3-8-部署图"><a href="#3-8-部署图" class="headerlink" title="3.8 部署图"></a>3.8 部署图</h5><ul>
<li>部署图的用途：UML部署图显示了基于计算机系统的物理体系结构。</li>
<li>部署图的特点：<ul>
<li>立方体图标</li>
<li>立方体之间的连线表示体系之间的关系<br><img src="/uml/部署图.png" width="40%"></li>
</ul>
</li>
</ul>
<h5 id="3-9-其他特征"><a href="#3-9-其他特征" class="headerlink" title="3.9 其他特征"></a>3.9 其他特征</h5><ul>
<li>注释：通过附加注释来做解释说明。</li>
<li>符号特征：<ul>
<li>带折角的矩形，矩形中是解释性文字。</li>
<li>注释和被注释的图元素之间用一条虚线连接。</li>
</ul>
</li>
<li>构造型（版型）<ul>
<li>版型是建模人员在已有的构造块上派生出的新构造块，这些新构造块是和特定问题相关的。</li>
<li>版型可以应用于所有类型的模型元素，包括类、节点、构件、注解、关系、包、操作等。</li>
</ul>
</li>
<li>关键字<ul>
<li>版型用两对尖括号括起来的一个名称来表示，这个括号叫做双尖括号（guillemots）。这个被括起来的名称叫做关键字。</li>
<li>如<code>&lt;&lt;Interface&gt;&gt;，&lt;&lt;entity&gt;&gt;</code></li>
</ul>
</li>
</ul>
<h5 id="3-10-为什么需要这么多种图"><a href="#3-10-为什么需要这么多种图" class="headerlink" title="3.10 为什么需要这么多种图"></a>3.10 为什么需要这么多种图</h5><ul>
<li>每一种UML图都提供一种组成特殊视图的方式。采用多视角的目标是为了能够和每一类风险承担人良好地沟通。</li>
<li>UML是一套表示法系统。</li>
<li>UML由一组图组成，它使得系统分析员可以利用这一标准来建立能够和客户、程序员以及任何参与程序开发的人员理解的多视角的系统蓝图。不同的风险承担人通常使用不同类型的图相互交流。</li>
<li>UML模型<strong>只说明一个系统应该做什么</strong>，并没有告诉我们系统应该怎么做。</li>
</ul>
<h2 id="4-关系"><a href="#4-关系" class="headerlink" title="4. 关系"></a>4. 关系</h2><h5 id="4-1-关联"><a href="#4-1-关联" class="headerlink" title="4.1 关联"></a>4.1 关联</h5><ul>
<li><strong>关联</strong>：当类之间在概念上有连接关系时，类之间的连接叫做关联。<ul>
<li>用一条线连接两个类，并把关联的名字放在这个连线上</li>
<li>关联的方向用一<strong>个实心三角形箭头</strong>来指明<br><img src="/uml/关联.png" width="50%">  <img src="/uml/关联1.png" width="35%"> <img src="/uml/关联.png" width="50%">  </li>
</ul>
</li>
<li><strong>关系上的约束</strong>：两个类之间的一个关联随后就有一个规则，可以通过关联线附近加注一个约束来说明这个规则。<ul>
<li>花括号、虚线（或关系）</li>
</ul>
</li>
<li><strong>关联类</strong>：和类一样，关联也可以有自己的属性和操作，称为关联类。<ul>
<li>用虚线将关联类和对应的关联线连接起来。</li>
</ul>
</li>
<li><strong>链</strong>：关联类的实例叫做链。（类的实例是对象）<ul>
<li>用一条线连接两个对象，并把链的名字放在这个连线上。</li>
<li>链的名字也要加下划线。<br><img src="/uml/约束.png" width="35%"> <img src="/uml/链.png" width="50%"><br><img src="/uml/关联类.png" width="50%"></li>
</ul>
</li>
</ul>
<h5 id="4-2-多重性"><a href="#4-2-多重性" class="headerlink" title="4.2 多重性"></a>4.2 多重性</h5><ul>
<li>多重性：某个类有多个对象可以和另一个类的多个对象关联。<ul>
<li>符号特征：在参与关联的类附近的关联线上注明多重性数值。UML使用 <code>*</code> 来代表许多；<code>1..*</code> 代表一个或多个；<code>,</code> 代表”或”关系<br><img src="/uml/多重性.png" width="50%"></li>
</ul>
</li>
</ul>
<h5 id="4-3-限定关联"><a href="#4-3-限定关联" class="headerlink" title="4.3 限定关联"></a>4.3 限定关联</h5><ul>
<li>在UML中，标识符ID（identification）信息叫做限定符。<ul>
<li>符号特征：一个小矩形框<br><img src="/uml/限定关联.png" width="50%"></li>
</ul>
</li>
</ul>
<h5 id="4-4-自身关联"><a href="#4-4-自身关联" class="headerlink" title="4.4 自身关联"></a>4.4 自身关联</h5><ul>
<li>一个类可能与它自己发生关联，这样的关联被称为自身关联。<br><img src="/uml/自身关联.png" width="50%"></li>
</ul>
<h5 id="4-5-继承与泛化"><a href="#4-5-继承与泛化" class="headerlink" title="4.5 继承与泛化"></a>4.5 继承与泛化</h5><ul>
<li><p>继承：如果你知道某物所属的种类，你自然就会知道同类的其他事物也具有该事物的一些特征。在面向对象术语中，这种关系被称为继承。<strong>在UML中，则被称为泛化</strong>。  </p>
<blockquote>
<p>基类或根类 —— 叶类<br>单继承 —— 多继承   </p>
</blockquote>
<ul>
<li>符号特征： <strong>指向父类一端</strong>带有一个空心三角箭头<br><img src="/uml/泛化.png" width="35%"></li>
</ul>
</li>
<li>抽象类：不提供实例对象的类被称为抽象类。 <ul>
<li>符号特征：类名<strong>用斜体书写</strong></li>
</ul>
</li>
</ul>
<h5 id="4-6-依赖"><a href="#4-6-依赖" class="headerlink" title="4.6 依赖"></a>4.6 依赖</h5><ul>
<li>依赖：如果一个类使用了另一个类，这种关系称之为依赖。<ul>
<li>符号特征：在有依赖关系的类之间画上一条带箭头的虚线<br><img src="/uml/依赖.png" width="45%"></li>
</ul>
</li>
</ul>
<h5 id="4-7-类图和对象图"><a href="#4-7-类图和对象图" class="headerlink" title="4.7 类图和对象图"></a>4.7 类图和对象图</h5><ul>
<li><p>类图给出的是多个类以及类之间的关系，它描述的是一般性的、定义性的信息</p>
<ul>
<li>类图包括类以及类之间的关联；</li>
<li>类图用来表现系统的静态构成；</li>
<li>一个系统的静态构成可以由<strong>多张类图</strong>来共同描述，不同的类图描述了系统的不同层面、角度及范围。</li>
</ul>
</li>
<li><p>对象图则在某个特定时刻多个具体实例以及它们如何联系起来的信息。<br><img src="/uml/类图.png" width="45%"> <img src="/uml/对象图.png" width="45%"> </p>
</li>
</ul>
<h2 id="5-聚集、组成、接口和实现"><a href="#5-聚集、组成、接口和实现" class="headerlink" title="5. 聚集、组成、接口和实现"></a>5. 聚集、组成、接口和实现</h2><h5 id="5-1-聚集"><a href="#5-1-聚集" class="headerlink" title="5.1 聚集"></a>5.1 聚集</h5><ul>
<li>聚集：一个类有时是由几个部分类构成，这种特殊类型的关系被称为聚集。部分类和由它们组成的类之间是一种整体－部分（part-whole）关联。<ul>
<li>符号特征：关联线上有一个<strong>空心菱形箭头</strong>，箭头的方向是从部分指向整体。<br><img src="/uml/聚集.png" width="55%"> </li>
</ul>
</li>
<li>聚集上的约束：可以在聚集上施加一个“or”约束，它表示某个整体包含一个或另一个部分。<br><img src="/uml/聚集约束.png" width="55%"> </li>
</ul>
<h5 id="5-2-组成"><a href="#5-2-组成" class="headerlink" title="5.2 组成"></a>5.2 组成</h5><ul>
<li>组成：组成是强类型的聚集。聚集中每个部分体只能属于一个整体。<ul>
<li>符号特征：关联线上有一个实心菱形箭头，箭头的方向是从部分指向整体。<br><img src="/uml/组成.png" width="55%"> </li>
</ul>
</li>
</ul>
<h5 id="5-3-组成结构图"><a href="#5-3-组成结构图" class="headerlink" title="5.3 组成结构图"></a>5.3 组成结构图</h5><ul>
<li>组成是展示一个类的构件的一种方式。通过组成结构图可以展示<strong>类的内部结构</strong>。<br><img src="/uml/组成结构图.png" width="50%"></li>
</ul>
<h5 id="5-4-接口和实现"><a href="#5-4-接口和实现" class="headerlink" title="5.4 接口和实现"></a>5.4 接口和实现</h5><ul>
<li><strong>接口</strong>是描述类的部分行为的一组操作，它也是一个类提供给另一个类的一组操作。<ul>
<li>符号特征：和类相似，都是用一个矩形图标来代表。接口只是一组操作，没有属性。</li>
</ul>
</li>
<li><strong>实现</strong>：一个类和它的接口之间的关系叫做实现。<ul>
<li>符号特征：和继承符号相似，但它是一个带空心三角形的箭头的虚线表示，箭头的方向指向接口。省略表示法是将接口表示为一个小圆圈，并和实现它的类用一条线连起来</li>
</ul>
</li>
</ul>
<p><img src="/uml/接口1.png" width="55%">  <img src="/uml/接口2.png" width="30%"><br><img src="/uml/接口3.png" width="50%">  <img src="/uml/接口4.png" width="40%"> </p>
<h5 id="5-5-接口和端口"><a href="#5-5-接口和端口" class="headerlink" title="5.5 接口和端口"></a>5.5 接口和端口</h5><ul>
<li>端口<ul>
<li>符号特征：位于类符号边缘上的一个小方格，这个小方格连接到接口<br><img src="/uml/端口.png" width="40%"> </li>
</ul>
</li>
</ul>
<h5 id="5-6-可见性"><a href="#5-6-可见性" class="headerlink" title="5.6 可见性"></a>5.6 可见性</h5><ul>
<li><strong>可见性</strong>可应用于属性或操作，它说明在给定类的属性和操作（或者接口的操作）的情况下，其他类可以访问到的属性和操作的范围。</li>
<li><strong>可见性有三个层次</strong>（级别）：<ul>
<li>公有层次上，其他类可以直接访问这个层次中的属性和操作。</li>
<li>受保护层次上，只有继承类这些属性和操作的子类可以访问最初类的属性和操作。</li>
<li>私有层次上，只有最初的类才能访问这些属性和操作。</li>
</ul>
</li>
<li>符号特征<ul>
<li><code>+</code> 表示该操作或属性是公有的（其它类可访问）</li>
<li><code>#</code> 表示该操作或属性是受保护的（子类才可访问）</li>
<li><code>-</code> 表示该操作或属性是私有的（最初类才可访问）</li>
</ul>
</li>
</ul>
<h5 id="5-7-作用域"><a href="#5-7-作用域" class="headerlink" title="5.7 作用域"></a>5.7 作用域</h5><ul>
<li>作用域是与属性和操作相关的又一个重要概念。存在两种可能的作用域：<ul>
<li>实例作用域：类的每个实例对象都有自己的属性值和操作。</li>
<li>分类符作用域：一个类的所有实例只存在一个属性值和操作。</li>
</ul>
</li>
</ul>
<h2 id="6-用例图"><a href="#6-用例图" class="headerlink" title="6. 用例图"></a>6. 用例图</h2><h5 id="6-1-什么是用例"><a href="#6-1-什么是用例" class="headerlink" title="6.1 什么是用例"></a>6.1 什么是用例</h5><ul>
<li>用例的定义：<ul>
<li>用例是系统的一组使用场景。每个场景描述了一个事件的序列。每个序列是由一个人、另一个系统、一台硬件设备或者某段时间的流逝所发起。</li>
<li>这些发起事件序列的实体叫做<strong>参与者</strong>。</li>
<li>用例是对一个<strong>参与者</strong>使用系统的一项功能时所进行的交互过程的一个文字描述序列。<br><img src="/uml/用例图1.png" width="40%"> </li>
</ul>
</li>
</ul>
<h5 id="6-2-用例模型的表示法"><a href="#6-2-用例模型的表示法" class="headerlink" title="6.2 用例模型的表示法"></a>6.2 用例模型的表示法</h5><ul>
<li>用例模型（use case model）<ul>
<li>用户知道的比他们清楚表达出来的要多，用例能帮助用户解决表达问题。</li>
<li>用例是由参与者发起的，参与者（或许是发起者，但不是必须的）能够从用例的执行中获得有价值的事物。</li>
<li>参与者、用例和互连线共同组成了用例模型。</li>
</ul>
</li>
<li>每个用例是一组场景的组合，而每个场景又是一个步骤序列。</li>
<li><p>用例描述的主要内容：</p>
<ul>
<li>用例的目标</li>
<li>用例是怎样启动的</li>
<li>参与者和用例之间的消息是如何传递的</li>
<li>用例中除了主路径外，其它路径是什么</li>
<li>用例结束后的系统状态</li>
<li>其它需要描述的内容</li>
</ul>
</li>
<li><p>符号特征：</p>
<ul>
<li>用例用一个椭圆形表示。</li>
<li>参与者用直立人形图标表示。</li>
<li>用例的发起参与者在用例图的左侧，接收参与者在用例图的右侧。</li>
<li>关联线连接参与者和用例并且表示参与者与用例之间有通信关系；关联线是实线。</li>
</ul>
<p><img src="/uml/用例图2.png" width="40%">  </p>
</li>
</ul>
<h5 id="6-3-用例之间关系的可视化表示"><a href="#6-3-用例之间关系的可视化表示" class="headerlink" title="6.3 用例之间关系的可视化表示"></a>6.3 用例之间关系的可视化表示</h5><ul>
<li><strong><code>包含</code></strong>：在一个用例中重用另一个用例中的步骤<ul>
<li>符号特征：虚线箭头，箭头指向被包含的用例，在虚线上加关键字<code>&lt;&lt;include&gt;&gt;</code><br><img src="/uml/用例包含.png" width="40%"> </li>
</ul>
</li>
<li><strong><code>扩展</code></strong>：通过对已有用例增加步骤创建一个新的用例<ul>
<li>基用例：新用例扩展了原来的用例，因为它在原来的用例上增加了新的步骤序列，因此原用例被称作基用例。</li>
<li>扩展点：扩展只能发生在基用例的序列中某个具体指定点上，这个点叫做扩展点。</li>
<li>符号特征：虚线箭头，箭头指向基用例，在虚线上加关键字<code>&lt;&lt;extend&gt;&gt;</code>，在基用例中注明扩展点的发生位置。<br><img src="/uml/用例扩展包含.png" width="40%"> </li>
</ul>
</li>
<li><strong><code>泛化</code></strong>：子用例可以继承父用例的行为和含义，还可以增加自己的行为。任何父用例出现的地方子用例也可以出现。</li>
<li><p><strong><code>分组</code></strong>：当一个系统包含很多子系统时。最直接的办法就是把相关的用例<strong>放在一个包中</strong>组织起来。</p>
<ul>
<li>符号特征：包用一个一边突起的文件夹形的矩形框表示，一组用例可以出现在一个文件夹框中。</li>
</ul>
<p><img src="/uml/泛化1.png" width="40%">  <img src="/uml/泛化2.png" width="40%"> </p>
</li>
</ul>
<h5 id="6-4-运用用例模型的实例-P75"><a href="#6-4-运用用例模型的实例-P75" class="headerlink" title="6.4 运用用例模型的实例 P75"></a>6.4 运用用例模型的实例 P75</h5><ul>
<li>《银行系统的分析与设计》中的用例图<br><img src="/uml/银行用例.png" width="40%"></li>
</ul>
<h5 id="6-5-用例的一些特点"><a href="#6-5-用例的一些特点" class="headerlink" title="6.5 用例的一些特点"></a>6.5 用例的一些特点</h5><ul>
<li>Use case从使用系统的角度描述系统中的信息，即站在系统外部察看系统功能，并不考虑系统内部对该功能的具体实现方式。</li>
<li>使用use case可以促进与用户沟通，理解正确的需求，同时也可以用来划分系统与外部实体的界限，是OO系统设计的起点，是类、对象、操作的来源。</li>
<li>用例描述了用户提出的一些可见的需求；用例可大可小；用例对应一个具体的用户目标</li>
<li>理论上可以把一个软件系统的所有Use Case画出来，但实际运用时只需把重要的、交互过程复杂的那些画出来。</li>
</ul>
<h2 id="7-顺序图"><a href="#7-顺序图" class="headerlink" title="7. 顺序图"></a>7. 顺序图</h2><h5 id="7-1-什么是顺序图"><a href="#7-1-什么是顺序图" class="headerlink" title="7.1 什么是顺序图"></a>7.1 什么是顺序图</h5><ul>
<li>关键思想<ul>
<li>对象之间的交互是<strong>按照特定的顺序发生</strong>的，这些按特定顺序发生的交互序列从开始到结束需要一定的时间。</li>
<li>当建立一个系统时，必须要指明这种交互序列，顺序图就是用来完成这项工作的UML组件。</li>
</ul>
</li>
<li>符号特征<ul>
<li><strong>对象</strong>用矩形表示，其中是带下划线的对象名。</li>
<li><strong>时间</strong>用垂直虚线表示。</li>
<li><strong>消息</strong>用带箭头的直线表示。</li>
<li><strong>激活</strong>用窄矩形条表示。<br><img src="/uml/顺序图.png" width="30%">   <img src="/uml/顺序图对象.png" width="30%"> </li>
</ul>
</li>
<li>建立顺序图的步骤 P93<ol>
<li>确定交互过程的上下文。</li>
<li>识别参与交互过程的对象。</li>
<li>为每个对象设置生命线，即确定哪些对象存在于整个交互过程中，哪些对象在交互过程中被创建和撤销。</li>
<li>从引发这个交互过程的初始消息开始，在生命线之间从顶到下依次画出随后的各个消息。</li>
<li>如果需要表示消息的嵌套，或/和表示消息发生时的时间点，则采用激活。</li>
<li>如果需要说明时间约束，则在消息旁边加上约束说明。</li>
<li>如果需要，可以为每个消息附上前置条件和后置条件。</li>
</ol>
</li>
</ul>
<h5 id="7-2-顺序图的组成部分"><a href="#7-2-顺序图的组成部分" class="headerlink" title="7.2 顺序图的组成部分"></a>7.2 顺序图的组成部分</h5><ul>
<li><strong><code>对象</code></strong><ul>
<li>从左到右布置在顺序图的顶部</li>
<li>匿名对象</li>
<li>生命线（lifeline）</li>
<li>激活（activation）＝控制焦点（focus of control，FOC）</li>
</ul>
</li>
<li><strong><code>消息</code></strong>：一个对象到另一个对象的消息用跨越对象生命线的消息线表示<ul>
<li><strong>调用消息</strong>：消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息接收者放弃或返回控制。一般地，调用消息的接收者必须是一个被动对象，即它是一个需要通过消息驱动才能执行动作的对象。</li>
<li><strong>返回消息</strong>：调用消息必有一个配对的返回消息，为了图的简洁和清晰，与调用消息配对的返回消息可以不用画出。如果为非过程调用，如果有返回消息，则必须明确表示出来。</li>
<li><strong>同步消息</strong>：调用消息。由于发送者等待接受者，调用消息又称为同步消息。</li>
<li><strong>异步消息</strong>：发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接收者返回消息或控制。异步消息的接收者和发送者是并发工作的。</li>
<li>其它：阻止消息，超时消息，反身消息<br><img src="/uml/消息符号1.png" width="40%">  <img src="/uml/消息符号2.png" width="40%"></li>
</ul>
</li>
<li><strong><code>时间</code></strong>：顺序图中垂直方向代表时间维，时间流逝的方向为自顶而下。</li>
</ul>
<h5 id="顺序图-汽车和车钥匙-P93"><a href="#顺序图-汽车和车钥匙-P93" class="headerlink" title="顺序图 - 汽车和车钥匙 P93"></a>顺序图 - 汽车和车钥匙 P93</h5><h5 id="顺序图-饮料销售机-P95"><a href="#顺序图-饮料销售机-P95" class="headerlink" title="顺序图 - 饮料销售机 P95"></a>顺序图 - 饮料销售机 P95</h5><h5 id="顺序图-一般顺序图-P97"><a href="#顺序图-一般顺序图-P97" class="headerlink" title="顺序图 - 一般顺序图 P97"></a>顺序图 - 一般顺序图 P97</h5><h5 id="顺序图-帧化顺序图-P100"><a href="#顺序图-帧化顺序图-P100" class="headerlink" title="顺序图 - 帧化顺序图 P100"></a>顺序图 - 帧化顺序图 P100</h5><ul>
<li>在UML2.0，帧化一个顺序图：用一个边框包围它并在左上角添加一个间隔区。这个间隔区包含了识别该顺序图的信息。</li>
<li>其中一小段信息是<strong>操作符</strong>，间隔区还包括了<strong>图所描述的交互的名字</strong>。</li>
<li>操作符：<ul>
<li><strong>顺序图</strong>：操作符为sd（sequence diagram）</li>
<li><strong>交互事件</strong>：操作符为ref（reference）</li>
<li><strong>交互片断的组合</strong>：操作符有alt（alternation）和par（parallel） <strong>P102</strong></li>
</ul>
</li>
</ul>
<h2 id="8-协作图"><a href="#8-协作图" class="headerlink" title="8. 协作图"></a>8. 协作图</h2><h5 id="8-1-协作图"><a href="#8-1-协作图" class="headerlink" title="8.1 协作图"></a>8.1 协作图</h5><ul>
<li>协作图的作用<ul>
<li>对象图展示的是对象之间的静态关系。</li>
<li>协作图是对象图的扩展。协作图除了展示出对象之间的关联，还显示出对象之间的消息传递。</li>
<li>对象图是一个快照；而协作图是一部电影。  </li>
</ul>
</li>
<li>协作图与顺序图两者之间是语意等价的。<ul>
<li>两种图表达的同一种信息，两者之间可以相互转换。</li>
</ul>
</li>
<li>顺序图与协作图之间的不同<ul>
<li>顺序图强调的是交互的时间顺序；</li>
<li>协作图强调的是交互的过程和参与交互的对象的整体组织。</li>
</ul>
</li>
</ul>
<h5 id="8-2-协作图-饮料销售机-P111"><a href="#8-2-协作图-饮料销售机-P111" class="headerlink" title="8.2 协作图 - 饮料销售机 P111"></a>8.2 协作图 - 饮料销售机 P111</h5><h2 id="9-状态图"><a href="#9-状态图" class="headerlink" title="9. 状态图"></a>9. 状态图</h2><h5 id="9-1-什么是状态图"><a href="#9-1-什么是状态图" class="headerlink" title="9.1 什么是状态图"></a>9.1 什么是状态图</h5><ul>
<li>状态图的概念：<ul>
<li>人或事物表现出来的形态。</li>
<li>当系统与用户（也可能是其它系统）交互的时候，组成系统的对象为了适应交互需要经历必要的变化。如果要对系统建立模型，那么模型中必须要反映出这种变化。</li>
</ul>
</li>
<li><strong>状态图与类图、对象图和用例图的本质区别</strong><ul>
<li>状态图只是对单个对象建立模型</li>
</ul>
</li>
<li>符号特征<ul>
<li>状态用圆角矩形表示</li>
<li>状态间带箭头的实线代表状态的迁移（转移），箭头指向目标状态</li>
<li>实心圆代表状态转移的起点，眼形圆圈代表终点<br><img src="/uml/状态图符号.png" width="50%"><img src="/uml/状态图区域.png" width="50%"></li>
</ul>
</li>
<li>增加状态图的细节<ul>
<li>常用的活动（入口动作；出口动作；动作）<br><img src="/uml/状态图例子.png" width="45%"></li>
</ul>
</li>
<li>增加转移的细节：事件和动作<ul>
<li>触发器事件：状态转移线可以指明引起转移发生的事件和引起状态发生变化所需之行的计算。</li>
<li>无触发器转移：有时候一个事件会引起没有相关动作的状态转移，或者一个转移是由于某个状态完成了它的活动所引起（而不是由于事件引起）</li>
<li>保护条件：当满足这个条件时，转移才能发生。<br><img src="/uml/状态图触发器.png" width="50%"></li>
</ul>
</li>
</ul>
<h5 id="8-2-子状态"><a href="#8-2-子状态" class="headerlink" title="8.2 子状态"></a>8.2 子状态</h5><ul>
<li>顺序子状态：按照顺序一个接着一个出现。</li>
<li><strong>并发子状态</strong>：在处于working状态时，GUI并不是<br><img src="/uml/子状态.png" width="35%"></li>
</ul>
<h2 id="9-活动图"><a href="#9-活动图" class="headerlink" title="9. 活动图"></a>9. 活动图</h2><h5 id="9-1-什么是活动图"><a href="#9-1-什么是活动图" class="headerlink" title="9.1 什么是活动图"></a>9.1 什么是活动图</h5><ul>
<li>活动图：被设计用于简化描述一个过程或者操作的工作步骤。</li>
<li>符号特征<ul>
<li>活动用圆角矩形表示（更接近椭圆）</li>
<li>箭头表示从一个活动转移到下一个活动</li>
<li>活动图中的起点用一个实心圆表示，终点用一个眼形圆表示<br><img src="/uml/活动图1.png" width="35%"></li>
</ul>
</li>
</ul>
<h5 id="9-2-活动图的组成"><a href="#9-2-活动图的组成" class="headerlink" title="9.2 活动图的组成"></a>9.2 活动图的组成</h5><ul>
<li><strong>判定(分支)</strong>：if-else    / if(无else)<br><img src="/uml/判断.png" width="35%"></li>
<li><strong>并发路径</strong>：两个单独的同时（并发）执行的路径。</li>
<li><strong>信号</strong>：活动序列中的活动可以发送信号。当信号被接受时，会引起另一个活动的发生<br><img src="/uml/并发1.png" width="22%"><img src="/uml/并发.png" width="33%"></li>
<li><strong>泳道</strong>：将活动图按执行的角色分割成多个平行的段，这些段被称为泳道。每个泳道的顶部显示出角色名，每个角色负责的活动放在各个角色的泳道中。<br><img src="/uml/泳道无.png" width="40%"><img src="/uml/泳道.png" width="50%"> </li>
<li>混合图：P122 对活动的描述更为具体、细化。</li>
</ul>
<h5 id="9-3-活动图-银行系统分析"><a href="#9-3-活动图-银行系统分析" class="headerlink" title="9.3 活动图 - 银行系统分析"></a>9.3 活动图 - 银行系统分析</h5><p><img src="/uml/登录.png" width="40%"><img src="/uml/存款.png" width="40%"></p>
<h2 id="10-构件图"><a href="#10-构件图" class="headerlink" title="10. 构件图"></a>10. 构件图</h2><h5 id="10-1-什么是构件"><a href="#10-1-什么是构件" class="headerlink" title="10.1 什么是构件"></a>10.1 什么是构件</h5><ul>
<li><strong>构件</strong>是系统中遵从一组接口且提供其实现的物理的、可替换的部分。</li>
<li><strong>构件图</strong>则显示一组构件以及他们之间的相互关系，包括编译、链接或执行时构件之间的依赖关系。<ul>
<li>构件图和部署图用于在OO系统中实现物理方面的建模</li>
</ul>
</li>
<li><strong>构件的类型</strong>：(构件就是一个实际文件，可以有以下几种类型)<ul>
<li><strong>部署构件</strong>，如dll文件、exe文件、COM+对象、动态Web页、数据库表等</li>
<li><strong>工作产品构</strong>件，如源代码文件、数据文件等，这些构件可以用来产生部署构件</li>
<li><strong>执行构件</strong>，也就是系统执行后得到的构件</li>
</ul>
</li>
<li><strong>构件与类的区别：</strong><ul>
<li>类是逻辑抽象，构件是物理抽象</li>
<li>构件是对其它逻辑元素，如类，协作的<strong>物理实现</strong></li>
<li>类可以有属性和操作；构件通常只有操作，而且这些操作只能通过构件的接口才能使用</li>
</ul>
</li>
<li>为什么要对构件和构件的关系建立模型<ul>
<li>使客户能够看到最终系统的结构和功能</li>
<li>让开发者有一个工作目标</li>
<li>让编写技术文档和帮助文件的技术人员能够理解所写的文档是关于哪方面的内容</li>
<li>利于复用</li>
</ul>
</li>
<li>符号特征：<ul>
<li>左侧附有两个小矩形的大矩形框；也可以用一个顶部带关键字<code>&lt;&lt;Component&gt;&gt;</code>的矩形表示</li>
<li>构件有自己的名称。如果构件属于一个包，可以在构件名称前面加上包名</li>
<li>可以在构件图标中列出构件的操作<br><img src="/uml/构件图标.png" width="50%"><img src="/uml/构件图标2.png" width="25%"> </li>
</ul>
</li>
</ul>
<h5 id="10-2-构件的接口表示法"><a href="#10-2-构件的接口表示法" class="headerlink" title="10.2 构件的接口表示法"></a>10.2 构件的接口表示法</h5><ul>
<li>可以用一个包含信息的矩形来表示接口，并用实现关系箭头和构件相连。</li>
<li>也可以用小圆圈表示接口，并用实现连接构件。<br><img src="/uml/构件接口.png" width="50%"></li>
</ul>
<h2 id="11-部署图"><a href="#11-部署图" class="headerlink" title="11. 部署图"></a>11. 部署图</h2><h5 id="11-1-什么是部署图"><a href="#11-1-什么是部署图" class="headerlink" title="11.1 什么是部署图"></a>11.1 什么是部署图</h5><ul>
<li>部署图的用途<ul>
<li>部署图用来描述系统硬件的物理拓扑结构以及在此结构上执行的软构件</li>
<li>部署图也称配置图，实施图。常常用于帮助理解分布式系统</li>
<li>部署图由体系结构设计师，网络工程师，系统工程师等描述</li>
</ul>
</li>
</ul>
<h5 id="11-2节点与连接"><a href="#11-2节点与连接" class="headerlink" title="11.2节点与连接"></a>11.2节点与连接</h5><ul>
<li>节点：<ul>
<li>节点代表一个物理设备以及其上运行的软件系统，如一台Unix主机、一个PC终端、一台打印机、一个传感器等</li>
<li>节点之间的连线表示系统之间进行交互的通信路径，在UML中称为连接。</li>
</ul>
</li>
<li>节点的划分<ul>
<li>处理器：能够执行软件构件的节点</li>
<li>设备：不能执行软件构件的外围硬件，但它通常都具备某种形式的与外部世界的接口。如modem、终端。</li>
</ul>
</li>
<li>符号特征：<ul>
<li>用立方体表示</li>
<li>加关键字<code>&lt;&lt;Device&gt;&gt;</code><br><img src="/uml/节点.png" width="25%"></li>
</ul>
</li>
<li>连接<ul>
<li>连接两个节点的一条线，表示了两个节点相连（但不一定要是一段电线或电缆）<br><img src="/uml/连接.png" width="25%"></li>
</ul>
</li>
</ul>
<h5 id="11-3-应用部署图-P147"><a href="#11-3-应用部署图-P147" class="headerlink" title="11.3 应用部署图 P147"></a>11.3 应用部署图 P147</h5><ul>
<li>家用计算机系统</li>
<li>令牌环网</li>
<li>ARCnet</li>
<li>细缆以太网</li>
<li>Ricochet无线网</li>
</ul>
<h5 id="11-4-部署图建模风格"><a href="#11-4-部署图建模风格" class="headerlink" title="11.4 部署图建模风格"></a>11.4 部署图建模风格</h5><ul>
<li>只对重要的软构件建模<ul>
<li>事实上，每个节点可能有几十甚至几百个软构件部署在上面，建模人员的目标不是把所有软构件都描绘出来，而是只描绘那些对理解系统来说至关重要的构件。</li>
<li>如果要探究软构件之间的关系，则采用UML构件图而不是部署图。</li>
</ul>
</li>
<li>对节点使用可视化的版型<ul>
<li>目前还没有关于如何在UML部署图中使用可视化版型的标准，但一般的经验法则是使用能找到的最合适的剪贴图。</li>
</ul>
</li>
</ul>
<h2 id="12-在开发过程中运用UML"><a href="#12-在开发过程中运用UML" class="headerlink" title="12. 在开发过程中运用UML"></a>12. 在开发过程中运用UML</h2><h5 id="12-1-开发过程方法学"><a href="#12-1-开发过程方法学" class="headerlink" title="12.1 开发过程方法学"></a>12.1 开发过程方法学</h5><ul>
<li>在进行程序设计前，开发人员必须要充分理解所要解决的问题，这需要专门有人负责需求的分析。在完成需求分析后，还必须有人将分析的产品转化为设计产品。然后，程序员再根据设计进行产品编制代码，这些代码在经过测试和部署后，最终称为目标系统。</li>
<li>传统的开发过程方法学：“瀑布”模型 <strong>分析 -&gt; 设计 -&gt; 编码 -&gt; 部署</strong></li>
<li>新的开发过程方法学：强调无缝集成</li>
<li>开发方式的变化<ul>
<li>个人→大型团队，短期→长期，交互与反馈，并行</li>
</ul>
</li>
<li>团队组成<ul>
<li>系统分析员：与客户交流，理解客户的问题</li>
<li>设计人员：设计问题的解决方案</li>
<li>程序设计人员：将解决方案编制成代码</li>
<li>系统工程师：将代码部署到硬件上运行</li>
</ul>
</li>
<li>一个开发方法学必须要能够做到：<ul>
<li>保证开发小组对所要解决的问题有个坚实的理解</li>
<li>要考虑到开发小组是由不同角色完成</li>
<li>能够在小组的不同角色成员之间培养良好的通信关系</li>
<li>考虑到跨越阶段的开发过程的反馈信息</li>
<li>开发出能够向客户反映出开发进度的工作产品，但是要避免产生过多的纸面制品</li>
</ul>
</li>
</ul>
<h5 id="12-2-GRAPPLE-快速应用工程指导原则"><a href="#12-2-GRAPPLE-快速应用工程指导原则" class="headerlink" title="12.2 GRAPPLE 快速应用工程指导原则"></a>12.2 GRAPPLE 快速应用工程指导原则</h5><ul>
<li>GRAPPLE的含义<ul>
<li>快速应用工程指导原则（Guidelines for Rapid APPLication Engineering）</li>
<li>强调可自适应的、灵活的开发思想</li>
</ul>
</li>
<li>GRAPPLE的结构：RADDD / RAD<sup>3</sup><ul>
<li>需求收集（requirements gathering）</li>
<li>分析（analysis）</li>
<li>设计（design）</li>
<li>开发（development）</li>
<li>部署（deployment）</li>
</ul>
</li>
<li><code>需求收集（一）</code><ul>
<li><strong>发现领域过程</strong>：获得客户业务领域词汇；活动图</li>
<li><strong>领域分析</strong>：高层类图</li>
<li><strong>识别协作系统</strong>：系统关系；部署图</li>
<li><strong>发现系统需求</strong>：联合应用开发会议；包图（每个包代表了一个系统功能的高层领域；每个包中包括了一组用例）</li>
<li><strong>将结果提交给用户</strong></li>
</ul>
</li>
<li><code>分析（二）</code><ul>
<li><strong>理解系统的用法</strong>：明确用例，开发新用例</li>
<li><strong>充实用例</strong>：分析出每个用例的步骤序列</li>
<li><strong>细化类图</strong>：关联名，抽象类，多重性，泛化，聚集</li>
<li><strong>分析对象状态变化</strong>：（对象）状态图</li>
<li><strong>定义对象之间的交互</strong>：顺序图，协作图</li>
<li><strong>分析与协作系统的集成</strong>：系统工程师完成</li>
</ul>
</li>
<li><code>设计（三）</code><ul>
<li><strong>开发和细化对象图</strong>：对象图，活动图</li>
<li><strong>开发构件图</strong>：构件图</li>
<li><strong>制定部署计划</strong>：部署图</li>
<li><strong>设计和开发用户界面原型</strong>：屏幕界面原型快照</li>
<li><strong>测试设计</strong>：外部专家</li>
<li><strong>开始编制文档</strong>：文档的高层结构</li>
</ul>
</li>
<li><code>开发（四）</code><ul>
<li><strong>编制代码</strong>：根据类图、对象图、活动图、构件图</li>
<li><strong>测试代码</strong></li>
<li><strong>构建用户界面和用户界面到代码的连接和测试</strong></li>
<li><strong>完成文档</strong></li>
</ul>
</li>
<li>部署（五）<ul>
<li><strong>编制备份和恢复计划</strong></li>
<li><strong>在硬件上安装最终系统</strong></li>
<li><strong>测试安装后的系统</strong></li>
<li>庆贺</li>
</ul>
</li>
</ul>
<h5 id="12-3-学习案例介绍-发现业务过程-P183"><a href="#12-3-学习案例介绍-发现业务过程-P183" class="headerlink" title="12.3 学习案例介绍 - 发现业务过程 P183"></a>12.3 学习案例介绍 - 发现业务过程 P183</h5><h2 id="13-领域分析"><a href="#13-领域分析" class="headerlink" title="13. 领域分析"></a>13. 领域分析</h2><h5 id="13-1-分析业务过程会谈"><a href="#13-1-分析业务过程会谈" class="headerlink" title="13.1 分析业务过程会谈"></a>13.1 分析业务过程会谈</h5><ul>
<li>概念性任务：运用技术来使外出就餐的人们感到更加满意</li>
<li>会谈目标<ul>
<li>建立领域词典（模型词典，初步类图）</li>
<li>通过谈话记录中整理名词、动词以及动词短语。其中的一些名词将可能成为模型中的类，另一些名词将成为类的属性。动词或者动词短语可能成为类的操作或类之间的关联标记。</li>
</ul>
</li>
</ul>
<h5 id="13-2-开发初步类图-P195"><a href="#13-2-开发初步类图-P195" class="headerlink" title="13.2 开发初步类图 P195"></a>13.2 开发初步类图 P195</h5><h5 id="13-3-对类分组"><a href="#13-3-对类分组" class="headerlink" title="13.3 对类分组"></a>13.3 对类分组</h5><h5 id="13-4-形成关联"><a href="#13-4-形成关联" class="headerlink" title="13.4 形成关联"></a>13.4 形成关联</h5><h5 id="13-5-形成聚集和组成"><a href="#13-5-形成聚集和组成" class="headerlink" title="13.5 形成聚集和组成"></a>13.5 形成聚集和组成</h5><h5 id="13-6-填充类的信息"><a href="#13-6-填充类的信息" class="headerlink" title="13.6 填充类的信息"></a>13.6 填充类的信息</h5><h2 id="14-收集系统需求"><a href="#14-收集系统需求" class="headerlink" title="14. 收集系统需求"></a>14. 收集系统需求</h2><ul>
<li>产生能反映系统功能的包图，每个包代表系统的一个功能模块，其中包含了详细说明该功能模块的若干个用例。<ul>
<li>系统部署图 </li>
<li>系统的功能包图 P219</li>
<li>新的类图（反映角色之间的静态关系） </li>
</ul>
</li>
</ul>
<h2 id="15-开发用例"><a href="#15-开发用例" class="headerlink" title="15. 开发用例"></a>15. 开发用例</h2><h5 id="15-1-用例分析"><a href="#15-1-用例分析" class="headerlink" title="15.1 用例分析"></a>15.1 用例分析</h5><ul>
<li>用例是一组场景的集合，每个场景又是由一系列步骤组成<ul>
<li>系统开发过程是用例驱动的</li>
<li>详细分析前面所列举出的用例，并开始研究如何将WIN系统中的构件具体化</li>
</ul>
</li>
<li>对于每个用例的每个场景，需要说明的内容有：<ul>
<li>场景的简单陈述</li>
<li>关于场景的假设条件</li>
<li>用例的发起参与者</li>
<li>场景的前置条件</li>
<li>场景中与系统相关的步骤序列</li>
<li>场景完成后的后置条件</li>
<li>用例的受益参与者</li>
<li>其它：异常条件，可选的场景流程</li>
</ul>
</li>
</ul>
<h5 id="15-2-Server包-P225"><a href="#15-2-Server包-P225" class="headerlink" title="15.2 Server包 P225"></a>15.2 Server包 P225</h5><h2 id="16-交互"><a href="#16-交互" class="headerlink" title="16. 交互"></a>16. 交互</h2><h5 id="16-1-系统中的工作部件-P223"><a href="#16-1-系统中的工作部件-P223" class="headerlink" title="16.1 系统中的工作部件 P223"></a>16.1 系统中的工作部件 P223</h5><ul>
<li>每个用例的背后都隐藏一张顺序图</li>
<li>绘制用例的顺序图可以帮助我们细化和修改用例</li>
<li>构件交互分析的结果应该能使程序员更容易地编制实现构件和构件之间通信的代码</li>
</ul>
<h2 id="17-设计外观、感觉和部署-P242"><a href="#17-设计外观、感觉和部署-P242" class="headerlink" title="17. 设计外观、感觉和部署 P242"></a>17. 设计外观、感觉和部署 P242</h2></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Dai Sine</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://daisine.me/uml/">http://daisine.me/uml/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/note/">note</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/CG/"><i class="fa fa-chevron-left">  </i><span>计算机图形学笔记及练习</span></a></div><div class="next-post pull-right"><a href="/Cryptography/"><span>密码学笔记</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://daisine.me/uml/';
  this.page.identifier = 'uml/';
  this.page.title = 'UML';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'dasine' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2019/05/10/5cd525fea97ac.png)"><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2019 By Dai Sine</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>