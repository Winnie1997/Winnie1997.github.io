<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="软件测试笔记"><meta name="keywords" content="note"><meta name="author" content="Dai Sine"><meta name="copyright" content="Dai Sine"><title>软件测试笔记 | Hi, Dai</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-117497526-4', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-软件测试概述"><span class="toc-text">1 软件测试概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#故障、错误-amp-失败"><span class="toc-text">故障、错误&amp;失败</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PIE模型"><span class="toc-text">PIE模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#概念"><span class="toc-text">概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C2-单元测试"><span class="toc-text">C2 单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单元测试"><span class="toc-text">单元测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C3-白盒测试"><span class="toc-text">C3 白盒测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-测试中的图"><span class="toc-text">1. 测试中的图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-图覆盖准则"><span class="toc-text">2. 图覆盖准则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-结构化的覆盖准则"><span class="toc-text">3. 结构化的覆盖准则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-控制流图-CFG-及其覆盖"><span class="toc-text">4. 控制流图(CFG)及其覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-主路径覆盖-Prime-Path-Coverage-PPC"><span class="toc-text">5. 主路径覆盖(Prime Path Coverage, PPC)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-基本路径覆盖"><span class="toc-text">6. 基本路径覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-数据流覆盖"><span class="toc-text">7. 数据流覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-事件流覆盖"><span class="toc-text">8. 事件流覆盖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C4-自动化软件测试"><span class="toc-text">C4 自动化软件测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C5-黑盒测试"><span class="toc-text">C5 黑盒测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-随机测试"><span class="toc-text">5.1 随机测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-等价划分"><span class="toc-text">5.2 等价划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-边界值分析"><span class="toc-text">5.3 边界值分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-组合测试"><span class="toc-text">5.4 组合测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-测试中的约束"><span class="toc-text">5.5 测试中的约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-决策表"><span class="toc-text">5.6 决策表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C7-功能、性能、移动应用测试"><span class="toc-text">C7 功能、性能、移动应用测试</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Dai Sine</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">51</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">10</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2019/05/10/5cd525fea97ac.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Hi, Dai</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">软件测试笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-30</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/软件工程/">软件工程</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h3 id="1-软件测试概述"><a href="#1-软件测试概述" class="headerlink" title="1 软件测试概述"></a>1 软件测试概述</h3><h4 id="故障、错误-amp-失败"><a href="#故障、错误-amp-失败" class="headerlink" title="故障、错误&amp;失败"></a>故障、错误&amp;失败</h4><ul>
<li>软件故障(fault)：软件中的一个静态的缺陷。</li>
<li>软件错误(error)：软件运行中一个不正确的内部状态，这是某个故障的表现。</li>
<li><p>软件失败(failure)：一个与软件需求或者是预期行为描述不相符的、外在的行为。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CSta</span> <span class="params">(<span class="keyword">int</span> [ ] numbers)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> length = numbers.length; <span class="comment">//(PIE Model - 3: int length = numbers.length-1; )</span></span><br><span class="line">   <span class="keyword">double</span> mean, sum; </span><br><span class="line">   sum = <span class="number">0.0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++)**<span class="comment">//i=0** </span></span><br><span class="line">   &#123;</span><br><span class="line">         sum += numbers [ i ]; </span><br><span class="line">   &#125;</span><br><span class="line">   mean = sum / (<span class="keyword">double</span>) length; </span><br><span class="line">   System.out.println (<span class="string">"mean: "</span> + mean); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>软件错误：Input: [3,4,5]  sum=4+5  ( × )</p>
</li>
<li>软件失败：Input: [3,4,5]  sum=4+5 mean=3  ( × )</li>
</ul>
<h4 id="PIE模型"><a href="#PIE模型" class="headerlink" title="PIE模型"></a>PIE模型</h4><ul>
<li>Execution/Reachability 执行/可达性：执行必须通过错误的代码。</li>
<li>Infection 感染：在执行错误代码的时候必须触发出一个错误的中间状态。</li>
<li>Propagation 传播：错误的中间状态必须传播到最后输出，使得观测到输出结果与预期结果不一致，即失效。</li>
</ul>
<blockquote>
<ol>
<li>测试可能无法执行故障的位置。</li>
<li>一个测试执行到包含错误的代码，不一定会产生错误的中间状态。Test Input: [0,4,5] sum=4+5  mean=3</li>
<li>产生了错误的中间状态，不一定会失效(failure)。Test Input: [3,5,4] sum=3+5 mean=8/2=4</li>
</ol>
</blockquote>
<p>Q: 是否存在一个fault，任何测试都不会将其测试出来？这样还能称之为fault吗？</p>
<p>A: 存在这样的fault。</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>测试用例(test case)：所有测试用例的基类，它是软件测试中最基本的组成单元。<ul>
<li>测试输入：测试数据</li>
<li>测试预期输出(test oracle)：软件中给定输入的预期输出</li>
<li>其他：环境</li>
</ul>
</li>
<li>测试预言(test oracle)：软件中给定输入的预期输出，测试用例的一部分。自动测试中最难的问题：测试预言的生成。</li>
<li>测试夹具(test fixture)：一个固定/已知的环境状态以确保测试可重复并且按照预期方式运行</li>
<li>测试套件(test suite)：一组测试用例。通常这些测试用例具有相似的先决条件和配置，可以按顺序一起运行。用于不同目的的不同测试套件。</li>
<li>测试脚本(test script)：自动运行一系列测试用例或测试套件的脚本。</li>
<li>测试驱动程序(test driver)：可以加载测试用例集或测试套件的软件框架，还可以处理预期输出和实际输出之间的配置和比较。</li>
<li>测试充分性(test adequacy)：用以判断一个软件的一组测试数据的充分性的规则。eg. 语句/分支覆盖率</li>
<li>Testing vs. Debugging<ul>
<li>Testing 是通过执行测试和观察失败来发现一个bug。</li>
<li>Debugging是通过定位、理解和纠正故障( fault)来修复bug。</li>
</ul>
</li>
<li><strong>Verification vs. Validation</strong><ul>
<li>Verification：确保产品，服务或系统满足客户和其他确定的利益相关者的<strong>需求</strong>。 </li>
<li>Validation：评估产品，服务或系统是否符合法规、要求、规范或强制条件。 它通常是一个内部过程。</li>
</ul>
</li>
<li><strong>Static Testing vs. Dynamic Testing</strong><ul>
<li>静态测试：不运行被测程序本身。</li>
<li>动态测试：运行被测程序。</li>
</ul>
</li>
<li><strong>Black-box Testing vs. White-box Testing</strong><ul>
<li>黑盒测试：没有源代码。</li>
<li>白盒测试：有源代码。</li>
</ul>
</li>
<li>V模型：<br><img src="/sftest/vmodel.png" width="50%"></li>
</ul>
<h3 id="C2-单元测试"><a href="#C2-单元测试" class="headerlink" title="C2 单元测试"></a>C2 单元测试</h3><ul>
<li>单元测试：每个模块的测试。</li>
<li>集成测试：测试模块之间的交互。</li>
<li>系统测试：开发人员对整个系统进行测试。</li>
<li>验收测试：根据需求和用户需要来评估软件。没有正式测试用例的客户根据用户要求验证系统。</li>
</ul>
<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul>
<li>测试软件的基本模块：功能，类，组件</li>
<li>揭示典型问题<ul>
<li>本地数据结构</li>
<li>算法</li>
<li>边界条件</li>
<li>错误处理</li>
</ul>
</li>
<li>为什么单元测试？<ul>
<li>分而治之的方法：将系统拆分为单位，单独调试单元。</li>
<li>缩小可能存在错误的地方，不想追逐其他单元的错误。</li>
</ul>
</li>
<li>如何单元测试？<ul>
<li>分层构建系统：从不依赖于其他的类开始，继续测试已经测试的类</li>
<li>好处：避免编写模拟类。当测试一个模块时，它所依赖的模块是可靠的。</li>
</ul>
</li>
<li>单元测试框架<ul>
<li>xUnit</li>
<li>JUnit</li>
</ul>
</li>
</ul>
<h3 id="C3-白盒测试"><a href="#C3-白盒测试" class="headerlink" title="C3 白盒测试"></a>C3 白盒测试</h3><h4 id="1-测试中的图"><a href="#1-测试中的图" class="headerlink" title="1. 测试中的图"></a>1. 测试中的图</h4><ul>
<li><strong>图G</strong>定义如下：G =（V，E）<ul>
<li>V：有限的非空顶点集V = {v<sub>1</sub>，v<sub>2</sub>，v<sub>3</sub>，v<sub>4</sub>}</li>
<li>E：一组边（顶点对）E = {（v<sub>1</sub>，v<sub>2</sub>），（v<sub>1</sub>，v<sub>3</sub>），（v<sub>2</sub>，v<sub>4</sub>），（v<sub>3</sub>，v<sub>4</sub>）}</li>
<li>V<sub>0</sub>：一组初始节点，V<sub>0</sub> = {v<sub>1</sub>}</li>
<li>V<sub>f</sub>：一组最终节点，Vf = {v4}</li>
<li>V<sub>0</sub>和V<sub>f</sub>是V的子集</li>
<li>图中允许存在多个初始节点，至少要有一个终止节点(或者多个)。</li>
</ul>
</li>
<li>Q：一个顶点是一个图吗？(Yes) E可以是一个无限的集合吗？(No)</li>
<li><p><strong>路径(Path)</strong>：一个节点序列[v<sub>1</sub>，v<sub>2</sub>，… ，v<sub>n</sub>]</p>
<ul>
<li>每对邻近节点(v<sub>i</sub>, v<sub>i+1</sub>)都是一条边(属于边集合E)</li>
<li>路径的长度：边的数量</li>
<li>长度为0的路径：单个节点的路径。</li>
<li>子路径：路径p的子路径是p的一个子序列(也可能是p自己)</li>
</ul>
</li>
<li><p><strong>测试路径</strong>：从初始节点(V<sub>0</sub>中某个节点)开始到最终节点(V<sub>f</sub>中某个节点)结束的路径。</p>
<ul>
<li>每个测试用例都只游历图G中的一条测试路径。</li>
<li>一条测试路径可以对应多个测试用例。(多对一)</li>
<li>一些测试路径不会被任何测试用例执行。(不可达：图G中的节点从V<sub>0</sub>中任何节点开始都无法在语法上到达，也无法满足覆盖准则)</li>
</ul>
</li>
<li><p><strong>测试和测试路径</strong></p>
<ul>
<li><strong>path( t )</strong>：测试 t 执行的测试路径</li>
<li><strong>path( T )</strong>：由一组测试执行的<strong>测试路径集 T</strong> </li>
</ul>
</li>
</ul>
<h4 id="2-图覆盖准则"><a href="#2-图覆盖准则" class="headerlink" title="2. 图覆盖准则"></a>2. 图覆盖准则</h4><ul>
<li><p>可达：从一个初始节点开始所有节点和边都语法可达的图。</p>
<ul>
<li>v<sub>1</sub>可达v<sub>2</sub>：存在一条路径开始于v<sub>1</sub>，终止于v<sub>2</sub>。</li>
<li><p>v<sub>1</sub>可达图G’：存在一条路径开始于v<sub>1</sub>，终止于图G中的某个节点。</p>
</li>
<li><p><strong>语法可达</strong>：图G中语法上存在一条路径。</p>
</li>
<li><strong>语义可达</strong>：存在测试用例执行该路径。</li>
</ul>
</li>
<li><p><strong>覆盖</strong>：</p>
<ul>
<li>测试路径p<strong>覆盖节点</strong>v：v在p中</li>
<li>测试路径p<strong>覆盖边</strong>e：e在p中</li>
<li>测试路径p<strong>覆盖子路径</strong>p’：p’在p中</li>
</ul>
</li>
<li><p><strong>图覆盖</strong></p>
<ul>
<li>结构图覆盖</li>
<li>数据流覆盖</li>
</ul>
</li>
<li><p>测试需求集<strong>( TR )</strong>：描述测试路径的属性</p>
</li>
<li><p>图覆盖：给定一个<strong>图覆盖准则C</strong>所包含的<strong>测试需求集TR</strong>，当且仅当对于TR中的<strong>每个测试需求tr</strong>，<strong>测试路径集path( T )</strong>中都至少存在一个测试路径p满足tr的时候，测试用例集T满足图G的覆盖准则C。</p>
</li>
</ul>
<h4 id="3-结构化的覆盖准则"><a href="#3-结构化的覆盖准则" class="headerlink" title="3. 结构化的覆盖准则"></a>3. 结构化的覆盖准则</h4><ul>
<li><p><strong>节点覆盖(VC)</strong></p>
<ul>
<li>当且仅当对于 V 中每个语法可达的节点 v，测试用例集T满足path( T )存在路径p使得p覆盖v。即测试用例集T在图G上满足节点覆盖。</li>
<li>TR包含G中的每个可达的节点。</li>
</ul>
</li>
<li><p><strong>边覆盖(EC)</strong></p>
</li>
<li><p>当且仅当对于 E 中的每个语法可达边e，测试用例集T满足path( T )中存在路径p使得p覆盖e。即测试用例集T在图G上满足边覆盖。</p>
</li>
<li><p>TR包含G中的每个可达的边。<br><img src="/sftest/vcec.png" width="60%"></p>
</li>
<li><p><strong>对边覆盖(EPC)</strong>：TR包含G中每个可达的长度小于等于2的路径。</p>
</li>
<li><strong>全路径覆盖(CPC)</strong>：TR中包含G中所有的路径。</li>
<li><p><strong>n-Path Coverage(nPC)</strong>：TR包含每个可达长度小于等于n的路径。</p>
</li>
<li><p><strong>包含(Subsume)关系</strong>：</p>
<ul>
<li><p>C1包含C2，表示为C1 ≧  C2</p>
</li>
<li><p>对任意测试用例集T，假如T满足C1，则T一定满足C2。</p>
</li>
<li>C1≧ C2 does not imply that <em>T1</em> satisfying C1 can detect any fault detected by T2 which satisfies C2.</li>
<li>C1≧ C2不意味着满足C1的T1可以检测到满足C2的T2检测到的故障。<br><img src="/sftest/sce.png" width="80%"></li>
</ul>
</li>
</ul>
<h4 id="4-控制流图-CFG-及其覆盖"><a href="#4-控制流图-CFG-及其覆盖" class="headerlink" title="4. 控制流图(CFG)及其覆盖"></a>4. 控制流图(CFG)及其覆盖</h4><ul>
<li><p>控制流图(CFG)</p>
<ul>
<li>使用图表符号表示<strong>在执行期间可能遍历程序的所有路径</strong>的表示。</li>
<li>边与每条可能的分支对应，节点与一系列的语句对应。</li>
</ul>
</li>
<li><p>基本块</p>
<ul>
<li>一段最长的可以被同时执行的程序语句序列。如果这个基本块中的一条语句被执行，那么这个块中所有语句都要被执行。</li>
<li>一个基本块只有一个起始点和一个终点。<br><img src="/sftest/if.png" width="40%"><img src="/sftest/ifreturn.png" width="36%"><img src="/sftest/while.png" width="40%"><img src="/sftest/do.png" width="36%"><img src="/sftest/for.png" width="45%"><img src="/sftest/switch.png" width="45%"><img src="/sftest/bc.png" width="45%"><img src="/sftest/cfg.png" width="80%"></li>
</ul>
</li>
<li><p>语句覆盖率：SCov = 4 / 5 = 80%</p>
</li>
<li>分支覆盖率：BCov = 2 / 4 = 50%</li>
<li>路径覆盖率：PCov = 1 / 4 = 25%</li>
</ul>
<p><img src="/sftest/scov.png" width="21%"><img src="/sftest/bcov.png" width="22%"><img src="/sftest/pcov.png" width="49%"></p>
<ul>
<li>如果测试套件达到100%分支覆盖率，则一定达到100%语句覆盖率。</li>
<li><p>如果测试套件达到100%路径覆盖率，则一定达到100%分支覆盖率。反之未必。</p>
</li>
<li><p>路径覆盖 -&gt; 分支覆盖 -&gt; 语句覆盖  (路径覆盖严格包含分支覆盖，分支覆盖严格包含语句覆盖) </p>
<ul>
<li>路径覆盖：被测试程序中的每一个语句至少被执行一次。<strong>实际运用中语句覆盖很难发现代码中的问题。</strong></li>
<li>分支覆盖：被测试程序中的每一个分支都至少执行一次。</li>
<li>语句覆盖：覆盖程序中所有可能的执行路径。</li>
</ul>
</li>
<li><p>基于CFG的覆盖</p>
<ul>
<li><p><strong>有效性：</strong>大约65％的错误可以在单元测试中捕获，单元测试由控制流测试方法主导，语句和分支测试在控制流测试中占主导地位。</p>
</li>
<li><p><strong>局限性：</strong>某些方面的100％覆盖率不能保证软件没有错误。</p>
</li>
<li><p>Test: assertEquals(1, sum(1,0))</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; </span><br><span class="line">		<span class="keyword">return</span> x-y; <span class="comment">//should be x+y</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="5-主路径覆盖-Prime-Path-Coverage-PPC"><a href="#5-主路径覆盖-Prime-Path-Coverage-PPC" class="headerlink" title="5. 主路径覆盖(Prime Path Coverage, PPC)"></a>5. 主路径覆盖(Prime Path Coverage, PPC)</h4><ul>
<li>简单路径<ul>
<li>从n<sub>i</sub>到n<sub>j</sub>的路径，当且仅当在这条路径中没有任何节点出现超过一次(除了初始节点和终止节点相同的情况)</li>
<li>简单路径可以是一个自环，但它没有内在的循环。<br><img src="/sftest/简单路径.png" width="55%"><img src="/sftest/主路径.png" width="40%"></li>
</ul>
</li>
<li>主路径：<ul>
<li>一条简单路径，且它不是任何其他简单路径的子路径。</li>
<li>最大长度的简单路径。</li>
</ul>
</li>
<li>往返路径：长度非0且初始节点和终止节点相同的主路径。</li>
<li><strong>主路径覆盖(PPC)</strong><ul>
<li>TR包含G中每条主路径。</li>
</ul>
</li>
<li><strong>简单往返路径(SRTC)</strong><ul>
<li>对于G中所有可达的，且可以作为往返路径起点和终点的节点，TR包含至少一条往返路径。</li>
</ul>
</li>
<li><p><strong>完全往返路径(CRTC)</strong></p>
<ul>
<li>对于G中所有可达的节点，TR包含所有的往返路径。<br><img src="/sftest/PPC.png" width="54%"></li>
</ul>
</li>
<li><p>主路径覆盖练习：<br><img src="/sftest/主路径覆盖.png" width="54%"></p>
</li>
</ul>
<h4 id="6-基本路径覆盖"><a href="#6-基本路径覆盖" class="headerlink" title="6. 基本路径覆盖"></a>6. 基本路径覆盖</h4><ul>
<li>独立路径：一条独立路径是指和其他的独立路径相比，至少引入一个新处理语句或一个新判断的程序通路。</li>
<li><strong>圈复杂度(Cyclomatic Complexity, CC)</strong>：<ul>
<li>一种为程序逻辑复杂性提供定量测度的软件度量，将该度量用于计算程序的基本的独立路径数目，为确保所有语句至少执行一次的测试数量的上界。</li>
<li>独立路径必须包含一条在定义之前不曾用到的边。</li>
<li>计算方法：<strong>CC =  E - V + 2  =  P + 1</strong>，E是边数量，V是节点的数量；P是<strong>判定结点</strong>的数量。</li>
</ul>
</li>
<li><strong>基本路径测试步骤</strong>：<ul>
<li>生成控制流图</li>
<li>计算圈复杂度</li>
<li>选择一组基本路径</li>
<li>生成基本路径的测试用例</li>
</ul>
</li>
<li>全路径测试 ≥ 基本路径测试 ≥ 分支测试</li>
</ul>
<h4 id="7-数据流覆盖"><a href="#7-数据流覆盖" class="headerlink" title="7. 数据流覆盖"></a>7. 数据流覆盖</h4><ul>
<li><strong>定义(def)</strong>：当一个变量的值被存储于内存时变量所处的位置。(写)</li>
<li><strong>使用(use)</strong>：当获取一个变量的值时变量所处的位置。(读)</li>
<li><p>数据流测试准则依据：数据值由定义转向使用。这种转移成为<strong>定义使用对/定义-使用/定义使用关联</strong>。<br><img src="/sftest/defuse.png" width="54%"></p>
</li>
<li><p><strong>定义使用对(DU Pair)</strong>：(l <sub>i</sub>,  l<sub>j</sub>) ，变量v在l <sub>i</sub>处定义，并在l <sub>j</sub>处使用。</p>
</li>
<li><strong>def(n) def(e)  / use(n) use(e)</strong><ul>
<li>由<strong>节点n</strong>或边e<strong>定义</strong>的变量集</li>
<li>由<strong>节点n</strong>或边e<strong>使用</strong>的变量集</li>
</ul>
</li>
<li><strong>无重复定义(Def-clear)</strong><ul>
<li>存在一条由l <sub>i</sub>到l <sub>j</sub>的路径，对于这条路径上的每个节点n<sub>k</sub>和每条边e<sub>k</sub>，k≠i 且 k≠j，变量v不属于def(n<sub>k</sub>)和def(e<sub>k</sub>)，那么这条路径对于变量v是无重复定义的。</li>
<li>如果变量v存在一条由l <sub>i</sub>到l <sub>j</sub>的无重复定义的路径，我们说处于l<sub>i</sub>的定义到达处于l<sub>j</sub>的使用。</li>
</ul>
</li>
<li><strong>定义使用路径(du-path)</strong><ul>
<li>定义使用路径是一条简单路径，并且对于变量v这是一条由节点n<sub>i</sub>到另一个节点n<sub>j</sub>的无重复定义路径，v在n<sub>i</sub>中存在于def(n<sub>i</sub>)而在n<sub>j</sub>中存在于use(n<sub>j</sub>)</li>
<li><em>du</em> (<em>n<sub>i</sub></em>, <em>n<sub>j</sub></em>, <em>v</em>)：变量v的定义使用路径集合，起始于n<sub>i</sub>，终止于n<sub>j</sub>。</li>
<li><em>du</em> (<em>n<sub>i</sub></em>, <em>v</em>)：对于变量v，定义路径集合是起始于n<sub>i</sub>的定义使用路径的集合。</li>
</ul>
</li>
<li><p><strong>全定义覆盖(ADC)</strong></p>
<ul>
<li>对于每个<strong>定义路径</strong>集合<em>S</em> = <em>du</em> (<em>n<sub>i</sub></em>, <em>v</em>)，TR包含S中至少一条路径d。</li>
</ul>
</li>
<li><p><strong>全使用覆盖(AUC)</strong></p>
<ul>
<li>对于每个<strong>定义对</strong>集合<em>S</em> = <em>du</em> (<em>n<sub>i</sub></em>, <em>n<sub>j</sub></em>, <em>v</em>)，TR包含S中至少一条路径d。</li>
</ul>
</li>
<li><p><strong>全定义使用路径覆盖(ADUPC)</strong></p>
<ul>
<li>对于每个<strong>定义对</strong>集合<em>S</em> = <em>du</em> (<em>n<sub>i</sub></em>, <em>n<sub>j</sub></em>, <em>v</em>)，TR包含S中每一条路径d。<br><img src="/sftest/dutest.png" width="54%"></li>
</ul>
</li>
<li><p>图覆盖准则之间的包含关系<br><img src="/sftest/包含关系.png" width="34%"></p>
</li>
</ul>
<h4 id="8-事件流覆盖"><a href="#8-事件流覆盖" class="headerlink" title="8. 事件流覆盖"></a>8. 事件流覆盖</h4><ul>
<li><strong>事件流图(EFG)</strong>是一个三元组M = &lt;V, I, E&gt;：<ul>
<li>V是一组表示对象所有事件的顶点。</li>
<li>I ⊆ V是一组初始顶点。</li>
<li>E ⊆ V × V是顶点之间的一组边，当v<sub>j</sub>可以在v<sub>i</sub>之后立即执行，(v<sub>i</sub>, v<sub>j</sub>) ∈ E。</li>
</ul>
</li>
</ul>
<p><img src="/sftest/event1.png" width="40%"><img src="/sftest/event2.png" width="40%"></p>
<p>#####9. 变异测试</p>
<ul>
<li>变异测试<ul>
<li>将错误插入程序以测试测试用例是否接收它们的方法。</li>
<li>是一种对测试集的充分性进行评估的技术。</li>
</ul>
</li>
<li>操作数变异操作符：将单个操作数替换为另一个操作数或常量。</li>
<li>表达变异操作符：更换一个操作符或者插入一个新的操作符。</li>
<li><strong>等价变异体</strong><ul>
<li>存在没有被杀死的变异体，被称为等价变异体</li>
<li>虽然变异体语法不同，但通过测试难以发现，需要手动检查。</li>
</ul>
</li>
<li><strong><em>Mutation Score = 100 \</em> K / (T - E)*</strong><ul>
<li>K：被杀死的变异体数</li>
<li>T：变异体总数</li>
<li>E：等价的变异体数</li>
</ul>
</li>
<li><p>主管程序员假设</p>
<ul>
<li>被测模块由合格的程序员或设计师编写。 因此，如果模块不正确，则它与正确的模块不同，最多只有几个小故障。</li>
</ul>
</li>
<li><p>耦合效应</p>
<ul>
<li>由于仅通过简单故障将所有模块与正确模块区分开来的测试套件非常敏感，它还可以隐式区分更复杂的故障。</li>
</ul>
</li>
</ul>
<p>#####10. 逻辑覆盖</p>
<ul>
<li><strong>语句覆盖(SC)</strong></li>
<li><strong>判定覆盖(DC)</strong><ul>
<li>判定的true和false至少各执行一次。</li>
<li>((x&gt;5) &amp;&amp; (y&gt;0)): <em>true</em> and <em>false</em></li>
</ul>
</li>
<li><strong>条件覆盖(CC)</strong><ul>
<li>每个条件的true和false至少各被执行一次。</li>
<li>(x&gt;5) 􏰄 <em>true</em> and <em>false</em></li>
<li>(y&gt;0) 􏰄<em>true</em> and <em>false</em></li>
</ul>
</li>
<li><strong>条件判定覆盖(C/DC)</strong><ul>
<li>同时满足DC和CC.</li>
<li>使得判定中的每个条件取到各种可能的值，并使每个判定取到各种可能的结果。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;(6, 1), (1,1)&#125;--DC</span></span><br><span class="line"><span class="comment">// &#123;(6, 0), (0,1)&#125;--CC </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> z = y;</span><br><span class="line">	<span class="keyword">if</span> ((x&gt;<span class="number">5</span>) &amp;&amp; (y&gt;<span class="number">0</span>)) &#123;</span><br><span class="line">		z = x; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> x*z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>SC&amp;DC&amp;CC的包含关系<ul>
<li>DC ≥ SC</li>
<li>CC not ≥ SC</li>
<li>DC not ≥ CC􏰂 CC not ≥ DC</li>
<li>C/DC ≥ CC </li>
<li>C/DC ≥ DC</li>
</ul>
</li>
<li><p>MC/DC ≥ C/DC</p>
</li>
<li><p><strong>多条件覆盖(MCC)</strong></p>
<ul>
<li>使得每个判定中条件的各种可能组合都至少出现一次。<br><img src="/sftest/MCC.png" width="30%"></li>
</ul>
</li>
<li><p><strong>修正条件判定覆盖(MCDC)</strong></p>
<ul>
<li>每个条件都要独立影响判定结果(true和false各一次)<br><img src="/sftest/MCDC.png" width="30%"></li>
</ul>
</li>
<li><p>计数</p>
<ul>
<li>DC——2</li>
<li>CC——2*n</li>
<li>MC/DC——2*n+1</li>
<li>MCC——2<sup>n</sup></li>
</ul>
</li>
</ul>
<h3 id="C4-自动化软件测试"><a href="#C4-自动化软件测试" class="headerlink" title="C4 自动化软件测试"></a>C4 自动化软件测试</h3><ul>
<li>自动化测试<strong>生成</strong><ul>
<li>测试用例生成</li>
<li>测试数据生成</li>
</ul>
</li>
<li>自动化测试<strong>执行</strong></li>
<li>自动化测试<strong>选择</strong><ul>
<li>针对修改部分的测试</li>
<li>针对测试需求的用例集约简</li>
<li>针对测试需求的用例排序</li>
</ul>
</li>
<li>自动化测试修复<ul>
<li>测试用例修复</li>
<li>测试用例演化</li>
</ul>
</li>
<li>自动化测试<strong>扩增</strong></li>
</ul>
<h3 id="C5-黑盒测试"><a href="#C5-黑盒测试" class="headerlink" title="C5 黑盒测试"></a>C5 黑盒测试</h3><h4 id="5-1-随机测试"><a href="#5-1-随机测试" class="headerlink" title="5.1 随机测试"></a>5.1 随机测试</h4><ul>
<li>随机测试<ul>
<li>测试用例完全随机生成</li>
<li>必须知道输入域</li>
<li>在输入域中选择随机点</li>
<li>自动化</li>
</ul>
</li>
<li>ART算法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* T = &#123;&#125;  是以前执行的一组测试用例*/</span></span><br><span class="line">随机生成输入t </span><br><span class="line">用t作为测试用例测试程序          </span><br><span class="line">将t添加到T     </span><br><span class="line"><span class="keyword">while</span>（未达到停止条件）           </span><br><span class="line">   随机生成下一个k候选c1，c2，…，ck    </span><br><span class="line">   <span class="keyword">for</span> 每个候选Ci </span><br><span class="line">      计算与T的最小距离di  </span><br><span class="line">   end <span class="keyword">for</span></span><br><span class="line">  选择一个具有最小距离的候选t</span><br><span class="line">  将t添加到T           </span><br><span class="line">  用T作为测试用例测试程序    </span><br><span class="line">end <span class="keyword">while</span></span><br></pre></td></tr></table></figure>
<h4 id="5-2-等价划分"><a href="#5-2-等价划分" class="headerlink" title="5.2 等价划分"></a>5.2 等价划分</h4><ul>
<li>等价划分<ul>
<li>可以同等地应用于多个级别的测试(• 单元  • 整合  • 系统)</li>
<li>相对容易应用，无需自动化</li>
<li>易于调整程序以获得更多或更少的测试</li>
</ul>
</li>
<li>输入域<ul>
<li>程序的输入域包含该程序的所有可能输入</li>
<li>对于即使是小型程序，输入域也是如此之大，以至于它可能是无限的</li>
<li>测试一般是从输入域中选择有限的值集</li>
<li>输入参数定义输入域的范围</li>
<li>每个输入参数的域被划分为区域</li>
<li>从每个区域至少选择一个值</li>
</ul>
</li>
<li><p>分区域</p>
<ul>
<li>域D</li>
<li>D的分区方案p</li>
<li>分区p定义了一组块b<sub>1</sub>，b<sub>2</sub>，… b<sub>n</sub></li>
<li>分区必须满足两个属性：<strong>1.块必须两两之间不相交（不重叠）2.所有块共同覆盖域D（完整）</strong></li>
</ul>
</li>
<li><p>两种方法</p>
<ul>
<li>基于接口的方法：直接根据各个输入参数开发特性，简单应用，在某些情况下可以部分自动化。</li>
<li>基于功能的方法：从被测程序的行为角度发展特征，更难开发，需要更多的设计工作，可以带来更好的测试，或者更少的测试。</li>
</ul>
</li>
<li><p>基于接口的方法：</p>
<ul>
<li>三角形有三个输入：q1=第一个边的输入与0的关系：大于，等于，小于</li>
</ul>
</li>
<li>基于功能的方法：<ul>
<li>三角形的类型：q1 =“几何分类”  b1=不等边  b2=等腰<strong>但不等边</strong>三角形  b3=正三角形  b4=无效</li>
<li>几何分区q1的可能值：b1= (4, 5, 6)，b2 = (3, 3, 4) ， b3 = (3, 3, 3)， b4 = (3, 4, 8)</li>
</ul>
</li>
</ul>
<h4 id="5-3-边界值分析"><a href="#5-3-边界值分析" class="headerlink" title="5.3 边界值分析"></a>5.3 边界值分析</h4><ul>
<li>示例：<ul>
<li>两个输入变量x1（a≤x1≤b）和x2（c≤x2≤d）。 测试用例包括：</li>
<li>&lt;x1nom，x2min&gt;，&lt;x1nom，x2min +&gt;，&lt;x1nom，x2nom&gt;，&lt;x1nom，x2max&gt;，&lt;x1nom，x2max-&gt;，&lt;x1min，x2nom&gt;，<x1min +，x2nom="">，&lt;x1max，x2nom&gt;，&lt;x1max-，x2nom&gt;</x1min></li>
<li>nomal，min，max</li>
</ul>
</li>
<li>弱边界值分析<ul>
<li>Min-  Min  Min+</li>
<li>Nom </li>
<li>Max-  Max  Max+ </li>
</ul>
</li>
</ul>
<p><img src="/sftest/弱边界1.png" width="40%"><img src="/sftest/弱边界2.png" width="30%"><img src="/sftest/边界.png" width="30%"></p>
<ul>
<li><p>强边界分析</p>
<p><img src="/sftest/强边界1.png" width="30%"><img src="/sftest/强边界2.png" width="35%"></p>
</li>
</ul>
<p><img src="/sftest/强边界3.png" width="35%"><img src="/sftest/强边界4.png" width="35%"></p>
<h4 id="5-4-组合测试"><a href="#5-4-组合测试" class="headerlink" title="5.4 组合测试"></a>5.4 组合测试</h4><ul>
<li>弱等价类测试</li>
<li>强等价类测试</li>
</ul>
<h4 id="5-5-测试中的约束"><a href="#5-5-测试中的约束" class="headerlink" title="5.5 测试中的约束"></a>5.5 测试中的约束</h4><ul>
<li>合并输入变量</li>
<li>优化输入域</li>
<li>修改测试用例</li>
</ul>
<h4 id="5-6-决策表"><a href="#5-6-决策表" class="headerlink" title="5.6 决策表"></a>5.6 决策表</h4><ul>
<li>决策表的优点<ul>
<li>能够将复杂的问题按照各种可能的情况全部列举出来，简明并避免遗漏。</li>
<li>利用决策表能够设计出完整的测试用例集合。 </li>
</ul>
</li>
<li>决策表通常由以下4部分组成:<ul>
<li>条件桩：列出问题的所有条件</li>
<li>条件项：针对条件桩中条件列出所有可能的取值</li>
<li>动作桩：列出问题规定的可能采取的操作</li>
<li>动作项：指出条件项各取值情况下应采取的动作</li>
</ul>
</li>
<li>构造决策表的5个步骤: <ol>
<li>确定规则的个数 ：有n个条件的决策表有2n个规则(每个条件取真、假值) </li>
<li>列出所有的条件桩和动作桩 </li>
<li>填入条件项 </li>
<li>填入动作项，得到初始决策表 </li>
<li>简化决策表，合并相似规则 </li>
</ol>
</li>
<li>练习：<ul>
<li>前一日函数DPreate是NextDate的逆函数，即给定一个月份、日期、年，会返回前一天的日期。</li>
<li>年的取值在1812年到2017年</li>
<li>日的取值在1日到31日之间</li>
<li>月的取值在1到12月之间</li>
<li>条件项(等价类划分)：<br><img src="/sftest/条件项.png" width="40%"></li>
</ul>
</li>
</ul>
<h3 id="C7-功能、性能、移动应用测试"><a href="#C7-功能、性能、移动应用测试" class="headerlink" title="C7 功能、性能、移动应用测试"></a>C7 功能、性能、移动应用测试</h3><ul>
<li>功能测试<ul>
<li>根据产品特性和设计需求，验证一个产品的特性和行为是否满足设计需求。</li>
<li>正确性、可靠性、易用性。</li>
</ul>
</li>
<li>性能测试<ul>
<li>验证产品的性能在特定负载和环境条件下使用是否满足性能指标。</li>
<li>度量方法：响应时间、并发用户数、吞吐量、性能计数器、负载测试、压力测试</li>
</ul>
</li>
<li><p>移动应用测试</p>
<ul>
<li>手机系统、型号</li>
<li>传感器与屏幕(尺寸？)碎片化</li>
</ul>
</li>
<li><p>软件缺陷的􏰀描述</p>
<ul>
<li>软件缺陷的生命周期</li>
<li>严重性和优先级</li>
<li>缺陷的其它属性</li>
<li>完整的缺陷信息</li>
<li>缺陷描述的基本要求</li>
<li>缺陷报告的示例</li>
</ul>
</li>
<li><p>软件缺陷的生命周期</p>
<ul>
<li>一个软件缺陷被发现、报告到 这个缺陷被修复、验证直至最后关闭的完整过程。</li>
</ul>
</li>
<li><p>基本的缺陷生命周期</p>
<ul>
<li>发现-打开:测试人员找到软件缺陷并将软件缺陷􏰁交给开发人员。 </li>
<li>打开-修复:开发人员再现、修复缺陷，然后提交给测试人员去验证。 </li>
<li>修复-关闭:测试人员验证修复过的软件，关闭已不存在的缺陷。 </li>
</ul>
</li>
<li><p>严重性(severity)：衡量缺陷对客户满意度的影响程度</p>
<ul>
<li>致命的(fatal)、严重的(critical)、一般的(major)、微小的(minor)</li>
</ul>
</li>
<li><p>优先级(Priority)：指缺陷被修复的紧急程度。</p>
</li>
<li><p><strong>缺陷􏰀述的基本要求</strong></p>
<ul>
<li>单一准确</li>
<li>可以再现</li>
<li>完整统一</li>
<li>短小简练</li>
<li>特定条件</li>
<li>补充完善</li>
<li>不做评价 </li>
</ul>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Dai Sine</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://daisine.me/sftest/">http://daisine.me/sftest/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/note/">note</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/vscode-macos/"><i class="fa fa-chevron-left">  </i><span>VS Code调教笔记 on Mac OS</span></a></div><div class="next-post pull-right"><a href="/manage/"><span>软件项目管理</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://daisine.me/sftest/';
  this.page.identifier = 'sftest/';
  this.page.title = '软件测试笔记';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'dasine' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2019/05/10/5cd525fea97ac.png)"><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2019 By Dai Sine</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>